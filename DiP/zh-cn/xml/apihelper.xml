<?xml version="1.0" encoding="utf-8"?>
<chapter id="apihelper">
<?dbhtml filename="power_of_introspection/index.html"?>
<title>自省的威力</title>
<titleabbrev id="apihelper.numberonly">第 4 章</titleabbrev>
<abstract>
<title/>
<para>本章论述了 &python; 众多强大功能之一：自省。正如你所知道的，<link linkend="odbchelper.objects">&python; 中万物皆对象</link>，自省是指代码可以查看内存中以对象形式存在的其它模块和函数，获取它们的信息，并对它们进行操作。用这种方法，你可以定义没有名称的函数，不按函数声明的参数顺序调用函数，甚至引用事先并不知道名称的函数。</para>
</abstract>
<section id="apihelper.divein">
<title>概览</title>
<abstract>
<title/>
<para>下面是一个完整可运行的 &python; 程序。大概看一下这段程序，你应该可以理解不少了。用数字标出的行阐述了 <xref linkend="odbchelper"/> 中涉及的一些概念。如果剩下来的代码看起来有点奇怪，不用担心，通过阅读本章你将会理解所有这些。</para>
</abstract>
<example>
<title>&apihelper_filename;</title>
&para_download;
<programlisting>
&apihelper_funcdef; <co id="apihelper.intro.1.1"/> <co id="apihelper.intro.1.2"/> <co id="apihelper.intro.1.3"/>
&apihelper_docstring;
&apihelper_docstring2;
&apihelper_docstring3;
&apihelper_methods;
&apihelper_lambda;
&apihelper_main;

&apihelper_ifname;                <co id="apihelper.intro.1.4"/> <co id="apihelper.intro.1.5"/>
&apihelper_printdoc;</programlisting>
<calloutlist>
<callout arearefs="apihelper.intro.1.1">
<para>该模块有一个声明为 &info; 的函数。根据它的<link linkend="odbchelper.funcdef">函数声明</link>可知，它有三个参数： <varname>object</varname>、<varname>spacing</varname> 和 <varname>collapse</varname>。实际上后面两个参数都是可选参数，关于这点你很快就会看到。</para>
</callout>
<callout arearefs="apihelper.intro.1.2">
<para>&info; 函数有一个多行的 <link linkend="odbchelper.docstring">&docstring;</link>，简要地描述了函数的功能。注意这里并没有提到返回值；单独使用这个函数只是为了这个函数产生的效果，并不是为了它的返回值。</para>
</callout>
<callout arearefs="apihelper.intro.1.3">
<para>函数内的代码是<link linkend="odbchelper.indenting">缩进</link>形式的。</para>
</callout>
<callout arearefs="apihelper.intro.1.4">
<para><literal>&if; &name;</literal> <link linkend="odbchelper.ifnametrick">技巧</link>允许这个程序在自己独立运行时做些有用的事情，同时又不妨碍作为其它程序的模块使用。在这个例子中，程序只是简单地打印出 &info; 函数的 &docstring;。</para>
</callout>
<callout arearefs="apihelper.intro.1.5">
<para><link linkend="odbchelper.ifnametrick">&if; 语句</link>使用 &comparisonequals; 进行比较，而且不需要括号。</para>
</callout>
</calloutlist>
</example>
<para>&info; 函数的设计意图是提供给工作在 &python; &ide; 中的开发人员使用，它可以接受任何含有函数或者方法的对象 (比如模块，含有函数，又比如list，含有方法) 作为参数，并打印出对象的所有函数和它们的 &docstring;。</para>
<example>
<title>&apihelper_filename; 的用法示例</title>
<screen>&apihelper_output;</screen>
</example>
<para>缺省地，程序输出进行了格式化处理，以使其易于阅读。多行 &docstring; 被合并到单行中，要改变这个选项需要指定 <parameter>collapse</parameter> 参数的值为 <constant>0</constant>。如果函数名称长于10个字符，你可以将 <parameter>spacing</parameter> 参数的值指定为更大的值以使输出更容易阅读。</para>
<example>
<title>&apihelper_filename; 的高级用法</title>
<screen>&prompt;<userinput>import &odbchelper_name;</userinput>
&prompt;<userinput>info(&odbchelper_name;)</userinput>
<computeroutput>&odbchelper_funcname; Build a connection string from a dictionary Returns string.</computeroutput>
&prompt;<userinput>info(&odbchelper_name;, 30)</userinput>
<computeroutput>&odbchelper_funcname;          Build a connection string from a dictionary Returns string.</computeroutput>
&prompt;<userinput>info(&odbchelper_name;, 30, 0)</userinput>
<computeroutput>&odbchelper_funcname;          Build a connection string from a dictionary
    
    Returns string.
</computeroutput></screen>
</example>
</section>
<section id="apihelper.optional">
<?dbhtml filename="power_of_introspection/optional_arguments.html"?>
<title>使用可选参数和命名参数</title>
<abstract>
<title/>
<para>&python; 允许函数参数有缺省值；如果调用函数时不使用参数，参数将获得它的缺省值。此外，通过使用命名参数还可以以任意顺序指定参数。&sqlserver; &tsql; 中的存储过程也可以做到这些；如果你是脚本高手，你可以略过这部分。</para>
</abstract>
<informalexample>
<!--<title>&info;, a Function with Two Optional Arguments</title>-->
<para>&info; 函数就是这样一个例子，它有两个可选参数。</para>
<programlisting>
&apihelper_funcdef;</programlisting>
</informalexample>
<para><varname>spacing</varname> 和 <varname>collapse</varname> 是可选参数，因为它们已经定义了缺省值。<varname>object</varname> 是必备参数，因为它没有指定缺省值。如果调用 &info; 时只指定一个参数，那么 <varname>spacing</varname> 缺省为 <constant>10</constant> ，<varname>collapse</varname> 缺省为 &one;。如果调用 &info; 时指定两个参数，<varname>collapse</varname> 依然默认为 &one;。</para>
<para>假如你要指定 <varname>collapse</varname> 的值，但是又想要接受 <varname>spacing</varname> 的缺省值。在绝大部分语言中，你可能运气就不太好了，因为你需要使用三个参数来调用函数，这势必要重新指定 <varname>spacing</varname> 的值。但是在 &python; 中，参数可以通过名称以任意顺序指定。</para>
<example>
<title>&info; 的有效调用</title>
<programlisting>
info(&odbchelper_name;)                    <co id="apihelper_args.1.1"/>
info(&odbchelper_name;, 12)                <co id="apihelper_args.1.2"/>
info(&odbchelper_name;, collapse=0)        <co id="apihelper_args.1.3"/>
info(spacing=15, object=&odbchelper_name;) <co id="apihelper_args.1.4"/></programlisting>
<calloutlist>
<callout arearefs="apihelper_args.1.1">
<para>只使用一个参数，<varname>spacing</varname> 使用缺省值 <literal>10</literal> ，<varname>collapse</varname> 使用缺省值 &one;。</para>
</callout>
<callout arearefs="apihelper_args.1.2">
<para>使用两个参数，<varname>collapse</varname> 使用缺省值 &one;。</para>
</callout>
<callout arearefs="apihelper_args.1.3">
<para>这里你显式命名了 <varname>collapse</varname> 并指定了它的值。<varname>spacing</varname> 将依然使用它的缺省值 <literal>10</literal>。</para>
</callout>
<callout arearefs="apihelper_args.1.4">
<para>甚至必备参数 (例如 <varname>object</varname>，没有指定缺省值) 也可以采用命名参数的方式，而且命名参数可以以任意顺序出现。</para>
</callout>
</calloutlist>
</example>
<para>这些看上去非常累，除非你意识到参数不过是一个字典。<quote>通常</quote> 不使用参数名称的函数调用只是一个简写的形式，&python; 按照函数声明中定义的的参数顺序将参数值和参数名称匹配起来。大部分时间，你会使用<quote>通常</quote>方式调用函数，但是如果你需要，总是可以提供附加的灵活性。</para>
<note id="tip.arguments">
<title>灵活的函数调用</title>
<para>调用函数时唯一必须做的事情就是为每一个必备参数指定值 (以某种方式)；以何种具体的方式和顺序都取决于你。</para>
</note>
<itemizedlist role="furtherreading">
<title>进一步阅读</title>
<listitem><para>&pythontutorial; 确切地讨论了<ulink url="&url_pythontutorial;node6.html#SECTION006710000000000000000">何时、如何进行缺省参数赋值</ulink>，这都和缺省值是一个 list 还是一个具有副作用的表达式有关。</para></listitem>
</itemizedlist>
</section>
<section id="apihelper.builtin">
<?dbhtml filename="power_of_introspection/built_in_functions.html"?>
<title>使用 &type;、&str;、&dir; 和其它内置函数</title>
<abstract>
<title/>
<para>&python; 有小部分相当有用的内置函数。除这些函数之外，其它所有的函数都被分到了各个模块中。其实这是一个非常明智的设计策略，避免了核心语言变得像其它脚本语言一样臃肿 (咳 咳，&vb;)。</para>
</abstract>
<section>
<title>&type; 函数</title>
<para>&type; 函数返回任意对象的数据类型。在 <filename class="headerfile">types</filename> 模块中列出了可能的数据类型。这对于处理多种数据类型的帮助者函数 <footnote><para>帮助者函数，原文是 helper function，也就是我们在前文所看到的诸如 <literal>odbchelper</literal>、<literal>apihelper</literal> 这样的函数。――译注</para></footnote> 非常有用。</para>
<example id="apihelper.type.intro">
<title>&type; 介绍</title>
<screen>&prompt;<userinput>type(1)</userinput>           <co id="apihelper.builtin.1.1"/>
<computeroutput>&lt;type 'int'></computeroutput>
&prompt;<userinput>li = []</userinput>
&prompt;<userinput>type(li)</userinput>          <co id="apihelper.builtin.1.2"/>
<computeroutput>&lt;type 'list'></computeroutput>
&prompt;<userinput>import odbchelper</userinput>
&prompt;<userinput>type(odbchelper)</userinput>  <co id="apihelper.builtin.1.3"/>
<computeroutput>&lt;type 'module'></computeroutput>
&prompt;<userinput>import types</userinput>      <co id="apihelper.builtin.1.4"/>
&prompt;<userinput>type(odbchelper) == types.ModuleType</userinput>
<computeroutput>True</computeroutput></screen>
<calloutlist>
<callout arearefs="apihelper.builtin.1.1">
<para>&type; 可以接收任何东西作为参数――我的意思是任何东西――并返回它的数据类型。整型、字符串、列表、字典、元组、函数、类、模块，甚至类型对象都可以作为参数被 &type; 函数接受。</para>
</callout>
<callout arearefs="apihelper.builtin.1.2">
<para>&type; 可以接收变量作为参数，并返回它的数据类型。</para>
</callout>
<callout arearefs="apihelper.builtin.1.3">
<para>&type; 还可以作用于模块。</para>
</callout>
<callout arearefs="apihelper.builtin.1.4">
<para>你可以使用 <filename class="headerfile">types</filename> 模块中的常量来进行对象类型的比较。这就是 &info; 函数所做的，很快你就会看到。</para>
</callout>
</calloutlist>
</example>
</section>
<section>
<title>&str; 函数</title>
<para>&str; 将数据强制转换为字符串。每种数据类型都可以强制转换为字符串。</para>
<example id="apihelper.str.intro">
<title>&str; 介绍</title>
<screen>
&prompt;<userinput>str(1)</userinput>          <co id="apihelper.builtin.2.1"/>
<computeroutput>'1'</computeroutput>
&prompt;<userinput>horsemen = ['war', 'pestilence', 'famine']</userinput>
&prompt;<userinput>horsemen</userinput>
<computeroutput>['war', 'pestilence', 'famine']</computeroutput>
&prompt;<userinput>horsemen.append('&powerbuilder;')</userinput>
&prompt;<userinput>str(horsemen)</userinput>   <co id="apihelper.builtin.2.2"/>
<computeroutput>"['war', 'pestilence', 'famine', '&powerbuilder;']"</computeroutput>
&prompt;<userinput>str(odbchelper)</userinput> <co id="apihelper.builtin.2.3"/>
<computeroutput>"&lt;module 'odbchelper' from 'c:\\docbook\\dip\\py\\odbchelper.py'>"</computeroutput>
&prompt;<userinput>str(None)</userinput>       <co id="apihelper.builtin.2.4"/>
<computeroutput>'None'</computeroutput></screen>
<calloutlist>
<callout arearefs="apihelper.builtin.2.1">
<para>对于简单的数据类型比如整型，你可以预料到 &str; 的正常工作，因为几乎每种语言都有一个将整型转化为字符串的函数。</para>
</callout>
<callout arearefs="apihelper.builtin.2.2">
<para>然而 &str; 可以作用于任何数据类型的任何对象。这里它作用于一个零碎构建的列表。</para>
</callout>
<callout arearefs="apihelper.builtin.2.3">
<para>&str; 还允许作用于模块。注意模块的字符串形式表示包含了模块在磁盘上的路径名，所以你的显示结果将会有所不同。</para>
</callout>
<callout arearefs="apihelper.builtin.2.4">
<para>&str; 的一个细小但重要的行为是它可以作用于 &none;，&none; 是 &python; 的 null 值。这个调用返回字符串 <literal>'None'</literal>。你将会使用这一点来改进你的 &info; 函数，这一点你很快就会看到。</para>
</callout>
</calloutlist>
</example>
<para>&info; 函数的核心是强大的 &dir; 函数。&dir; 函数返回任意对象的属性和方法列表，包括模块对象、函数对象、字符串对象、列表对象、字典对象 …… 相当多的东西。</para>
<example id="apihelper.dir.intro">
<title>&dir; 介绍</title>
<screen>&prompt;<userinput>li = []</userinput>
&prompt;<userinput>dir(li)</userinput>           <co id="apihelper.builtin.3.1"/>
<computeroutput>['append', 'count', 'extend', 'index', 'insert',
'pop', 'remove', 'reverse', 'sort']</computeroutput>
&prompt;<userinput>d = {}</userinput>
&prompt;<userinput>dir(d)</userinput>            <co id="apihelper.builtin.3.2"/>
<computeroutput>['clear', 'copy', 'get', 'has_key', 'items', 'keys', 'setdefault', 'update', 'values']</computeroutput>
&prompt;<userinput>import &odbchelper_name;</userinput>
&prompt;<userinput>dir(&odbchelper_name;)</userinput>   <co id="apihelper.builtin.3.3"/>
<computeroutput>['__builtins__', '__doc__', '__file__', '__name__', '&odbchelper_funcname;']</computeroutput></screen>
<calloutlist>
<callout arearefs="apihelper.builtin.3.1">
<para><varname>li</varname> 是一个列表，所以 <literal>&dir;(<varname>li</varname>)</literal> 返回一个包含所有列表方法的列表。注意返回的列表只包含了字符串形式的方法名称，而不是方法对象本身。</para>
</callout>
<callout arearefs="apihelper.builtin.3.2">
<para><varname>d</varname> 是一个字典，所以 <literal>&dir;(<varname>d</varname>)</literal> 返回字典方法的名称列表。其中至少有一个方法，<link linkend="odbchelper.items">&keys;</link>，看起来还是挺熟悉的。</para>
</callout>
<callout arearefs="apihelper.builtin.3.3">
<para>这里就是真正变得有趣的地方。&odbchelper_modulename; 是一个模块，所以 <literal>&dir;(&odbchelper_modulename;)</literal> 返回模块中定义的所有部件的列表，包括内置的属性，例如 <link linkend="odbchelper.ifnametrick">&name;</link>、<link linkend="odbchelper.import">&doc;</link>，以及其它你所定义的属性和方法。在这个例子中，&odbchelper_modulename; 只有一个用户定义的方法，就是在<xref linkend="odbchelper" endterm="odbchelper.numberonly"/>中论述的 &odbchelper_function; 函数。</para>
</callout>
</calloutlist>
</example>
<para>最后是 &callable; 函数，它接收任何对象作为参数，如果参数对象是可调用的，返回 &true;；否则返回 &false;。可调用对象包括函数、类方法，甚至类自身 (下一章将更多的关注类)。</para>
<example id="apihelper.builtin.callable">
<title>&callable; 介绍</title>
<screen>
&prompt;<userinput>import string</userinput>
&prompt;<userinput>string.punctuation</userinput>           <co id="apihelper.builtin.4.1"/>
<computeroutput>'!"#$&pct;&amp;\'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~'</computeroutput>
&prompt;<userinput>string.join</userinput>                  <co id="apihelper.builtin.4.2"/>
<computeroutput>&lt;function join at 00C55A7C&gt;</computeroutput>
&prompt;<userinput>callable(string.punctuation)</userinput> <co id="apihelper.builtin.4.3"/>
<computeroutput>False</computeroutput>
&prompt;<userinput>callable(string.join)</userinput>        <co id="apihelper.builtin.4.4"/>
<computeroutput>True</computeroutput>
&prompt;<userinput>print string.join.__doc__</userinput>    <co id="apihelper.builtin.4.5"/>
<computeroutput>join(list [,sep]) -> string

    Return a string composed of the words in list, with
    intervening occurrences of sep.  The default separator is a
    single space.

    (joinfields and join are synonymous)</computeroutput></screen>
<calloutlist>
<callout arearefs="apihelper.builtin.4.1">
<para>&string; 模块中的函数现在已经不赞成使用了 (尽管很多人现在仍然还在使用 &join; 函数)，但是在这个模块中包含了许多有用的变量，例如 <varname>string.punctuation</varname>，这个字符串包含了所有标准的标点符号字符。</para>
</callout>
<callout arearefs="apihelper.builtin.4.2">
<para><link linkend="odbchelper.join"><function>string.join</function></link> 是一个用于连接字符串列表的函数。</para>
</callout>
<callout arearefs="apihelper.builtin.4.3">
<para><varname>string.punctuation</varname> 是不可调用的对象；它是一个字符串。(字符串确有可调用的方法，但是字符串本身不是可调用的。)</para>
</callout>
<callout arearefs="apihelper.builtin.4.4">
<para><function>string.join</function> 是可调用的；这个函数可以接受两个参数。</para>
</callout>
<callout arearefs="apihelper.builtin.4.5">
<para>任何可调用的对象都有 &docstring;。通过将 &callable; 函数作用于一个对象的每个属性，可以确定哪些属性 (方法、函数、类) 是你要关注的，哪些属性 (常量等等) 是你可以忽略、之前不需要知道的。</para>
</callout>
</calloutlist>
</example>
</section>
<section>
<title>内置函数</title>
<para>&type;、&str;、&dir; 和其它的 &python; 内置函数都归组到了 &builtins; (前后分别是双下划线) 这个特殊的模块中。如果有帮助的话，你可以认为 &python; 在启动时自动执行了 <literal>from __builtin__ import *</literal>，此语句将所有的 <quote>内置</quote>  函数导入该命名空间，所以在这个命名空间中可以直接使用这些内置函数。</para>
<para>像这样考虑的好处是，你是可以获取 <filename class="headerfile">__builtin__</filename> 模块信息的，并以组的形式访问所有的内置函数和属性。猜到什么了吗，现在我们的 &python; 有一个称为 &info; 的函数。自己尝试一下，略看一下结果列表。后面我们将深入到一些更重要的函数。(一些内置的错误类，比如 <link linkend="odbchelper.tuplemethods"><errorcode>AttributeError</errorcode></link>，应该看上去已经很熟悉了。)</para>
<example id="apihelper.builtin.list">
<title>内置属性和内置函数</title>
<screen>&prompt;<userinput>from apihelper import info</userinput>
&prompt;<userinput>import __builtin__</userinput>
&prompt;<userinput>info(__builtin__, 20)</userinput>
<computeroutput>ArithmeticError      Base class for arithmetic errors.
AssertionError       Assertion failed.
AttributeError       Attribute not found.
EOFError             Read beyond end of file.
EnvironmentError     Base class for I/O related errors.
Exception            Common base class for all exceptions.
FloatingPointError   Floating point operation failed.
IOError              I/O operation failed.

[...snip...]</computeroutput></screen>
</example>
<note id="tip.manuals">
<title>&python; 是自文档化的</title>
<para>&python; 提供了很多出色的参考手册，你应该好好地精读一下所有 &python; 提供的必备模块。对于其它大部分语言，你会发现自己要常常回头参考手册或者 man 页来提醒自己如何使用这些模块，但是 &python; 不同于此，它很大程度上是自文档化的。</para>
</note>
<itemizedlist role="furtherreading">
<title>进一步阅读</title>
<listitem><para>&pythonlibraryreference; 对<ulink url="&url_pythonlibraryreference;built-in-funcs.html">所有的内置函数</ulink>和<ulink url="&url_pythonlibraryreference;module-exceptions.html">所有的内置异常</ulink>都进行了文档化。</para></listitem>
</itemizedlist>
</section>
</section>
<section id="apihelper.getattr">
<?dbhtml filename="power_of_introspection/getattr.html"?>
<title>通过 &getattr; 获取对象引用</title>
<abstract>
<title/>
<para>你已经知道 <link linkend="odbchelper.objects">&python; 函数是对象</link>。你不知道的是，使用 &getattr; 函数，可以得到一个直到运行时才知道名称的函数的引用。</para>
</abstract>
<example id="apihelper.getattr.intro">
<title>&getattr; 介绍</title>
<screen>&prompt;<userinput>li = ["Larry", "Curly"]</userinput>
&prompt;<userinput>li.pop</userinput>                       <co id="apihelper.getattr.1.1"/>
<computeroutput>&lt;built-in method pop of list object at 010DF884></computeroutput>
&prompt;<userinput>getattr(li, "pop")</userinput>           <co id="apihelper.getattr.1.2"/>
<computeroutput>&lt;built-in method pop of list object at 010DF884></computeroutput>
&prompt;<userinput>getattr(li, "append")("Moe")</userinput> <co id="apihelper.getattr.1.3"/>
&prompt;<userinput>li</userinput>
<computeroutput>["Larry", "Curly", "Moe"]</computeroutput>
&prompt;<userinput>getattr({}, "clear")</userinput>         <co id="apihelper.getattr.1.4"/>
<computeroutput>&lt;built-in method clear of dictionary object at 00F113D4></computeroutput>
&prompt;<userinput>getattr((), "pop")</userinput>           <co id="apihelper.getattr.1.5"/>
<computeroutput role="traceback">&traceback;
AttributeError: 'tuple' object has no attribute 'pop'</computeroutput></screen>
<calloutlist>
<callout arearefs="apihelper.getattr.1.1">
<para>该语句获取列表的 &pop; 方法的引用。注意该语句并不是调用 &pop; 方法；调用 &pop; 方法的应该是 <literal>li.pop()</literal>。这里指的是方法对象本身。</para>
</callout>
<callout arearefs="apihelper.getattr.1.2">
<para>该语句也是返回 &pop; 方法的引用，但是此时，方法名称是作为一个字符串参数传递给 &getattr; 函数的。&getattr; 是一个有用到令人无法致信的内置函数，可以返回任何对象的任何属性。在这个例子中，对象是一个 list，属性是 &pop; 方法。</para>
</callout>
<callout arearefs="apihelper.getattr.1.3">
<para>如果不确信它是多么的有用，试试这个：&getattr; 的返回值<emphasis>是</emphasis> 方法，然后你就可以调用它，就像直接使用 <literal>li.append("Moe")</literal> 一样。但是实际上你没有直接调用函数；只是以字符串形式指定了函数名称。</para>
</callout>
<callout arearefs="apihelper.getattr.1.4">
<para>&getattr; 也可以作用于字典。</para>
</callout>
<callout arearefs="apihelper.getattr.1.5">
<para>理论上，&getattr; 可以作用于元组，但是由于<link linkend="odbchelper.tuplemethods">元组没有方法</link>，所以不管你指定什么属性名称 &getattr; 都会引发一个异常。</para>
</callout>
</calloutlist>
</example>
<section>
<title>用于模块的 &getattr;</title>
<para>&getattr; 不仅仅适用于内置数据类型，也可作用于模块。</para>
<example id="apihelper.getattr.example">
<title>&apihelper_filename; 中的 &getattr; 函数</title>
<screen>&prompt;<userinput>import &odbchelper_name;</userinput>
&prompt;<userinput>&odbchelper_name;.&odbchelper_funcname;</userinput>             <co id="apihelper.getattr.2.1"/>
<computeroutput>&lt;function &odbchelper_funcname; at 00D18DD4></computeroutput>
&prompt;<userinput>getattr(&odbchelper_name;, "&odbchelper_funcname;")</userinput> <co id="apihelper.getattr.2.2"/>
<computeroutput>&lt;function &odbchelper_funcname; at 00D18DD4></computeroutput>
&prompt;<userinput>object = &odbchelper_name;</userinput>
&prompt;<userinput>method = "&odbchelper_funcname;"</userinput>
&prompt;<userinput>getattr(object, method)</userinput>                      <co id="apihelper.getattr.2.3"/>
<computeroutput>&lt;function &odbchelper_funcname; at 00D18DD4></computeroutput>
&prompt;<userinput>type(getattr(object, method))</userinput>                <co id="apihelper.getattr.2.4"/>
<computeroutput>&lt;type 'function'></computeroutput>
&prompt;<userinput>import types</userinput>
&prompt;<userinput>type(getattr(object, method)) == types.FunctionType</userinput>
<computeroutput>True</computeroutput>
&prompt;<userinput>callable(getattr(object, method))</userinput>            <co id="apihelper.getattr.2.5"/>
<computeroutput>True</computeroutput></screen>
<calloutlist>
<callout arearefs="apihelper.getattr.2.1">
<para>该语句返回 &odbchelper_modulename; 模块中 &odbchelper_function; 函数的引用，<xref linkend="odbchelper"/> 你已经研习过这个方法了。(你看到的这个十六进制地址是我机器上的；你的输出结果会有所不同。)</para>
</callout>
<callout arearefs="apihelper.getattr.2.2">
<para>使用 &getattr;，你能够获得同一函数的同一引用。通常，<literal>&getattr;(<replaceable>object</replaceable>, "<replaceable>attribute</replaceable>")</literal> 等价于 <literal><replaceable>object</replaceable>.<replaceable>attribute</replaceable></literal>。如果 <replaceable>object</replaceable> 是一个模块的话，那么 <replaceable>attribute</replaceable> 可能是定义在模块中的任何东西：函数、类或者全局变量。</para>
</callout>
<callout arearefs="apihelper.getattr.2.3">
<para>接下来的是你真正用在 &info; 函数中的东西。<varname>object</varname> 作为一个参数传递给函数； <varname>method</varname> 是方法或者函数的名称字符串。</para>
</callout>
<callout arearefs="apihelper.getattr.2.4">
<para>在这个例子中，<varname>method</varname> 是函数的名称，通过获取 <link linkend="apihelper.type.intro">&type;</link> 可以进行验证。</para>
</callout>
<callout arearefs="apihelper.getattr.2.5">
<para>由于 <varname>method</varname> 是一个函数，所以它是<link linkend="apihelper.builtin.callable">可调用的</link>。</para>
</callout>
</calloutlist>
</example>
</section>
<section>
<title>&getattr; 作为一个分发者</title>
<para>&getattr; 常见的使用模式是作为一个分发者。举个例子，如果你有一个程序可以以不同的格式输出数据，你可以为每种输出格式定义各自的格式输出函数，然后使用唯一的分发函数调用所需的格式输出函数。</para>
<para>例如，让我们假设有一个以 &html;、&xml; 和普通文本格式打印站点统计的程序。输出格式在命令行中指定，或者保存在配置文件中。<filename>statsout</filename> 模块定义了三个函数：<function>output_html</function>、<function>output_xml</function> 和 <function>output_text</function>。然后主程序定义了唯一的输出函数，如下：</para>
<example id="apihelper.getattr.dispatch">
<title>使用&getattr; 创建分发者</title>
<programlisting>
import statsout

def output(data, format="text"):                              <co id="apihelper.getattr.3.1"/>
    output_function = getattr(statsout, "output_%s" % format) <co id="apihelper.getattr.3.2"/>
    return output_function(data)                              <co id="apihelper.getattr.3.3"/>
</programlisting>
</example>
<calloutlist>
<callout arearefs="apihelper.getattr.3.1">
<para><function>output</function> 函数接收一个必备参数 <varname>data</varname>，和一个可选参数 <varname>format</varname>。如果没有指定 <varname>format</varname> 参数，其缺省值是 <literal>text</literal> 并完成普通文本输出函数的调用。</para>
</callout>
<callout arearefs="apihelper.getattr.3.2">
<para>你可以连接 <varname>format</varname> 参数值和 "output_" 来创建一个函数名称作为参数值，然后从 <filename>statsout</filename> 模块中取得该函数。这种方式允许今后很容易地扩展程序以支持其它的输出格式，而且无需修改分发函数。所要做的仅仅是向 <filename>statsout</filename> 中添加一个函数，比如 <function>output_pdf</function>，之后只要将 “pdf” 作为 <varname>format</varname> 的参数值传递给 <function>output</function> 函数即可。</para>
</callout>
<callout arearefs="apihelper.getattr.3.3">
<para>现在你可以简单地调用输出函数，就像调用其它函数一样。<varname>output_function</varname> 变量是指向 <filename>statsout</filename> 模块中相应函数的引用。</para>
</callout>
</calloutlist>
<para>你是否发现前面示例的一个 Bug？即字符串和函数之间的松耦合，而且没有错误检查。如果用户传入一个格式参数，但是在 <filename>statsout</filename> 中没有定义相应的格式输出函数，会发生什么呢？还好，&getattr; 会返回 &none;，它会取代一个有效函数并被赋值给 <varname>output_function</varname>，然后下一行调用函数的语句将会失败并抛出一个异常。这种方式不好。</para>
<para>值得庆幸的是，&getattr; 能够使用可选的第三个参数，一个缺省返回值。</para>
<example id="apihelper.getattr.default">
<title>&getattr; 缺省值</title>
<programlisting>
import statsout

def output(data, format="text"):
    output_function = getattr(statsout, "output_%s" % format, statsout.output_text)
    return output_function(data) <co id="apihelper.getattr.4.1"/>
</programlisting>
<calloutlist>
<callout arearefs="apihelper.getattr.4.1">
<para>这个函数调用一定可以工作，因为你在调用 &getattr; 时添加了第三个参数。第三个参数是一个缺省返回值，如果第二个参数指定的属性或者方法没能找到，则将返回这个缺省返回值。</para>
</callout>
</calloutlist>
</example>
<para>正如你所看到，&getattr; 是相当强大的。它是自省的核心，在后面的章节中你将看到它更强大的示例。</para>
</section>
</section>
<section id="apihelper.filter">
<?dbhtml filename="power_of_introspection/filtering_lists.html"?>
<title>过滤列表</title>
<abstract>
<title/>
<para>如你所知，&python; 具有通过列表解析 (<xref linkend="odbchelper.map"/>) 将列表映射到其它列表的强大能力。这种能力同过滤机制结合使用，使列表中的有些元素被映射的同时跳过另外一些元素。</para>
</abstract>
<informalexample>
<!--<title>List Filtering Syntax</title>-->
<para>过滤列表语法：</para>
<programlisting>
[<replaceable>mapping-expression</replaceable> for <replaceable>element</replaceable> in <replaceable>source-list</replaceable> if <replaceable>filter-expression</replaceable>]</programlisting>
</informalexample>
<para>这是你所知所爱的<link linkend="odbchelper.map">列表解析</link>的扩展。前三部分都是相同的；最后一部分，以 &if; 开头的是过滤器表达式。过滤器表达式可以是返回值为真或者假的任何表达式 (在 &python; 中是<link linkend="tip.boolean">几乎任何东西</link>)。任何经过滤器表达式演算值为真的元素都可以包含在映射中。其它的元素都将忽略，它们不会进入映射表达式，更不会包含在输出列表中。</para>
<example>
<title>列表过滤介绍</title>
<screen>&prompt;<userinput>li = ["a", "mpilgrim", "foo", "b", "c", "b", "d", "d"]</userinput>
&prompt;<userinput>[elem for elem in li if len(elem) > 1]</userinput>       <co id="apihelper.filter.1.1"/>
<computeroutput>['mpilgrim', 'foo']</computeroutput>
&prompt;<userinput>[elem for elem in li if elem != "b"]</userinput>         <co id="apihelper.filter.1.2"/>
<computeroutput>['a', 'mpilgrim', 'foo', 'c', 'd', 'd']</computeroutput>
&prompt;<userinput>[elem for elem in li if li.count(elem) == 1]</userinput> <co id="apihelper.filter.1.3"/>
<computeroutput>['a', 'mpilgrim', 'foo', 'c']</computeroutput></screen>
<calloutlist>
<callout arearefs="apihelper.filter.1.1">
<para>这里的映射表达式很简单 (只是返回每个元素的值)，所以请把注意力集中到过滤器表达式上。由于 &python; 会遍历整个列表，它将对每个元素执行过滤器表达式。如果过滤器表达式演算值为真，该元素就会被映射，同时映射表达式的结果将包含在返回的列表中。这里，你过滤掉了所有单字符的字符串，留下了一个由长字符串构成的列表。</para>
</callout>
<callout arearefs="apihelper.filter.1.2">
<para>这里你过滤掉了一个特定值 <literal>b</literal>。注意这个过滤器会过滤掉所有的 <literal>b</literal>，因为每次取出 <literal>b</literal>，过滤表达式都将为假。</para>
</callout>
<callout arearefs="apihelper.filter.1.3">
<para>&count; 是一个列表方法，返回某个值在列表中出现的次数。你可以认为这个过滤器将从列表中剔除重复元素，返回一个只包含了在原始列表中有着唯一值拷贝的列表。但并非如此，因为在原始列表中出现两次的值 (在本例中，<literal>b</literal> 和 <literal>d</literal>) 被完全剔除了。从一个列表中排除重复值有多种方法，但过滤并不是其中的一种。</para>
</callout>
</calloutlist>
</example>
<informalexample id="apihelper.filter.care">
<!--<title>Filtering a List in &apihelper_filename;</title>-->
<para>回到 &apihelper_filename; 中的这一行：</para>
<programlisting>
&apihelper_methods;</programlisting>
</informalexample>
<para>这行看上去挺复杂――确实也很复杂――但是基本结构都还是一样的。整个过滤表达式返回一个列表，并赋值给 <varname>methodList</varname> 变量。表达式的前半部分是列表映射部分。映射表达式是一个和遍历元素相同的表达式，因此它返回每个元素的值。<literal>&dir;(<varname>object</varname>)</literal> 返回 <varname>object</varname> 对象的属性和方法列表――你正在映射的列表。所以唯一新出现的部分就是在 &if; 后面的过滤表达式。</para>
<para>过滤表达式看上去很恐怖，其实不是。你已经知道了 <link linkend="apihelper.builtin.callable">&callable;</link>、<link linkend="apihelper.getattr.intro">&getattr;</link> 和 <link linkend="odbchelper.tuplemethods">&in;</link>。正如你在<link linkend="apihelper.getattr">前面的部分</link>中看到的，如果 <varname>object</varname> 是一个模块，并且 <varname>method</varname> 是上述模块中某个函数的名称，那么表达式 <literal>&apihelper_getattr;</literal> 将返回一个函数对象。</para>
<para>所以这个表达式接收一个名为 <varname>object</varname> 的对象，然后得到它的属性、方法、函数和其他成员的名称列表，接着过滤掉我们不关心的成员。执行过滤行为是通过对每个属性/方法/函数的名称调用 &getattr; 函数取得实际成员的引用，然后检查这些成员对象是否是可调用的，当然这些可调用的成员对象可能是方法或者函数，同时也可能是内置的 (比如列表的 &pop; 方法) 或者用户自定义的 (比如 &odbchelper_modulename; 模块的 &odbchelper_function; 函数)。这里你不用关心其它的属性，如内置在每一个模块中的 &name; 属性。</para>
<itemizedlist role="furtherreading">
<title>进一步阅读</title>
<listitem><para>&pythontutorial; 讨论了<ulink url="&url_pythontutorial;node7.html#SECTION007130000000000000000">使用内置 <function>filter</function> 函数</ulink>过滤列表的另一种方式。</para></listitem>
</itemizedlist>
</section>
<section id="apihelper.andor">
<?dbhtml filename="power_of_introspection/and_or.html"?>
<title>&andfunction; 和 &orfunction; 的特殊性质</title>
<abstract>
<title/>
<para>在&python; 中，&andfunction; 和 &orfunction; 执行布尔逻辑演算，如你所期待的一样。但是它们并不返回布尔值，而是返回它们实际进行比较的值之一。</para>
</abstract>
<example id="apihelper.andor.intro.example">
<title>&andfunction; 介绍</title>
<screen>&prompt;<userinput>'a' and 'b'</userinput>         <co id="apihelper.andor.1.1"/>
<computeroutput>'b'</computeroutput>
&prompt;<userinput>'' and 'b'</userinput>          <co id="apihelper.andor.1.2"/>
<computeroutput>''</computeroutput>
&prompt;<userinput>'a' and 'b' and 'c'</userinput> <co id="apihelper.andor.1.3"/>
<computeroutput>'c'</computeroutput></screen>
<calloutlist>
<callout arearefs="apihelper.andor.1.1">
<para>使用 &andfunction; 时，在布尔环境中从左到右演算表达式的值。&zero;、<literal>''</literal>、<literal>[]</literal>、<literal>()</literal>、<literal>{}</literal>、&none; 在布尔环境中为假；其它任何东西都为真。还好，几乎是所有东西。默认情况下，布尔环境中的类实例为真，但是你可以在类中定义特定的方法使得类实例的演算值为假。你将会在<xref linkend="fileinfo" endterm="fileinfo.numberonly"/>中了解到类和这些特殊方法。如果布尔环境中的所有值都为真，那么 &andfunction; 返回最后一个值。在这个例子中，&andfunction; 演算 <literal>'a'</literal> 的值为真，然后是 <literal>'b'</literal> 的演算值为真，最终返回 <literal>'b'</literal>。</para>
</callout>
<callout arearefs="apihelper.andor.1.2">
<para>如果布尔环境中的某个值为假，则 &andfunction; 返回第一个假值。在这个例子中，<literal>''</literal> 是第一个假值。</para>
</callout>
<callout arearefs="apihelper.andor.1.3">
<para>所有值都为真，所以 &andfunction; 返回最后一个真值，<literal>'c'</literal>。</para>
</callout>
</calloutlist>
</example>
<example>
<title>&orfunction; 介绍</title>
<screen>&prompt;<userinput>'a' or 'b'</userinput>          <co id="apihelper.andor.2.1"/>
<computeroutput>'a'</computeroutput>
&prompt;<userinput>'' or 'b'</userinput>           <co id="apihelper.andor.2.2"/>
<computeroutput>'b'</computeroutput>
&prompt;<userinput>'' or [] or {}</userinput>      <co id="apihelper.andor.2.3"/>
<computeroutput>{}</computeroutput>
&prompt;<userinput>def sidefx():</userinput>
&continuationprompt;<userinput>print "in sidefx()"</userinput>
&continuationprompt;<userinput>return 1</userinput>
&prompt;<userinput>'a' or sidefx()</userinput>     <co id="apihelper.andor.2.4"/>
<computeroutput>'a'</computeroutput></screen>
<calloutlist>
<callout arearefs="apihelper.andor.2.1">
<para>使用 &orfunction; 时，在布尔环境中从左到右演算值，就像 &andfunction; 一样。如果有一个值为真，&orfunction; 立刻返回该值。本例中，<literal>'a'</literal> 是第一个真值。</para>
</callout>
<callout arearefs="apihelper.andor.2.2">
<para>&orfunction; 演算 <literal>''</literal> 的值为假，然后演算 <literal>'b'</literal> 的值为真，于是返回 <literal>'b'</literal> 。</para>
</callout>
<callout arearefs="apihelper.andor.2.3">
<para>如果所有的值都为假，&orfunction; 返回最后一个假值。&orfunction; 演算 <literal>''</literal> 的值为假，然后演算 <literal>[]</literal> 的值为假，依次演算 <literal>{}</literal> 的值为假，最终返回 <literal>{}</literal> 。</para>
</callout>
<callout arearefs="apihelper.andor.2.4">
<para>注意 &orfunction; 在布尔环境中会一直进行表达式演算直到找到第一个真值，然后就会忽略剩余的比较值。如果某些值具有副作用，这种特性就非常重要了。在这里，函数 <function>sidefx</function> 永远都不会被调用，因为 &orfunction; 演算 <literal>'a'</literal> 的值为真，所以紧接着就立刻返回 <literal>'a'</literal> 了。</para>
</callout>
</calloutlist>
</example>
<para>如果你是一名 &c; 语言黑客，肯定很熟悉 &candor; 表达式，如果 <replaceable>bool</replaceable> 为真，表达式演算值为 <varname>a</varname>，否则为 <varname>b</varname>。基于 &python; 中 &andfunction; 和 &orfunction; 的工作方式，你可以完成相同的事情。</para>
<section>
<title>使用 &andor; 技巧</title>
<example id="apihelper.andortrick.intro">
<title>&andor; 技巧介绍</title>
<screen>&prompt;<userinput>a = "first"</userinput>
&prompt;<userinput>b = "second"</userinput>
&prompt;<userinput>1 and a or b</userinput> <co id="apihelper.andor.3.1"/>
<computeroutput>'first'</computeroutput>
&prompt;<userinput>0 and a or b</userinput> <co id="apihelper.andor.3.2"/>
<computeroutput>'second'</computeroutput>
</screen>
<calloutlist>
<callout arearefs="apihelper.andor.3.1">
<para>这个语法看起来类似于 &c; 语言中的 &candor; 表达式。整个表达式从左到右进行演算，所以先进行 &andfunction; 表达式的演算。<literal>1 and 'first'</literal> 演算值为 <literal>'first'</literal>，然后 <literal>'first' or 'second'</literal> 的演算值为 <literal>'first'</literal>。</para>
</callout>
<callout arearefs="apihelper.andor.3.2">
<para><literal>0 and 'first'</literal> 演算值为 &false;，然后 <literal>0 or 'second'</literal> 演算值为 <literal>'second'</literal>。</para>
</callout>
</calloutlist>
</example>
<para>然而，由于这种 &python; 表达式单单只是进行布尔逻辑运算，并不是语言的特定构成，这是 &andor; 技巧和 &c; 语言中的 &candor; 语法非常重要的不同。如果 <varname>a</varname> 为假，表达式就不会按你期望的那样工作了。(你能知道我被这个问题折腾过吗？不止一次？)</para>
<example>
<title>&andor; 技巧无效的场合</title>
<screen>&prompt;<userinput>a = ""</userinput>
&prompt;<userinput>b = "second"</userinput>
&prompt;<userinput>1 and a or b</userinput>         <co id="apihelper.andor.4.1"/>
<computeroutput>'second'</computeroutput></screen>
<calloutlist>
<callout arearefs="apihelper.andor.4.1">
<para>由于 <varname>a</varname> 是一个空字符串，在 &python; 的布尔环境中空字符串被认为是假的，<literal>1 and ''</literal> 的演算值为 <literal>''</literal>，最后 <literal>'' or 'second'</literal> 的演算值为 <literal>'second'</literal>。噢！这个值并不是你想要的。</para>
</callout>
</calloutlist>
</example>
<para>&andor; 技巧，也就是 <literal><replaceable>bool</replaceable> and <varname>a</varname> or <varname>b</varname></literal> 表达式，当 <varname>a</varname> 在布尔环境中的值为假时，不会像 &c; 语言表达式 &candor; 那样工作。</para>
<para>在 &andor; 技巧后面真正的技巧是，确保 <varname>a</varname> 的值决不会为假。最常用的方式是使 <varname>a</varname> 成为 <literal>[<varname>a</varname>]</literal> 、 <varname>b</varname> 成为 <literal>[<varname>b</varname>]</literal>，然后使用返回值列表的第一个元素，应该是 <varname>a</varname> 或 <varname>b</varname>中的某一个。</para>
<example>
<title>安全使用 &andor; 技巧</title>
<screen>&prompt;<userinput>a = ""</userinput>
&prompt;<userinput>b = "second"</userinput>
&prompt;<userinput>(1 and [a] or [b])[0]</userinput> <co id="apihelper.andor.5.1"/>
<computeroutput>''</computeroutput></screen>
<calloutlist>
<callout arearefs="apihelper.andor.5.1">
<para>由于 <literal>[<varname>a</varname>]</literal> 是一个非空列表，所以它决不会为假。即使 <varname>a</varname> 是 &zero; 或者 <literal>''</literal> 或者其它假值，列表 <literal>[<varname>a</varname>]</literal> 也为真，因为它有一个元素。</para>
</callout>
</calloutlist>
</example>
<para>到现在为止，这个技巧可能看上去问题超过了它的价值。毕竟，使用 &if;  语句可以完成相同的事情，那为什么要经历这些麻烦事呢？哦，在很多情况下，你要在两个常量值中进行选择，由于你知道 <varname>a</varname> 的值总是为真，所以你可以使用这种较为简单的语法而且不用担心。对于使用更为复杂的安全形式，依然有很好的理由要求这样做。例如，在 &python; 语言的某些情况下 &if; 语句是不允许使用的，比如在 &lambdafunction; 函数中。</para>
<itemizedlist role="furtherreading">
<title>进一步阅读</title>
<listitem><para>&pythoncookbook; 讨论了<ulink url="&url_pythoncookbook;Recipe/52310">其它的 &andor; 技巧</ulink>。</para></listitem>
</itemizedlist>
</section>
</section>
<section id="apihelper.lambda">
<?dbhtml filename="power_of_introspection/lambda_functions.html"?>
<title>使用 &lambdafunction; 函数</title>
<abstract>
<title/>
<para>&python; 支持一种有趣的语法，它允许你快速定义单行的最小函数。这些叫做 &lambdafunction; 的函数，是从 &lisp; 借用来的，可以用在任何需要函数的地方。</para>
</abstract>
<example>
<title>&lambdafunction; 函数介绍</title>
<screen>&prompt;<userinput>def f(x):</userinput>
&continuationprompt;<userinput>return x*2</userinput>
&continuationprompt;<userinput/>
&prompt;<userinput>f(3)</userinput>
<computeroutput>6</computeroutput>
&prompt;<userinput>g = lambda x: x*2</userinput>  <co id="apihelper.lambda.1.2"/>
&prompt;<userinput>g(3)</userinput>
<computeroutput>6</computeroutput>
&prompt;<userinput>(lambda x: x*2)(3)</userinput> <co id="apihelper.lambda.1.3"/>
<computeroutput>6</computeroutput></screen>
<calloutlist>
<callout arearefs="apihelper.lambda.1.2">
<para>这是一个 &lambdafunction; 函数，完成同上面普通函数相同的事情。注意这里的简短的语法：在参数列表周围没有括号，而且忽略了 <literal>return</literal> 关键字 (隐含存在，因为整个函数只有一行)。而且，该函数没有函数名称，但是可以将它赋值给一个变量进行调用。</para>
</callout>
<callout arearefs="apihelper.lambda.1.3">
<para>使用 &lambdafunction; 函数时甚至不需要将它赋值给一个变量。这可能不是世上最有用的东西，它只是展示了 &lambdafunction; 函数只是一个内联函数。</para>
</callout>
</calloutlist>
</example>
<para>总的来说，&lambdafunction; 函数可以接收任意多个参数 (包括<link linkend="apihelper.optional">可选参数</link>) 并且返回单个表达式的值。&lambdafunction; 函数不能包含命令，包含的表达式不能超过一个。不要试图向 &lambdafunction; 函数中塞入太多的东西；如果你需要更复杂的东西，应该定义一个普通函数，然后想让它多长就多长。</para>
<note id="tip.lambda">
<title>&lambdafunction; 是可选的</title>
<para>&lambdafunction; 函数是一种风格问题。不一定非要使用它们；任何能够使用它们的地方，都可以定义一个单独的普通函数来进行替换。我将它们用在需要封装特殊的、非重用代码上，避免令我的代码充斥着大量单行函数。</para>
</note>
<section>
<title>真实世界中的 &lambdafunction; 函数</title>
<informalexample>
<!--<title>&lambdafunction; Functions in &apihelper_filename;</title>-->
<para>&apihelper_filename; 中的 &lambdafunction; 函数：</para>
<programlisting>
&apihelper_lambda;</programlisting>
</informalexample>
<para>注意这里使用了 <link linkend="apihelper.andor">&andor;</link> 技巧的简单形式，它是没问题的，因为 &lambdafunction; 函数<link linkend="tip.boolean">在布尔环境中</link>总是为真。(这并不意味这 &lambdafunction; 函数不能返回假值。这个函数对象的布尔值为真；它的返回值可以是任何东西。)</para>
<para>还要注意的是使用了没有参数的 &split; 函数。你已经看到过它带<link linkend="odbchelper.split.example">一个或者两个参数</link>的使用，但是不带参数它按空白进行分割。</para>
<example>
<title>&split; 不带参数</title>
<screen>&prompt;<userinput>s = "this   is\na\ttest"</userinput>  <co id="apihelper.split.1.1"/>
&prompt;<userinput>print s</userinput>
<computeroutput>this   is
a	test</computeroutput>
&prompt;<userinput>print s.split()</userinput>           <co id="apihelper.split.1.2"/>
<computeroutput>['this', 'is', 'a', 'test']</computeroutput>
&prompt;<userinput>print " ".join(s.split())</userinput> <co id="apihelper.split.1.3"/>
<computeroutput>'this is a test'</computeroutput></screen>
<calloutlist>
<callout arearefs="apihelper.split.1.1">
<para>这是一个多行字符串，通过使用转义字符的定义代替了<link linkend="odbchelper.triplequotes">三重引号</link>。<literal>\n</literal> 是一个回车，<literal>\t</literal> 是一个制表符。</para>
</callout>
<callout arearefs="apihelper.split.1.2">
<para>不带参数的 &split; 按照空白进行分割。所以三个空格、一个回车和一个制表符都是一样的。</para>
</callout>
<callout arearefs="apihelper.split.1.3">
<para>通过 &split; 分割字符串你可以将空格统一化；然后再以单个空格作为分隔符用 &join; 将其重新连接起来。这也就是 &info; 函数将多行 &docstring; 合并成单行所做的事情。</para>
</callout>
</calloutlist>
</example>
<para>那么 &info; 函数到底用这些 &lambdafunction; 函数、&split; 函数和 &andor; 技巧做了些什么呢？</para>
<informalexample id="apihelper.funcassign">
<!--<title>Assigning a Function to a Variable</title>-->
<programlisting>
&apihelper_lambda;</programlisting>
</informalexample>
<para><varname>processFunc</varname> 现在是一个函数，但是它到底是哪一个函数还要取决于 <varname>collapse</varname> 变量。如果 <varname>collapse</varname> 为真，<literal><varname>processFunc</varname>(<replaceable>string</replaceable>)</literal> 将压缩空白；否则 <literal><varname>processFunc</varname>(<replaceable>string</replaceable>)</literal> 将返回未改变的参数。</para>
<para>在一个不很健壮的语言中实现它，像 &vb;，你很有可能要创建一个函数，接受一个字符串参数和一个 <parameter>collapse</parameter> 参数，并使用 &if; 语句确定是否压缩空白，然后再返回相应的值。这种方式是低效的，因为函数可能需要处理每一种可能的情况。每次你调用它，它将不得不在给出你所想要的东西之前，判断是否要压缩空白。在 &python; 中，你可以将决策逻辑拿到函数外面，而定义一个裁减过的 &lambdafunction; 函数提供确切的 (唯一的) 你想要的。这种方式更为高效、更为优雅，而且很少引起那些令人讨厌 (哦，想到那些参数就头昏) 的错误。</para>
<itemizedlist role="furtherreading">
<title>&lambdafunction; 函数进一步阅读</title>
<listitem><para>&pythonknowledgebase; 讨论了使用 &lambdafunction; 来<ulink url="&url_pythonknowledgebase;view.phtml/aid/6081/fid/241">间接调用函数</ulink>。</para></listitem>
<listitem><para>&pythontutorial; 演示了如何<ulink url="&url_pythontutorial;node6.html#SECTION006740000000000000000">从一个 &lambdafunction; 函数内部访问外部变量</ulink>。(<ulink url="&url_pythonpeps;pep-0227.html"><acronym>PEP</acronym> 227</ulink> 解释了在 &python; 的未来版本中将如何变化。)</para></listitem>
<listitem><para>&pythonfaq; 有关于<ulink url="&url_pythonorg;cgi-bin/faqw.py?query=4.15&amp;querytype=simple&amp;casefold=yes&amp;req=search">令人模糊的使用 &lambdafunction; 单行语句</ulink>的例子。</para></listitem>
</itemizedlist>
</section>
</section>
<section id="apihelper.alltogether">
<?dbhtml filename="power_of_introspection/all_together.html"?>
<title>全部放在一起</title>
<abstract>
<title/>
<para>最后一行代码是唯一还没有解释过的，它完成全部的工作。但是现在工作已经简单了，因为所需要的每件事都已经按照需求建立好了。所有的多米诺骨牌已经就位，到了将它们推倒的时候了。</para>
</abstract>
<informalexample>
<!--<title>The Meat of &apihelper_filename;</title>-->
<para>下面是 &apihelper_filename; 的关键</para>
<programlisting>
&apihelper_main;</programlisting>
</informalexample>
<para>注意这是一条命令，被分隔成了多行，但是并没有使用续行符 (<literal>\</literal>)。还记得我说过<link linkend="tip.implicitmultiline">一些表达式可以分割成多行</link>而不需要使用反斜线吗？列表解析就是这些表达式之一，因为整个表达式包括在方括号里。</para>
<para>现在，让我们从后向前分析。</para><programlisting>
for method in methodList</programlisting><para>告诉我们这是一个<link linkend="odbchelper.map">列表解析</link>。如你所知 <varname>methodList</varname> 是 <varname>object</varname> 中<link linkend="apihelper.filter.care">所有你关心的方法</link>的一个列表。所以你正在使用 <varname>method</varname> 遍历列表。</para>
<example>
<title>动态得到 &docstring; </title>
<screen>&prompt;<userinput>import &odbchelper_name;</userinput>
&prompt;<userinput>object = &odbchelper_name;</userinput>                   <co id="apihelper.alltogether.1.1"/>
&prompt;<userinput>method = '&odbchelper_funcname;'</userinput>      <co id="apihelper.alltogether.1.2"/>
&prompt;<userinput>getattr(object, method)</userinput>               <co id="apihelper.alltogether.1.3"/>
<computeroutput>&lt;function buildConnectionString at 010D6D74></computeroutput>
&prompt;<userinput>print getattr(object, method).__doc__</userinput> <co id="apihelper.alltogether.1.4"/>
<computeroutput>&odbchelper_docstring;</computeroutput></screen>
<calloutlist>
<callout arearefs="apihelper.alltogether.1.1">
<para>在 &info; 函数中，<varname>object</varname> 是要得到帮助的对象，作为一个参数传入。</para>
</callout>
<callout arearefs="apihelper.alltogether.1.2">
<para>在你遍历 <varname>methodList</varname> 时，<varname>method</varname> 是当前方法的名称。</para>
</callout>
<callout arearefs="apihelper.alltogether.1.3">
<para>通过 <link linkend="apihelper.getattr">&getattr;</link> 函数，你可以得到 <replaceable>object</replaceable> 模块中 <replaceable>method</replaceable> 函数的引用。</para>
</callout>
<callout arearefs="apihelper.alltogether.1.4">
<para>现在，很容易就可以打印出方法的 &docstring; 。</para>
</callout>
</calloutlist>
</example>
<para>接下来令人困惑的是 &docstring; 周围 &str; 的使用。你可能记得，&str; 是一个内置函数，它可以<link linkend="apihelper.builtin">强制将数据转化为字符串</link>。但是一个 &docstring; 应该总是一个字符串，为什么还要费事地使用 &str; 函数呢？答案就是：不是每个函数都有 &docstring; ，如果没有，这个 &doc; 属性为 &none;。</para>
<example>
<title>为什么对一个 &docstring; 使用 &str; ？</title>
<screen>&prompt;<userinput>>>> def foo(): print 2</userinput>
&prompt;<userinput>>>> foo()</userinput>
<computeroutput>2</computeroutput>
&prompt;<userinput>>>> foo.__doc__</userinput>     <co id="apihelper.alltogether.2.1"/>
&prompt;<userinput>foo.__doc__ == None</userinput> <co id="apihelper.alltogether.2.2"/>
<computeroutput>True</computeroutput>
&prompt;<userinput>str(foo.__doc__)</userinput>    <co id="apihelper.alltogether.2.3"/>
<computeroutput>'None'</computeroutput>
</screen>
<calloutlist>
<callout arearefs="apihelper.alltogether.2.1">
<para>你可以很容易的定义一个没有 &docstring; 的函数，这种情况下它的 &doc; 属性为 &none;。令人迷惑的是，如果你直接演算 &doc; 属性的值，&python; &ide; 什么都不会打印。这是有意义的 (前提是你考虑了这个结果的来由)，但是却没有什么用。</para>
</callout>
<callout arearefs="apihelper.alltogether.2.2">
<para>你可以直接通过 &doc; 属性和 &none; 的比较验证 &doc; 属性的值。</para>
</callout>
<callout arearefs="apihelper.alltogether.2.3">
<para>&str; 函数可以接收值为 null  的参数，然后返回它的字符串表示，<literal>'None'</literal>。</para>
</callout>
</calloutlist>
</example>
<note id="compare.isnull.sql" role="compare" vendor="sql">
<title>&python; &vs; &sql;：的 null 值比较</title>
<para>在 &sql; 中，你必须使用 <literal>IS NULL</literal> 代替 <literal>= NULL</literal> 进行 null 值比较。在 &python;，你可以使用 <literal>== None</literal> 或者 <literal>is None</literal> 进行比较，但是 <literal>is None</literal> 更快。</para>
</note>
<para>现在你确保有了一个字符串，可以把这个字符串传给 <varname>processFunc</varname>，这个函数<link linkend="apihelper.lambda">已经定义</link>是一个既可以压缩空白也可以不压缩空白的函数。现在你看出来为什么使用 &str; 将 &none; 转化为一个字符串很重要了。<varname>processFunc</varname> 假设接收到一个字符串参数然后调用 &split; 方法，如果你传入 &none; ，将导致程序崩溃，因为 &none; 没有 &split; 方法。</para>
<para>再往回走一步，你再一次使用了字符串格式化来连接 <varname>processFunc</varname> 的返回值 和 <varname>method</varname> 的 &ljust; 方法的返回值。&ljust; 是一个你之前没有见过的新字符串方法。</para>
<example>
<title>&ljust; 方法介绍</title>
<screen>&prompt;<userinput>s = 'buildConnectionString'</userinput>
&prompt;<userinput>s.ljust(30)</userinput> <co id="apihelper.alltogether.3.1"/>
<computeroutput>'buildConnectionString         '</computeroutput>
&prompt;<userinput>s.ljust(20)</userinput> <co id="apihelper.alltogether.3.2"/>
<computeroutput>'buildConnectionString'</computeroutput></screen>
<calloutlist>
<callout arearefs="apihelper.alltogether.3.1">
<para>&ljust; 用空格填充字符串以符合指定的长度。<function>info</function> 函数使用它生成了两列输出并将所有在第二列的 &docstring; 纵向对齐。</para>
</callout>
<callout arearefs="apihelper.alltogether.3.2">
<para>如果指定的长度小于字符串的长度，&ljust; 将简单地返回未变化的字符串。它决不会截断字符串。</para>
</callout>
</calloutlist>
</example>
<para>几乎已经完成了。有了 &ljust; 方法填充过的方法名称和来自调用 <varname>processFunc</varname> 方法得到的 &docstring; (可能压缩过)，你就可以将两者连接起来并得到单个字符串。因为对 <varname>methodList</varname> 进行了映射，最终你将获得一个字符串列表。利用 <literal>"\n"</literal> 的 &join; 函数，将这个列表连接为单个字符串，列表中每个元素独占一行，接着打印出结果。</para>
<example>
<title>打印列表</title>
<screen>&prompt;<userinput>li = ['a', 'b', 'c']</userinput>
&prompt;<userinput>print "\n".join(li)</userinput> <co id="apihelper.alltogether.4.1"/>
<computeroutput>a
b
c</computeroutput></screen>
<calloutlist>
<callout arearefs="apihelper.alltogether.4.1">
<para>在你处理列表时，这确实是一个有用的调试技巧。在 &python; 中，你会十分频繁地操作列表。</para>
</callout>
</calloutlist>
</example>
<para>上述就是最后一个令人困惑的地方了。但是现在你应该已经理解这段代码了。</para>
<informalexample>
<!--<title>The Meat of &apihelper_filename;, Revisited</title>-->
<programlisting>
&apihelper_main;</programlisting>
</informalexample>
</section>
<section id="apihelper.summary">
<?dbhtml filename="power_of_introspection/summary.html"?>
<title>小结</title>
<abstract>
<title/>
<para>&apihelper_filename; 程序和它的输出现在应该非常清晰了。</para>
</abstract>
<informalexample>
<!--<title>&apihelper_filename;</title>-->
<programlisting>
&apihelper_funcdef;
&apihelper_docstring;
&apihelper_docstring2;
&apihelper_docstring3;
&apihelper_methods;
&apihelper_lambda;
&apihelper_main;

&apihelper_ifname;
&apihelper_printdoc;</programlisting>
</informalexample>
<informalexample>
<!--<title>Output of &apihelper_filename;</title>-->
<para>&apihelper_filename; 的输出：</para>
<screen>&apihelper_output;</screen>
</informalexample>
<highlights>
<para>在研究下一章前，确保你可以无困难的完成下面这些事情：</para>
<itemizedlist>
<listitem><para>用<link linkend="apihelper.optional">可选和命名参数</link>定义和调用函数</para></listitem>
<listitem><para>用 <link linkend="apihelper.str.intro">&str;</link> 强制转换任意值为字符串形式</para></listitem>
<listitem><para>用 <link linkend="apihelper.getattr">&getattr;</link> 动态得到函数和其它属性的引用</para></listitem>
<listitem><para>扩展列表解析语法实现<link linkend="apihelper.filter">列表过滤</link></para></listitem>
<listitem><para>识别 <link linkend="apihelper.andor">&andor; 技巧</link>并安全地使用它</para></listitem>
<listitem><para>定义 <link linkend="apihelper.lambda">&lambdafunction; 函数</link></para></listitem>
<listitem><para><link linkend="apihelper.funcassign">将函数赋值给变量</link>然后通过引用变量调用函数。我强调的已经够多了：这种思考方式对于提高对 &python; 的理解力至关重要。在本书中你会随处可见这种技术的更复杂的应用。</para></listitem>
</itemizedlist>
</highlights>
</section>
</chapter>
