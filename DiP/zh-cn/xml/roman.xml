<?xml version="1.0" encoding="utf-8"?>
<chapter id="roman">
<?dbhtml filename="unit_testing/index.html"?>
<title>单元测试</title>
<titleabbrev id="roman.numberonly">第 13 章</titleabbrev>
<section id="roman.intro">
<title>罗马数字程序介绍 II</title>
<abstract>
<title/>
<para>在前面的章节中，通过阅读代码，你迅速<quote>深入</quote>，以最快的速度理解了各个程序。既然你已对 &python; 有了一定的了解，那么接下来让我们看看程序开发<emphasis>之前</emphasis> 的工作。</para>
</abstract>
<para>在接下来的几章中，你将会编写、调试和优化一系列工具函数来进行罗马数字和阿拉伯数字之间的转换。你已从<xref linkend="re.roman"/>中获知构造和验证罗马数字的机制，现在我们要做的事是退后一步去思考如何将这些机制扩展到一个双向转换的工具。</para>

<para><link linkend="re.roman">罗马数字的规则</link>有如下一些有趣的特点：</para>
<orderedlist>
<listitem><para>一个特定数字以罗马数字表示时只有单一方式。</para></listitem>
<listitem><para>反之亦然：一个有效的罗马数字表示的数也只对应一个阿拉伯数字表示。(也就是说转换成阿拉伯数字表示只有一种方法。)</para></listitem>
<listitem><para>我们研究的是 <literal>1</literal> 和 <literal>3999</literal> 之间的数字的罗马数字表示。(罗马数字有很多方法用以记录更大的数，例如在数字上加线表示<literal>1000</literal>倍的数，但你不必去理会这些。就本章而言，我们姑且把罗马数字限定在 <literal>1</literal> 到 <literal>3999</literal> 之间)。</para></listitem>
<listitem><para>罗马数字无法表示 &zero;。(令人诧异，古罗马竟然没有 &zero; 这个数字的概念。数字是为数数服务的，没有怎么数呢？)</para></listitem>
<listitem><para>罗马数字不能表示负数。</para></listitem>
<listitem><para>罗马数字无法表示分数和非整数。</para></listitem>
</orderedlist>
<para>基于如上所述，你将如何构造罗马数字转换函数呢？</para>
<orderedlist id="roman.requirements">
<title>&roman_filename; 功能需求</title>
<listitem><para>&toroman; 应该能返回 &one; 到 <literal>3999</literal> 中任意数的罗马数字表示。</para></listitem>
<listitem><para>&toroman; 在遇到 &one; 到 <literal>3999</literal> 之外的数字时应该失败。</para></listitem>
<listitem><para>&toroman; 在遇到非整数时应该失败。</para></listitem>
<listitem><para>&fromroman; 应该能将给定的有效罗马数字表示转换为阿拉伯数字表示。</para></listitem>
<listitem><para>&fromroman; 在遇到无效罗马数字表示时应该失败。</para></listitem>
<listitem><para>将一个数转换为罗马数字表示，再转换回阿拉伯数字表示后应该和最初的数相同。因此，<literal>fromRoman(toRoman(n)) == n </literal>对于 <literal>1..3999</literal> 之间所有 <varname>n</varname> 都适用。</para></listitem>
<listitem><para>&toroman; 返回的罗马数字应该使用大写字母。</para></listitem>
<listitem><para>&fromroman; 应该只接受大写罗马数字 (也就是说给定小写字母进行转换时应该失败)。</para></listitem>
</orderedlist>
<itemizedlist role="furtherreading">
<title>进一步阅读</title>
<listitem><para><ulink url="&url_romannumerals;">这个站点</ulink> 有关于罗马数字更多的内容，包括罗马人如何使用罗马数字的迷人 <ulink url="&url_romanhistory;">历史</ulink> (简言之：充满偶然性和反复无常)。</para></listitem>
</itemizedlist>
</section>
<section id="roman.divein">
<?dbhtml filename="unit_testing/diving_in.html"?>
<title>深入</title>
<abstract>
<title/>
<para>现在你已经定义了你的转换程序所应有的功能，下面一步会有点儿出乎你的意料：你将要开发一个测试组件 (test suite) 来测试你未来的函数以确保它们工作正常。没错：你将为还未开发的程序开发测试代码。</para>
</abstract>
<para>这就是所谓的单元测试，因为这两个转换函数可以被当作一个单元来开发和测试，不用考虑它们可能今后成为一个大程序的一部分。&python; 有一个单元测试框架，被恰如其分地称作 &unittest_module; 模块。</para>
<note id="note.unittest" role="compatibility">
<title>你有 &unittest_module; 吗？</title>
<para>&python; 2.1 和之后的版本已经包含了 &unittest_module;。&python; 2.0 用户则可以从 <ulink url="&url_pyunit;">&url_pyunit_display;</ulink>下载。</para>
</note>
<para>单元测试是以测试为核心开发策略的重要组成部分。如果你要写单元测试代码，尽早 (最好是在被测试代码开发之前) 开发并根据代码开发和需求的变化不断更新是很重要的。单元测试不能取代更高层面的功能和系统测试，但在开发的每个阶段都很重要：</para>
<itemizedlist>
<listitem><para>代码开发之前，强迫你以有效的方式考虑需求的细节。</para></listitem>
<listitem><para>代码开发中，防止过度开发。通过了所有测试用例，程序的开发就完成了。</para></listitem>
<listitem><para>重构代码时，确保新版和旧版功能一致。</para></listitem>
<listitem><para>维护代码时，当你的代码更改导致别人代码出问题时帮你留住面子。(<quote>但是<emphasis>先生</emphasis>，我检入 (check in) 代码时所有的单元测试都通过了……</quote>)</para></listitem>
<listitem><para>在团队开发时，可以使你有信心，保证自己提交的代码不会破坏其他人的代码，因为你可以 先运行其他人的单元测试代码。(我在“代码风暴”中见过这种事情。一个团队将任务拆分，每个人都根据自己那部分的需求开发单元测试，然后与其他成员共享。没有人会出太大的偏差而导致代码无法集成。) </para></listitem>
</itemizedlist>
</section>
<section id="roman.romantest">
<?dbhtml filename="unit_testing/romantest.html"?>
<title>&romantest_filename; 介绍</title>
<abstract>
<title/>
<para>这是将被开发并保存为 &roman_filename; 的罗马数字转换程序的完整测试组件 (test suite)。很难立刻看出它们是如何协同工作的，似乎所有类或者方法之间都没有关系。这是有原因的，而且你很快就会明了。</para>
</abstract>
<example>
<title>&romantest_filename;</title>
&para_download;
<programlisting>
&romantest_full;</programlisting>
</example>
<itemizedlist role="furtherreading">
<title>进一步阅读</title>
<listitem><para><ulink url="&url_pyunit;"> &pyunit; 主页</ulink> 对于使用 <ulink url="&url_pyunit;pyunit.html">&unittest_module; 框架</ulink> 以及本章没能涵盖的高级特性有深入的讨论。</para></listitem>
<listitem><para><ulink url="&url_pyunit;pyunit.html"> &pyunit; &faq;</ulink> 解释了 <ulink url="&url_pyunit;pyunit.html#WHERE">为什么测试用例要和被测试代码分开存放</ulink> 。</para></listitem>
<listitem><para>&pythonlibraryreference; 总结了 <ulink url="&url_pythonlibraryreference;module-unittest.html">&unittest_module;</ulink> 模块。</para></listitem>
<listitem><para><ulink url="&url_xp;">ExtremeProgramming.org</ulink> 讨论 <ulink url="&url_xp;rules/unittests.html">你为什么需要编写单元测试</ulink>。</para></listitem>
<listitem><para><ulink url="&url_c2;">The Portland Pattern Repository</ulink> 有一个持续的 <ulink url="&url_c2;?UnitTests">单元测试</ulink> 讨论，包括了一个 <ulink url="&url_c2;?StandardDefinitionOfUnitTest">标准的定义</ulink>，为什么你需要 <ulink url="&url_c2;?CodeUnitTestFirst">首先开发单元测试代码</ulink> 以及另外一些深层次 <ulink url="&url_c2;?UnitTestTrial">案例</ulink>。</para></listitem>
</itemizedlist>
</section>
<section id="roman.success">
<?dbhtml filename="unit_testing/testing_for_success.html"?>
<title>正面测试 (Testing for success)</title>
<abstract>
<title/>
<para>单元测试的基础是构建独立的测试用例 (test case)。一个测试用例只回答一个关于被测试代码的问题。</para>
</abstract>
<para>一个测试用例应该做到：</para>
<itemizedlist>
<listitem><para>完全独立运行，不需要人工输入。单元测试应该是自动的。</para></listitem>
<listitem><para>可以自己判断被测试函数是通过还是失败，不需要人工干预结果。</para></listitem>
<listitem><para>独立运行，可以与其他测试用例隔离 (尽管它们可能测试着同一个函数)。每个测试用例是一个孤岛。</para></listitem>
</itemizedlist>
<para>基于如上原则，让我们构建第一个测试用例。应符合如下<link linkend="roman.requirements">要求</link>：</para>
<orderedlist>
<listitem><para>&toroman; 应该为所有 &one; 到 <literal>3999</literal> 的整数返回罗马数字表示。</para></listitem>
</orderedlist>
<example id="roman.testtoromanknownvalues.example">
<title><function>testToRomanKnownValues</function></title>
<programlisting>
&romantest_knownvaluesdef; <co id="roman.success.1.0"/>
&romantest_knownvaluesattr; <co id="roman.success.1.1"/>

&romantest_toknowndef; <co id="roman.success.1.2"/>
&romantest_toknowndoc;
&romantest_toknownfor;
&romantest_toknowncode1; <co id="roman.success.1.3"/> <co id="roman.success.1.4"/>
&romantest_toknowncode2; <co id="roman.success.1.5"/></programlisting>
<calloutlist>
<callout arearefs="roman.success.1.0">
<para>编写测试用例的第一步就是继承 &unittest_module; 模块中的 &testcase_classname; 类，它提供了很多可以用在你的测试用例中来测试特定情况的有用方法。</para>
</callout>
<callout arearefs="roman.success.1.1">
<para>这是我手工转换的一个 integer/numeral 对列表。它包含了最小的十个数、最大的数、每个单字符罗马数字对应的数，以及其他随机挑选的有效数样本。单元测试的关键不在于所有可能的输入，而是一个有代表性的样本。</para>
</callout>
<callout arearefs="roman.success.1.2">
<para>每个独立测试本身都是一个方法，既不需要参数也不返回任何值。如果该方法正常退出没有引发异常，测试被认为通过；如果测试引发异常，测试被认为失败。</para>
</callout>
<callout arearefs="roman.success.1.3">
<para>这里你真正调用了 &toroman; 函数。(当然，函数还没有编写，但一旦被编写，这里便是调用之处。) 注意你在这里为 &toroman; 函数定义了 &api; ：它必须接受整数 (待转换的数) 并返回一个字符串 (对应的罗马数字表示)，如果 &api; 不是这样，测试将失败。</para>
</callout>
<callout arearefs="roman.success.1.4">
<para>同样值得注意，你在调用 &toroman; 时没有试图捕捉任何可能发生的异常。这正是我们所希望的。以有效输入调用 &toroman; 不会引发任何异常，而你看到的这些输入都是有效的。如果 &toroman; 引发了异常，则测试失败。</para>
</callout>
<callout arearefs="roman.success.1.5">
<para>假设 &toroman; 函数被正确编写，正确调用，运行成功并返回一个值，最后一步便是检查这个返回值<emphasis>正确</emphasis> 与否。这是一个常见的问题，&testcase_classname; 类提供了一个方法：&assertEqual;，来测试两个值是否相等。如果 &toroman; 返回的结果 (<varname>value</varname>) 不等于我们预期的值 (<varname>numeral</varname>)，&assertEqual; 将会引发一个异常，测试也就此失败。如果两个值相等，&assertEqual; 什么也不做。如果每个从 &toroman; 返回的值都等于预期值，&assertEqual; 便不会引发异常，于是 <function>testToRomanKnownValues</function> 最终正常退出，这意味着 &toroman; 通过了该测试。</para>
</callout>
</calloutlist>
</example>
</section>
<section id="roman.failure">
<?dbhtml filename="unit_testing/testing_for_failure.html"?>
<title>负面测试 (Testing for failure)</title>
<abstract>
<title/>
<para>使用有效输入确保函数成功通过测试还不够，你还需要测试无效输入导致函数失败的情形。但并不是任何失败都可以，必须如你预期地失败。</para>
</abstract>
<para>还记得 &toroman; 的<link linkend="roman.requirements">其他要求</link>吧：</para>
<orderedlist continuation="continues">
<listitem><para>&toroman; 在输入值为 &one; 到 <literal>3999</literal> 之外时失败。</para></listitem>
<listitem><para>&toroman; 在输入值为非整数时失败。</para></listitem>
</orderedlist>
<para>在 &python; 中，函数以引发<link linkend="fileinfo.exception">异常</link>的方式表示失败。&unittest_module; 模块提供了用于测试函数是否在给定无效输入时引发特定异常的方法。</para>
<example id="roman.tobadinput.example">
<title>测试 &toroman; 的无效输入</title>
<programlisting>
&romantest_tobadinputdef;
&romantest_toolargedef;
&romantest_toolargedoc;
&romantest_toolargecode; <co id="roman.failure.1.1"/>

&romantest_zerodef;
&romantest_zerodoc;
&romantest_zerocode; <co id="roman.failure.1.2"/>

&romantest_negativedef;
&romantest_negativedoc;
&romantest_negativecode;

&romantest_decimaldef;
&romantest_decimaldoc;
&romantest_decimalcode; <co id="roman.failure.1.3"/></programlisting>
<calloutlist>
<callout arearefs="roman.failure.1.1">
<para>&unittest_module; 模块中的 &testcase_classname; 类提供了 &assertRaises; 方法，它接受这几个参数：预期的异常、测试的函数，以及传递给函数的参数。(如果被测试函数有不止一个参数，把它们按顺序全部传递给 &assertRaises; ，它会把这些参数传给被测的函数。) 特别注意这里的操作：不是直接调用 &toroman; 再手工查看是否引发特定异常 (使用 <link linkend="fileinfo.exception">&tryexcept; 块</link>捕捉异常)，&assertRaises; 为我们封装了这些。所有你要做的就是把异常 (<errorcode>roman.OutOfRangeError</errorcode>)、函数 (&toroman;) 以及 &toroman; 的参数 (<literal>4000</literal>) 传递给 &assertRaises; ，它会调用 &toroman; 查看是否引发 <errorcode>roman.OutOfRangeError</errorcode> 异常。(还应注意到你是把 &toroman; 函数本身当作一个参数，而不是调用它，传递它的时候也不是把它的名字作为一个字符串。我提到过吗？无论是函数还是异常，<link linkend="odbchelper.objects"> &python; 中万物皆对象</link>)。</para>
</callout>
<callout arearefs="roman.failure.1.2">
<para>与测试过大的数相伴的便是测试过小的数。记住，罗马数字不能表示 &zero; 和负数，所以你要分别编写测试用例 ( <function>testZero</function> 和 <function>testNegative</function>)。在 <function>testZero</function> 中，你测试 &toroman; 调用 &zero; 引发的 <errorcode>roman.OutOfRangeError</errorcode> 异常，如果<emphasis>没能</emphasis> 引发 <errorcode>roman.OutOfRangeError</errorcode> (不论是返回了一个值还是引发了其他异常)，则测试失败。</para>
</callout>
<callout arearefs="roman.failure.1.3">
<para><link linkend="roman.requirements">要求 #3</link>：&toroman; 不能接受非整数输入，所以这里你测试 &toroman; 在输入 <literal>0.5</literal> 时引发 <errorcode>roman.NotIntegerError</errorcode> 异常。如果 &toroman; 没有引发 <errorcode>roman.NotIntegerError</errorcode> 异常，则测试失败。</para>
</callout>
</calloutlist>
</example>
<para>接下来的两个<link linkend="roman.requirements">要求</link>与前三个类似，不同点是他们所针对的是 &fromroman; 而不是 &toroman;：</para>
<orderedlist continuation="continues">
<listitem><para>&fromroman; 应该能将输入的有效罗马数字转换为相应的阿拉伯数字表示。</para></listitem>
<listitem><para>&fromroman; 在输入无效罗马数字时应该失败。</para></listitem>
</orderedlist>
<para>要求 #4 与<link linkend="roman.testtoromanknownvalues.example">要求 #1</link> 的处理方法相同，即测试一个已知样本中的一个个数字对。要求 #5 与 #2 和 #3的处理方法相同，即通过无效输入确认 &fromroman; 引发恰当的异常。</para>
<example id="roman.frombadinput.example">
<title>测试 &fromroman; 的无效输入</title>
<programlisting>
&romantest_frombadinputdef;
&romantest_toomanydef;
&romantest_toomanydoc;
&romantest_toomanyfor;
&romantest_toomanyassert; <co id="roman.failure.2.1"/>

&romantest_repeateddef;
&romantest_repeateddoc;
&romantest_repeatedfor;
&romantest_repeatedassert;

&romantest_malformeddef;
&romantest_malformeddoc;
&romantest_malformedfor;
&romantest_malformedassert;</programlisting>
<calloutlist>
<callout arearefs="roman.failure.2.1">
<para>没什么新鲜的，与测试 &toroman; 无效输入时相同的模式，只是你有了一个新的异常：<errorcode>roman.InvalidRomanNumeralError</errorcode>。&roman_filename; 中一共要定义三个异常 (另外的两个是 <errorcode>roman.OutOfRangeError</errorcode> 和 <errorcode>roman.NotIntegerError</errorcode>)。稍后你在开始编写 &roman_filename; 时将会知道如何定义这些异常。</para>
</callout>
</calloutlist>
</example>
</section>
<section id="roman.sanity">
<?dbhtml filename="unit_testing/testing_for_sanity.html"?>
<title>完备性检测 (Testing for sanity)</title>
<abstract>
<title/>
<para>你经常会发现一组代码中包含互逆的转换函数，一个把 A 转换为 B ，另一个把 B 转换为 A。在这种情况下，创建<quote>完备性检测</quote>可以使你在由 A 转 B 再转 A 的过程中不会出现丢失精度或取整等错误。</para>
</abstract>
<para>考虑这个<link linkend="roman.requirements">要求</link>：</para>
<orderedlist continuation="continues">
<listitem><para>如果你给定一个数，把它转化为罗马数字表示，然后再转换回阿拉伯数字表示，你所得到的应该是最初给定的那个数。因此，对于 <literal>1..3999</literal> 中的<varname>n</varname>，<literal>fromRoman(toRoman(n)) == n</literal> 总成立。</para></listitem>
</orderedlist>
<example id="roman.sanity.example">
<title>以 &toroman; 测试 &fromroman; 的输出</title>
<programlisting>
&romantest_sanityclassdef;
&romantest_sanitydef;
&romantest_sanitydoc;
&romantest_sanityfor; <co id="roman.sanity.1.1"/> <co id="roman.sanity.1.2"/>
&romantest_sanitycode1;
&romantest_sanitycode2;
&romantest_sanitycode3; <co id="roman.sanity.1.3"/></programlisting>
<calloutlist>
<callout arearefs="roman.sanity.1.1">
<para>你已经见到过 <link linkend="odbchelper.multiassign.range">&range; 函数</link>，但这里它以两个参数被调用，返回了从第一个参数 (&one;) 开始到<emphasis>但不包括</emphasis> 第二个参数 (<literal>4000</literal>) 的整数列表。因此，<literal>1..3999</literal> 就是准备转换为罗马数字表示的有效值列表。</para>
</callout>
<callout arearefs="roman.sanity.1.2">
<para>我想提一下，这里的 <varname>integer</varname> 并不是一个 &python; 关键字，而只是没有什么特别的变量名。</para>
</callout>
<callout arearefs="roman.sanity.1.3">
<para>这里的测试逻辑显而易见：把一个数 (<varname>integer</varname>) 转换为罗马数字表示的数 (<varname>numeral</varname>)，然后再转换回来 (<varname>result</varname>) 并确保最后的结果和最初的数是同一个数。如果不是，&assertEqual; 便会引发异常，测试也便立刻失败。如果所有的结果都和初始数一致，&assertEqual; 将会保持沉默，整个 <function>testSanity</function> 方法将会最终也保持沉默，测试则将会被认定为通过。</para>
</callout>
</calloutlist>
</example>
<para><link linkend="roman.requirements">最后两个要求</link>和其他的要求不同，似乎既武断而又微不足道：</para>
<orderedlist continuation="continues">
<listitem><para>&toroman; 返回的罗马数字应该使用大写字母。</para></listitem>
<listitem><para>&fromroman; 应该只接受大写罗马数字 (也就是说给定小写字母进行转换时应该失败)。</para></listitem>
</orderedlist>
<para>事实上，它们确实有点武断，譬如你完全可以让 &fromroman; 接受小写和大小写混合的输入；但他们也不是完全武断；如果 &toroman; 总是返回大写的输出，那么 &fromroman; 至少应该接受大写字母输入，不然 <quote>完备性检测</quote> (要求 #6) 就会失败。不管怎么说，<emphasis>只</emphasis> 接受大写输入还是武断的，但就像每个系统都会告诉你的那样，大小写总会出问题，因此事先规定这一点还是有必要的。既然有必要规定，那么也就有必要测试。</para>
<example>
<title>大小写测试</title>
<programlisting>
&romantest_casecheckdef;
&romantest_toromancasedef;
&romantest_toromancasedoc;
&romantest_toromancasefor;
&romantest_toromancasecode;
&romantest_toromancaseassert;         <co id="roman.sanity.2.1"/>

&romantest_fromromancasedef;
&romantest_fromromancasedoc;
&romantest_fromromancasefor;
&romantest_fromromancasecode1;
&romantest_fromromancasecode2;         <co id="roman.sanity.2.2"/> <co id="roman.sanity.2.3"/>
&romantest_fromromancaseassert;   <co id="roman.sanity.2.4"/></programlisting>
<calloutlist>
<callout arearefs="roman.sanity.2.1">
<para>关于这个测试用例最有趣的一点不在于它测试了什么，而是它不测试什么。它不会测试 &toroman; 的返回值是否<link linkend="roman.testtoromanknownvalues.example">正确</link>或者<link linkend="roman.sanity.example">一致</link>；这些问题由其他测试用例来回答。整个测试用例仅仅测试大写问题。你也许觉得应该将它并入到<link linkend="roman.sanity.example">完备性测试</link>，毕竟都要遍历整个输入值范围并调用 &toroman;。<footnote><para><quote>除了诱惑什么我都能抗拒。 (I can resist everything except temptation.)</quote>――Oscar Wilde</para></footnote>但是这样将会违背一条<link linkend="roman.success">基本规则</link>：每个测试用例只回答一个问题。试想一下，你将这个测试并入到完备性测试中，然后遇到了测试失败。你还需要进一步分析以便判定测试用例的哪部分出了问题。如果你需要分析方能找出问题所在，无疑你的测试用例在设计上出了问题。</para>
</callout>
<callout arearefs="roman.sanity.2.2">
<para>这有一个和前面相似的情况：尽管 <quote>你知道</quote> &toroman; 总是返回大写字母，你还是需要把返回值显式地转换成大写字母后再传递给只接受大写的 &fromroman; 进行测试。为什么？因为 &toroman; 只返回大写字母是一个独立的需求。如果你改变了这个需求，例如改成总是返回小写字母，那么 <function>testToRomanCase</function> 测试用例也应作出调整，但这个测试用例应该仍能通过。这是另外一个<link linkend="roman.success">基本规则</link>：每个测试用例必须可以与其他测试用例隔离工作，每个测试用例是一个“孤岛”。</para>
</callout>
<callout arearefs="roman.sanity.2.3">
<para>注意你并没有使用 &fromroman; 的返回值。这是一个有效的 &python; 语法：如果一个函数返回一个值，但没有被使用，&python; 会直接把这个返回值扔掉。这正是你所希望的，这个测试用例并不对返回值进行测试，只是测试 &fromroman; 接受大写字母而不引发异常。</para>
</callout>
<callout arearefs="roman.sanity.2.4">
<para>这行有点复杂，但是它与 <classname>ToRomanBadInput</classname> 和 <classname>FromRomanBadInput</classname> 测试很相似。
你在测试以特定值 (<literal>numeral.lower()</literal>，循环中目前罗马数字的小写版) 调用特定函数 (<function>roman.fromRoman</function>) 会确实引发特定的异常 (<literal>roman.InvalidRomanNumeralError</literal>)。如果 (在循环中的每一次) 确实如此，测试通过；如果有一次不是这样 (比如引发另外的异常或者不引发异常)，测试失败。</para>
</callout>
</calloutlist>
</example>
<para>在下一章中，你将看到如何编写可以通过这些测试的代码。</para>
</section>
</chapter>
<chapter id="roman1.5">
<?dbhtml filename="unit_testing/stage_1.html"?>
<title>测试优先编程</title>
<titleabbrev id="roman1.5.numberonly">第 14 章</titleabbrev>
<section id="roman.stage1">
<title>&roman_filename;, 第 1 阶段</title>
<abstract>
<title/>
<para>到目前为止，单元测试已经完成，是时候开始编写被单元测试测试的代码了。你将分阶段地完成这个工作，因此开始时所有的单元测试都是失败的，但在逐步完成 &roman_filename; 的同时你会看到它们一个个地通过测试。</para>
</abstract>
<example>
<title>&roman1_filename;</title>
<para>这个程序可以在例子目录下的 <filename>py/roman/stage1/</filename> 目录中找到。</para>
&para_download;
<programlisting>
"""Convert to and from Roman numerals"""

#Define exceptions
class RomanError(Exception): pass                <co id="roman.stage1.1.1"/>
class OutOfRangeError(RomanError): pass          <co id="roman.stage1.1.2"/>
class NotIntegerError(RomanError): pass
class InvalidRomanNumeralError(RomanError): pass <co id="roman.stage1.1.3"/>

def toRoman(n):
    """convert integer to Roman numeral"""
    pass                                         <co id="roman.stage1.1.4"/>

def fromRoman(s):
    """convert Roman numeral to integer"""
    pass
</programlisting>
<calloutlist>
<callout arearefs="roman.stage1.1.1">
<para>这就是如何定义你自己的 &python; 异常。异常 (Exception) 也是类，通过继承已有的异常，你可以创建自定义的异常。强烈建议 (但不是必须) 你继承 <errorcode>Exception</errorcode> 来定义自己的异常，因为它是所有内建异常的基类。这里我定义了 <errorcode>RomanError</errorcode> (从 <errorcode>Exception</errorcode> 继承而来) 作为我所有自定义异常的基类。这是一个风格问题，我也可以直接从 <errorcode>Exception</errorcode> 继承建立每一个自定义异常。</para>
</callout>
<callout arearefs="roman.stage1.1.2">
<para><errorcode>OutOfRangeError</errorcode> 和 <errorcode>NotIntegerError</errorcode> 异常将会最终被用于 &toroman; 以标示不同类型的无效输入，更具体而言就是 <link linkend="roman.tobadinput.example"><classname>ToRomanBadInput</classname></link> 测试的那些。</para>
</callout>
<callout arearefs="roman.stage1.1.3">
<para><errorcode>InvalidRomanNumeralError</errorcode> 将被最终用于 &fromroman; 以标示无效输入，具体而言就是 <link linkend="roman.frombadinput.example"><classname>FromRomanBadInput</classname></link>测试的那些。</para>
</callout>
<callout arearefs="roman.stage1.1.4">
<para>在这一步中你只是想定义每个函数的 &api; ，而不想具体实现它们，因此你以 &python; 关键字 <link linkend="fileinfo.class.simplest">&pass;</link> 姑且带过。</para>
</callout>
</calloutlist>
</example>
<para>重要的时刻到了 (请打起鼓来)：你终于要对这个简陋的小模块开始运行单元测试了。目前而言，每一个测试用例都应该失败。事实上，任何测试用例在此时通过，你都应该回头看看 &romantest_filename; ，仔细想想为什么你写的测试代码如此没用，以至于连什么都不作的函数都能通过测试。</para>
<para>用命令行选项 <option>-v</option> 运行 &romantest1_filename; 可以得到更详细的输出信息，这样你就可以看到每一个测试用例的具体运行情况。如果幸运，你的结果应该是这样的：</para>
<example id="roman.stage1.output">
<title>以 &romantest1_filename; 测试 &roman1_filename; 的输出</title>
<screen><computeroutput>fromRoman should only accept uppercase input ... ERROR
toRoman should always return uppercase ... ERROR
fromRoman should fail with malformed antecedents ... FAIL
fromRoman should fail with repeated pairs of numerals ... FAIL
fromRoman should fail with too many repeated numerals ... FAIL
fromRoman should give known result with known input ... FAIL
toRoman should give known result with known input ... FAIL
fromRoman(toRoman(n))==n for all n ... FAIL
toRoman should fail with non-integer input ... FAIL
toRoman should fail with negative input ... FAIL
toRoman should fail with large input ... FAIL
toRoman should fail with 0 input ... FAIL

======================================================================
ERROR: fromRoman should only accept uppercase input
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 154, in testFromRomanCase
    roman1.fromRoman(numeral.upper())
AttributeError: 'None' object has no attribute 'upper'</computeroutput><computeroutput>
======================================================================
ERROR: toRoman should always return uppercase
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 148, in testToRomanCase
    self.assertEqual(numeral, numeral.upper())
AttributeError: 'None' object has no attribute 'upper'</computeroutput><computeroutput>
======================================================================
FAIL: fromRoman should fail with malformed antecedents
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 133, in testMalformedAntecedent
    self.assertRaises(roman1.InvalidRomanNumeralError, roman1.fromRoman, s)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</computeroutput><computeroutput>
======================================================================
FAIL: fromRoman should fail with repeated pairs of numerals
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 127, in testRepeatedPairs
    self.assertRaises(roman1.InvalidRomanNumeralError, roman1.fromRoman, s)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</computeroutput><computeroutput>
======================================================================
FAIL: fromRoman should fail with too many repeated numerals
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 122, in testTooManyRepeatedNumerals
    self.assertRaises(roman1.InvalidRomanNumeralError, roman1.fromRoman, s)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</computeroutput><computeroutput>
======================================================================
FAIL: fromRoman should give known result with known input
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 99, in testFromRomanKnownValues
    self.assertEqual(integer, result)
  File "c:\python21\lib\unittest.py", line 273, in failUnlessEqual
    raise self.failureException, (msg or '%s != %s' % (first, second))
AssertionError: 1 != None</computeroutput><computeroutput>
======================================================================
FAIL: toRoman should give known result with known input
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 93, in testToRomanKnownValues
    self.assertEqual(numeral, result)
  File "c:\python21\lib\unittest.py", line 273, in failUnlessEqual
    raise self.failureException, (msg or '%s != %s' % (first, second))
AssertionError: I != None</computeroutput><computeroutput>
======================================================================
FAIL: fromRoman(toRoman(n))==n for all n
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 141, in testSanity
    self.assertEqual(integer, result)
  File "c:\python21\lib\unittest.py", line 273, in failUnlessEqual
    raise self.failureException, (msg or '%s != %s' % (first, second))
AssertionError: 1 != None</computeroutput><computeroutput>
======================================================================
FAIL: toRoman should fail with non-integer input
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 116, in testNonInteger
    self.assertRaises(roman1.NotIntegerError, roman1.toRoman, 0.5)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: NotIntegerError</computeroutput><computeroutput>
======================================================================
FAIL: toRoman should fail with negative input
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 112, in testNegative
    self.assertRaises(roman1.OutOfRangeError, roman1.toRoman, -1)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: OutOfRangeError</computeroutput><computeroutput>
======================================================================
FAIL: toRoman should fail with large input
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 104, in testTooLarge
    self.assertRaises(roman1.OutOfRangeError, roman1.toRoman, 4000)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: OutOfRangeError</computeroutput><computeroutput>
======================================================================
FAIL: toRoman should fail with 0 input                                 </computeroutput><co id="roman.stage1.2.1"/><computeroutput>
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage1\romantest1.py", line 108, in testZero
    self.assertRaises(roman1.OutOfRangeError, roman1.toRoman, 0)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: OutOfRangeError                                        </computeroutput><co id="roman.stage1.2.2"/><computeroutput>
----------------------------------------------------------------------
Ran 12 tests in 0.040s                                                 </computeroutput><co id="roman.stage1.2.3"/><computeroutput>

FAILED (failures=10, errors=2)                                         </computeroutput><co id="roman.stage1.2.4"/></screen>
<calloutlist>
<callout arearefs="roman.stage1.2.1">
<para>运行脚本将会执行 <function>unittest.main()</function>，由它来执行每个测试用例，也就是每个在 &romantest_filename; 中定义的方法。对于每个测试用例，无论测试通过与否，都会输出这个方法的 &docstring;。意料之中，没有通过一个测试用例。</para>
</callout>
<callout arearefs="roman.stage1.2.2">
<para>对于每个失败的测试用例，&unittest_module; 显示的跟踪信息告诉我们都发生了什么。就此处而言，调用 &assertRaises; (也称作 <function>failUnlessRaises</function>) 引发了一个 <errorcode>AssertionError</errorcode> 异常，因为期待 &toroman; 所引发的 <errorcode>OutOfRangeError</errorcode> 异常没有出现。</para>
</callout>
<callout arearefs="roman.stage1.2.3">
<para>在这些细节后面，&unittest_module; 给出了一个关于被执行测试的个数和花费时间的总结。</para>
</callout>
<callout arearefs="roman.stage1.2.4">
<para>总而言之，由于至少一个测试用例没有通过，单元测试失败了。当某个测试用例没能通过时，&unittest_module; 会区分是失败 (failures) 还是错误 (errors)。失败是指调用 <function>assertXYZ</function> 方法，比如 &assertEqual; 或者 &assertRaises; 时，断言的情况没有发生或预期的异常没有被引发。而错误是指你测试的代码或单元测试本身发生了某种异常。例如：<function>testFromRomanCase</function> 方法 (<quote>&fromroman; 只接受大写输入</quote>) 就是一个错误，因为调用 <function>numeral.upper()</function> 引发了一个 <errorcode>AttributeError</errorcode> 异常，因为 &toroman; 的返回值不是期望的字符串类型。但是，<function>testZero</function> (<quote>&toroman; 应该在输入 0 时失败</quote>) 是一个失败，因为调用 &fromroman; 没有引发一个 &assertRaises; 期待的异常：<errorcode>InvalidRomanNumeral</errorcode>。</para>
</callout>
</calloutlist>
</example>
</section>
<section id="roman.stage2">
<?dbhtml filename="unit_testing/stage_2.html"?>
<title>&roman_filename;, 第 2 阶段</title>
<abstract>
<title/>
<para>现在你有了 &roman_module; 模块的大概框架，到了开始写代码以通过测试的时候了。</para>
</abstract>
<example id="roman.stage2.example">
<title>&roman2_filename;</title>
<para>这个文件可以从 <filename>py/roman/stage2/</filename> 目录中找到。</para>
&para_download;
<programlisting>
"""Convert to and from Roman numerals"""

#Define exceptions
class RomanError(Exception): pass
class OutOfRangeError(RomanError): pass
class NotIntegerError(RomanError): pass
class InvalidRomanNumeralError(RomanError): pass

#Define digit mapping
romanNumeralMap = (('M',  1000), <co id="roman.stage2.1.1"/>
                   ('CM', 900),
                   ('D',  500),
                   ('CD', 400),
                   ('C',  100),
                   ('XC', 90),
                   ('L',  50),
                   ('XL', 40),
                   ('X',  10),
                   ('IX', 9),
                   ('V',  5),
                   ('IV', 4),
                   ('I',  1))

def toRoman(n):
    """convert integer to Roman numeral"""
    result = ""
    for numeral, integer in romanNumeralMap:
        while n >= integer:      <co id="roman.stage2.1.2"/>
            result += numeral
            n -= integer
    return result

def fromRoman(s):
    """convert Roman numeral to integer"""
    pass
</programlisting>
<calloutlist>
<callout arearefs="roman.stage2.1.1">
<para><varname>romanNumeralMap</varname> 是一个用来定义三个内容的元组的元组：</para>
<orderedlist>
<listitem><para>代表大部分罗马数字的字符。注意不只是单字符的罗马数字，你同样在这里定义诸如 <literal>CM</literal> (<quote>比一千少一百，即 900</quote>) 的双字符，这可以让稍后编写的 &toroman; 简单一些。</para></listitem>
<listitem><para>罗马数字的顺序。它们是以降序排列的，从<literal>M</literal> 一路到 <literal>I</literal>。</para></listitem>
<listitem><para>每个罗马数字所对应的数值。每个内部的元组都是一个 <literal> (<replaceable>numeral</replaceable>，<replaceable>value</replaceable>)</literal> 数值对。</para></listitem>
</orderedlist>
</callout>
<callout arearefs="roman.stage2.1.2">
<para>这里便显示出你丰富的数据结构带来的优势，你不需要什么特定的逻辑处理减法规则。你只需要通过搜寻 <varname>romanNumeralMap</varname> 寻找不大于输入数值的最大对应整数即可。只要找到，就在结果的结尾把这个整数对应的罗马字符添加到输出结果的末尾，从输入值中减去这个整数，一遍遍这样继续下去。</para>
</callout>
</calloutlist>
</example>
<example>
<title>&toroman; 如何工作</title>
<para>如果你不明了 &toroman; 如何工作，在 <literal>while</literal> 循环的结尾添加一个 <function>print</function> 语句：</para>
<programlisting>
        while n >= integer:
            result += numeral
            n -= integer
            print 'subtracting', integer, 'from input, adding', numeral, 'to output'</programlisting>
<screen>
&prompt;<userinput>import roman2</userinput>
&prompt;<userinput>roman2.toRoman(1424)</userinput>
<computeroutput>subtracting 1000 from input, adding M to output
subtracting 400 from input, adding CD to output
subtracting 10 from input, adding X to output
subtracting 10 from input, adding X to output
subtracting 4 from input, adding IV to output
'MCDXXIV'</computeroutput>
</screen>
</example>
<para>看来 &toroman; 可以运转了，至少手工测试可以。但能通过单元测试吗？啊哈，不，不完全可以。</para>
<example>
<title>以 &romantest2_filename; 测试 &roman2_filename; 的输出</title>
<para>要记得用 <literal>-v</literal> 命令行选项运行 &romantest2_filename; 开启详细信息模式。</para>
<screen><computeroutput>fromRoman should only accept uppercase input ... FAIL
toRoman should always return uppercase ... ok                  </computeroutput><co id="roman.stage2.2.1"/><computeroutput>
fromRoman should fail with malformed antecedents ... FAIL
fromRoman should fail with repeated pairs of numerals ... FAIL
fromRoman should fail with too many repeated numerals ... FAIL
fromRoman should give known result with known input ... FAIL
toRoman should give known result with known input ... ok       </computeroutput><co id="roman.stage2.2.2"/><computeroutput>
fromRoman(toRoman(n))==n for all n ... FAIL
toRoman should fail with non-integer input ... FAIL            </computeroutput><co id="roman.stage2.2.3"/><computeroutput>
toRoman should fail with negative input ... FAIL
toRoman should fail with large input ... FAIL
toRoman should fail with 0 input ... FAIL</computeroutput></screen>
<calloutlist>
<callout arearefs="roman.stage2.2.1">
<para>事实上，&toroman; 的返回值总是大写的，因为 <varname>romanNumeralMap</varname> 定义的罗马字符都是以大写字母表示的。因此这个测试已经通过了。</para>
</callout>
<callout arearefs="roman.stage2.2.2">
<para>好消息来了：这个版本的 &toroman; 函数能够通过<link linkend="roman.testtoromanknownvalues.example">已知值测试</link>。记住，这并不能证明完全没问题，但至少通过测试多种有效输入考验了这个函数：包括每个单一字符的罗马数字，可能的最大输入 (<literal>3999</literal>)，以及可能的最长的罗马数字 (对应于 <literal>3888</literal>)。从这点来看，你有理由相信这个函数对于任何有效输入都不会出问题。</para>
</callout>
<callout arearefs="roman.stage2.2.3">
<para>但是，函数还没办法处理无效输入，每个<link linkend="roman.tobadinput.example">无效输入测试</link>都失败了。这很好理解，因为你还没有对无效输入进行检查，测试用例希望捕捉到特定的异常 (通过 &assertRaises;)，而你根本没有让这些异常引发。这是你下一阶段的工作。</para>
</callout>
</calloutlist>
<para>下面是单元测试结果的剩余部分，列出了所有失败的详细信息，你已经让它降到了 10 个。</para>
<screen><computeroutput>
======================================================================
FAIL: fromRoman should only accept uppercase input
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 156, in testFromRomanCase
    roman2.fromRoman, numeral.lower())
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</computeroutput><computeroutput>
======================================================================
FAIL: fromRoman should fail with malformed antecedents
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 133, in testMalformedAntecedent
    self.assertRaises(roman2.InvalidRomanNumeralError, roman2.fromRoman, s)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</computeroutput><computeroutput>
======================================================================
FAIL: fromRoman should fail with repeated pairs of numerals
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 127, in testRepeatedPairs
    self.assertRaises(roman2.InvalidRomanNumeralError, roman2.fromRoman, s)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</computeroutput><computeroutput>
======================================================================
FAIL: fromRoman should fail with too many repeated numerals
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 122, in testTooManyRepeatedNumerals
    self.assertRaises(roman2.InvalidRomanNumeralError, roman2.fromRoman, s)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</computeroutput><computeroutput>
======================================================================
FAIL: fromRoman should give known result with known input
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 99, in testFromRomanKnownValues
    self.assertEqual(integer, result)
  File "c:\python21\lib\unittest.py", line 273, in failUnlessEqual
    raise self.failureException, (msg or '%s != %s' % (first, second))
AssertionError: 1 != None</computeroutput><computeroutput>
======================================================================
FAIL: fromRoman(toRoman(n))==n for all n
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 141, in testSanity
    self.assertEqual(integer, result)
  File "c:\python21\lib\unittest.py", line 273, in failUnlessEqual
    raise self.failureException, (msg or '%s != %s' % (first, second))
AssertionError: 1 != None</computeroutput><computeroutput>
======================================================================
FAIL: toRoman should fail with non-integer input
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 116, in testNonInteger
    self.assertRaises(roman2.NotIntegerError, roman2.toRoman, 0.5)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: NotIntegerError</computeroutput><computeroutput>
======================================================================
FAIL: toRoman should fail with negative input
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 112, in testNegative
    self.assertRaises(roman2.OutOfRangeError, roman2.toRoman, -1)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: OutOfRangeError</computeroutput><computeroutput>
======================================================================
FAIL: toRoman should fail with large input
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 104, in testTooLarge
    self.assertRaises(roman2.OutOfRangeError, roman2.toRoman, 4000)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: OutOfRangeError</computeroutput><computeroutput>
======================================================================
FAIL: toRoman should fail with 0 input
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage2\romantest2.py", line 108, in testZero
    self.assertRaises(roman2.OutOfRangeError, roman2.toRoman, 0)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: OutOfRangeError</computeroutput><computeroutput>
----------------------------------------------------------------------
Ran 12 tests in 0.320s

FAILED (failures=10)</computeroutput></screen>
</example>
</section>
<section id="roman.stage3">
<?dbhtml filename="unit_testing/stage_3.html"?>
<title>&roman_filename;, 第 3 阶段</title>
<abstract>
<title/>
<para>现在 &toroman; 对于有效的输入 (<literal>1</literal> 到 <literal>3999</literal> 整数) 已能正确工作，是正确处理那些无效输入 (任何其他输入) 的时候了。</para>
</abstract>
<example>
<title>&roman3_filename;</title>
<para>这个文件可以在例子目录下的 <filename>py/roman/stage3/</filename> 目录中找到。</para>
&para_download;
<programlisting>
"""Convert to and from Roman numerals"""

#Define exceptions
class RomanError(Exception): pass
class OutOfRangeError(RomanError): pass
class NotIntegerError(RomanError): pass
class InvalidRomanNumeralError(RomanError): pass

#Define digit mapping
romanNumeralMap = (('M',  1000),
                   ('CM', 900),
                   ('D',  500),
                   ('CD', 400),
                   ('C',  100),
                   ('XC', 90),
                   ('L',  50),
                   ('XL', 40),
                   ('X',  10),
                   ('IX', 9),
                   ('V',  5),
                   ('IV', 4),
                   ('I',  1))

def toRoman(n):
    """convert integer to Roman numeral"""
    if not (0 &lt; n &lt; 4000):                                             <co id="roman.stage3.1.1"/>
        raise OutOfRangeError, "number out of range (must be 1..3999)" <co id="roman.stage3.1.2"/>
    if int(n) &lt;> n:                                                    <co id="roman.stage3.1.3"/>
        raise NotIntegerError, "non-integers can not be converted"

    result = ""                                                        <co id="roman.stage3.1.4"/>
    for numeral, integer in romanNumeralMap:
        while n >= integer:
            result += numeral
            n -= integer
    return result

def fromRoman(s):
    """convert Roman numeral to integer"""
    pass
</programlisting>
<calloutlist>
<callout arearefs="roman.stage3.1.1">
<para>这个写法很 Pythonic：一次进行多个比较。这等价于<literal>if not ((0 &lt; n) and (n &lt; 4000))</literal>，但是更容易让人理解。这是在进行范围检查，可以将过大的数、负数和零查出来。</para>
</callout>
<callout arearefs="roman.stage3.1.2">
<para>你使用 <literal>raise</literal> 语句引发自己的异常。你可以引发任何内建异常或者已定义的自定义异常。第二个参数是可选的，如果给定，则会在异常未被处理时显示于追踪信息 (trackback) 之中。</para>
</callout>
<callout arearefs="roman.stage3.1.3">
<para>这是一个非整数检查。非整数无法转化为罗马数字表示。</para>
</callout>
<callout arearefs="roman.stage3.1.4">
<para>函数的其他部分未被更改。</para>
</callout>
</calloutlist>
</example>
<example>
<title>观察 &toroman; 如何处理无效输入</title>
<screen>
&prompt;<userinput>import roman3</userinput>
&prompt;<userinput>roman3.toRoman(4000)</userinput>
<computeroutput role="traceback">Traceback (most recent call last):
  File "&lt;interactive input>", line 1, in ?
  File "roman3.py", line 27, in toRoman
    raise OutOfRangeError, "number out of range (must be 1..3999)"
OutOfRangeError: number out of range (must be 1..3999)</computeroutput>
&prompt;<userinput>roman3.toRoman(1.5)</userinput>
<computeroutput role="traceback">Traceback (most recent call last):
  File "&lt;interactive input>", line 1, in ?
  File "roman3.py", line 29, in toRoman
    raise NotIntegerError, "non-integers can not be converted"
NotIntegerError: non-integers can not be converted</computeroutput>
</screen>
</example>
<example>
<title>用 &romantest3_filename; 测试 &roman3_filename; 的结果</title>
<screen><computeroutput>fromRoman should only accept uppercase input ... FAIL
toRoman should always return uppercase ... ok
fromRoman should fail with malformed antecedents ... FAIL
fromRoman should fail with repeated pairs of numerals ... FAIL
fromRoman should fail with too many repeated numerals ... FAIL
fromRoman should give known result with known input ... FAIL
toRoman should give known result with known input ... ok </computeroutput><co id="roman.stage3.2.1"/><computeroutput>
fromRoman(toRoman(n))==n for all n ... FAIL
toRoman should fail with non-integer input ... ok        </computeroutput><co id="roman.stage3.2.2"/><computeroutput>
toRoman should fail with negative input ... ok           </computeroutput><co id="roman.stage3.2.3"/><computeroutput>
toRoman should fail with large input ... ok
toRoman should fail with 0 input ... ok</computeroutput></screen>
<calloutlist>
<callout arearefs="roman.stage3.2.1">
<para>&toroman; 仍然能通过<link linkend="roman.testtoromanknownvalues.example">已知值测试</link>，这很令人鼓舞。所有<link linkend="roman.stage2">第 2 阶段</link>通过的测试仍然能通过，这说明新的代码没有对原有代码构成任何负面影响。</para>
</callout>
<callout arearefs="roman.stage3.2.2">
<para>更令人振奋的是所有的<link linkend="roman.tobadinput.example">无效输入测试</link>现在都通过了。<function>testNonInteger</function> 这个测试能够通过是因为有了 <literal>int(n) &lt;> n</literal> 检查。当一个非整数传递给 &toroman; 时，<literal>int(n) &lt;> n</literal> 检查出问题并引发 <errorcode>NotIntegerError</errorcode> 异常，这正是 <function>testNonInteger</function> 所期待的。</para>
</callout>
<callout arearefs="roman.stage3.2.3">
<para><function>testNegative</function> 这个测试能够通过是因为 <literal>not (0 &lt; n &lt; 4000)</literal> 检查引发了 <function>testNegative</function> 期待的 <errorcode>OutOfRangeError</errorcode> 异常。</para>
</callout>
</calloutlist>
<screen><computeroutput>
======================================================================
FAIL: fromRoman should only accept uppercase input
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage3\romantest3.py", line 156, in testFromRomanCase
    roman3.fromRoman, numeral.lower())
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</computeroutput><computeroutput>
======================================================================
FAIL: fromRoman should fail with malformed antecedents
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage3\romantest3.py", line 133, in testMalformedAntecedent
    self.assertRaises(roman3.InvalidRomanNumeralError, roman3.fromRoman, s)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</computeroutput><computeroutput>
======================================================================
FAIL: fromRoman should fail with repeated pairs of numerals
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage3\romantest3.py", line 127, in testRepeatedPairs
    self.assertRaises(roman3.InvalidRomanNumeralError, roman3.fromRoman, s)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</computeroutput><computeroutput>
======================================================================
FAIL: fromRoman should fail with too many repeated numerals
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage3\romantest3.py", line 122, in testTooManyRepeatedNumerals
    self.assertRaises(roman3.InvalidRomanNumeralError, roman3.fromRoman, s)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</computeroutput><computeroutput>
======================================================================
FAIL: fromRoman should give known result with known input
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage3\romantest3.py", line 99, in testFromRomanKnownValues
    self.assertEqual(integer, result)
  File "c:\python21\lib\unittest.py", line 273, in failUnlessEqual
    raise self.failureException, (msg or '%s != %s' % (first, second))
AssertionError: 1 != None</computeroutput><computeroutput>
======================================================================
FAIL: fromRoman(toRoman(n))==n for all n
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage3\romantest3.py", line 141, in testSanity
    self.assertEqual(integer, result)
  File "c:\python21\lib\unittest.py", line 273, in failUnlessEqual
    raise self.failureException, (msg or '%s != %s' % (first, second))
AssertionError: 1 != None</computeroutput><computeroutput>
----------------------------------------------------------------------
Ran 12 tests in 0.401s

FAILED (failures=6)</computeroutput> <co id="roman.stage3.3.1"/></screen>
<calloutlist>
<callout arearefs="roman.stage3.3.1">
<para>你已将失败降至 6 个，而且它们都是关于 &fromroman; 的：已知值测试、三个独立的无效输入测试，大小写检查和完备性检查。这意味着 &toroman; 通过了所有可以独立通过的测试 (完备性测试也测试它，但需要 &fromroman; 编写后一起测试)。这就是说，你应该停止对 &toroman; 的代码编写。不必再推敲，不必再做额外的检查 <quote>恰到好处</quote>。停下来吧！现在，别再敲键盘了。</para>
</callout>
</calloutlist>
</example>
<note>
<title>知道什么时候停止编写代码</title>
<para>全面的单元测试能够告诉你的最重要的事情是什么时候停止编写代码。当一个函数的所有单元测试都通过了，停止编写这个函数。一旦整个模块的单元测试通过了，停止编写这个模块。</para>
</note>
</section>
<section id="roman.stage4">
<?dbhtml filename="unit_testing/stage_4.html"?>
<title>&roman_filename;, 第 4 阶段</title>
<abstract>
<title/>
<para>现在 &toroman; 完成了，是开始编写 &fromroman; 的时候了。感谢那个将每个罗马数字和对应整数关连的完美数据结构，这个工作不比 &toroman; 函数复杂。</para>
</abstract>
<example>
<title>&roman4_filename;</title>
<para>这个文件可以在例子目录下的 <filename>py/roman/stage4/</filename> 目录中找到。</para>
&para_download;
<programlisting>
"""Convert to and from Roman numerals"""

#Define exceptions
class RomanError(Exception): pass
class OutOfRangeError(RomanError): pass
class NotIntegerError(RomanError): pass
class InvalidRomanNumeralError(RomanError): pass

#Define digit mapping
romanNumeralMap = (('M',  1000),
                   ('CM', 900),
                   ('D',  500),
                   ('CD', 400),
                   ('C',  100),
                   ('XC', 90),
                   ('L',  50),
                   ('XL', 40),
                   ('X',  10),
                   ('IX', 9),
                   ('V',  5),
                   ('IV', 4),
                   ('I',  1))

# toRoman function omitted for clarity (it hasn't changed)

def fromRoman(s):
    """convert Roman numeral to integer"""
    result = 0
    index = 0
    for numeral, integer in romanNumeralMap:
        while s[index:index+len(numeral)] == numeral: <co id="roman.stage4.1.1"/>
            result += integer
            index += len(numeral)
    return result
</programlisting>
<calloutlist>
<callout arearefs="roman.stage4.1.1">
<para>这和 <link linkend="roman.stage2.example">&toroman;</link> 的工作模式很相似。你遍历整个罗马数字数据结构 (一个元组的元组)，与前面不同的是不去一个个搜寻最大的整数，而是搜寻 <quote>最大的</quote>罗马数字字符串。</para>
</callout>
</calloutlist>
</example>
<example>
<title>&fromroman; 如何工作</title>
<para>如果你不清楚 &fromroman; 如何工作，在 <literal>while</literal> 结尾处添加一个 <function>print</function> 语句：</para>
<programlisting>
        while s[index:index+len(numeral)] == numeral:
            result += integer
            index += len(numeral)
            print 'found', numeral, 'of length', len(numeral), ', adding', integer</programlisting>
<screen>
&prompt;<userinput>import roman4</userinput>
&prompt;<userinput>roman4.fromRoman('MCMLXXII')</userinput>
<computeroutput>found M , of length 1, adding 1000
found CM , of length 2, adding 900
found L , of length 1, adding 50
found X , of length 1, adding 10
found X , of length 1, adding 10
found I , of length 1, adding 1
found I , of length 1, adding 1
1972</computeroutput></screen>
</example>
<example>
<title>用 &romantest4_filename; 测试 &roman4_filename; 的结果</title>
<screen><computeroutput>fromRoman should only accept uppercase input ... FAIL
toRoman should always return uppercase ... ok
fromRoman should fail with malformed antecedents ... FAIL
fromRoman should fail with repeated pairs of numerals ... FAIL
fromRoman should fail with too many repeated numerals ... FAIL
fromRoman should give known result with known input ... ok </computeroutput><co id="roman.stage4.2.1"/><computeroutput>
toRoman should give known result with known input ... ok
fromRoman(toRoman(n))==n for all n ... ok                  </computeroutput><co id="roman.stage4.2.2"/><computeroutput>
toRoman should fail with non-integer input ... ok
toRoman should fail with negative input ... ok
toRoman should fail with large input ... ok
toRoman should fail with 0 input ... ok</computeroutput></screen>
<calloutlist>
<callout arearefs="roman.stage4.2.1">
<para>这儿有两个令人激动的消息。一个是 &fromroman; 对于所有有效输入运转正常，至少对于你测试的<link linkend="roman.testtoromanknownvalues.example">已知值</link>是这样。</para>
</callout>
<callout arearefs="roman.stage4.2.2">
<para>第二个好消息是，<link linkend="roman.sanity.example">完备性测试</link>也通过了。与已知值测试的通过一起来看，你有理由相信 &toroman; 和 &fromroman; 对于所有有效输入值工作正常。(尚不能完全相信，理论上存在这种可能性：&toroman; 存在错误而导致一些特定输入会产生错误的罗马数字表示，<emphasis>并且</emphasis> &fromroman; 也存在相应的错误，把 &toroman; 错误产生的这些罗马数字错误地转换为最初的整数。取决于你的应用程序和你的要求，你或许需要考虑这个可能性。如果是这样，编写更全面的测试用例直到解决这个问题。)</para>
</callout>
</calloutlist>
<screen><computeroutput>
======================================================================
FAIL: fromRoman should only accept uppercase input
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage4\romantest4.py", line 156, in testFromRomanCase
    roman4.fromRoman, numeral.lower())
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</computeroutput><computeroutput>
======================================================================
FAIL: fromRoman should fail with malformed antecedents
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage4\romantest4.py", line 133, in testMalformedAntecedent
    self.assertRaises(roman4.InvalidRomanNumeralError, roman4.fromRoman, s)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</computeroutput><computeroutput>
======================================================================
FAIL: fromRoman should fail with repeated pairs of numerals
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage4\romantest4.py", line 127, in testRepeatedPairs
    self.assertRaises(roman4.InvalidRomanNumeralError, roman4.fromRoman, s)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</computeroutput><computeroutput>
======================================================================
FAIL: fromRoman should fail with too many repeated numerals
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage4\romantest4.py", line 122, in testTooManyRepeatedNumerals
    self.assertRaises(roman4.InvalidRomanNumeralError, roman4.fromRoman, s)
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</computeroutput><computeroutput>
----------------------------------------------------------------------
Ran 12 tests in 1.222s

FAILED (failures=4)</computeroutput></screen>
</example>
</section>
<section id="roman.stage5">
<?dbhtml filename="unit_testing/stage_5.html"?>
<title>&roman_filename;, 第 5 阶段</title>
<abstract>
<title/>
<para>现在 &fromroman; 对于有效输入能够正常工作了，是揭开最后一个谜底的时候了：使它正常工作于无效输入的情况下。这意味着要找出一个方法检查一个字符串是不是有效的罗马数字。这比 &toroman; 中<link linkend="roman.stage3">验证有效的数字输入</link>困难，但是你可以使用一个强大的工具：正则表达式。</para>
</abstract>
<para>如果你不熟悉正则表达式，并且没有读过 <xref linkend="re"/>，现在是该好好读读的时候了。</para>
<para>如你在 <xref linkend="re.roman"/>中所见到的，构建罗马数字有几个简单的规则：使用字母 <literal>M</literal>, <literal>D</literal>, <literal>C</literal>, <literal>L</literal>, <literal>X</literal>, <literal>V</literal> 和 <literal>I</literal>。让我们回顾一下：</para>
<orderedlist>
<listitem><para>字符是被“加”在一起的：<literal>I</literal> 是 &one;，<literal>II</literal> 是 <literal>2</literal>，<literal>III</literal> 是 <literal>3</literal>。<literal>VI</literal> 是 <literal>6</literal> (看上去就是 <quote><literal>5</literal> 加 <literal>1</literal></quote>)，<literal>VII</literal> 是 <literal>7</literal>，<literal>VIII</literal> 是 <literal>8</literal>。</para></listitem>
<listitem><para>这些字符 (<literal>I</literal>, <literal>X</literal>, <literal>C</literal> 和 <literal>M</literal>) 最多可以重复三次。对于 <literal>4</literal>，你则需要利用下一个能够被5整除的字符进行减操作得到。你不能把 <literal>4</literal> 表示为 <literal>IIII</literal> 而应该表示为 <literal>IV</literal> (<quote>比 <literal>5</literal> 小 <literal>1</literal> </quote>)。<literal>40</literal> 则被写作 <literal>XL</literal> (<quote>比 <literal>50</literal> 小 <literal>10</literal></quote>)，<literal>41</literal> 表示为 <literal>XLI</literal>，<literal>42</literal> 表示为 <literal>XLII</literal>，<literal>43</literal> 表示为 <literal>XLIII</literal>，<literal>44</literal> 表示为 <literal>XLIV</literal> (<quote>比<literal>50</literal>小<literal>10</literal>，加上 <literal>5</literal> 小 <literal>1</literal></quote>)。</para></listitem>
<listitem><para>类似地，对于数字 <literal>9</literal>，你必须利用下一个能够被10整除的字符进行减操作得到：<literal>8</literal> 是 <literal>VIII</literal>，而 <literal>9</literal> 是 <literal>IX</literal> (<quote>比 <literal>10</literal> 小 <literal>1</literal></quote>)，而不是 <literal>VIIII</literal> (由于 <literal>I</literal> 不能重复四次)。<literal>90</literal> 表示为 <literal>XC</literal>，<literal>900</literal> 表示为 <literal>CM</literal>。</para></listitem>
<listitem><para>含五的字符不能被重复：<literal>10</literal> 应该表示为 <literal>X</literal>，而不会是 <literal>VV</literal>。<literal>100</literal> 应该表示为 <literal>C</literal>，而不是 <literal>LL</literal>。</para></listitem>
<listitem><para>罗马数字一般从高位到低位书写，从左到右阅读，因此不同顺序的字符意义大不相同。<literal>DC</literal> 是 <literal>600</literal>，<literal>CD</literal> 是完全另外一个数 (<literal>400</literal>，<quote>比 <literal>500</literal> 少 <literal>100</literal></quote>)。<literal>CI</literal> 是 <literal>101</literal>，而 <literal>IC</literal> 根本就不是一个有效的罗马数字 (因为你无法从<literal>100</literal>直接减<literal>1</literal>，应该写成 <literal>XCIX</literal>，意思是 <quote>比 <literal>100</literal> 少 <literal>10</literal>，然后加上数字 <literal>9</literal>，也就是比 <literal>10</literal> 少 <literal>1</literal></quote>)。</para></listitem>
</orderedlist>

<example>
<title>&roman5_filename;</title>
<para>这个程序可以在例子目录下的<filename>py/roman/stage5/</filename> 目录中找到。</para>
&para_download;
<programlisting>
"""Convert to and from Roman numerals"""
import re

#Define exceptions
class RomanError(Exception): pass
class OutOfRangeError(RomanError): pass
class NotIntegerError(RomanError): pass
class InvalidRomanNumeralError(RomanError): pass

#Define digit mapping
romanNumeralMap = (('M',  1000),
                   ('CM', 900),
                   ('D',  500),
                   ('CD', 400),
                   ('C',  100),
                   ('XC', 90),
                   ('L',  50),
                   ('XL', 40),
                   ('X',  10),
                   ('IX', 9),
                   ('V',  5),
                   ('IV', 4),
                   ('I',  1))

def toRoman(n):
    """convert integer to Roman numeral"""
    if not (0 &lt; n &lt; 4000):
        raise OutOfRangeError, "number out of range (must be 1..3999)"
    if int(n) &lt;> n:
        raise NotIntegerError, "non-integers can not be converted"

    result = ""
    for numeral, integer in romanNumeralMap:
        while n >= integer:
            result += numeral
            n -= integer
    return result

#Define pattern to detect valid Roman numerals
romanNumeralPattern = '^M?M?M?(CM|CD|D?C?C?C?)(XC|XL|L?X?X?X?)(IX|IV|V?I?I?I?)$' <co id="roman.stage5.3.1"/>

def fromRoman(s):
    """convert Roman numeral to integer"""
    if not re.search(romanNumeralPattern, s):                                    <co id="roman.stage5.3.2"/>
        raise InvalidRomanNumeralError, 'Invalid Roman numeral: %s' % s

    result = 0
    index = 0
    for numeral, integer in romanNumeralMap:
        while s[index:index+len(numeral)] == numeral:
            result += integer
            index += len(numeral)
    return result
</programlisting>
<calloutlist>
<callout arearefs="roman.stage5.3.1">
<para>这只是 <xref linkend="re.roman"/> 中讨论的匹配模版的继续。十位上可能是<literal>XC</literal> (<literal>90</literal>)，<literal>XL</literal> (<literal>40</literal>)，或者可能是 <literal>L</literal> 后面跟着 0 到 3 个 <literal>X</literal> 字符。个位则可能是 <literal>IX</literal> (<literal>9</literal>)，<literal>IV</literal> (<literal>4</literal>)，或者是一个可能是 <literal>V</literal> 后面跟着 0 到 3 个 <literal>I</literal> 字符。</para>
</callout>
<callout arearefs="roman.stage5.3.2">
<para>把所有的逻辑编码成正则表达式，检查无效罗马字符的代码就很简单了。如果 <function>re.search</function> 返回一个对象则表示匹配了正则表达式，输入是有效的，否则输入无效。</para>
</callout>
</calloutlist>
</example>
<para>这里你可能会怀疑，这个面目可憎的正则表达式是否真能查出错误的罗马字符表示。没关系，不必完全听我的，不妨看看下面的结果：</para>
<example>
<title>用 &romantest5_filename; 测试 &roman5_filename; 的结果</title>
<screen><computeroutput>
fromRoman should only accept uppercase input ... ok          </computeroutput><co id="roman.stage5.4.1"/><computeroutput>
toRoman should always return uppercase ... ok
fromRoman should fail with malformed antecedents ... ok      </computeroutput><co id="roman.stage5.4.2"/><computeroutput>
fromRoman should fail with repeated pairs of numerals ... ok </computeroutput><co id="roman.stage5.4.3"/><computeroutput>
fromRoman should fail with too many repeated numerals ... ok
fromRoman should give known result with known input ... ok
toRoman should give known result with known input ... ok
fromRoman(toRoman(n))==n for all n ... ok
toRoman should fail with non-integer input ... ok
toRoman should fail with negative input ... ok
toRoman should fail with large input ... ok
toRoman should fail with 0 input ... ok

----------------------------------------------------------------------
Ran 12 tests in 2.864s

OK                                                           </computeroutput><co id="roman.stage5.4.4"/></screen>
<calloutlist>
<callout arearefs="roman.stage5.4.1">
<para>有件事我未曾讲过，那就是默认情况下正则表达式大小写敏感。由于正则表达式 <varname>romanNumeralPattern</varname> 是以大写字母构造的，<function>re.search</function> 将拒绝不全部是大写字母构成的输入。因此大写输入的检查就通过了。</para>
</callout>
<callout arearefs="roman.stage5.4.2">
<para>更重要的是，无效输入测试也通过了。例如，上面这个用例测试了 <literal>MCMC</literal> 之类的情形。正如你所见，这不匹配正则表达式，因此 &fromroman; 引发一个测试用例正在等待的 <errorcode>InvalidRomanNumeralError</errorcode> 异常，所以测试通过了。</para>
</callout>
<callout arearefs="roman.stage5.4.3">
<para>事实上，所有的无效输入测试都通过了。正则表达式捕捉了你在编写测试用例时所能预见的所有情况。</para>
</callout>
<callout arearefs="roman.stage5.4.4">
<para>最终迎来了 <quote><literal>OK</literal></quote>这个平淡的“年度大奖”，所有测试都通过后 &unittest_module; 模块就会输出它。</para>
</callout>
</calloutlist>
</example>
<note>
<title>所有测试都通过后做什么呢？</title>
<para>当所有测试都通过了，停止编程。</para>
</note>
</section>
</chapter>
<chapter id="roman2">
<?dbhtml filename="refactoring/index.html"?>
<title>重构</title>
<titleabbrev id="roman2.numberonly">第 15 章</titleabbrev>
<section id="roman.bugs">
<?dbhtml filename="refactoring/handling_bugs.html"?>
<title>处理 bugs</title>
<abstract>
<title/>
<para>尽管你很努力地编写全面的单元测试，但是 bug 还是会出现。我所说的 <quote>bug</quote> 是什么呢？Bug 是你还没有编写的测试用例。</para>
</abstract>
<example>
<title>关于 Bug</title>
<screen>&prompt;<userinput>import roman5</userinput>
&prompt;<userinput>roman5.fromRoman("")</userinput> <co id="roman.bugs.1.1"/>
<computeroutput>0</computeroutput></screen>
<calloutlist>
<callout arearefs="roman.bugs.1.1">
<para>在前面的<link linkend="roman.stage5">章节中</link>你注意到一个空字符串会匹配上那个检查罗马数字有效性的正则表达式了吗？对于最终版本中的正则表达式这一点仍然没有改变。这就是一个 Bug ，你希望空字符串能够像其他无效的罗马数字表示一样引发 <errorcode>InvalidRomanNumeralError</errorcode> 异常。</para>
</callout>
</calloutlist>
</example>
<para>在重现这个 Bug 并修改它之前你应该编写一个会失败的测试用例来说明它。</para>
<example>
<title>测试 bug (&romantest61_filename;)</title>
<programlisting>
&romantest_frombadinputdef;

    # previous test cases omitted for clarity (they haven't changed)

&romantest_blankdef;
&romantest_blankdoc;
&romantest_blankcode; <co id="roman.bugs.2.1"/>
</programlisting>
<calloutlist>
<callout arearefs="roman.bugs.2.1">
<para>这里很简单。以空字符串调用 &fromroman; 并确保它会引发一个 <errorcode>InvalidRomanNumeralError</errorcode> 异常。难点在于找出 Bug，既然你已经知道它了，测试就简单了。</para>
</callout>
</calloutlist>
</example>
<para>因为你的代码存在一个 Bug，并且你编写了测试这个 Bug 的测试用例，所以测试用例将会失败：</para>
<example>
<title>用 &romantest61_filename; 测试 &roman61_filename; 的结果</title>
<screen><computeroutput>fromRoman should only accept uppercase input ... ok
toRoman should always return uppercase ... ok
fromRoman should fail with blank string ... FAIL
fromRoman should fail with malformed antecedents ... ok
fromRoman should fail with repeated pairs of numerals ... ok
fromRoman should fail with too many repeated numerals ... ok
fromRoman should give known result with known input ... ok
toRoman should give known result with known input ... ok
fromRoman(toRoman(n))==n for all n ... ok
toRoman should fail with non-integer input ... ok
toRoman should fail with negative input ... ok
toRoman should fail with large input ... ok
toRoman should fail with 0 input ... ok

======================================================================
FAIL: fromRoman should fail with blank string
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage6\romantest61.py", line 137, in testBlank
    self.assertRaises(roman61.InvalidRomanNumeralError, roman61.fromRoman, "")
  File "c:\python21\lib\unittest.py", line 266, in failUnlessRaises
    raise self.failureException, excName
AssertionError: InvalidRomanNumeralError</computeroutput><computeroutput>
----------------------------------------------------------------------
Ran 13 tests in 2.864s

FAILED (failures=1)</computeroutput></screen>
</example>
<para><emphasis>现在</emphasis> 你可以修改这个 Bug了。</para>
<example>
<title>修改 Bug (&roman62_filename;)</title>
<para>这个文件可以在例子目录下的 <filename>py/roman/stage6/</filename> 目录中找到。</para>
<programlisting>
def fromRoman(s):
    """convert Roman numeral to integer"""
    if not s: <co id="roman.bugs.4.1"/>
        raise InvalidRomanNumeralError, 'Input can not be blank'
    if not re.search(romanNumeralPattern, s):
        raise InvalidRomanNumeralError, 'Invalid Roman numeral: %s' % s

    result = 0
    index = 0
    for numeral, integer in romanNumeralMap:
        while s[index:index+len(numeral)] == numeral:
            result += integer
            index += len(numeral)
    return result
</programlisting>
<calloutlist>
<callout arearefs="roman.bugs.4.1">
<para>只需要两行代码：一行直接检查空字符串和一行 &raise; 语句。</para>
</callout>
</calloutlist>
</example>
<example>
<title>用 &romantest62_filename; 测试 &roman62_filename; 的结果</title>
<screen><computeroutput>fromRoman should only accept uppercase input ... ok
toRoman should always return uppercase ... ok
fromRoman should fail with blank string ... ok </computeroutput><co id="roman.bugs.5.1"/><computeroutput>
fromRoman should fail with malformed antecedents ... ok
fromRoman should fail with repeated pairs of numerals ... ok
fromRoman should fail with too many repeated numerals ... ok
fromRoman should give known result with known input ... ok
toRoman should give known result with known input ... ok
fromRoman(toRoman(n))==n for all n ... ok
toRoman should fail with non-integer input ... ok
toRoman should fail with negative input ... ok
toRoman should fail with large input ... ok
toRoman should fail with 0 input ... ok

----------------------------------------------------------------------
Ran 13 tests in 2.834s

OK</computeroutput> <co id="roman.bugs.5.2"/></screen>
<calloutlist>
<callout arearefs="roman.bugs.5.1">
<para>空字符串测试用例现在通过了，说明 Bug 被修正了。</para>
</callout>
<callout arearefs="roman.bugs.5.2">
<para>所有其他测试用例依然通过，证明这个 Bug 修正没有影响到其他部分。不需要再编程了。</para>
</callout>
</calloutlist>
</example>
<para>这样编程，并没有令 Bug 修正变得简单。简单的 Bug (就像这一个) 需要简单的测试用例，复杂 Bug 则需要复杂的测试用例。以测试为核心的氛围<emphasis>好像</emphasis> 延长了修正 Bug 的时间，因为你需要先贴切地描述出 Bug (编写测试用例) 然后才去修正它。如果测试用例没能正确通过，你需要思量这个修改错了还是测试用例本身出现了 Bug。无论如何，从长远上讲，这样在测试代码和代码之间的反复是值得的，因为这样会使 Bug 在第一时间就被修正的可能性大大提高。而且不论如何更改，你都可以轻易地重新运行<emphasis>所有</emphasis> 测试用例，新代码破坏老代码的机会也变得微乎其微。今天的单元测试就是明天的回归测试 (regression test)。</para>
</section>
<section id="roman.change">
<?dbhtml filename="refactoring/handling_changing_requirements.html"?>
<title>应对需求变化</title>
<abstract>
<title/>
<para>尽管你竭尽努力地分析你的客户，并点灯熬油地提炼出精确的需求，但需求还是会是不断变化。大部分客户在看到产品前不知道他们想要什么。即便知道，也不擅于精确表述出他们的有效需求。即便能表述出来，他们在下一个版本一定会要求更多的功能。因此你需要做好更新测试用例的准备以应对需求的改变。</para>
</abstract>
<para>假设你想要扩展罗马数字转换函数的范围。还记得<link linkend="roman.divein">没有哪个字符可以重复三遍以上</link>这条规则吗？呃，现在罗马人希望给这条规则来个例外，用连续出现 4 个 <literal>M</literal> 字符来表示 <literal>4000</literal>。如果这样改了，你就可以把转换范围从 <literal>1..3999</literal> 扩展到 <literal>1..4999</literal>。但你先要对测试用例进行修改。</para>
<example>
<title>修改测试用例以适应新需求 (&romantest71_filename;)</title>
<para>这个文件可以在例子目录下的 <filename>py/roman/stage7/</filename> 目录中找到。</para>
&para_download;
<programlisting>
import roman71
import unittest

class KnownValues(unittest.TestCase):
    knownValues = ( (1, 'I'),
                    (2, 'II'),
                    (3, 'III'),
                    (4, 'IV'),
                    (5, 'V'),
                    (6, 'VI'),
                    (7, 'VII'),
                    (8, 'VIII'),
                    (9, 'IX'),
                    (10, 'X'),
                    (50, 'L'),
                    (100, 'C'),
                    (500, 'D'),
                    (1000, 'M'),
                    (31, 'XXXI'),
                    (148, 'CXLVIII'),
                    (294, 'CCXCIV'),
                    (312, 'CCCXII'),
                    (421, 'CDXXI'),
                    (528, 'DXXVIII'),
                    (621, 'DCXXI'),
                    (782, 'DCCLXXXII'),
                    (870, 'DCCCLXX'),
                    (941, 'CMXLI'),
                    (1043, 'MXLIII'),
                    (1110, 'MCX'),
                    (1226, 'MCCXXVI'),
                    (1301, 'MCCCI'),
                    (1485, 'MCDLXXXV'),
                    (1509, 'MDIX'),
                    (1607, 'MDCVII'),
                    (1754, 'MDCCLIV'),
                    (1832, 'MDCCCXXXII'),
                    (1993, 'MCMXCIII'),
                    (2074, 'MMLXXIV'),
                    (2152, 'MMCLII'),
                    (2212, 'MMCCXII'),
                    (2343, 'MMCCCXLIII'),
                    (2499, 'MMCDXCIX'),
                    (2574, 'MMDLXXIV'),
                    (2646, 'MMDCXLVI'),
                    (2723, 'MMDCCXXIII'),
                    (2892, 'MMDCCCXCII'),
                    (2975, 'MMCMLXXV'),
                    (3051, 'MMMLI'),
                    (3185, 'MMMCLXXXV'),
                    (3250, 'MMMCCL'),
                    (3313, 'MMMCCCXIII'),
                    (3408, 'MMMCDVIII'),
                    (3501, 'MMMDI'),
                    (3610, 'MMMDCX'),
                    (3743, 'MMMDCCXLIII'),
                    (3844, 'MMMDCCCXLIV'),
                    (3888, 'MMMDCCCLXXXVIII'),
                    (3940, 'MMMCMXL'),
                    (3999, 'MMMCMXCIX'),
                    (4000, 'MMMM'),                                       <co id="roman.change.1.1"/>
                    (4500, 'MMMMD'),
                    (4888, 'MMMMDCCCLXXXVIII'),
                    (4999, 'MMMMCMXCIX'))

    def testToRomanKnownValues(self):
        """toRoman should give known result with known input"""
        for integer, numeral in self.knownValues:
            result = roman71.toRoman(integer)
            self.assertEqual(numeral, result)

    def testFromRomanKnownValues(self):
        """fromRoman should give known result with known input"""
        for integer, numeral in self.knownValues:
            result = roman71.fromRoman(numeral)
            self.assertEqual(integer, result)

class ToRomanBadInput(unittest.TestCase):
    def testTooLarge(self):
        """toRoman should fail with large input"""
        self.assertRaises(roman71.OutOfRangeError, roman71.toRoman, 5000) <co id="roman.change.1.2"/>

    def testZero(self):
        """toRoman should fail with 0 input"""
        self.assertRaises(roman71.OutOfRangeError, roman71.toRoman, 0)

    def testNegative(self):
        """toRoman should fail with negative input"""
        self.assertRaises(roman71.OutOfRangeError, roman71.toRoman, -1)

    def testNonInteger(self):
        """toRoman should fail with non-integer input"""
        self.assertRaises(roman71.NotIntegerError, roman71.toRoman, 0.5)

class FromRomanBadInput(unittest.TestCase):
    def testTooManyRepeatedNumerals(self):
        """fromRoman should fail with too many repeated numerals"""
        for s in ('MMMMM', 'DD', 'CCCC', 'LL', 'XXXX', 'VV', 'IIII'):     <co id="roman.change.1.3"/>
            self.assertRaises(roman71.InvalidRomanNumeralError, roman71.fromRoman, s)

    def testRepeatedPairs(self):
        """fromRoman should fail with repeated pairs of numerals"""
        for s in ('CMCM', 'CDCD', 'XCXC', 'XLXL', 'IXIX', 'IVIV'):
            self.assertRaises(roman71.InvalidRomanNumeralError, roman71.fromRoman, s)

    def testMalformedAntecedent(self):
        """fromRoman should fail with malformed antecedents"""
        for s in ('IIMXCC', 'VX', 'DCM', 'CMM', 'IXIV',
                  'MCMC', 'XCX', 'IVI', 'LM', 'LD', 'LC'):
            self.assertRaises(roman71.InvalidRomanNumeralError, roman71.fromRoman, s)

    def testBlank(self):
        """fromRoman should fail with blank string"""
        self.assertRaises(roman71.InvalidRomanNumeralError, roman71.fromRoman, "")

class SanityCheck(unittest.TestCase):
    def testSanity(self):
        """fromRoman(toRoman(n))==n for all n"""
        for integer in range(1, 5000):                                    <co id="roman.change.1.4"/>
            numeral = roman71.toRoman(integer)
            result = roman71.fromRoman(numeral)
            self.assertEqual(integer, result)

class CaseCheck(unittest.TestCase):
    def testToRomanCase(self):
        """toRoman should always return uppercase"""
        for integer in range(1, 5000):
            numeral = roman71.toRoman(integer)
            self.assertEqual(numeral, numeral.upper())

    def testFromRomanCase(self):
        """fromRoman should only accept uppercase input"""
        for integer in range(1, 5000):
            numeral = roman71.toRoman(integer)
            roman71.fromRoman(numeral.upper())
            self.assertRaises(roman71.InvalidRomanNumeralError,
                              roman71.fromRoman, numeral.lower())

if __name__ == "__main__":
    unittest.main()
</programlisting>
<calloutlist>
<callout arearefs="roman.change.1.1">
<para>原来的已知值没有改变 (它们仍然是合理的测试值) 但你需要添加几个大于 <literal>4000</literal> 的值。这里我添加了 <literal>4000</literal> (最短的一个)，<literal>4500</literal> (次短的一个)，<literal>4888</literal> (最长的一个) 和 <literal>4999</literal> (值最大的一个)。</para>
</callout>
<callout arearefs="roman.change.1.2">
<para><quote>最大输入</quote>的定义改变了。以前是以 <literal>4000</literal> 调用 &toroman; 并期待一个错误；而现在 <literal>4000-4999</literal> 成为了有效输入，需要将这个最大输入提升至 <literal>5000</literal>。</para>
</callout>
<callout arearefs="roman.change.1.3">
<para><quote>过多字符重复</quote> 的定义也改变了。这个测试以前是以 <literal>'MMMM'</literal> 调用 &fromroman; 并期待一个错误；而现在 <literal>MMMM</literal> 被认为是一个有效的罗马数字表示，需要将这个“过多字符重复”改为 <literal>'MMMMM'</literal>。</para>
</callout>
<callout arearefs="roman.change.1.4">
<para>完备测试和大小写测试原来在 &one; 到 <literal>3999</literal> 范围内循环。现在范围扩展了，这个 &for; 循环需要将范围也提升至 <literal>4999</literal>。</para>
</callout>
</calloutlist>
</example>
<para>现在你的测试用例和新需求保持一致了，但是你的程序代码还没有，因此几个测试用例的失败是意料之中的事。</para>
<example>
<title>用 &romantest71_filename; 测试 &roman71_filename; 的结果</title>
<screen><computeroutput>
fromRoman should only accept uppercase input ... ERROR        </computeroutput><co id="roman.change.2.1"/><computeroutput>
toRoman should always return uppercase ... ERROR
fromRoman should fail with blank string ... ok
fromRoman should fail with malformed antecedents ... ok
fromRoman should fail with repeated pairs of numerals ... ok
fromRoman should fail with too many repeated numerals ... ok
fromRoman should give known result with known input ... ERROR </computeroutput><co id="roman.change.2.2"/><computeroutput>
toRoman should give known result with known input ... ERROR   </computeroutput><co id="roman.change.2.3"/><computeroutput>
fromRoman(toRoman(n))==n for all n ... ERROR                  </computeroutput><co id="roman.change.2.4"/><computeroutput>
toRoman should fail with non-integer input ... ok
toRoman should fail with negative input ... ok
toRoman should fail with large input ... ok
toRoman should fail with 0 input ... ok
</computeroutput></screen>
<calloutlist>
<callout arearefs="roman.change.2.1">
<para>我们的大小写检查是因为循环范围是 &one; 到 <literal>4999</literal>，而 &toroman; 只接受 &one; 到 <literal>3999</literal> 之间的数，因此测试循环到 <literal>4000</literal> 就会失败。</para>
</callout>
<callout arearefs="roman.change.2.2">
<para>&fromroman; 的已知值测试在遇到 <literal>'MMMM'</literal> 就会失败，因为 &fromroman; 还认为这是一个无效的罗马数字表示。</para>
</callout>
<callout arearefs="roman.change.2.3">
<para>&toroman; 的已知值测试在遇到 <literal>4000</literal> 就会失败，因为 &toroman; 仍旧认为这超出了有效值范围。</para>
</callout>
<callout arearefs="roman.change.2.4">
<para>完备测试在遇到 <literal>4000</literal> 也会失败，因为 &toroman; 也会认为这超出了有效值范围。</para>
</callout>
</calloutlist>
<screen><computeroutput>
======================================================================
ERROR: fromRoman should only accept uppercase input
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage7\romantest71.py", line 161, in testFromRomanCase
    numeral = roman71.toRoman(integer)
  File "roman71.py", line 28, in toRoman
    raise OutOfRangeError, "number out of range (must be 1..3999)"
OutOfRangeError: number out of range (must be 1..3999)</computeroutput><computeroutput>
======================================================================
ERROR: toRoman should always return uppercase
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage7\romantest71.py", line 155, in testToRomanCase
    numeral = roman71.toRoman(integer)
  File "roman71.py", line 28, in toRoman
    raise OutOfRangeError, "number out of range (must be 1..3999)"
OutOfRangeError: number out of range (must be 1..3999)</computeroutput><computeroutput>
======================================================================
ERROR: fromRoman should give known result with known input
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage7\romantest71.py", line 102, in testFromRomanKnownValues
    result = roman71.fromRoman(numeral)
  File "roman71.py", line 47, in fromRoman
    raise InvalidRomanNumeralError, 'Invalid Roman numeral: %s' % s
InvalidRomanNumeralError: Invalid Roman numeral: MMMM</computeroutput><computeroutput>
======================================================================
ERROR: toRoman should give known result with known input
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage7\romantest71.py", line 96, in testToRomanKnownValues
    result = roman71.toRoman(integer)
  File "roman71.py", line 28, in toRoman
    raise OutOfRangeError, "number out of range (must be 1..3999)"
OutOfRangeError: number out of range (must be 1..3999)</computeroutput><computeroutput>
======================================================================
ERROR: fromRoman(toRoman(n))==n for all n
----------------------------------------------------------------------
</computeroutput><computeroutput role="traceback">Traceback (most recent call last):
  File "C:\docbook\dip\py\roman\stage7\romantest71.py", line 147, in testSanity
    numeral = roman71.toRoman(integer)
  File "roman71.py", line 28, in toRoman
    raise OutOfRangeError, "number out of range (must be 1..3999)"
OutOfRangeError: number out of range (must be 1..3999)</computeroutput><computeroutput>
----------------------------------------------------------------------
Ran 13 tests in 2.213s

FAILED (errors=5)</computeroutput></screen>
</example>
<para>既然新的需求导致了测试用例的失败，你该考虑修改代码以便它能再次通过测试用例。(在你开始编写单元测试时要习惯一件事：被测试代码永远不会在编写测试用例<quote>之前</quote>编写。正因为如此，你还有一些工作要做，一旦可以通过所有的测试用例，停止编码。)</para>
<example>
<title>为新的需求编写代码 (&roman72_filename;)</title>
<para>这个文件可以在例子目录下的 <filename>py/roman/stage7/</filename> 目录中找到。</para>
<programlisting>
"""Convert to and from Roman numerals"""
import re

#Define exceptions
class RomanError(Exception): pass
class OutOfRangeError(RomanError): pass
class NotIntegerError(RomanError): pass
class InvalidRomanNumeralError(RomanError): pass

#Define digit mapping
romanNumeralMap = (('M',  1000),
                   ('CM', 900),
                   ('D',  500),
                   ('CD', 400),
                   ('C',  100),
                   ('XC', 90),
                   ('L',  50),
                   ('XL', 40),
                   ('X',  10),
                   ('IX', 9),
                   ('V',  5),
                   ('IV', 4),
                   ('I',  1))

def toRoman(n):
    """convert integer to Roman numeral"""
    if not (0 &lt; n &lt; 5000):                                                         <co id="roman.change.3.1"/>
        raise OutOfRangeError, "number out of range (must be 1..4999)"
    if int(n) &lt;> n:
        raise NotIntegerError, "non-integers can not be converted"

    result = ""
    for numeral, integer in romanNumeralMap:
        while n >= integer:
            result += numeral
            n -= integer
    return result

#Define pattern to detect valid Roman numerals
romanNumeralPattern = '^M?M?M?M?(CM|CD|D?C?C?C?)(XC|XL|L?X?X?X?)(IX|IV|V?I?I?I?)$' <co id="roman.change.3.2"/>

def fromRoman(s):
    """convert Roman numeral to integer"""
    if not s:
        raise InvalidRomanNumeralError, 'Input can not be blank'
    if not re.search(romanNumeralPattern, s):
        raise InvalidRomanNumeralError, 'Invalid Roman numeral: %s' % s

    result = 0
    index = 0
    for numeral, integer in romanNumeralMap:
        while s[index:index+len(numeral)] == numeral:
            result += integer
            index += len(numeral)
    return result
</programlisting>
</example>
<calloutlist>
<callout arearefs="roman.change.3.1">
<para>&toroman; 只需要在取值范围检查一处做个小改动。将原来的 <literal>0 &lt; n &lt; 4000</literal>，更改为现在的检查 <literal>0 &lt; n &lt; 5000</literal>。你还要更改你 &raise; 的错误信息以反映接受新取值范围 (<literal>1..4999</literal> 而不再是 <literal>1..3999</literal>)。你不需要改变函数的其他部分，它们已经适用于新的情况。(它们会欣然地为新的 1000 添加 <literal>'M'</literal>，以 <literal>4000</literal> 为例，函数会返回 <literal>'MMMM'</literal> 。之前没能这样做是因为到范围检查时就被停了下来。)</para>
</callout>
<callout arearefs="roman.change.3.2">
<para>你对 &fromroman; 也不需要做过多的修改。唯一的修改就在 <varname>romanNumeralPattern</varname>：如果你注意的话，你会发现你只需在正则表达式的第一部分增加一个可选的 <literal>M</literal> 。这就允许最多 4 个 <literal>M</literal> 字符而不再是 3 个，意味着你允许代表 <literal>4999</literal> 而不只是 <literal>3999</literal> 的罗马数字。&fromroman; 函数本身是普遍适用的，它并不在意字符被多少次的重复，只是根据重复的罗马字符对应的数值进行累加。以前没能处理 <literal>'MMMM'</literal> 是因为你通过正则表达式的检查强行停止了。</para>
</callout>
</calloutlist>
<para>你可能会怀疑只需这两处小改动。嘿，不相信我的话，你自己看看吧：</para>
<example id="roman.roman72.output">
<title>用 &romantest72_filename; 测试 &roman72_filename; 的结果</title>
<screen><computeroutput>fromRoman should only accept uppercase input ... ok
toRoman should always return uppercase ... ok
fromRoman should fail with blank string ... ok
fromRoman should fail with malformed antecedents ... ok
fromRoman should fail with repeated pairs of numerals ... ok
fromRoman should fail with too many repeated numerals ... ok
fromRoman should give known result with known input ... ok
toRoman should give known result with known input ... ok
fromRoman(toRoman(n))==n for all n ... ok
toRoman should fail with non-integer input ... ok
toRoman should fail with negative input ... ok
toRoman should fail with large input ... ok
toRoman should fail with 0 input ... ok

----------------------------------------------------------------------
Ran 13 tests in 3.685s

OK</computeroutput> <co id="roman.change.4.1"/></screen>
<calloutlist>
<callout arearefs="roman.change.4.1">
<para>所有的测试用例都通过了，停止编写代码。</para>
</callout>
</calloutlist>
</example>
<para>全面的单元测试意味着不必依赖于程序员的一面之词：<quote>相信我！</quote></para>
</section>
<section id="roman.refactoring">
<?dbhtml filename="refactoring/refactoring.html"?>
<title>重构</title>
<abstract>
<title/>
<para>全面的单元测试带来的最大好处不是你的全部测试用例最终通过时的成就感；也不是被责怪破坏了别人的代码时能够<emphasis>证明</emphasis> 自己的自信。最大的好处是单元测试给了你自由去无情地重构。</para>
</abstract>
<para>重构是在可运行代码的基础上使之工作得更好的过程。通常，<quote>更好</quote>意味着<quote>更快</quote>，也可能意味着 <quote>使用更少的内存</quote>，或者 <quote>使用更少的磁盘空间</quote>，或者仅仅是<quote>更优雅的代码</quote>。不管对你，对你的项目意味什么，在你的环境中，重构对任何程序的长期良性运转都是重要的。</para>
<para>这里，<quote>更好</quote> 意味着 <quote>更快</quote>。更具体地说，&fromroman; 函数可以更快，关键在于那个丑陋的、用于验证罗马数字有效性的正则表达式。尝试不用正则表达式去解决是不值得的 (这样做很难，而且可能也快不了多少)，但可以通过预编译正则表达式使函数提速。</para>
<example>
<title>编译正则表达式</title>
<screen>
&prompt;<userinput>import re</userinput>
&prompt;<userinput>pattern = '^M?M?M?$'</userinput>
&prompt;<userinput>re.search(pattern, 'M')</userinput>               <co id="roman.refactoring.1.1"/>
<computeroutput>&lt;SRE_Match object at 01090490></computeroutput>
&prompt;<userinput>compiledPattern = re.compile(pattern)</userinput> <co id="roman.refactoring.1.2"/>
&prompt;<userinput>compiledPattern</userinput>
<computeroutput>&lt;SRE_Pattern object at 00F06E28></computeroutput>
&prompt;<userinput>dir(compiledPattern)</userinput>                  <co id="roman.refactoring.1.3"/>
<computeroutput>['findall', 'match', 'scanner', 'search', 'split', 'sub', 'subn']</computeroutput>
&prompt;<userinput>compiledPattern.search('M')</userinput>           <co id="roman.refactoring.1.4"/>
<computeroutput>&lt;SRE_Match object at 01104928></computeroutput></screen>
<calloutlist>
<callout arearefs="roman.refactoring.1.1">
<para>这是你看到过的 <function>re.search</function> 语法。把一个正则表达式作为字符串 (<varname>pattern</varname>) 并用这个字符串来匹配 (<literal>'M'</literal>)。如果能够匹配，函数返回 一个 match 对象，可以用来确定匹配的部分和如何匹配的。</para>
</callout>
<callout arearefs="roman.refactoring.1.2">
<para>这里是一个新的语法：<function>re.compile</function> 把一个正则表达式作为字符串参数接受并返回一个 pattern 对象。注意这里没去匹配字符串。编译正则表达式和以特定字符串 (<literal>'M'</literal>) 进行匹配不是一回事，所牵扯的只是正则表达式本身。</para>
</callout>
<callout arearefs="roman.refactoring.1.3">
<para><function>re.compile</function> 返回的已编译的 pattern 对象有几个值得关注的功能：包括了几个 &re; 模块直接提供的功能 (比如：<function>search</function> 和 <function>sub</function>)。</para>
</callout>
<callout arearefs="roman.refactoring.1.4">
<para>用 <literal>'M'</literal> 作参数来调用已编译的 pattern 对象的 <function>search</function> 函数与用正则表达式和字符串 <literal>'M'</literal> 调用 <function>re.search</function> 可以得到相同的结果，只是快了很多。 (事实上，<function>re.search</function> 函数仅仅将正则表达式编译，然后为你调用编译后的 pattern 对象的 <function>search</function> 方法。)</para>
</callout>
</calloutlist>
</example>
<note>
<title>编译正则表达式</title>
<para>在需要多次使用同一个正则表达式的情况下，应该将它进行编译以获得一个 pattern 对象，然后直接调用这个 pattern 对象的方法。</para>
</note>
<example>
<title>&roman81_filename; 中已编译的正则表达式</title>
<para>这个文件可以在例子目录下的 <filename>py/roman/stage8/</filename> 目录中找到。</para>
&para_download;
<programlisting>
# toRoman and rest of module omitted for clarity

romanNumeralPattern = \
    re.compile('^M?M?M?M?(CM|CD|D?C?C?C?)(XC|XL|L?X?X?X?)(IX|IV|V?I?I?I?)$') <co id="roman.refactoring.2.1"/>

def fromRoman(s):
    """convert Roman numeral to integer"""
    if not s:
        raise InvalidRomanNumeralError, 'Input can not be blank'
    if not romanNumeralPattern.search(s):                                    <co id="roman.refactoring.2.2"/>
        raise InvalidRomanNumeralError, 'Invalid Roman numeral: %s' % s

    result = 0
    index = 0
    for numeral, integer in romanNumeralMap:
        while s[index:index+len(numeral)] == numeral:
            result += integer
            index += len(numeral)
    return result
</programlisting>
<calloutlist>
<callout arearefs="roman.refactoring.2.1">
<para>看起来很相似，但实质却有很大改变。<varname>romanNumeralPattern</varname> 不再是一个字符串了，而是一个由 <function>re.compile</function> 返回的 pattern 对象。</para>
</callout>
<callout arearefs="roman.refactoring.2.2">
<para>这意味着你可以直接调用 <varname>romanNumeralPattern</varname> 的方法。这比每次调用 <function>re.search</function> 要快很多。模块被首次导入 (import) 之时，正则表达式被一次编译并存储于 <varname>romanNumeralPattern</varname>。之后每次调用 &fromroman; 时，你可以立刻以正则表达式匹配输入的字符串，而不需要在重复背后的这些编译的工作。</para>
</callout>
</calloutlist>
</example>
<para>那么编译正则表达式可以提速多少呢？你自己来看吧：</para>
<example id="roman.stage8.1.output">
<title>用 &romantest81_filename; 测试 &roman81_filename; 的结果</title>
<screen><computeroutput>.............          </computeroutput><co id="roman.refactoring.3.1"/><computeroutput>
----------------------------------------------------------------------
Ran 13 tests in 3.385s </computeroutput><co id="roman.refactoring.3.2"/><computeroutput>

OK</computeroutput>                     <co id="roman.refactoring.3.3"/></screen>
<calloutlist>
<callout arearefs="roman.refactoring.3.1">
<para>有一点说明一下：这里，我在运行单元测试时<emphasis>没有</emphasis> 使用 <option>-v</option> 选项，因此输出的也不再是每个测试完整的 &docstring;，而是用一个圆点来表示每个通过的测试。(失败的测试标用 <literal>F</literal> 表示，发生错误则用 <literal>E</literal> 表示，你仍旧可以获得失败和错误的完整追踪信息以便查找问题所在。)</para>
</callout>
<callout arearefs="roman.refactoring.3.2">
<para>运行 <literal>13</literal> 个测试耗时 <literal>3.385</literal> 秒，与之相比是没有预编译正则表达式时的 <literal>3.685秒</literal>。这是一个 <literal>8%</literal> 的整体提速，记住单元测试的大量时间实际上花在做其他工作上。(我单独测试了正则表达式部分的耗时，不考虑单元测试的其他环节，正则表达式编译可以让匹配 <function>search</function> 平均提速 <literal>54%</literal>。)小小修改还真是值得。</para>
</callout>
<callout arearefs="roman.refactoring.3.3">
<para>对了，不必顾虑什么，预先编译正则表达式并没有破坏什么，你刚刚证实这一点。</para>
</callout>
</calloutlist>
</example>
<para>我还想做另外一个性能优化工作。就正则表达式语法的复杂性而言，通常有不止一种方法来构造相同的表达式是不会令人惊讶的。在 &clp; 上对该模块进行一些讨论后，有人建议我使用 <literal>{<replaceable>m</replaceable>,<replaceable>n</replaceable>}</literal> 语法来查找可选重复字符。</para>
<example>
<title>&roman82_filename;</title>
<para>这个文件可以在例子目录下的 <filename>py/roman/stage8/</filename> 目录中找到。</para>
&para_download;
<programlisting>
# rest of program omitted for clarity

#old version
#romanNumeralPattern = \
#   re.compile('^M?M?M?M?(CM|CD|D?C?C?C?)(XC|XL|L?X?X?X?)(IX|IV|V?I?I?I?)$')

#new version
romanNumeralPattern = \
    re.compile('^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$') <co id="roman.refactoring.4.1"/>
</programlisting>
<calloutlist>
<callout arearefs="roman.refactoring.4.1">
<para>你已经将 <literal>M?M?M?M?</literal> 替换为 <literal>M{0,4}</literal>。它们的含义相同：<quote>匹配 0 到 4 个 <literal>M</literal> 字符</quote>。类似地，<literal>C?C?C?</literal> 改成了 <literal>C{0,3}</literal> (<quote>匹配 0 到 3 个 <literal>C</literal> 字符</quote>) 接下来的 <literal>X</literal> 和 <literal>I</literal> 也一样。</para>
</callout>
</calloutlist>
</example>
<para>这样的正则表达简短一些 (虽然可读性不太好)。核心问题是，是否能加快速度？</para>
<example>
<title>以 &romantest82_filename; 测试 &roman82_filename; 的结果</title>
<screen><computeroutput>.............
----------------------------------------------------------------------
Ran 13 tests in 3.315s </computeroutput><co id="roman.refactoring.5.1"/><computeroutput>

OK</computeroutput>                     <co id="roman.refactoring.5.2"/></screen>
<calloutlist>
<callout arearefs="roman.refactoring.5.1">
<para>总体而言，这种正则表达使单元测试提速 2%。这不太令人振奋，但记住 &search; 函数只是整体单元测试的一个小部分，很多时间花在了其他方面。(我另外的测试表明这个应用了新语法的正则表达式使 &search; 函数提速 <literal>11%</literal> 。) 通过预先编译和使用新语法重写可以使正则表达式的性能提升超过 <literal>60%</literal>，令单元测试的整体性能提升超过 <literal>10%</literal>。</para>
</callout>
<callout arearefs="roman.refactoring.5.2">
<para>比任何的性能提升更重要的是模块仍然运转完好。这便是我早先提到的自由：自由地调整、修改或者重写任何部分并且保证在此过程中没有把事情搞得一团糟。这并不是给无休止地为了调整代码而调整代码以许可；你有很切实的目标 (<quote>让 &fromroman; 更快</quote>)，而且你可以实现这个目标，不会因为考虑在改动过程中是否会引入新的 Bug 而有所迟疑。</para>
</callout>
</calloutlist>
</example>
<para>还有另外一个我想做的调整，我保证这是最后一个，之后我会停下来，让这个模块歇歇。就像你多次看到的，正则表达式越晦涩难懂越快，我可不想在六个月内再回头试图维护它。是呀！测试用例通过了，我便知道它工作正常，但如果我搞不懂它是<emphasis>如何</emphasis> 工作的，添加新功能、修正新 Bug，或者维护它都将变得很困难。正如你在 <xref linkend="re.verbose"/> 看到的，&python; 提供了逐行注释你的逻辑的方法。</para>
<example>
<title>&roman83_filename;</title>
<para>该文件可以在例子目录下的 <filename>py/roman/stage8/</filename> 目录中找到。</para>
&para_download;
<programlisting>
# rest of program omitted for clarity

#old version
#romanNumeralPattern = \
#   re.compile('^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$')

#new version
romanNumeralPattern = re.compile('''
    ^                   # beginning of string
    M{0,4}              # thousands - 0 to 4 M's
    (CM|CD|D?C{0,3})    # hundreds - 900 (CM), 400 (CD), 0-300 (0 to 3 C's),
                        #            or 500-800 (D, followed by 0 to 3 C's)
    (XC|XL|L?X{0,3})    # tens - 90 (XC), 40 (XL), 0-30 (0 to 3 X's),
                        #        or 50-80 (L, followed by 0 to 3 X's)
    (IX|IV|V?I{0,3})    # ones - 9 (IX), 4 (IV), 0-3 (0 to 3 I's),
                        #        or 5-8 (V, followed by 0 to 3 I's)
    $                   # end of string
    ''', re.VERBOSE) <co id="roman.refactoring.6.1"/>
</programlisting>
<calloutlist>
<callout arearefs="roman.refactoring.6.1">
<para><function>re.compile</function> 函数的第二个参数是可选的，这个参数通过一个或一组标志 (flag) 来控制预编译正则表达式的选项。这里你指定了 <literal>re.VERBOSE</literal> 选项，告诉 &python; 正则表达式里有内联注释。注释和它们周围的空白<emphasis>不</emphasis> 会被认做正则表达式的一部分，在编译正则表达式时 <function>re.compile</function> 函数会忽略它们。这个新 <quote>verbose</quote> 版本与老版本完全一样，只是更具可读性。</para>
</callout>
</calloutlist>
</example>
<example>
<title>用 &romantest83_filename; 测试 &roman83_filename; 的结果</title>
<screen><computeroutput>.............
----------------------------------------------------------------------
Ran 13 tests in 3.315s </computeroutput><co id="roman.refactoring.7.1"/><computeroutput>

OK</computeroutput>                     <co id="roman.refactoring.7.2"/></screen>
<calloutlist>
<callout arearefs="roman.refactoring.7.1">
<para>新 <quote>verbose</quote> 版本和老版本的运行速度一样。事实上，编译的 pattern 对象也一样，因为 <function>re.compile</function> 函数会剔除掉所有你添加的内容。</para>
</callout>
<callout arearefs="roman.refactoring.7.2">
<para>新 <quote>verbose</quote> 版本可以通过所有老版本通过的测试。什么都没有改变，但在六个月后重读该模块的程序员却有了理解功能如何实现的机会。</para>
</callout>
</calloutlist>
</example>
</section>
<section id="roman.postscript">
<?dbhtml filename="refactoring/postscript.html"?>
<title>后记</title>
<abstract>
<title/>
<para>聪明的读者在学习<link linkend="roman.refactoring">前一节</link>时想得会更深入一层。现在写的这个程序中最令人头痛的性能负担是正则表达式，但它是必需的，因为没有其它方法来识别罗马数字。但是，它们只有 5000 个，为什么不一次性地构建一个查询表来读取？不必用正则表达式凸现了这个主意的好处。你建立了整数到罗马数字查询表的时候，罗马数字到整数的逆向查询表也构建了。</para>
</abstract>
<para>更大的好处在于，你已经拥有一整套完全的单元测试。你修改了多半的代码，但单元测试还是一样的，因此你可以确定你的新代码与来的代码一样可以正常工作。</para>
<example>
<title>&roman9_filename;</title>
<para>这个文件可以在例子目录下的 <filename>py/roman/stage9/</filename> 目录中找到。</para>
&para_download;
<programlisting>
&romancache_exceptions;

&romancache_max;

&romancache_mapping;

&romancache_lookupvars;

&romancache_toroman;
&romancache_toromanreturn;

&romancache_fromroman;
&romancache_fromromanreturn;

&romancache_dynamicdef;
&romancache_dynamicdoc;
&romancache_dynamiccode;
&romancache_dynamicbreak;
&romancache_dynamicwickedcooltrick;
&romancache_dynamicreturn;

&romancache_filldef;
&romancache_filldoc;
&romancache_fillcomment;
&romancache_fillfor;
&romancache_fillcalldynamic;
&romancache_fillto;
&romancache_fillfrom;

&romancache_fillcall;
</programlisting>
</example>
<para>这样有多快呢？</para>
<example>
<title>用 &romantest9_filename; 测试 &roman9_filename; 的结果</title>
<screen>
<computeroutput>
.............
----------------------------------------------------------------------
Ran 13 tests in 0.791s

OK
</computeroutput>
</screen>
</example>
<para>还记得吗？你原有版本的最快速度是 13 个测试耗时 3.315 秒。当然，这样的比较不完全公平，因为这个新版本需要更长的时间来导入 (当它填充查询表时)。但是导入只需一次，在运行过程中可以忽略。</para>
<para>这个重构的故事的寓意是什么？</para>
<itemizedlist>
<listitem><para>简洁是美德。</para></listitem>
<listitem><para>特别是使用正则表达式时。</para></listitem>
<listitem><para>并且单元测试给了你大规模重构的信心……即使原有的代码不是你写的。</para></listitem>
</itemizedlist>
</section>
<section id="roman.summary">
<?dbhtml filename="refactoring/summary.html"?>
<title>小结</title>
<abstract>
<title/>
<para>单元测试是一个强大的概念，使用得当的话既可以减少维护成本又可以增加长期项目的灵活性。同样重要的是要意识到单元测试并不是“灵丹妙药”，也不是“银弹”。编写好的测试用例很困难，保持其更新更需要磨练 (特别是当顾客对修复严重的 Bug 大呼小叫之时)。单元测试不是其它形式测试的替代品，比如说功能性测试、集成测试以及可用性测试。但它切实可行且功效明显，一旦相识，你会反问为什么以往没有应用它。</para>
</abstract>
<para>这一章涵盖了很多内容，有很多都不是 &python; 所特有的。很多语言都有单元测试框架，都要求你理解相同的基本概念：</para>
<highlights>
<itemizedlist>
<listitem><para>测试用例的设计方针是目的单一、可以自动运行、互不干扰。</para></listitem>
<listitem><para>在被测试代码编写<emphasis>之前</emphasis> 编写测试用例。</para></listitem>
<listitem><para>编写测试<link linkend="roman.success">有效输入的测试用例</link>并检查正确的结果。</para></listitem>
<listitem><para>编写测试<link linkend="roman.failure">无效输入的测试用例</link>并检查正确的失败。</para></listitem>
<listitem><para>为<link linkend="roman.bugs">描述 Bug</link> 或<link linkend="roman.change">反映新需求</link>而编写和升级测试用例。</para></listitem>
<listitem><para>为改进性能、可伸缩性、可读性、可维护性和任何缺少的特性而无情地<link linkend="roman.refactoring">重构</link>。</para></listitem>
</itemizedlist>
</highlights>
<para>另外，你应该能够自如地做到如下 &python; 的特有工作：</para>
<highlights>
<itemizedlist>
<listitem><para>继承 <link linkend="roman.testtoromanknownvalues.example"> <literal>unittest.TestCase</literal></link> 生成子类并为每个单独的测试用例编写方法。</para></listitem>
<listitem><para>使用 <link linkend="roman.testtoromanknownvalues.example">&assertEqual;</link> 检查已知结果的返回。</para></listitem>
<listitem><para>使用 <link linkend="roman.tobadinput.example">&assertRaises;</link> 检查函数是否引发已知异常。</para></listitem>

<listitem><para>在 <literal>if __name__</literal> 子句中调用 <link linkend="roman.stage1.output"><literal>unittest.main()</literal></link> 来一次性运行所有测试用例。</para></listitem>
<listitem><para>以<link linkend="roman.stage1.output">详细 (verbose) </link>或者<link linkend="roman.stage8.1.output">普通 (regular) </link>模式运行单元测试</para></listitem>
</itemizedlist>
</highlights>
<itemizedlist role="furtherreading">
<title>进一步阅读</title>
<listitem><para><ulink url="&url_xpcom;">&xpcom;</ulink> 有多种语言的 <ulink url="&url_xpcom;software.htm">单元测试框架</ulink> 的下载链接。</para></listitem>
</itemizedlist>
</section>
</chapter>
