.. rst3: filename: html\plugins.html

##########################
Chapter 12: Plugins
##########################

This chapter discusses the plugins contained in leoPlugins.leo.
These plugins are part of Leo's official distribution.
`Chapter 13: Writing Plugins`_ tells how to write plugins.

The scripting plugin (mod_scripting.py) deserves special mention. This
plugin lets you create **script buttons** in a matter of seconds. See `Creating
script buttons`_. Script buttons are extraordinarily useful. Try them, you'll be
instantly hooked.

.. .. contents::

.. External links...
.. _docutils:             http://docutils.sourceforge.net
.. _LaTeX:                http://www.latex-project.org/
.. _reStructuredText:     http://docutils.sourceforge.net/rst.html
.. _SilverCity:           http://silvercity.sourceforge.net

.. Relative links...
.. _`Specifying settings`:              customizer.html#specifying-settings
.. _`Chapter 8\: Customizing Leo`:      customizing.html
.. _`Chapter 13\: Writing Plugins`:     writingPlugins.html
.. _`Creating script buttons`:          scripting.html#creating-script-buttons

Enabling plugins
++++++++++++++++

You enable or disable plugins using @enabled-plugins nodes in leoSettings files (leoSettings.leo, myLeoSettings.leo or the .leo file being loaded).  See `Specifying settings`_ for full details of settings files.

The body text of the @enabled-plugins node contains a list of enabled plugins.
Notes:

- Leo attempts to load all plugins every time an @enabled-plugins node is seen.
   If the plugin has already been loaded, Leo silently ignores the request to
   re-enable the plugin. Leo never attempts to disable a plugin while processing
   enabled plugin strings. Thus, plugins enabled in an @enabled-plugins node in
   leoSettings.leo *will* be enabled regardless of the contents of any other
   @enabled-plugins node.

- g.app.gui.getEnabledPlugins contains the last value last processed
   @enabled-plugins node.

Body pane
+++++++++



arrows.py
*********

Rebinds up/down arrow keys.

image.py
********

Handles images in body text. Based on work by Gil Shwartz. Brent Burley provided
many important insights. See:
http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/52264

rClick.py
*********

This plugin provides a simple but powerful and flexible system of managing
scriptable context menus.

Named menus defined in scripts or @popup <name> settings can be associated with any widget.

Menu items may have icons and the foreground/background colors can be set in @popup settings.

Full details can be found in the plugins docstring.

Many executable howto's, demos and examples can be found in::

    test/testAtPopup.leo

autocompleter.py
****************

Autocompletion and calltips plugin.

- . summons the autocompletion.
- ( summons the calltips
- Escape closes either box.
- Ctrl selects an item.
- alt-up_arrow, alt-down_arrow move up or down in the list.
  The mouse will work for this as well.

This plugin scans the complete outline at startup.
You many enable or disable features in autocompleter.ini.
This file contains two options under the [ autocompleter ] section::

    useauto
    usecalltips

Setting either to 1 will turn on the feature. 0 means off. If there is a section
called [ newlanguages ] it will read each option as a new language for
autocompleter to recognize, and compile its value as a regex pattern for the
autocompleter system to recognize as a calltip. This has relevance for the .ato
system described below.  Languages that currently have patterns::

    python, java, c++, c, perl

Autocompleter looks in the plugin directory for a directory called
autocompleter. If it doesn't find one it will attempt to create this directory.
This directory should contain what are called .ato files ( pronounced auto ).
Autocompleter will scan each .ato file that has a first part that matches a
languages name. For example: python.ato autocompleter recognizes python, and
will scan this file. The contents are read with the same mechanism that reads
the information in the nodes, so calltip and autocompleter information is added
to autocompleter's runtime database. If a new language has been added in the
autocompleter.ini file then an .ato file that starts with the new languages name
will be recognized and read in. Note, this language needs to be recognizable to
Leo. Used correctly an .ato file is a mechanism by which a user can carry
autocompletion and calltip information between .leo files/sessions.

color_markup.py
***************

Handle coloring for markup in doc parts and Python triple-double-quoted strings.

**Important**:

- This plugin requires that the add_directives plugin is enabled.

- To color a text with wiki markup the text must be in the range of an @markup wiki directive.

The currently supported markups are::

    ''text''                    # write text in italics
    __text__                    # write text in bold
    ~~<color>:text~~            # write text in the color specified by <color> (e.g. blue, grey, etc)
    {picture file=<filename>}   # load the picture indicated by <filename>
    http://url                  # URL support: double clicking on the url will open it in the default browser.
    https://url                 # URL support: double clicking on the url will open it in the default browser.

-   Note 1: italics and bold markups can be nested, e.g.,::

        ''__text__''            # write text in italics and bold

    Just remember to terminate the tags in the order they were opened.

- Note 2: URLs must be terminated by a space.

By default, once the text has been markup up, the actual tags (e.g. '__' for
bold) are not displayed anymore. You can choose to display them selecting "Show
Invisibles" from the Edit menu.

script_io_to_body.py
********************

Send output from the Execute Script command to the end of the body pane.

Commands & directives
+++++++++++++++++++++



add_directives.py
*****************

Supports new Leo directives.

bibtex.py
*********

This plugin manages BibTeX files with Leo. Create a bibliographic database by
putting @bibtex filename in a headline. Entries are added as nodes, with
@entrytype key as the headline, and the contents of the entry in body text.
The plugin will automatically insert a template for the entry in the body pane
when a new entry is created (hooked to pressing enter when typing the headline
text). The templates are defined in dictionary templates in the \<\<globals\>\>
section, by default containing all required fields for every entry.

The file is written by double-clicking the node. Thus the following outline::

    -@bibtex biblio.bib
     +@book key
      author = {A. Uthor},
      year = 1999

will be written in the file 'biblio.bib' as::

    @book{key,
    author = {A. Uthor},
    year= 1999}

Strings are defined in @string nodes and they can contain multiple entries.
All @string nodes are written at the start of the file. Thus the following
outline::

    -@bibtext biblio.bib
     +@string
      j1 = {Journal}
     +@article AUj1
      author = {A. Uthor},
      journal = j1
     +@string
      j2 = {Journal2}
      j3 = {Journal3}

Will be written as::

    @string{j1 = {Journal1}}
    @string{j2 = {Journal2}}
    @string{j3 = {Journal3}}

    @article{AUj1,
    author = {A. Uthor},
    journal = j1}

No error checking is made on the syntax. The entries can be organized under
nodes--if the headline doesn't start with '@', the headline and body text are
ignored, but the child nodes are parsed as usual. BibTeX files can be imported
by creating an empty node with @bibtex filename in the headline.
Double-clicking it will read the file filename and parse it into a
@bibtex tree. No syntax checking is made, filename is expected to be a
valid BibTeX file.

ConceptualSort.py
*****************

This plugin is enhances the EditAttributes.py plugin. It puts a command in
Outline called ConceptualSort. This will prompt you for a concept to sort by.
This gives the user some more flexibility in how they want to arrange their
nodes. Nodes without the attribute in question go to the bottom of the sort.
The user can:

- Select which attribute he wants to sort on by clicking on the Attribute box.

- Select the type of sort he wants by clicking on the radio buttons:

    -   Normal.
    -   Reversed. Like normal but the results are reversed.
    -   Used defined. For advanced users. The text box is where a user can type in
        their own python code to sort the nodes-attributes. There is no need for a
        def. That gets appended to the beginning of the code. It prototype looks
        like::

            def( a, b, att ):

where a and b are nodes and att is dictionary of the nodes and the respective
value of the selected attribute. There is no need to indent on the first level
since indentation is added at compile time.

datenodes.py
************

This plugin adds **date nodes** (nodes with dates as their headlines) to the
current outline. Date nodes may be added one at a time, a month's-worth at a
time, or a year's-worth at a time. The format of the headlines is
configurable in the ini file.

FileActions.py
**************

Leo plugin that permits the definition of actions for double-clicking on file
nodes. Double-clicking in a @file node writes out the file if changes have
been made since the last save, and then runs a script on it, which is retrieved
from the outline. Scripts are located in a node whose headline is FileActions.
This node can be anywhere in the outline. If there is more than one such node,
the first one in outline order is used. The children of that node are expected
to contain a file pattern in the headline and the script to be executed in the
body. The file name is matched against the patterns (which are Unix-style shell
patterns), and the first matching node is selected. If the filename is a path,
only the last item is matched. Execution of the scripts is similar to the
Execute Script command in Leo. The main difference is that the namespace in
which the scripts are run contains two elements:

-   filename, which contains the filename from the @file directive.

-   shellScriptInWindow, a utility function that runs
    a shell script in an external windows, thus permitting
    programs to be called that require user interaction

File actions are implemented for @file nodes and all its variants
(@file-nosent, @thin, etc.). There is also a new node type
@file-ref for referring to files purely for the purpose of
file actions, Leo does not do anything with or to such files.

groupOperations.py
******************

A Leo Plugin that adds Group commands functionality.  Restrictions currently apply to using Leo with a Tk front end.
There are several commands in this plugin:

-   Mark Node: marks a node for further operations such as copying, cloning and moving.

-   Mark Spot: marks a node as the place where group operations are to target.

-   Operate On Marked: moves lassoed nodes to the spot where the roundup node is
    placed. Clones are maintained.

-   Clear Marked: unmarks all marked nodes and removes the roundup node.

-   Transfer Lassoed Nodes: this is a menu for inter-window communication.
    The windows must all be spawned from the same Leo instance. 
    It allows the user to move all node marked for copying and moving from another window to this one.

import_cisco_config.py
**********************

This plugin adds a menu item under the File->Import menu to import
Cisco configuration files.
The plugin will:

1)  Create a new node, under the current node, where the configuration will be
    written. This node will typically have references to several sections (see below).

2)  Create sections (child nodes) for the indented blocks present in the original
    config file. These child nodes will have sub-nodes grouping similar blocks (e.g.
    there will be an 'interface' child node, with as many sub-nodes as there are real
    interfaces in the configuration file).

3)  Create sections for the custom keywords specified in the customBlocks[] list in
    importCiscoConfig(). You can modify this list to specify different keywords. DO
    NOT put keywords that are followed by indented blocks (these are taken care of by
    point 2 above). The negated form of the keywords (for example, if the keyword is
    'service', the negated form is 'no service') is also included in the sections.


4)  Not display consecutive empty comment lines (lines with only a '!').

All created sections are alphabetically ordered.

Library.py
**********

A plugin to store Leo trees in anydbm files. Note: there isn't such a thing as an
anydbm file: it's whatever the anydbm module uses.
Under Outline, there is an option called Library. This will open a
dialog with a list of the trees that you have saved. You can insert trees stored
in the library, remove them and add trees to the library. Be aware of unicode,
any characters outside of the ascii set gets turned into a ?. I found this
problem in storing some trees from Edward's Leo outline. Id like it to be able to
store unicode, but that may require a more specific db background, than anydbm.
Also note, that your library files may not be OS independent. If your python
distribution does not have the backing db on another machine, it will not be
able to open your library.
This should help people develop templates that they want to reuse between Leo
projects.  For example, Id like a template of many Java interfaces to be easily
accessible.

macros.py
*********

Creates new nodes containing parameterized section references.

mod_autosave.py
***************

Autosave the Leo document every so often. The time between saves is given in
seconds in autosave.ini.

mod_read_dir_outline.py
***********************

This plugin allows Leo to read a complete directory's outline into a Leo's
Outline. Directories are converted into headlines and files names are listed
into the bodies.

mod_timestamp.py
****************

Timestamp all save operations to show when they occur.

nodeActions.py
**************

A Leo plugin that permits the "easy" assignment of scripts to be performed on
double-clicked nodes based on pattern matching.

When a node is double-clicked, the nodeActions plugin checks for a match of the
double-clicked node's headline text with a list of patterns and, if a match
occurs, the script associated with the pattern is executed.

The nodeActions plugin will only pass the double-click event to other plugins
if no pattern match occurred unless overridden by the ">" `pattern directive`__.

__ nA_Directives_

.. _nA_Patterns:

Patterns:
   The patterns are defined in the headlines of sub-nodes of a single
   "nodeActions" node.

   The "nodeActions" node can be located anywhere within the same Leo file as
   the node that will be double-clicked.  For example, a pattern that matches a
   URL and a pattern that matches any python files stored as an @thin derived
   file could be stored under an @settings node as follows::

      @settings
      |
      +- nodeActions
         |
         +- http:\\*
         |
         +- @thin *.py

   __ nA_Directives_

   Pattern matching is performed using python's support for Unix
   shell-style patterns unless overwritten by the "X" `pattern directive`__.
   The following pattern elements are supported::

              * - matches everything
              ? - matches any single character
        [<seq>] - matches any character in <seq>
       [!<seq>] - matches any character **not** in <seq>

   Unix shell-style pattern matching is case insensitive and always starts from
   the beginning of the headline.  For example:

      .. table::

         ======= =========== ==============
         Pattern   Matches   Does not match
         ======= =========== ==============
         \*.py   Abc_Test.py
         .py     .py - Test  Abc_Test.py
         test*   Test_Abc.py Abc_Test.py
         ======= =========== ==============

   To enable a script to run on any type of @file node (@thin, @shadow, ...),
   the pattern can use "@files" at the beginning of the pattern to match on any
   external file type.  For example, the pattern "@files \*.py" will
   match a node with the headline "@thin Abcd.py".

   The headline of the double-clicked node is matched against the patterns
   starting from the first sub-node under the "nodeActions" node to the last
   sub-node.  Only the script associated with the first matching pattern is
   invoked unless overwritten by the "V" `pattern directive`__.

   __ nA_Directives_

   This can be used to define a broad pattern such
   as "@files \*.py", and then, by placing a more restrictive pattern above it,
   such as "@files \*_test.py", a different script can be executed for those
   special cases::

      +- nodeActions
         |
         +- @files *_test.py
         |
         +- @files *.py

   :Note:
      To prevent Leo from trying to save patterns that begin with a derived
      file directive (@thin, @auto, ...) to disk, such as "@thin \*.py",
      place the "@ignore" directive in the body of the "nodeActions" node.

Scripts:
   The script for a pattern is located in the body of the pattern's node.
   The following global variables are available to the script::

      c
      g
      pClicked - node position of the double-clicked node
      pScript - node position of the invoked script

.. _nA_Directives:

Directives:
   The following pattern specific directives can be appended to the end of a
   pattern (do not include the ':'):

   :[X]:
      Use python's regular expression type patterns instead of the Unix
      shell-style pattern syntax.

      For example, the following patterns will match the same headline string::

         Unix shell-style pattern:
            @files *.py

         Regular Expression patern:
            ^@files .*\.py$ [X]

   :[V]:
      Matching the pattern will not block the double-click event from
      being passed to the remaining patterns.
      The "V" represents a down arrow that symbolizes the passing of the event
      to the next pattern below it.

      __ nA_Patterns_

      For example, adding the "[V]" directive to the "@files \*_test.py" in
      the `Patterns`__ section above, changes its script from being 'an
      alternate to' to being 'a pre-processor for' the "@files \*.py" script::

         +- nodeActions
            |
            +- @files *_test.py [V]
            |
            +- @files *.py

   :[>]:
      Matching the pattern will not block the double-click event from being
      passed to other plugins.
      The ">" represents a right arrow that
      symbolizes the passing of the event to the next plugin.

      If the headline matched more than one headline,
      the double-click event will be passed to the next plugin if the
      directive is associated with any of the matched patterns.

   The directive(s) for a pattern must be contained within a single set of
   brackets, separated from the pattern by a space, with or without a comma
   separator.  For example, the following specifies all three directives::

      ^@files .*\.py$ [X,V>]

Configurations:
   The nodeActions plugin supports the following global configurations using
   Leo's support for setting global variables within an @settings node's
   sub-nodes in the leoSettings.leo, myLeoSettings.leo, and the project Leo
   file:

   @bool nodeActions_save_atFile_nodes = False

      :True:
         The nodeActions plugin will save a double-clicked external file node
         to disk, if a pattern match occurred, before executing its script.  

      :False:
         A pattern match to a double-clicked external file node will **not**
         cause the external file to be saved to disk.
         (default)

   @int nodeActions_message_level = 1

      Specifies the type of messages to be sent to the log pane.  Specifying a
      higher message level will display that level and all lower levels.
      The following integer values are supported:

      :0: no messages
      :1: Plugin triggered and the patterns that were matched (default)
      :2: Double-click event passed or not to next plugin
      :3: Patterns that did not match
      :4: Code debugging messages

Script examples:
   Displaying URLs (tested with WinXP):

      Double-clicking on a node with a "http:\\\\www.google.com" headline
      will invoke the script associated with the
      "http:\\\\\*" pattern.  The following script in the body of the pattern's
      node displays the URL in a browser::

         import webbrowser
         hClicked = pClicked.h     #Clicked node's Headline text
         webbrowser.open(hClicked) #Invoke browser

   Executing commands (tested with WinXP):

      The following script can be placed in the body of a pattern's node to
      execute a command in the first line of the body of a double-clicked node::

         g.os.system('"Start /b ' + pClicked.bodyString() + '"')

outline_export.py
*****************

Modify the way exported outlines are displayed.

paste_as_headlines.py
*********************

This plug-in takes any text is stored in the clipboard and creates new headlines
for each line of text. The paste routine checks to make sure the line of text is not
greater than 50 characters in length. If it is, the routine truncates the headline to
50 characters and pastes the entire line into the body text of that node.

If the plug-in is functioning properly, a "Paste as Headlines" option should appear in
the Edit menu directly under the existing Paste option.

pretty_print.py
***************

A plugin that helps customize pretty printing. It creates a do-nothing subclass
of the default pretty printer. To customize, simply override in this file the
methods of the base prettyPrinter class in leoCommands.py. You would typically
want to override putNormalToken or its allies. Templates for these methods have
been provided. You may, however, override any methods you like. You could even
define your own class entirely, provided you implement the prettyPrintNode
method.

scheduler.py
************

A plugin to schedule commands for later execution. It's provides the ability to
issue commands at a future time and to write messages that will be displayed at
a later time. To record commands You goto Schedule and choose begin recording.
Then you jump to the nodes and select the commands you want issued on them. This
process is ended with the end recording option. A dialog pops up. You can then
click on the individual commands and set the time for execution. To set the
execution time for all, enter a value and hit set_all. All times must be in the
form hh:mm. For example I want to issue a save command for 5:00 PM. I would do
so by using the value 17:00. The Schedule Message is simple. There is a Text box
to enter the message and a Entry to place the time. View Queue will summon a
view of The Queue. This dialog will show the commands that have been enqueued.
There is also the option to Cancel out any scheduled commands/messages.

table.py
********

This plugin puts the View Table command in the Outline menu. This command checks
the current node using the csv (comma separated values) mods Sniffer. It tries
to determine the format that is in the nodes data. If you had excel data in it,
it should be able to determine its excel data. It then creates a dialog with the
data presented as in a table for the user to see it. Requires Pmw and the
tktable widget at http://sourceforge.net/projects/tktable.

templates.py
************

This plugin lets you add customizable templates to an outline. Templates are
like any other node except that the plugin replaces %s in the body text by
values that you specify when using template. Templates may have section
references; this plugin uses Leo's @nosent write machinery to create one
string out of possibly many nodes. This plugin requires the simplified atFile
write code that is new in 4.2.1.

This plugin creates two buttons in Leo's icon area:

- The '%s' button marks or unmarks a node as a template. A %s symbol will appear to
  the left of the node when it is marked as a template.

- The '----> %s' button brings up a dialog that shows you the template text and
  asks you to specify the value for all %s instances. Dismissing this dialog
  inserts the template as the first child of the node, and creates a section
  reference in the node that references the template.

If a template does not have a '%s' in it, then the templates plugin just adds
the text as a node. Templates once marked are stored across sessions. Do not put
a template in a thin file, as your template mark will be erased between
sessions.

word_cound.py
*************

This plugin displays a message box with information about the body text of the current node 
such as number of: characters, words, lines, and paragraphs. It adds a "Word Count..." option
to the bottom of the Edit menu that will activate the message box.

The Word Count... menu has a shortcut key of 'W'.

Dialogs
+++++++



gtkDialogs
**********

gtkDialogs replaces Tk's file dialogs with Gtk file chooser dialogs.

The plugin is aimed mainly at Linux users with pyGtk installed on their systems,
but it should work on on any system that support Gtk2 and pyGtk.

Debugging &  testing
++++++++++++++++++++



failed_import.py
****************

A plugin to test import problems.

dump_globals.py
***************

Dump Python globals at startup.

enable_gc.py
************

Enable debugging and tracing for Python's garbage collector.

trace_gc.py
***********

Trace changes to Leo's objects at idle time.

trace_keys.py
*************

Trace keystrokes in the outline and body panes.

trace_tags.py
*************

Trace the most common hooks, but not key, drag or idle hooks.

External editors & Open With
++++++++++++++++++++++++++++



mod_tempfname.py
****************

Replaces Commands.openWithTempFilePath so Leo opens temporary
files with a filename that begins with the headline text, and
located in a username_Leo subdirectory of the temporary
directory. The LeoTemp prefix is omitted.  This makes it easier to
see which temporary file is related to which outline node.

open_shell.py
*************

Creates an 'extensions' menu with commands to open either an xterm on Linux
or a cmd windows/explorer window on win32 in the directory of the current @file node.
This allows quick navigation to facilitate testing and navigating large systems
with complex directories.

open_with.py
************

This plugin creates menu items in the File:Open With menu.

@openwith nodes in @settings trees create menu items. The openWith
plugin must be active for these settings to have any effect.

The headline of an @openwith node has the form::

    @openwith name = shortcut

name is name of the menu item. shortcut specifies the shortcut used to invoke
the menu item. shortcut may be None.

The body text @openwith nodes should contain a single line contain a tuple of the form::

    command,arg,ext

For example::

    'subprocess.Popen',['pythonw','C:/Python24/Lib/idlelib/idle.pyw'],'.py'

When the user selects this menu item Leo executes command(arg+path) where path
is the full path to the temp file. The ext argument specifies the extension of
the temp file.

Notes:

- command is a string.  Valid values are::

  'subprocess.Popen'
  'os.system'
  'os.startfile'
  'os.spawnl'
  'os.spawnv'
  'exec'

- arg is either a single string or a list of strings.

- ext is a string or None. If None, Leo computes a file extension base on what
  @language directive is in effect.

- If the .leo file being loaded contains @openwith nodes, the File:Open With
  menu contains only the items created by those nodes. Similarly, @openwith
  nodes in myLeoSettings.leo override entries in leoSettings.leo.

- If no @openwith nodes are found anywhere the openWith plugin uses hard-coded
  tables in the plugin itself.

temacs.py & usetemacs.py
************************

temacs is a binding module for the Tkinter Text widget.
usetemacs is a Leo plugin that patches the temacs modules Emacs emulation
into the standard Leo Tkinter Text editor.

vim.py
******

A plugin that communicates with VIM:

When properly installed, this plugin does the following:

- Double clicking on a node's icon opens that node in VIM.

- Leo will put the Vim cursor at same location as the Leo cursor in node's body if the Leo 'vim_plugin_positions_cursor' variable is set to True.

- Leo will put node in a Vim tab card if the Leo 'vim_plugin_uses_tab_feature' is set to True.

- Leo will update the node in the outline when you save the file in VIM.

word_export.py
**************

Use commands in the Plugins:Word Export:Export menu to formats and export
the selected outline to a Word document, starting Word if necessary.

xemacs.py
*********

This plugin allows you to edit nodes in emacs/xemacs.
Depending on your preference, selecting or double-clicking a node will pass the
body text of that node to emacs. You may edit the node in the emacs buffer and
changes will appear in Leo.

Files
+++++



active_path.py
**************

Makes \@path nodes "active".

With this plugin running, double clicking on \@path nodes
and their descendents synchronizes the node with the
filesystem.  If the node refers to a fodler (as the top
level \@path node always will), the folder's contents are
loaded as child nodes.  If it refers to a file, the file is
loaded as an @auto node.

For files not previously seen in a folder a new node will appear on top of
the children list (with a mark).

Folders appear in the list as /foldername/.  If you double click on the
icon-box of the folder node, it will have children added to it based on
the contents of the folder on disk.  These folders have the '@path' directive
as the first line of their body text.

When files are deleted from the folder and the list is updated by double
clicking the files will appear in the list as *filename* (or */foldername/*).

You can describe files and directories in the body of the nodes.

You can organize files and directories with organizer nodes, an organizer
node name cannot contain with '/'.

Files and folders can be created by entering a node with the required
name as its headline (must start and/or end with "/" for a folder)
and then double clicking on the node's status-iconbox.

@auto nodes can be set up for existing files can be loaded by
double clicking on the node's status-iconbox.  If you prefer
@shadow or something else use the "active_path_attype" setting,
without the "@".

There are commands on the Plugins active_path submenu:

    - show path - show the current path
    - set absolute path - changes a node "/dirname/" to "@path /absolute/path/to/dirname".
    - purge vanished (recursive) - remove *entries*
    - purge unoaded files (recursive) - remove *entries*
    - update recursive - recursive load of directories, use with caution on large
      file systems

If you want to use an input other than double clicking a node's status-iconbox
set active_path_event to a value like 'iconrclick1' or 'iconclick1'.


active_path is a rewrite of the at_directory plugin to use \@path directives (which influence
@auto and other @file type directives), and to handle sub-folders more automatically.
'''

Settings
^^^^^^^^

  @string active_path_attype = auto
    Change to load file nodes as something other than @auto
  
  @string active_path_event = icondclick1
    The default is probably the most useful event binding here
  
  @data active_path_ignore
    List of regex expressions active_path doesn't list in folders
    
  @data active_path_autoload
    List of regex expressions active_path @auto loads automatically

empty_leo_file.py
*****************

Opens any empty file as a minimal .leo file.

leoOPML.py
**********

.. _OPML:                   http://en.wikipedia.org/wiki/OPML
.. _`OPML 2.0 standard`:    http://www.opml.org

**Warning**: the OPML plugin is not fully functional at present.  Use with caution.

The OPML plugin creates two new commands that read and write
Leo outlines in OPML_ format.
The read-opml-file command creates a Leo outline from an .opml file.
The write-opml-file command writes the present Leo outline to an .opml file.

Various settings control what gets written to .opml files, and in what format.
As usual, you specify settings for the OPML plugin using leoSettings.leo.
The settings for the OPML are found in the node::

    @settings-->Plugins-->opml plugin

Here are the settings that control the format of .opml files.
The default values are shown.

- @bool opml_read_derived_files = True

  If True, Leo reads external files when reading .opml files.

- @string opml_namespace = leo:com:leo-opml-version-1

  The namespace urn for the xmlns attribute of <opml> elements.
  This value typically is not used, but it should refer to Leo in some way.

- @bool opml_use_outline_elements = True

  If True, Leo writes body text to <:body> elements nested in <outline> elements.
  Otherwise, Leo writes body text to :body attributes of <outline> elements.

  **Note**: Leo-specific attributes and elements are clearly distinguished from 'standard' opml elements:
  they are preceded by a colon, which marks them as members of the default namespace specified specified
  by this option.  Thus, all OPML text generated by this plugin should conform to the `OPML 2.0 standard`_.

- @string opml_version = 2.0

  The opml version string written to the <OPML> element.
  Use 2.0 unless there is a specific reason to use 1.0.

- @bool opml_write_body_text = True

  If True, Leo writes body text to the OPML file.

- @bool opml_write_derived_files = True

  If True, Leo writes external files when writing .opml files.

- @bool opml_write_leo_details = True

  If True, Leo writes the native attributes of Leo's <v> elements
  as attributes of the opml <outline> elements.
  The native attributes of <v> elements are
  a, descendentTnodeUnknownAttributes, expanded, marks,
  t, and tnodeList.

- @bool opml_write_leo_globals_attributes = True

  If True, Leo writes body_outline_ratio and global_window_position
  attributes to the <head> element of the .opml file.

- @bool opml_write_uAs = True

  If True, Leo writes unknown attributes (uA's) in <:uA> sub-elements of <outline> elements.

lineNumbers.py
**************

Adds #line directives in perl and perlpod programs.
Currently supports only perl and perlpod.

multifile.py
************

Multipath enables the ability to write a file to multiple locations. It acts as
a post-write mechanism, a file must be written to the file system for it to work.
At this point it is not a replacement for @path or an absolute path, it works in
tandem with them. To use, place @multipath at the start of a line in the root
node or an ancestor of the node. The format is (On Unix systems)::

    @multipath /machine/unit/:/machine/robot/:/machine/

It will place a copy of the written file in each of these directories.

There is an additional directive that simplifies common paths, it is called
@multiprefix. By typing @multiprefix with a path following it, before a
@multipath directive you set the beginning of the paths in the
@multipath directive. For example::

    @multiprefix /leo #@multipath /plugins 

or::

    @multiprefix /leo/
    @multipath plugins: fungus : drain

copies a file to /leo/plugins /leo/fungus /leo/drain.

The @multiprefix stays in effect for the entire tree until reset with
another @multiprefix directive. @multipath is cumulative, in that for
each @multipath in an ancestor a copy of the file is created. These
directives must at the beginning of the line and by themselves.

niceNosent.py
*************

Preprocess @file-nosent nodes: make sure each subnode ends
with exactly one newline, replace all tabs with spaces, and
add a newline before class and functions in the external file.

leoToRTF
********

This plugin takes an outline stored in LEO and outputs it as a numbered list to
an RTF file. The RTF file can be loaded into Microsoft Word and formatted as a
proper outline.

If this plug-in loads properly, you should have an "Outline to Microsoft RTF"
option added to your File > Export... menu in Leo.

Settings such as outputting just the headlines (vs. headlines & body text) and whether
to include or ignore the contents of @file nodes are stored in the rtf_export.ini file
in your Leo\plugins folder.

The default export path is also stored in the INI file. By default, it's set to c:\ so
you may need to modify it depending on your system.

leoToHTML
*********

This plugin takes an outline stored in LEO and converts it to html which is
then either saved in a file or shown in a browser.

The outline can be represented as a bullet list, a numbered list or using html
<h?> type headings. Optionally, the body text may be included in the output.

If desired, only the current node will be included in the output rather than
the entire outline.

An xhtml header may be included in the output, in which case the generated html
will be valid XHTML 1.0 Strict.

The plugin is fully scriptable as all its functionality is available through a
Leo_to_HTML object which can be imported and used in scripts.

Several commands and menu items are provided to give easy access to the plugins
various features and options may be set via leo_to_html.ini file and the plugins
properties dialog.

leoOPML
*******

This plugin reads and writes Leo outlines in .opml (http://en.wikipedia.org/wiki/OPML) format.

The OPML plugin creates two new commands that read and write Leo outlines in OPML format.
The read-opml-file command creates a Leo outline from an .opml file.
The write-opml-file command writes the present Leo outline to an .opml file.

Various settings control what gets written to .opml files, and in what format.
As usual, you specify settings for the OPML plugin using leoSettings.leo.
The settings for the OPML are found in the node: @settings-->Plugins-->opml plugin

Here are the settings that control the format of .opml files. The default values are shown.

- @string opml_namespace = leo:com:leo-opml-version-1

  The namespace urn for the xmlns attribute of <opml> elements.
  This value typically is not used, but it should refer to Leo in some way.

- @bool opml_use_outline_elements = True

  If True, Leo writes body text to <:body> elements nested in <outline> elements.
  Otherwise, Leo writes body text to :body attributes of <outline> elements.

- @string opml_version = 2.0

  The opml version string written to the <OPML> element.
  Use 2.0 unless there is a specific reason to use 1.0.

- @bool opml_write_body_text = True

  Leo writes body text to the OPML file only if this is True.

- @bool opml_write_leo_details = True

  If True, Leo writes the native attributes of Leo's <v> elements as attributes of
  the opml <outline> elements. The native attributes of <v> elements are a,
  descendentTnodeUnknownAttributes, expanded, marks, t, and tnodeList.

- @bool opml_write_leo_globals_attributes = True

  If True, Leo writes body_outline_ratio` and global_window_position attributes to
  the <head> element of the .opml file.

Guis
++++



__wx_alt_gui.py
***************

This plugin allows wxPython to be used as leo's gui instead of TK.

It is a prototype under development and so does not have all the features of Tk
leo nor are there many plugins compatible with it yet.

It is mainly being developed for Linux at the moment, but attempts are being
made to keep it working on Windows as well.

Work on this project has now halted in favor of a gtkLeo plugin.

Icon and status areas
+++++++++++++++++++++



chapter_hoist.py
****************

This plugin puts two buttons in the icon area.
The 'Save Hoist' button hoists the presently selected node and creates a button
which can later rehoist the same node.
The 'Dehoist' button performs one level of dehoisting.

This plugin replaces the old chapters plugin.

nav_buttons.py
**************

Adds navigation buttons to icon bar. Tk only.

nav_qt.py
*********

Qt version of nav_buttons.py (history navigation)

newButtons.py
*************

Automatically add nodes for common tasks.

hoist.py
********

Add Hoist/De-Hoist buttons to the toolbar.

nodenavigator.py
****************

Adds "Recent" and "Marks" pulldown buttons to the toolbar.

searchbox.py
************

Adds a quick search to Leo's toolbar, along with a "GO" button to do quick
searches right from the main Leo window. All the current search options are
retained except that "search body text" is explicitly set - mainly because this
is by far the most common use case. Pressing <CR> while editing the text
automatically does a search. Repeated searches can be done by clicking the "GO"
button. The combo box also stores a list of previous searches, which can be
selected to quickly repeat a search. When activating a previous search the
original search mode is used.

shortcut_button.py
******************

Creates a 'Shortcut' button in the icon area.
Pressing the Shortcut button creates *another* button which when pressed will
select the presently selected node at the time the button was created.

toolbar.py
**********

A plugin that enhances Leo's iconBar and script buttons.


This plugin provides:

    multiple iconBars each of which automatically collapse and
    expand so that all the buttons are always visible.

    drag and drop of buttons within and between iconBars.

    enhancements to Leo's buttons and @button settings to allow
    icons, menus, tooltips and text and background colors to be set
    in @button settings and scripts. 


see test/testToolbar.leo for demo's and howto's
see test/testAtPopup.leo for examples of enhanced buttons

UNL.py
******

This plugin supports Uniform Node Locators (UNL's). UNL's specify nodes within
Leo files. UNL's are not limited to nodes within the present Leo file; you can
use them to create cross-Leo-file links. This plugin consists of two parts:

1) Selecting a node shows the UNL in the status line at the bottom of the Leo
   window. You can copy from the status line and paste it into headlines, emails,
   whatever. 

2) Double-clicking @url nodes containing UNL's select the node specified in the
   UNL. If the UNL species in another Leo file, the other file will be opened.

UNL's referring to nodes within the present outline have the form::

    headline1-->headline2-->...-->headlineN

where headline1 is the headline of a top-level node, and each successive headline is
the headline of a child node.  UNL's of the form::

    file:<path>#headline1-->...-->headlineN

refer to a node specified in <path> For example, double clicking the following
headline will take you to Chapter 8 of Leo's Users Guide::

    @url file:c:/prog/leoCvs/leo/doc/leoDocs.leo#Users Guide-->Chapter 8: Customizing Leo

For example, suppose you want to email someone with comments about a Leo file.
Create a comments.leo file containing @url UNL nodes. That is, headlines are
@url followed by a UNL. The body text contains your comments about the nodes in
the _other_ Leo file! Send the comments.leo to your friend, who can use the
comments.leo file to quickly navigate to the various nodes you are talking
about. As another example, you can copy UNL's into emails. The recipient can
navigate to the nodes 'by hand' by following the arrows in the UNL.

**Notes**:

- At present, UNL's refer to nodes by their position in the outline. Moving a
  node will break the link.

- Don't refer to nodes that contain UNL's in the headline. Instead, refer to the
  parent or child of such nodes.

- You don't have to replace spaces in URL's or UNL's by '%20'.

quicksearch.py
**************

This plugin adds a fast-to-use search widget, in the style of "Find in files" feature of many editors.

Just load the plugin, activate "Nav" tab, enter search text and press enter.

colorize_headlines.py
*********************

A plugin that manipulates appearance of individual tree widget items.

This plugin is mostly an example of how to change appearance of headlines - as
such, it does a relatively mundane chore of highlighting @thin, @auto, @shadow
nodes in bold.

LeoN
++++

LeoN is Leo over the Network. LeoN is Collaborative Leo. This is an important
project for Leo's long-term development. See leo/doc/LeoN for important research
papers that form the basis of this project.

Menus & translations
++++++++++++++++++++



chinese_menu.py
***************

Translate a few menu items into Simplified Chinese

By Zhang Le <ejoy@xinhuanet.com>

french_fm.py
************

Translate menus to French

pie_menus.py
************

Adds pie menus.  See http://www.piemenus.com/

contextmenu.py
**************

Define various useful actions for context menus (for Qt ui)

Examples are:

- Edit in $EDITOR
- Edit @thin node in $EDITOR (remember to do "refresh" after this!)
- Refresh @thin node from disk (e.g. after editing it in external editor)
- Go to clone

Here's an example on how to implement your own context menu items 
in your plugins::

    def nextclone_rclick(c,p, menu):
        """ Go to next clone """

        # only show the item if you are on a clone
        # this is what makes this "context sensitive"
        if not p.isCloned():
            return    

        def nextclone_rclick_cb():
            c.goToNextClone()

        # 'menu' is a QMenu instance that was created by Leo 
        # in response to right click on tree item

        action = menu.addAction("Go to clone")
        action.connect(action, QtCore.SIGNAL("triggered()"), nextclone_rclick_cb)

And call this in your plugin *once*::

    g.tree_popup_handlers.append(nextclone_rclick)

Nodes
+++++



at_folder.py
************

Synchronizes @folder nodes with folders. If a node is named @folder
path_to_folder, the content (filenames) of the folder and the children of that
node will be sync. Whenever a new file is put there, a new node will appear on
top of the children list (with mark). So that I can put my description (i.e.,
annotation) as the content of that node. In this way, I can find any files much
easier from leo. Moreover, I add another feature to allow you to group files(in
leo) into children of another group. This will help when there are many files in
that folder. You can logically group it in leo (or even clone it to many
groups), while keep every files in a flat/single directory on your computer.

at_produce.py
*************

Executes commands in nodes whose body text starts with @produce.
To use, put in the body text of a node::

    @produce javac -verbose Test.java

To execute, you goto Outline and look at Produce. Choose Execute All Produce or
Execute Tree Produce. The Tree does the current Tree, All does the whole
Outline. Executing will fire javac, or whatever your using. @produce functions
as a directive. After executing, a log file/node is created at the top of the
Outline. Any output, even error messages, should be there. It executes in a
hierarchal manner. Nodes that come before that contain @produce go first. I'm
hoping that this orthogonal to @run nodes and anything like that. Its not
intended as a replacement for make or Ant, but as a simple substitute when that
machinery is overkill. **Warning**: trying to execute a non-existent command
will hang Leo.

at_view.py
**********

A plugin that supports @clip, @view and @strip nodes.

-   Selecting a headline containing @clip appends the contents of the clipboard to
    the end of the body pane.

-   Double clicking the icon box of a node whose headline contains @view <path-to-file>
    places the contents of the file in the body pane.

-   Double clicking the icon box of a node whose headline contains @strip <path-to-file>
    places the contents of the file in the body pane, with all sentinels removed.

This plugin also accumulates the effect of all @path nodes.

autotrees.py
************

The AutoTrees plugin is a helper plugin designed to make it very easy to write
"handler" plugins to manage dynamic content in Leo outlines. AutoTrees provides:

- Convenient handler base classes which can be specialized for particular uses.
- A manager to turn handlers on and off.
- A set of example handlers to show the kinds of things that are possible.

AutoTrees doesn't do anything that you cannot do in other ways, but it does
provide a consistent way of adding dynamic content. This means that individual
plugin writers don't have to rewrite all the same kinds of code each time and
also makes it easier to maintain Leo, since it standardizes the way that certain
classes of plugin interact with the Leo core. Why use this? I'm a plugin writer
and I want to write a plugin to display dynamic content, i.e., content not
directly contained in the .leo or external files, e.g.,

- email messages 
- news feeds
- news groups
- documentation
- remote files
- statistics
- file system data
- data base records

You can do this as a standard plugin, but as an AutoTrees handler you,

- don't need to write code that interacts with the tree (this is done for you)
- get centralized management
- can still do everything else you could as a normal plugin

base64Packager.py
*****************

This plugin allows the user to import binary data and store it in Leo as a
base64 string. This plugin adds Import base64 and Export base64 commands
to the Import menu and adds the 'View base64' command to the outline menu. The
Import base64 command creates a new node with the headline::

    @base64 <filename>

The body of this node will kill the colorizer, add some info on the original
file and create a section reference to the payload node, which contains the
data. The Export base64 command asks for a location to place the file. The
plugin checks that the structure of the base64 node is what it expected,
basically what an import operation creates. If Ok, it will write the file to the
selected directory. The View base64 command brings up a Pmw Dialog that displays
the data as a PhotoImage. This currently only supports formats recognized by the
PhotoImage class. This would be the .gif format. This functionality may be
enhanced in the future by PIL to support more image types. Depending on the size
of the image, you may have to scroll around to see it. For example, a leo clone
icon will require scrolling to find. Id like to change this in the future.

fastGotoNode.py
***************

A Leo plugin that adds quick utility commands through a pop-up menu.
To summon Menu, type control-space.
To unsummon, Right Click.

1. Movement. If a node has ancestors,siblings or children a menu option will
appear offering the user the ability to jump to the node from the current node.
This is an improvement over moving one node at a time with the keyboard
commands.

2. Inserting text. These menus offer the current language keywords, the
directives the body recognizes and any @file type headline directives. It offers
the new user easy access to the different directives and ways to write a file.

3. Moving Nodes(experimental). You can quickly move a node to its
parent's parent or after a sibling, if they exist.

mod_labels.py
*************

This plugin allows you to associate information with nodes. This information is
organized around "labels", which is are just strings and freely chosen by the
user. The plugin allows you to create such a label quickly for each marked node,
and to mark all nodes which have a certain label. Labels can be converted to
subnodes, and vice versa. This facility allows you to add additional information
for each label. You can create clones for each node which has a label. These
clones are created as children of the current node. This last facility can be
used to create clones for each node which has been found or changed by the
standard search/replace dialog:

- Delete all marks.
- Do a "find all" / "change all".
- Convert the marks to a label.
- Run the "Clone label subnodes" command.

Finally, if you read a external file, and the content of a node changes, the
previous content is available under the label "before change:"

quickmove.py
************

Create buttons to quickly move nodes to other nodes

Quickly move nodes from around the tree to one or more target nodes.

Adds 'Move/Clone/Copy To Last Child Button' and 'Move/Clone/Copy To First Child
Button' commands to the Move submenu on the Outline menu, and the context menu,
if contextmenu.py is enabled.

Select a node 'Foo' and then use the 'To Last Child Button' command. The adds a
'to Foo' button to the button bar. Now select another node and click the 'to
Foo' button. The selected node will be moved or cloned to the last child of the
node 'Foo'.

'To First Child Button' works the same way, except that moved nodes are inserted
as the first child of the target node.

read_only_nodes.py
******************

A plugin to create and update @read-only nodes. I wanted to have the ability to
import files in "read-only" mode, that is, in a mode where files could only be
read by leo (not tangled), and also kept in sync with the content on the drive.
The reason for this is for example that I have external programs that generate
resource files. I want these files to be part of a leo outline, but I don't want
leo to tangle or in any way modify them. At the same time, I want them to be
up-to-date in the leo outline. This plugin has the following characteristics:

- It reads the specified file and puts it into the node content.

- If the @read-only directive was in the leo outline already, and the file content
  on disk has changed from what is stored in the outline, it marks the node as
  changed and prints a "changed" message to the log window; if, on the other hand,
  the file content has *not* changed, the file is simply read and the node is
  not marked as changed.

- When you write a @read-only directive, the file content is added to the node
  immediately, i.e. as soon as you press Enter (no need to call a menu
  entry to import the content).

- If you want to refresh/update the content of the file, just edit the headline
  and press Enter. The file is reloaded, and if in the meantime it has changed,
  a "change" message is sent to the log window.

- The body text of a @read-only file cannot be modified in leo.

The syntax to access files in @read-only via ftp/http is the following::

    @read-only http://www.ietf.org/rfc/rfc0791.txt
    @read-only ftp://ftp.someserver.org/filepath

If FTP authentication (username/password) is required, it can be specified as follows::

    @read-only ftp://username:password@ftp.someserver.org/filepath

run_nodes.py
************

Runs a program and interface Leo through its input/output/error streams.
Double clicking the icon box whose headlines are @run 'cmd args' will execute
the command. There are several other features, including @arg and @input nodes.

The run_nodes.py plugin introduce two new nodes that transform leo into a
terminal. It was mostly intended to run compilers and debuggers while having the
possibility to send messages to the program.

- Double clicking on the icon of an node whose headline is::

    @run <command> <args>

will launch <command> with the given arguments. It will also mark the node. #
Terminates the argument list. @run # <comment> is also valid.

- @in nodes are used to send input to the running process. Double clicking
  on the icon of an @in <message> node will append a "\n" to <message> and
  write it to the program, no matter where the node is placed. If no @run node is
  active, nothing happens.

- The body text of every child, in which the headlines do not begin with @run
  or @in, will be appended to <command>, allowing you to add an infinite number
  of arguments to <command>.

- The output of the program is written in the log pane (Error outputted in red).
  When the program exit the node is set unmarked and the return value is
  displayed...When the enter key is pressed in the body pane of an active @run
  node the content of it body pane is written to the program and then emptied
  ready for another line of input. If the node have @run nodes in its descendants,
  they will be launched successively (unless one returned an exit code other
  than 0, then it will stop there).

slideshow.py
************

This plugin supports slideshows in Leo outlines.

It defines four new commands:

- next-slide-show:  move to the start of the next slide show,
  or the first slide show if no slide show has been seen yet.

- prev-slide-show:  move to the start of the previous slide show,
  or the first slide show if no slide show has been seen yet.

- next-slide: move to the next slide of a present slide show.

- prev-slide: move to the previous slide of the present slide show.

Slides shows consist of a root @slideshow node with descendant @slide nodes.
@slide nodes may be organized via non-@slide nodes that do not appear in the slideshow.

All these commands ignore @ignore trees.

startfile.py
************

Launches (starts) a file given by a headline when double-clicking the icon.
Ignores headlines starting with an '@'. Uses the @folder path if the headline
is under an @folder headline. Otherwise the path is relative to the Leo file.

Plugins manager & menu
++++++++++++++++++++++



leoupdate.py
************

A plugin to automatically update Leo from the current CVS version
of the code stored on the SourceForge site. You can view individual
files and update your entire Leo installation directly without needing
a CVS client.

plugin_manager.py
*****************

A plugin to manage Leo's Plugins:

- Enables and disables plugins.
- Shows plugin details.
- Checks for conflicting hook handlers.
- Checks for and updates plugins from the web.

plugins_menu.py
***************

Create a Plugins menu and adds an item to the plugin menu for each active
plugin. Selecting this menu item will bring up a short About dialog with the
details of the plugin. Plugins can create additional menu items by defining
functions named cmd_XZY. These will appear in a submenu. If the plugin
requires an INI file then a configure menu item will be created which will show
an INI file editor. The plugin can define an applyConfiguration function,
which will be called when the configuration changes. Plugins can also define a
top level function to be called instead of the default "About" dialog by
defining a "topLevelMenu" function in the plugin. This function will be called
when the user clicks on the plugin name in the plugins menu, but only if the
plugin was loaded properly and registered with g.plugin_signon.

Plugins can define their name by setting the __plugin_name__ property.
Plugins can also attempt to select the order they will appear in the menu by
defining a __plugin_prioriy__. The menu will be created with the highest
priority items first. This behavior is not guaranteed since other plugins can
define any priority. This priority does not affect the order of calling
handlers. To change the order select a number outside the range 0-200 since this
range is used internally for sorting alphabetically.

Scripting
+++++++++



dyna_menu
*********

The dyna_menu plugin is a remarkable body of work by 'e'.
This plugin creates a dyna_menu menu from which you can execute commands.
You may download the latest version at: http://rclick.netfirms.com/dyna_menu.py.html

mod_scripting
*************

A plugin to create script buttons and @button, @plugin and @script nodes.
This plugin puts two buttons in the icon area: a button called run Script and
a button called script Button. The run Script button is simply another way
of doing the Execute Script command: it executes the selected text of the
presently selected node, or the entire text if no text is selected. The 'script
Button' button creates another button in the icon area every time you push it.
The name of the button is the headline of the presently selected node. Hitting
this _new_ button executes the button's script.

For example, to run a script on any part of an outline do the following:

1.  Select the node containing the script.
2.  Press the scriptButton button.  This will create a new button, call it X.
3.  Select the node on which you want to run the script.
4.  Push button X.

That's all.  You can delete a script button by right-clicking on it.
This plugin optionally scans for @button nodes, @plugin nodes and @script nodes
whenever a .leo file is opened.

- @button nodes create script buttons.
- @plugin nodes cause plugins to be loaded.
- @script nodes cause a script to be executed when opening a .leo file.

Such nodes may be security risks. This plugin scans for such nodes only if the
corresponding atButtonNodes, atPluginNodes, and atScriptNodes constants are set
to True in this plugin.

Servers
+++++++



mod_http.py
***********

A minimal http plugin for LEO, based on AsyncHttpServer.py.
Use this plugin is as follows:

1. Start Leo with the plugin enabled.  You will see a purple message that says something like::

    http serving enabled on port 8080, version 0.91

2. Start a web browser, and enter the following url: http://localhost:8080/ You
   will see a a "top" level page containing one link for every open .leo
   file.  Start clicking :-)

You can use the browser's refresh button to update the top-level view in the browser after you have opened or closed files.

To enable this plugin put this into your file::

    @settings
        @bool http_active = True
        @int  port = 8080
        @string rst_http_attributename = 'rst_http_attribute'

Spell checking
++++++++++++++



spellpyx.py
***********

aspell.pyx: Leo's new spell checking plugin that uses aspell.exe. It is much
faster than the old mod_spelling plugin, but requires Python 2.3 or above and a
recent version of Aspell. When properly installed and enabled, this plugin adds
a Check Spelling command to Leo's Edit menu. This command brings up a spell
checking dialog. You can set options by changing entries in spellpyx.ini in
Leo's plugins menu. One of these settings is the name of the dictionary,
spellpyx.txt by default. **Warning**: do not create spellpyx.txt with an @asis
tree in leoPlugins.leo: only the plugin code should typically change
spellpyx.txt. You **can** edit spellpyx.txt yourself in an external editor: just
make sure that Leo isn't running when you do this. You can bring up the spell
checker without enabling the spellpyx plugin by using an @button Check
Spelling... script button. LeoDocs.leo contains such a script button.

Text formatting
+++++++++++++++



Leo to AsciiDoc
***************

Leo2AsciiDoc is a small Python program which has been built to be used as a
plugin module for the Leo outlining editor.
For more information see:  http://www.marshallresearch.com/michael-dawson/os/leo.html
I am still using Leo version 4.1 (rc3, build 1.62), as I've been unable to keep
up with the speed of Edward's Leo development. He has made such significant
changes to Leo since 4.1 that I doubt that Leo2AsciiDoc will work with any
version later than 4.1. I do intend to rewrite Leo2AsciiDoc for the new Leo, but
there is no schedule set. 

Leo2AscDoc enables the contents of plain text Leo outlines to be published to HTML
or PDF via the AsciiDoc program and the DocBook set of publishing tools. Plain
text from the Leo outline can be transformed into a final result that has
typeset body text, in which bulleted and numbered lists, variable lists, page
numbers, URLs, index terms,and bold and italic text are automatically
recognized. typeset Headings a Table of Contents an Index containing any items
marked by the user, and any Python classes or functions. To produce HTML and
PDF, you'll need to have the AsciiDoc program installed (a trivial task) and a
DocBook tool chain installed, which is not a trivial task. And, of course,
Python and Leo. In sum, this little program is an easy install for people who
are already using Leo and DocBook. As noted later, Leo2AsciiDoc has only been
tested on Linux

rst3.py
*******

The rst3 plugin creates output files from Leo outlines containing rST
(reStructuredText_) markup. rst3 options control most aspects of this plugin's
operations. You can set options in @settings trees, in headlines and in body
text. There are too many options to describe here. See:
http://webpages.charter.net/edreamleo/rstplugin3.html for full documentation. To
use this plugin effectively, Python's docutils_ module must be installed. The
rst3 plugin will use the SilverCity_ syntax coloring package if it installed.

The rst3 plugin adds the Write Restructured Text command to Leo's Edit menu.
This command searches the selected outline looking for **rst root nodes** whose
headline have the form::

    @rst <filename>

The plugin then creates the named file in various ways depending which rst3
options are in effect. By default, the rst3 plugin creates rST headings
automatically from outlines, so the higher-level nodes in the outline correspond
to higher-level sections in the output. Creating rST headings automatically
eliminates one of the most tedious chores associated with rST markup.
This plugin sends .htm, .html or .tex files to the docutils module for further
processing. Docutils generates HTML files or LaTeX files depending on the file's
extension. HTML files generated by docutils refer to three .css (cascading style
sheet) files that should exist in the same directory as the generated HTML file.
You can control the formatting of the HTML file by altering these .css files.

For full details on this plugin, see http://webpages.charter.net/edreamleo/rstplugin3.html

A new method has been added to the rst3 plugin to make it more easily to drive
the plugin from scripts::

    def writeNodeToString (self,p=None,ext=None)

writeNodeToString scans p's tree (p defaults to presently selected node) looking for @rst nodes.
When the first @rst node is found, writeNodeToString processes the node as usual, with the following changes:

- @rst need not be followed by a filename; any filename and its extension are *ignored*.

- Only the ext argument to writeNodeToString determines the type of output produced.
  The valid values for the ext argument are None (for rst output), '.html', '.pdf', and '.tex'.

- Instead of writing the result to a file, writeNodeToString returns the tuple (p,s),
  where p is the node whose tree produced the output, and s is the output itself.

- writeNodeToString returns after processing at most one @rst node.

Scripts can easily use writeNodeToString to convert @rst trees into various kinds of output.
For example, here is the body of @button rst->html in LeoDocs.leo::

    import leo.core.leoPlugins as leoPlugins
    rst3 = leoPlugins.getPluginModule('rst3')
    if rst3:
        controller = rst3.controllers.get(c)
        if controller:
            p,s = controller.writeNodeToString(ext='.html')
            print '*' * 40,p
            print s

Notes:

- This script scans the presently selected tree for @rst nodes, just like the @button rst script does.
  In particular, if the presently selected tree does not contain an @rst node the search continues in parent trees.
  When an @rst node is found, it converts the node (and descendants) to html and returns p,
  the found @rst node and s, the html itself.

- The script shown above merely prints the output, but many other actions could be taken.
  In particular, because writeNodeToString returns p it would be possible to write a script that
  would scan multiple @rst nodes.

- None and '.tex' are also valid values for the ext argument to writeNodeToString.
  None converts the @rst tree to a single reStructuredText string, as shown in @button rst->rst.

- There is some support for ext='.pdf', but this is experimental code.  Expect crashes.

xsltWithNodes.py
****************

Adds XSLT-Node Command submenu item to the Outline menu.
This menu contains the following items:

Set StyleSheet Node
    Selects the current node as the xsl stylesheet the plugin will use.

Process Node with Stylesheet Node
    Processes the current node as an xml document,
    resolving section references and Leo directives,
    and creates a sibling containing the results.

Requires 4Suite 1.0a3 or better, downloadable from http://4Suite.org.

Windows
+++++++



cleo.py
*******

Cleo allows you to annotate or colour leo outlines based on priority, code
archetype, node types or some arbitrary criteria. The annotations and colour
coding can play a similar role like that of syntax highlighting. Right-click on
the icon area to popup its menu to play with it.

footprints.py
*************

A plugin to leave footprints! This colors the Leo nodes so that the ones you
have visited most and most recently will stand out.

EditAttributes.py
*****************

A plugin that lets the user to associate text with a specific node.
Summon it by pressing button-2 or button-3 on an icon Box in the outline. This
will create an attribute editor where the user can add, remove and edit
attributes. Since attributes use the underlying tnode, clones will share the
attributes of one another.

maximizeNewWindows.py
*********************

Maximizes all new windows.

nodebar.py
**********

The nodebar plugin adds buttons at the bottom of the tree canvas. The buttons
correspond to commands found in the Outline commands. It is intended to speed up
a new users ability to use the outline. Experienced users may find value in
being able to quickly execute commands they do not use very often.

redirect_to_log.py
******************

Send all output to the log pane.

TabbedLog.py
************

Turns the log into a tabbed component.  Other plugins may add tabs.
To get a new tab in TabbedLog::

    import TabbedLog
    pane = TabbedLog.getPane(name,c)

- pane is the pane returned for you to work with.
- name is the name of the tab you want for the pane.
- c is the commander for the leoFrame.

UASearch.py
***********

A plugin for searching unknownAttributes (uA's).

UniversalScrolling.py
*********************

A plugin that enables the user to scroll down with a left mouse click and hold,
and to scroll up with a right mouse click and hold. Scrolling continues until
the user releases the mouse. Originally designed as a workaround for various
bugs in Tkinter scrolling, this may actually be superior to wheel scrolling, in
that there is little work a user has to do to scroll except to press a button.

URLloader.py
************

This plugin uses Python's urllib module to download files and import them into Leo.
It requires the TabbedLog plugin.

