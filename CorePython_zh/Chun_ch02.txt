Getting
Started 
快速入门



Chapter Topics
 本章主题
?       Introduction
?       引言
?       Input/Output
?       输入/输出
?       Comments
?       注释
?       Operators
?       运算符
?       Variables and Assignment
?       变量与赋值
?       Python Types
?       Python 数据类型
?       Indentation
?       缩进
?       Loops and Conditionals
?       循环与条件
?       Files
?       文件
?       Errors
?       错误
?       Functions
?       函数
?       Classes
?       类
?       Modules
?       模块

        2


his “quick start” section is intended to “flash” Python to you so that
any  constructs  recognized  from  previous  programming  experience can be used for your immediate needs. The details will be spelled out in succeeding chapters, but a high-level tour is one fast and easy way to get you into Python and show you what it has to offer. The best way to follow along is to bring up the Python interpreter in front of you and try some of these examples, and at the same time you can experiment on your own.
本章将对Python的主要特性做一个快速介绍，这样你就可以借助以前的编程经验识别出熟悉的语言结构，并立刻将Python付诸使用。虽然细节内容会在后续的章节中逐一讲解，但是对整体的了解可以让你迅速融入到Python中。阅读本章的最好的方法就是在你的电脑上打开Python解释器，尝试书中的示例， 当然你也可以随心所欲的自己做实验。

We introduced how to start up the Python interpreter in Chapter 1 as well
as in the exercises (Problems 1C4). In all interactive examples, you will see the
Python primary ( >>> ) and secondary ( ... ) prompts. The primary prompt
is a way for the interpreter to let you know that it is expecting the next Python
statement, while the secondary prompt indicates that the interpreter is waiting for additional input to complete the current statement.
  我们已经在第一章和练习1C4中介绍了如何启动Python解释器。在所有的交互示例中，你会看到Python的主提示符( >>> )和次提示符( ... )。主提示符是解释器告诉你它在等待你输入下一个语句，次提示符告诉你解释器正在等待你输入当前语句的其它部分。

You will notice two primary ways that Python “does things” for you: statements and expressions (functions, equations, etc.). Most of you already know the difference between the two, but in case you need to review, a statement is a body of control which involves using keywords. It is similar to issuing a command to the interpreter. You ask Python to do something for you, and it will do it. Statements may or may not lead to a result or output. Let us use the print statement for the programmer’s perennial first example, Hello World:

Python有两种主要的方式来完成你的要求：语句和表达式（函数、算术表达式等）。相信大部分读者已经了解二者的不同，但是不管怎样，我们还是再来复习一下。语句使用关键字来组成命令，类似告诉解释器一个命令。你告诉Python做什么，它就为你做什么，语句可以有输出，也可以没有输出。下面我们先用print语句完成程序员们老生常谈第一个编程实例，Hello World:

>>> print 'Hello World!' Hello World!

Expressions, on the other hand, do not use keywords. They can be simple equations  that  you  use  with  mathematical  operators,  or  can  be  functions which are called with parentheses. They may or may not take input, and they may or may not return a (meaningful) value. (Functions that do not explicitly return a value by the programmer automatically return None, Python’s equivalent to NULL.) An example of a function that takes input and has a return value is the abs() function, which takes a number and returns its absolute value is:
而表达式没有关键字。它们可以是使用数学运算符构成的算术表达式，也可以是使用括号调用的函数。它们可以接受用户输入，也可以不接受用户输入，有些会有输出，有些则没有。（在Python中未指定返回值的函数会自动返回None，等价于NULL）下面举一个例子，函数abs()接受一个数值输入，然后输出这个数值的绝对值：

>>> abs(-4)
4
>>> abs(4)
4

We will introduce both statements and expressions in this chapter. Let us continue with more about the print statement.
本章中我们将分别介绍语句和表达式。我们先来研究 print 语句。


2.1  Program Output, the print Statement, and “Hello World!”
程序输出，print语句及“Hello World!”

In some languages, such as C, displaying to the screen is accomplished with a function, e.g., printf(), while with Python and most interpreted and scripting  languages,  it  is  a  statement.  Many  shell  script  languages  use  an  echo command for program output.
有些语言， 比如 C, 通过函数输出数据到屏幕，例如函数printf()。然而在Python和大多数解释执行的脚本语言，使用语句进行输出。很多的shell脚本语言使用echo命令来输出程序结果。

CORE NOTE: Dumping variable contents in interactive interpreter
核心笔记：在交互式解释器中显示变量的值

Usually when you want to see the contents of a variable, you use the print statement in your code. However, from within the interactive interpreter, you can use the print statement to give you the string representation of a variable, or just dump the variable raw―this is accomplished by simply giving the name of the variable.
In the following example, we assign a string variable, then use print to display its contents. Following that, we issue just the variable name.
通常当你想看变量内容时，你会在代码中使用print语句输出。不过在交互式解释器中，你可以用 print 语句显示变量的字符串表示，或者仅使用变量名查看该变量的原始值。
    在下面的例子中，我们把一个字符串赋值给变量myString，先用print 来显示变量的内容，之后用变量名称来显示。

>>> myString = 'Hello World!'
>>> print myString
Hello World!
>>> myString
'Hello World!'

Notice how just giving only the name reveals quotation marks around the string. The reason for this is to allow objects other than strings to be displayed in the same manner as this string―being able to display
a printable string representation of any object, not just strings.The quotes are there to indicate that the object whose value you just dumped to the display
is a string. Once you become more familiar with Python, you will recognize that str() is used for print statements, while repr() is what the interactive interpreter calls to display your objects.
注意：在仅用变量名时，输出的字符串是被用单引号括起来了的。这是为了让非字符串对象也能以字符串的方式显示在屏幕上－－即它显示的是该对象的字符串表示，而不仅仅是字符串本身。引号表示你刚刚输入的变量的值是一个字符串。等你对Python有了较深入的了解之后，你就知道print语句调用str()函数显示对象，而交互式解释器则调用repr()函数来显示对象。

2.2     Program Input and the raw_input()Built-in Function      
程序输入和raw_input()内建函数

The underscore (_) also has special meaning in the interactive interpreter: the last evaluated expression. So after the code above has executed, _ will contain the string:
下划线(_)在解释器中有特别的含义，表示最后一个表达式的值。所以上面的代码执行之后，下划线变量会包含字符串：

>>> _
Hello World!

Python’s  print statement,  paired  with  the  string  format  operator  (  % ), supports string substitution, much like the printf() function in C:
Python的print语句，与字符串格式运算符(  % )结合使用，可实现字符串替换功能，这一点和 C 语言中的printf()函数非常相似：

>>> print "%s is number %d!" % ("Python", 1) Python is number 1!

%s means to substitute a string while %d indicates an integer should be substituted. Another popular one is %f for floating point numbers. We will see more examples throughout this chapter. Python is fairly flexible, though, so you could pass in a number to %s without suffering any consequences with more rigid languages. See Section 6.4.1 for more information on the string format operator.
The print statement also allows its output directed to a file. This feature was added way back in Python 2.0. The >> symbols are used to redirect the output, as in this example with standard error:
%s表示由一个字符串来替换，而%d表示由一个整数来替换，另外一个很常用的就是%f， 它表示由一个浮点数来替换。我们会在本章中看到更多类似的例子。Python非常灵活，所以即使你将数字传递给 %s，也不会像其他要求严格的语言一样引发严重后果。参阅章节6.4.1以了解更多关于字符串格式运算符的信息。Print语句也支持将输出重定向到文件。这个特性是从Python2.0开始新增的。符号 >> 用来重定向输出，下面这个例子将输出重定向到标准错误输出：

import sys
print >> sys.stderr, 'Fatal error: invalid input!'
import sys
print >> sys.stderr, 'Fatal error: invalid input!'



Here is the same example with a logfile:
下面是一个将输出重定向到日志文件的例子：

logfile = open('/tmp/mylog.txt', 'a')
print >> logfile, 'Fatal error: invalid input!'
logfile.close()

The  easiest  way  to  obtain  user  input  from  the  command  line  is  with  the raw_input() built-in function. It reads from standard input and assigns the string  value  to  the  variable  you  designate.  You  can  use  the  int() built-in function to convert any numeric input string to an integer representation.
从用户那里得到数据输入的最容易的方法是使用raw_input()内建函数。 它读取标准输入， 并将读取到的数据赋值给指定的变量。 你可以使用 int() 内建函数将用户输入的字符串转换为整数。


>>> user = raw_input('Enter login name: ') Enter login name: root
>>> print 'Your login is:', user
Your login is: root

The  earlier  example  was  strictly  for  text  input.  A  numeric  string  input (with conversion to a real integer) example follows below:
上面这个例子只能用于文本输入。 下面是输入一个数值字符串(并将字符串转换为整数）的例子：

>>> num = raw_input('Now enter a number: ') Now enter a number: 1024
>>> print 'Doubling your number: %d' % (int(num) * 2) Doubling your number: 2048


The int() function converts the string num to an integer so that the mathematical operation can be performed. See Section 6.5.3 for more information
in the raw_input() built-in function.
内建函数int()将数值字符串转换成整数值，这样才可以对它进行数学运算。参阅章节6.5.3以了解更多有关内建函数raw_input()的知识。

CORE NOTE: Ask for help in the interactive interpreter
核心笔记：从交互式解释器中获得帮助

If you are learning Python and need help on a new function you are not familiar with, it is easy to get that help just by calling the help() built-in function and passing in the name of the function you want help with:
在学习 Python 的过程中，如果需要得到一个生疏函数的帮助，只需要对它调用内建函数help()。通过用函数名作为 help()的参数就能得到相应的帮助信息：
>>> help(raw_input)

Help on built-in function raw_input in module __builtin__:
 
raw_input(...)
raw_input([prompt]) -> string

Read a string from standard input. The trailing newline is stripped. If the user hits EOF (Unix: Ctl-D, Windows: Ctl-Z+Return), raise EOFError. On Unix, GNU readline is used if enabled. The prompt string,
if given, is printed without a trailing newline before reading.'
从标准输入读取一个字符串并自动删除串尾的换行字符。 如果用入键入了 EOF 字符（Unix: Ctrl+D, Windows: Ctrl+Z+回车）， 则引发 EOFError, 在Unix平台， 只要可用，就使用GNU readline库。如果提供提示字符串参数， 则显示该字符串并自动删去字符串末尾的换行字符。
（上面一行是help（raw_input）的输出，译文是对其加以解释――译者注）
CORE STYLE: Keep user interaction outside of functions
核心风格： 一直在函数外做用户交互操作

           It’s very tempting for beginners to put print statements and raw_input() functions wherever they need to display information to or get information from a user. However, we would like to suggest that functions should be kept “clean,” meaning they should silently be used purely to take parameters and provide return values. Get all the values needed from the user, send them all to the function, retrieve the return value, and then display the results to the user. This will enable you to use the same function elsewhere without having to worry about customized output.The exception to this rule is if you create functions specifically to obtain input from the user or display output. More importantly, it is good practice to separate functions into two categories: those that do things (i.e. , interact with the user or set variables) and those that calculate things (usually returning results). It is surely not bad practice to put a print statement in a function if that was its purpose.

新手在需要显示信息或得到用户输入时， 很容易想到使用 print 语句和raw_input()内建函数。不过我们在此建议函数应该保持其清晰性， 也就是它只应该接受参数，返回结果。从用户那里得到需要的数据， 然后调用函数处理， 从函数得到返回值，然后显示结果给用户。 这样你就能够在其它地方也可以使用你的函数而不必担心自定义输出的问题。这个规则的一个例外是，如果函数的基本功能就是为了得到用户输出， 或者就是为了输出信息，这时在函数体使用 print 语句或 raw_input() 也未尝不可。更重要的， 将函数分为两大类， 一类只做事， 不需要返回值（比如与用户交互或设置变量的值）， 另一类则执行一些运算，最后返回结果。如果输出就是函数的目的，那么在函数体内使用 print 语句也是可以接受的选择。

2.3     Comments
注释

As with most scripting and Unix-shell languages, the hash or pound ( # ) sign signals that a comment begins from the # and continues until the end of the line.
和大部分脚本及Unix-shell语言一样，Python也使用 # 符号标示注释，从 # 开始，直到一行结束的内容都是注释。 

>>> # one comment
... print 'Hello World!'        # another comment
Hello World!

There  are  special  comments  called  documentation  strings,  or  “doc strings” for short. You can add a “comment” at the beginning of a module, class, or function string that serves as a doc string, a feature familiar to Java programmers:
有一种叫做文档字符串的特别注释。你可以在模块、类或者函数的起始添加一个字符串，起到在线文档的功能，这是Java程序员非常熟悉的一个特性。

def foo():
"This is a doc string."
return True


Unlike regular comments, however, doc strings can be accessed at runtime and be used to automatically generate documentation.
与普通注释不同，文档字符串可以在运行时访问，也可以用来自动生成文档。

2.4     Operators 
运算符

The standard mathematical operators that you are familiar with work the same way in Python as in most other languages.
和其他绝大多数的语言一样，Python中的标准算术运算符以你熟悉的方式工作

+       -       *       /       //      %       **

Addition,  subtraction,  multiplication,  division,  and  modulus  (remainder) are all part of the standard set of operators. Python has two division operators, a single slash character for classic division and a double-slash for “floor” division (rounds down to nearest whole number). Classic division means that if  the  operands  are  both  integers,  it  will  perform  floor  division,  while  for floating point numbers, it represents true division. If true division is enabled, then the division operator will always perform that operation, regardless of operand types. You can read more about classic, true, and floor division in Chapter 5, “Numbers.”
加、减、乘、除和取余都是标准运算符。Python有两种除法运算符，单斜杠用作传统除法，双斜杠用作浮点除法（对结果进行四舍五入）。传统除法是指如果两个操作数都是整数的话，它将执行是地板除(取比商小的最大整数)（关于“地板除”请参考第5章――译者注），而浮点除法是真正的除法，不管操作数是什么类型，浮点除法总是执行真正的除法。你可以在第五章（数字）学到更多有关传统除法、真正的除法及浮点除法的知识。

There is also an exponentiation operator, the double star/asterisk (  ** ). Although  we  are  emphasizing  the  mathematical  nature  of  these  operators, please note that some of these operators are overloaded for use with other data types as well, for example, strings and lists. Let us look at an example:
还有一个乘方运算符， 双星号(**)。尽管我们一直强调这些运算符的算术本质， 但是请注意对于其它数据类型，有些运算符是被重载了，比如字符串和列表。。让我们看一个例子：

>>> print -2 * 4 + 3 ** 2
1
As you can see, the operator precedence is what you expect: + and - are at the bottom, followed by *, /, //, and %; then comes the unary + and -, and finally, we have ** at the top. ((3 ** 2) is calculated first, followed by  (-2 * 4), then both results are summed together.)
就象你看到的， 运算符的优先级和你想象的一样： + 和 － 优先级最低， *, /, //， %优先级较高， 单目运算符 + 和 - 优先级更高， 乘方的优先级最高。(3 ** 2) 首先求值， 然后是 (-2 * 4)， 然后是对两个结果进行求和。

Python also provides the standard comparison operators, which return a Boolean value indicating the truthfulness of the expression:
Python当然也有标准比较运算符， 比较运算根据表达式的值的真假返回布尔值：

<       <=      >       >=      ==      !=      <>

Trying out some of the comparison operators we get:
试一试，看看这些比较运算会得到什么结果：
>>> 2 < 4
True
>>> 2 == 4
False
>>> 2 > 4
False
>>> 6.2 <= 6
False
>>> 6.2 <= 6.2
True
>>> 6.2 <= 6.20001
True
Python currently supports two “not equal” comparison operators, != and <>.  These  are  the  C-style  and  ABC/Pascal-style  notations.  The  latter  is slowly being phased out, so we recommend against its use.
Python目前支持两种“不等于”比较运算符， != 和 <> ， 分别是C风格和ABC/Pascal风格。目前后者慢慢地被淘汰了， 所以我们推荐使用前者。

Python also provides the expression conjunction operators:
Python也提供了逻辑运算符：
and     or      not

We can use these operations to chain together arbitrary expressions and logically combine the Boolean results:
使用逻辑运算符可以将任意表达式连接在一起，并得到一个布尔值：

>>> 2 < 4 and 2 == 4
False
>>> 2 > 4 or 2 < 4
True
>>> not 6.2 <= 6
True
>>> 3 < 4 < 5
True

The last example is an expression that may be invalid in other languages, but in Python it is really a short way of saying:
>>> 3 < 4 and 4 < 5
最后一个例子在其他语言中通常是不合法的，不过Python支持这样的表达式， 既简洁又优美。它实际上是下面表达式的缩写：

>>> 3 < 4 and 4 < 5

You can find out more about Python operators in Section 4.5 of the text.
参阅章节4.5种可以得到更多有关Python运算符的信息。


CORE STYLE: Use parentheses for clarification

Parentheses are a good idea in many cases, such as when the outcome is altered if they are not there, if the code is difficult to read without them, or
in situations that might be confusing without them. They are typically not required in Python, but remember that readability counts. Anyone maintaining
your code will thank you, and you will thank you later.

核心风格： 合理使用括号增强代码的可读性
      ， 在很多场合使用括号都是一个好主意，而没用括号的话，会使程序得到错误结果，或使代码可读性降低，引起阅读者困惑。。括号在Python语言中不是必须存在的， 不过为了可读性， 使用括号总是值得的。任何维护你代码的人会感谢你， 在你再次阅读自己的代码时，你也会感谢你自己。

2.5  Variables and Assignment 
变量和赋值

Rules for variables in Python are the same as they are in most other high level languages inspired by (or more likely, written in) C. They are simply identifier  names  with  an  alphabetic  first  character―“alphabetic”  meaning upper-  or  lowercase  letters,  including  the  underscore  (  _  ).  Any  additional characters  may  be  alphanumeric  or  underscore.  Python  is  case-sensitive, meaning that the identifier “cAsE” is different from “CaSe.”
Python中变量名规则与其它大多数高级语言一样， 都是受C语言影响（或者说这门语言本身就是C语言写成的）。变量名仅仅是一些字母开头的标识符－－所谓字母开头－－意指大写或小写字母，另外还包括下划线( _ ). 其它的字符可以是数字，字母， 或下划线。Python变量名是大小写敏感的， 也就是说变量 "cAsE" 与 "CaSe" 是两个不同的变量。

Python is dynamically typed, meaning that no pre-declaration of a variable
or its type is necessary. The type (and value) are initialized on assignment. Assignments are performed using the equal sign.
Python是动态类型语言， 也就是说不需要预先声明变量的类型。 变量的类型和值在赋值那一刻被初始化。变量赋值通过等号来执行。

>>> counter = 0
>>> miles = 1000.0
>>> name = 'Bob'
>>> counter = counter + 1
>>> kilometers = 1.609 * miles
>>> print '%f miles is the same as %f km' % (miles, kilometers)
1000.000000 miles is the same as 1609.000000 km

We have presented five examples of variable assignment. The first is an integer assignment followed by one each for floating point numbers, one for strings, an increment statement for integers, and finally, a floating point oper- ation and assignment.
上面是五个变量赋值的例子。第一个是整数赋值，第二个是浮点数赋值，第三个是字符串赋值，第四个是对一个整数增1， 最后一个是浮点乘法赋值。

Python also supports augmented assignment, statements that both refer to and assign values to variables. You can take the following expression . . .
Python也支持增量赋值，也就是运算符和等号合并在一起， 看下面的例子:

n = n * 10

. . . and use this shortcut instead:
将上面的例子改成增量赋值方式就是：

n *= 10

Python does not support increment and decrement operators like the ones
in C: n++ or --n. Because + and -- are also unary operators, Python will interpret --n as -(-n) == n, and the same is true for ++n.
Python 不支持C语言中的自增1和自减1运算符， 这是因为 + 和 － 也是单目运算符， Python 会将 --n 解释为-(-n) 从而得到 n , 同样 ++n 的结果也是 n.

2.6  Numbers 数字

Python supports five basic numerical types, three of which are integer types.
Python支持五种基本数字类型，其中有三种是整数类型。
 
?  int (signed integers)
        有符号整数
?   long (long integers)
        长整数
?   bool (Boolean values)
        布尔值
?  float (floating point real numbers)
        浮点值
?  complex (complex numbers) 
        复数
Here are some examples:
下面是一些例子：

int     0101    84      ?237    0x80    017     ?680    ?0X92
0xDECADEDEADBEEFBADFEEDDEAL

-90.    6.022e23        ?1.609E?19
complex   6.23+1.5j     ?1.23-875J      0+1j    9.80665-8.31441J ?.0224+0j

Numeric types of interest are the Python long and complex types. Python long integers should not be confused with C longs. Python longs have a capa- city that surpasses any C long. You are limited only by the amount of (virtual) memory in your system as far as range is concerned. If you are familiar with Java, a Python long is similar to numbers of the BigInteger class type.
Python中有两种有趣的类型是 Python 的长整型和复数类型。请不要将Python 的长整数与C语言的长整数混淆。Python的长整数所能表达的范围远远超过C语言的长整数， 事实上，Python长整数仅受限于用户计算机的虚拟内存总数。如果你熟悉 Java, Python的长整数类似于 Java 中的BigInteger 类型。

Moving forward, ints and longs are in the process of becoming unified into a single integer type. Beginning in version 2.3, overflow errors are no longer reported―the result is automagically converted to a long. In a future version of Python, the distinction will be seamless because the trailing “L” will no longer be used or required.
从长远来看， 整型与长整型正在逐步统一为一种整数类型。从Python2.3开始，再也不会报整型溢出错误， 结果会自动的被转换为长整数。在未来版本的Python中， 两种整数类型将会无缝结合， 长整数后缀 “L”也会变得可有可无。

Boolean values are a special case of integer. Although represented by the con- stants True and False, if put in a numeric context such as addition with other numbers, True is treated as the integer with value 1, and False has a value of 0. Complex numbers (numbers that involve the square root of ?1, so-called “imaginary” numbers) are not supported in many languages and perhaps are implemented only as classes in others.
布尔值是特殊的整数。 尽管布尔值由常量 True 和 False 来表示， 如果将布尔值放到一个数值上下文环境中（比方将 True与一个数字相加）， True 会被当成整数值 1， 而False则会被当成整数值 0。 复数（包括-1的平方根, 即所谓的虚数）在其它语言中通常不被直接支持（一般通过类来实现）。

There is also a sixth numeric type, decimal, for decimal floating numbers, but  it  is  not  a  built-in  type.  You  must  import  the  decimal module  to  use these types of numbers. They were added to Python (version 2.4) because of a need for more accuracy. For example, the number 1.1 cannot be accurately representing  with  binary  floating  point  numbers  (floats)  because  it  has  a repeating fraction in binary. Because of this, numbers like 1.1 look like this as a float:
其实还有第六种数字类型， decimal， 用于十进制浮点数。不过它并不是内建类型， 你必须先导入 decimal 模块才可以使用这种数值类型。 由于需求日渐强烈， Python 2.4增加了这种类型。举例来说， 由于在二进制表示中有一个无限循环片段，数字1.1无法用二进制浮点数精确表示。因此， 数字1.1实际上会被表示成：

>>> 1.1
1.1000000000000001

 
Chun_ch02.fm  Page 39  Wednesday, August 23, 2006  4:43 PM

>>> print decimal.Decimal('1.1')
1.1

All numeric types are covered in Chapter 5.
第五章详细将介绍所有的数字类型

2.7  Strings 字符串

Strings  in  Python  are  identified  as  a  contiguous  set  of  characters  in between quotation marks. Python allows for either pairs of single or double quotes.  Triple  quotes  (three  consecutive  single  or  double  quotes)  can  be used to escape special characters. Subsets of strings can be taken using the index ( [ ] ) and slice ( [ : ] ) operators, which work with indexes starting at 0 in the beginning of the string and working their way from ?1 at the end.
Python中字符串被定义为引号之间的字符集合。Python支持使用成对的单引号或双引号，三引号（三个连续的单引号或者双引号）可以用来包含特殊字符。使用索引运算符( [ ] )和切片运算符( [ : ] )可以得到子字符串。字符串有其特有的索引规则：第一个字符的索引是 0， 最后一个字符的索引是 －1

The plus ( + ) sign is the string concatenation operator, and the asterisk ( * ) is the repetition operator. Here are some examples of strings and string usage:
加号( + )用于字符串连接运算，星号( * )则用于字符串重复。下面是几个例子：

>>> pystr = 'Python'
>>> iscool = 'is cool!'
>>> pystr[0]
'P'
>>> pystr[2:5]
'tho'
>>> iscool[:2]
'is'
>>> iscool[3:]
'cool!'
>>> iscool[-1]
'!'
>>> pystr + iscool
'Pythonis cool!'
>>> pystr + ' ' + iscool
'Python is cool!'
>>> pystr * 2
'PythonPython'
>>> '-' * 20
'--------------------'
>>> pystr = '''python
... is cool'''
>>> pystr
'python\nis cool'
>>> print pystr python
is cool
>>>

You can learn more about strings in Chapter 6.
你可以在第六章学到更多有关字符串的知识。


2.8  Lists and Tuples 
列表和元组

Lists and tuples can be thought of as generic “arrays” with which to hold an arbitrary  number  of  arbitrary  Python  objects.  The  items  are  ordered  and accessed via index offsets, similar to arrays, except that lists and tuples can store different types of objects.
可以将列表和元组当成普通的“数组”，它能保存任意数量任意类型的Python对象。和数组一样，通过从0开始的数字索引访问元素，但是列表和元组可以存储不同类型的对象。

There are a few main differences between lists and tuples. Lists are enclosed in brackets (  [ ] ) and their elements and size can be changed. Tuples are enclosed in parentheses ( ( ) ) and cannot be updated (although their contents may be). Tuples can be thought of for now as “read-only” lists. Subsets can be taken with the slice operator ( [] and [ : ] ) in the same manner as strings.
列表和元组有几处重要的区别。列表元素用中括号( [ ])包裹，元素的个数及元素的值可以改变。元组元素用小括号(( ))包裹，不可以更改（尽管他们的内容可以）。元组可以看成是只读的列表。通过切片运算( [ ] 和 [ : ] )可以得到子集，这一点与字符串的使用方法一样。

>>> aList = [1, 2, 3, 4]
>>> aList
[1, 2, 3, 4]
>>> aList[0]
1
>>> aList[2:]
[3, 4]
>>> aList[:3]
[1, 2, 3]
>>> aList[1] = 5
>>> aList
[1, 5, 3, 4]
Slice access to a tuple is similar, except it cannot be modified:
元组也可以进行切片运算，得到的结果也是元组（不能被修改）：

>>> aTuple = ('robots', 77, 93, 'try')
>>> aTuple
('robots', 77, 93, 'try')
>>> aTuple[:3]
('robots', 77, 93)
>>> aTuple[1] = 5
Traceback (innermost last): File "<stdin>", line 1, in ?
TypeError: object doesn't support item assignment
TypeError: 对象不支持元素赋值运算

You  can  find  out  a  lot  more  about  lists  and  tuples  along  with  strings  in Chapter 6.
你可以在第六章学到更多有关列表、元组以及字符串的知识。

2.9  Dictionaries 
字典

Dictionaries (or “dicts” for short) are Python’s mapping type and work like associative  arrays  or  hashes  found  in  Perl;  they  are  made  up  of  key-value pairs. Keys can be almost any Python type, but are usually numbers or strings.
字典是Python中的映射数据类型，工作原理类似Perl中的关联数组或者哈希表，由键-值(key-value)对构成。几乎所有类型的Python对象都可以用作键，不过一般还是以数字或者字符串最为常用。

Values,  on  the  other  hand,  can  be  any  arbitrary  Python  object.  Dicts  are enclosed by curly braces ( { } ).
值可以是任意类型的Python对象，字典元素用大括号({ })包裹。

>>> aDict = {'host': 'earth'}   # create dict
>>> aDict['port'] = 80  # add to dict
>>> aDict
{'host': 'earth', 'port': 80}
>>> aDict.keys()
['host', 'port']
>>> aDict['host']
'earth'
>>> for key in aDict:
...     print key, aDict[key]
...
host earth port 80
Dictionaries are covered in Chapter 7.
在第七章中会详细讲解字典。


2.10  Code Blocks Use Indentation 
代码块及缩进对齐

Code blocks are identified by indentation rather than using symbols like curly braces. Without extra symbols, programs are easier to read. Also, indentation clearly identifies which block of code a statement belongs to. Of course, code blocks can consist of single statements, too.
代码块通过缩进对齐表达代码逻辑而不是使用大括号，因为没有了额外的字符，程序的可读性更高。而且缩进完全能够清楚地表达一个语句属于哪个代码块。当然，代码块也可以只有一个语句组成。

When one is new to Python, indentation may comes as a surprise. Humans generally prefer to avoid change, so perhaps after many years of coding with brace delimitation, the first impression of using pure indentation may not be completely positive. However, recall that two of Python’s features are that it is simplistic in nature and easy to read. If you have a strong dislike of indenta- tion as a delimitation ***, we invite you to revisit this notion half a year from now. More than likely, you will have discovered that life without braces is not as bad as you had originally thought.
对一个Python初学者来说， 仅使用缩进可能令他诧异。 人们通常竭力避免改变， 因此对那些使用大括号很多年的人来说， 初次使用纯缩进来表示逻辑也许会多少感到有些不够坚定。（不用大括号？到底成不成啊？）。然而回想一下， python有两大特性， 一是简洁，二是可读性好。如果你实在讨厌使用缩进作为代码分界， 我们希望你从现在开始，半年后再来看一下这种方式。也许你会发现生活中没有大括号并不会象你想像的那么糟糕。

2.11  if Statement     
if语句

The standard if conditional statement follows this syntax:
标准if条件语句的语法如下：
if expression:
        if_suite
If the expression is non-zero or True, then the statement if_suite is executed; otherwise, execution continues on the first statement after. Suite is the term used in Python to refer to a sub-block of code and can consist of single or multiple statements. You will notice that parentheses are not required in if statements as they are in other languages.
如果表达式的值非0或者为布尔值True, 则代码组 if_suite 被执行; 否则就去执行下一条语句。 代码组是一个Python术语， 它由一条或多条语句组成，表示一个子代码块。Python与其它语言不同， 条件条达式并不需要用括号括起来。

if x < .0:
        print '”x” must be atleast 0!'

Python supports an else statement that is used with if in the following manner:
Python 当然也支持 else 语句， 语法如下：
if expression:
        if_suite
else:
        else_suite

Python 还支持 elif （意指 “else-if ”）语句，语法如下:

if expression1:
        if_suite
elif expression2:
        elif_suite
else:
        else_suite

At the time of this writing, there has been some discussion pertaining to a switch or case statement, but nothing concrete. It is possible that we will see such an animal in a future version of the language. This may also seem strange and/or distracting at first, but a set of if-elif-else state- ments are not as “ugly” because of Python’s clean syntax. If you really want to circumvent a set of chained if-elif-else statements, another elegant workaround is using a for loop (see Section 2.13) to iterate through your list of possible “cases.”
在本书写作之时， 正在进行一个关于是否需要增加 switch/case 语句的讨论， 不过目前并没有什么实质性的进展。 在将来版本的Python语言当中， 也非常有可能看到这样的“动物”。 这个例子似乎有点奇怪、让人觉得困惑， 但是因为有了Python干净的语法，if-elif-else 语句并不象别人说的那么丑陋（以致不能让人接受）。如果你非要避免写一堆 if-elif-else 语句， 另一种变通的解决方案是使用for循环（参阅2.13）来迭代你可能的"cases"列表。

You can learn more about if, elif, and else statements in the condi- tional section of Chapter 8.
在第8章你可以学到更多有关 if, elif, else 条件语句的知识。


2.12    while Loop   
while循环

The standard while conditional loop statement is similar to the if. Again, as  with  every  code  sub-block,  indentation  (and  dedentation)  are  used  to delimit blocks of code as well as to indicate which block of code statements belong to:
标准while条件循环语句的语法类似if. 再说一次， 要使用缩进来分隔每个子代码块。 
while expression:
        while_suite

The statement while_suite is executed continuously in a loop until the expression  becomes  zero  or  false;  execution  then  continues  on  the  first succeeding  statement.  Like  if statements,  parentheses  are  not  required with Python while statements.
语句 while_suite 会被连续不断的循环执行， 直到表达式的值变成 0 或 False; 接着Python会执行下一句代码。 类似if语句， Python的while语句中的条件表达式也不需要用括号括起来。

>>> counter = 0
>>> while counter < 3:
...     print 'loop #%d' % (counter)
...     counter += 1

loop #0 loop #1 loop #2
Loops such as while and for (see below) are covered in the loops section
of Chapter 8.
while循环和马上就要讲到的for 循环会在第8章的循环一节进行详细讲解。

2.13  for Loop and the range()
Built-in Function
for 循环和range()内建函数

The for loop in Python is more like a foreach iterative-type loop in a shell scripting language than a traditional for conditional loop that works like a counter. Python’s for takes an iterable (such as a sequence or iterator) and traverses each element once.
Python中的for循环与传统的for循环（计数器循环）不太一样， 它更象shell脚本里的foreach迭代。Python中的for接受可迭代对象（例如序列或迭代器）作为其参数，每次迭代其中一个元素。

>>> print 'I like to use the Internet for:' 
I like to use the Internet for:
>>> for item in ['e-mail', 'net-surfing', 'homework','chat']:
...     print item
...
e-mail
net-surfing 
homework 
chat

Our output in the previous example may look more presentable if we display the items on the same line rather than on separate lines. print statements by default automatically add a NEWLINE character at the end of every line. This can be suppressed by terminating the print statement with a comma ( , ).
上面例子的输出如果能在同一行就会美观许多。print 语句默认会给每一行添加一个换行符。只要在print语句的最后添加一个逗号(,)， 就可以改变它这种行为。

print 'I like to use the Internet for:'
for item in ['e-mail', 'net-surfing', 'homework', 'chat']:
print item,
print

The  code  required  further  modification  to  include  an  additional  print
statement with no arguments to flush our line of output with a terminating NEWLINE; otherwise, the prompt will show up on the same line immediately after the last piece of data output. Here is the output with the modified code:
上面的代码还添加了一个额外的没有任何参数的 print 语句， 它用来输出一个换行符。否则， 提示信息就会立刻出现在我们的输出之后。 下面是以上代码的输出：

I like to use the Internet for:
e-mail net-surfing homework chat

Elements  in  print statements  separated  by  commas  will  automatically include a delimiting space between them as they are displayed.
Providing a string format gives the programmer the most control because it dictates the exact output layout, without having to worry about the spaces gen- erated by commas. It also allows all the data to be grouped together in one place―the tuple or dictionary on the right-hand side of the format operator.
为了输出清晰美观， 带逗号的print语句输出的元素之间会自动添加一个空格。通过指定输出格式， 程序员可以最大程度的控制输出布局， 也不用担心这些自动添加的空格。它也可以将所有数据放到一处输出－－只需要将数据放在格式化运算符右侧的元组或字典中。

>>> who = 'knights'
>>> what = 'Ni!'
>>> print 'We are the', who, 'who say', what, what, what, what
We are the knights who say Ni! Ni! Ni! Ni!
>>> print 'We are the %s who say %s' % \
...     (who, ((what + ' ') * 4))
We are the knights who say Ni! Ni! Ni! Ni!

Using  the  string  format  operator  also  allows  us  to  do  some  quick  string manipulation before the output, as you can see in the previous example.
使用字符串格式运算符还允许我们做一些字符串输出之前的整理工作， 就象你在刚才的例子中看到的一样。

We conclude our introduction to loops by showing you how we can make Python’s  for statement  act  more  like  a  traditional  loop,  in  other  words,  a numerical  counting  loop.  Because  we  cannot  change  the  behavior  of  a  for loop (iterates over a sequence), we can manipulate our sequence so that it is a list of numbers. That way, even though we are still iterating over a sequence, it will at least appear to perform the number counting and incrementing that we envisioned.
通过演示一个让Python for 循环更象传统循环（换言之， 计数循环）的示例， 我们来结束对循环的介绍。因为我们不能改变 for循环的行为（迭代一个序列）， 我们可以生成一个数字序列。 这样， 尽管我们确实是在迭代一个序列， 但是它至少展示的是递增计数的效果。

>>> for eachNum in [0, 1, 2]:
...     print eachNum
...
0
1
2

Within our loop, eachNum contains the integer value that we are displaying and can use it in any numerical calculation we wish. Because our range of num- bers may differ, Python provides the  range() built-in function to generate such a list for us. It does exactly what we want, taking a range of numbers and generating a list.
在这个循环中， eachNum包含的整数值可以用于显示， 也可以用于计算。因为我们要使用的数值范围可能会经常变化，Python提供了一个range()内建函数来生成这种列表。它正好能满足我们的需要， 接受一个数值范围， 生成一个列表。

>>> for eachNum in range(3):
...     print eachNum
...

0
1
2
For strings, it is easy to iterate over each character:
对字符串来说， 很容易迭代每一个字符。

>>> foo = 'abc'
>>> for c in foo:
...     print c
... a
b c
The range() function has been often seen with len() for indexing into a string. Here, we can display both elements and their corresponding index value:
range()函数经常和len()函数一起用于字符串索引。 在这里我们要显示每一个元素及其索引值：
>>> foo = 'abc'
>>> for i in range(len(foo)):
...     print foo[i], '(%d)' % i
...
a (0) b (1) c (2)
However, these loops were seen as restrictive―you either index by each element or by its index, but never both. This led to the enumerate() func- tion (introduced in Python 2.3) that does give both:
不过， 这些循环有一个约束， 你要么循环索引， 要么循环元素。这导致了enumerate()函数的推出（Python2.3新增）。 它同时做到了这两点：

>>> for i, ch in enumerate(foo):
...     print ch, '(%d)' % i
...
a (0) b (1) c (2)

2.13    List Comprehensions   
列表解析

These are just fancy terms to indicate how you can programmatically use a
for loop to put together an entire list on a single line:
这是一个让人欣喜的术语， 表示你可以在一行中使用一个for循环将所有值放到一个列表当中：
>>> squared = [x ** 2 for x in range(4)]
>>> for i in squared:
...     print i

0
1
4
9

List  comprehensions  can  do  even  fancier  things  like  being  selective  of what to include in the new list:
列表解析甚至能做更复杂的事情， 比如挑选出符合要求的值放入列表：

>>> sqdEvens = [x ** 2 for x in range(8) if not x % 2]
>>>
>>> for i in sqdEvens:
...     print i

0
4
16
36


2.15  Files and the open() and file()
Built-in Functions
文件和内建函数open() 、file()


File access is one of the more important aspects of a language once you are comfortable  with  the  syntax;  there  is  nothing  like  the  power  of  persistent storage to get some real work done.
在你已经习惯一门语言的语法之后， 文件访问是相当重要的一环。在一些工作做完之后， 将它保存到持久存储是很重要的。

How to Open a File
如何打开文件

handle = open(file_name, access_mode = 'r')

The file_name variable contains the string name of the file we wish to open, and access_mode is either 'r' for read, 'w' for write, or 'a' for append. Other flags that can be used in the access_mode string include the  '+' for  dual  read-write  access  and  the  'b' for  binary  access.  If  the mode is not provided, a default of read-only ('r') is used to open the file.
If open() is successful, a file object will be returned as the handle (handle). All succeeding access to this file must go through its file handle. Once a file object is returned, we then have access to the other functionality through its methods such as readlines() and close(). Methods are attributes of file objects and must be accessed via the dotted attribute notation (see the following Core Note).
file_name 变量包含我们希望打开的文件的字符串名字， access_mode 中 'r' 表示读取， 'w' 表示写入， 'a' 表示添加。其它可能用到的标声还有 '+' 表示读写， 'b'表示二进制访问. 如果未提供 access_mode ， 默认值为 'r'。如果 open() 成功， 一个文件对象句柄会被返回。所有后续的文件操作都必须通过此文件句柄进行。当一个文件对象返回之后， 我们就可以访问它的一些方法， 比如 readlines() 和close().文件对象的方法属性也必须通过句点属性标识法访问（参阅下面的核心笔记）

CORE NOTE: What are attributes?
核心笔记：什么是属性？

Attributes are items associated with a piece of data. Attributes can be simple data values or executable objects such as functions and methods. What kind of objects have attributes? Many. Classes, modules, files, and complex numbers just some of the Python objects that have attributes.
属性是与数据有关的项目， 属性可以是简单的数据值， 也可以是可执行对象， 比如函数和方法。哪些对象拥有属性呢？ 很多。 类， 模块， 文件还有复数等等对象都拥有属性。

How do I access object attributes? With the dotted attribute notation,
that is, by putting together the object and attribute names, separated by
a dot or period: object.attribute.
我如何访问对象属性？ 使用句点属性标识法。 也就是说在对象名和属性名之间加一个句点： object.attribute

Here is some code that prompts the user for the name of a text file, then opens the file and displays its contents to the screen:
下面有一些代码， 提示用户输入文件名， 然后打开一个文件， 并显示它的内容到屏幕上：

filename = raw_input('Enter file name: ')
fobj = open(filename, 'r')
for eachLine in fobj:
print eachLine, fobj.close()

      This script prompts the user for a filename, opens the file, and loops over the (text) file and displays one line at a time, and finally closes the file. This technique or idiom is simple to understand and works great, especially with large files because you do not need the entire file in memory at the same time. As an alternative for shorter files, take a look at this similar piece of code: 
     这个脚本提示用户输入一个文件名,打开该文件,然后循环的读取和显示(文本)文件的每一行, 最后关闭文件.  这种技术很容易理解而且工作的也很好, 特别是对于大文件,你不需要将整个文件读到内存中. 对于小文件, 我们有另一种方案, 请看下面的代码:
filename = raw_input('Enter file name: ')
fobj = open(filename, 'r')
data = fobj.readlines()
fobj.close()
for eachLine in data:
      print eachLine, 
	  
Rather than looping to read and display one line at a time, our code does something a little different. We read all lines in one fell swoop, close the file, and then iterate through the lines of the file. One advantage to coding this way is that it permits the file access to complete more quickly. The output and file access do not have to alternate back and forth between reading a line and printing a line. It is cleaner and separates two somewhat unrelated tasks. The caveat here is the file size. The code above is reasonable for files with reasonable sizes. Very large data files may take up too much memory, in which case  you  would  have  to  revert  back  to  reading  one  line  at  a  time.  (A  good example can be found in the next section.)
我们的代码没有用循环一次取一行显示， 而是做了点改变。我们一次读入文件的所有行， 然后关闭文件， 再迭代每一行输出。这样写代码的好处是能够快速完整的访问文件。内容输出和文件访问不必交替进行。这样代码更清晰， 而且将不相关的任务区分开来。需要注意的一点是文件的大小。 上面的代码适用于文件大小适中的文件。对于很大的文件来说， 上面的代码会占用太多的内存， 这时你最好一次读一行。（下一节有一个好例子）

The other interesting statement in our code is that we are again using the comma at the end of the  print statement to suppress the printing of the NEWLINE character. Why? Because each text line of the file already contains NEWLINEs at the end of every line. If we did not suppress the NEWLINE from being added by print, our display would be double-spaced.
我们的代码中另一个有趣的语句是我们又一次在print语句中使用逗号来抑制自动生成的换行符号。 为什么要这样做？因为文件中的每行文本已经自带了换行字符， 如果我们不抑制print语句产生的换行符号， 文本在显示时就会有额外的空行产生。
The file() built-in function was recently added to Python. It is identical
to open(), but is named in such a way to indicate that is a factory function
(producing file objects), similar to how int() produces integers and dict()
results in dictionary objects. In Chapter 9, we cover file objects, their built-in methods attributes, and how to access your local file system. Please refer to Chapter 9 for all the details.
file()内建函数是最近才添加到Python当中的。它的功能等同于 open()， 不过file()这个名字可以更确切的表明它是一个工厂函数。（生成文件对象）类似int()生成整数对象， dict()生成字典对象。在第9章， 我们详细介绍文件对象， 及它们的内建方法属性， 以及如何访问本地文件系统。 请参考第9章以了解详细信息。

2.16    Errors and Exceptions
错误和异常

Syntax  errors  are  detected  on  compilation,  but  Python  also  allows  for  the detection of errors during program execution. When an error is detected, the Python  interpreter  raises  (aka  throws,  generates,  triggers)  an  exception. Armed with the information that Python’s exception reporting can generate at  runtime,  programmers  can  quickly  debug  their  applications  as  well  as fine-tune their software to take a specific course of action if an anticipated error occurs.
编译时会检查语法错误， 不过 Python 也允许在程序运行时检测错误。当检测到一个错误， Python解释器就引发一个异常， 并显示异常的详细信息。程序员可以根据这些信息迅速定位问题并进行调试， 并找出处理错误的办法。

To  add  error  detection  or  exception  handling  to  your  code,  just
“wrap”  it  with  a  try-except statement.  The  suite  following  the  try
statement  will  be  the  code  you  want  to  manage.  The  code  that  comes
after the except will be the code that executes if the exception you are
anticipating occurs:
要给你的代码添加错误检测及异常处理， 只要将它们封装在 try-except 语句当中。 try 之后的代码组， 就是你打算管理的代码。 except 之后的代码组， 则是你处理错误的代码。

 
try:

filename = raw_input('Enter file name: ')
fobj = open(filename, 'r')
for eachLine in fobj:
print eachLine, fobj.close()
except IOError, e:
print 'file open error:', e

Programmers can explicitly raise an exception with the raise command. You can learn more about exceptions as well as see a complete list of Python exceptions in Chapter 10.
程序员也可以通过使用 raise 语句故意引发一个异常。在第10章你可以学到更多有关Python异常的知识。

2.17    Functions
函数

Like many other languages, functions in Python are called using the func- tional  operator  (  (  ) ),  functions  must  be  declared  before  they  can  be called.  You  do  not  need  to  declare  function  (return)  types  or  explicitly return values (None, Python’s NULL object is returned by default if one is not given.)
类似其它的语言， Python中的函数使用小括号( () )调用。函数在调用之前必须先定义。如果函数中没有 return 语句， 就会自动返回 None 对象。

Python can be considered “call by reference.” This means that any changes
to these parameters within the function affect the original objects in the call- ing function. However, the caveat is that in Python, it is really dependent on the object type being passed. If that object allows updating, then it behaves as you would expect from “call by reference,” but if that object’s value cannot be changed, then it will behave like “call by value.”
Python是通过引用调用的。 这意味着函数内对参数的改变会影响到原始对象。不过事实上只有可变对象会受此影响， 对不可变对象来说， 它的行为类似按值调用。

How to Declare Functions
如何定义函数

def function_name([arguments]):
"optional documentation string"
function_suite

The syntax for declaring a function consists of the def keyword followed by
the function name and any arguments that the function may take. Function
arguments  such  as  arguments above  are  optional,  which  is  why  they  are enclosed in brackets above. (Do not physically put brackets in your code!) The statement terminates with a colon (the same way that an if or while state- ment is terminated), and a code suite representing the function body follows. Here is one short example:
定义一个函数的语法由 def 关键字及紧随其后的函数名再加上该函数需要的几个参数组成。函数参数（比较上面例子中的arguments)是可选的， 这也是为什么把它们放到中括号中的原因。（在你的代码里千万别写上中括号！）这个语句由一个冒号(:)结束（与if和while语句的结束方式一样）， 之后是代表函数体的代码组， 下面是一个简短的例子：

def addMe2Me(x):
        'apply + operation to argument'
        return (x + x)

This function, presumably meaning “add me to me” takes an object, adds its current value to itself and returns the sum. While the results are fairly obvious with numerical arguments, we point out that the plus sign works for almost all types.  In  other  words,  most  of  the  standard  types  support  the  + operator, whether it be numeric addition or sequence concatenation.
这个函数， 干的是“在我的值上加我”的活。它接受一个对象， 将它的值加到自身， 然后返回和。对于数值类型参数， 它的结果是显而易见的， 不过我要在这里指出， 加号运算符几乎与所有数据类型工作。换句话说， 几乎所有的标准数据类型都支持 + 运算符， 不管是数值相加还是序列合并。

How to Call Functions
如何调用函数

>>> addMe2Me(4.25)
8.5
>>>
>>> addMe2Me(10)
20
>>>
>>> addMe2Me('Python')
'PythonPython'
>>>
>>> addMe2Me([-1, 'abc'])
[-1, 'abc', -1, 'abc']

Calling functions in Python is similar to function invocations in many other high-level  languages,  by  giving  the  name  of  the  function  followed  by  the functional  operator,  a  pair  of  parentheses.  Any  optional  parameters  go between the parentheses, which are required even if there are no arguments. Observe how the + operator works with non-numeric types.
Python语言中调用函数与在其它高级语言中一样， 函数名加上函数运算符， 一对小括号。括号之间是所有可选的参数。即使一个参数也没有， 小括号也不能省略。注意一下， + 运算符在非数值类型中如何工作。

Default Arguments
默认参数

Functions  may  have  arguments  that  have  default  values.  If  present,  argu- ments will take on the appearance of assignment in the function declaration, but in actuality, it is just the syntax for default arguments and indicates that if a value is not provided for the parameter, it will take on the assigned value as a default.
函数的参数可以有一个默认值， 如果提供有默认值，在函数定义中， 参数以赋值语句的形式提供。事实上这仅仅是提供默认参数的语法，它表示函数调用时如果没有提供这个参数， 它就取这个值做为默认值。

>>> def foo(debug=True):
...     'determine if in debug mode with default argument'
...     if debug:
...     print 'in debug mode'
...     print 'done'
...
>>> foo()
in debug mode done
>>> foo(False)
done

In the example above, the debug parameter has a default value of True. When we do not pass in an argument to the function foo(), debug automat- ically takes on a value of True. On our second call to foo(), we deliberately send an argument of False, so that the default argument is not used. Functions have many more features than we could describe in this intro- ductory section. Please refer to Chapter 11 for more details.
在上面的例子里， debug 参数有一个默认值 True. 如果我们没有传递参数给函数foo(), debug 自动拿到一个值， True. 在第二次调用 foo()时, 我们故意传递一个参数 False 给foo()， 这样， 默认参数就没有被使用。 函数拥有的特性远比我们在这里介绍的多， 请阅读第11章以了解更详细的函数的信息。

2.18    Classes 
类

Classes are a core part of object-oriented programming and serve as a “con- tainer”  for  related  data  and  logic.  They  provide  a  “blueprint”  for  creating “real” objects, called instances. Because Python does not require you to pro- gram  in  an  object-oriented  way  (like  Java  does),  classes  are  not  required learning at this time. However, we will present some examples here for those who are interested in getting a sneak peek.
类是面向对象编程的核心， 它扮演相关数据及逻辑的容器角色。它们提供了创建“真实”对象(也就是实例)的蓝图。因为Python并不强求你以面向对象的方式编程（与Java不同）， 此刻你也可以不学习类。 不过我们还是在这儿放了些例子， 以方便感兴趣的读者浏览。

How to Declare Classes
如何定义类

class ClassName(base_class[es]):
        "optional documentation string" 
        static_member_declarations 
        method_declarations
Classes are declared using the class keyword. A base or parent class is optional;  if  you  do  not  have  one,  just  use  object as  the  base  class.  This header line is followed by an optional documentation string, static member declarations, and any method declarations.
使用 class 关键字定义类。 可以提供一个可选的父类或者说基类; 如果没有合适的基类， 那就使用 object 作为基类。class 行之后是可选的文档字符串， 静态成员定义， 及方法定义。
class FooClass(object):
"""my very first class: FooClass"""
version = 0.1   # class (data) attribute



def __init__(self, nm='John Doe'):
"""constructor"""
self.name = nm  # class instance (data) attribute
print 'Created a class instance for', nm
def showname(self):
"""display instance attribute and class name"""
print 'Your name is', self.name
print 'My name is', self.__class__.__name__
def showver(self):
"""display class(static) attribute"""
print self.version      # references FooClass.version
def addMe2Me(self, x):  # does not use 'self'
"""apply + operation to argument"""
return x + x

In  the  above  class,  we  declared  one  static  data  type  variable  version shared among all instances and four methods,  __init__(), showname(), showver(), and the familiar  addMe2Me(). The show*() methods do not really  do  much  but  output  the  data  they  were  created  to  output.  The
__init__() method has a special name, as do all those whose names begin and end with a double underscore ( __ ).
在上面这个类中， 我们定义了一个静态变量 version, 它将被所有实例及四个方法共享， __init__()， showname(), showver(), 及熟悉的 addMe2Me(). 这些 show*()方法并没有做什么有用的事情， 仅仅输出对应的信息。 __init__() 方法有一个特殊名字， 所有名字开始和结束都有两个下划线的方法都是特殊方法。

The __init__() method is a function provided by default that is called when a class instance is created, similar to a constructor and called after the object has been instantiated. __init__() can be thought of as a constructor, but unlike constructors in other languages, it does not create an instance―it
is really just the first method that is called after your object has been created. Its  purpose  is  to  perform  any  other  type  of  “start  up”  necessary  for  the instance  to  take  on  a  life  of  its  own.  By  creating  our  own  __init__() method, we override the default method (which does not do anything) so that we can do customization and other “extra things” when our instance is cre- ated.  In  our  case,  we  initialize  a  class  instance  attribute  or  member  called name. This variable is associated only with class instances and is not part of the actual class itself. __init__() also features a default argument, intro- duced in the previous section. You will no doubt also notice the one argu- ment which is part of every method, self.
当一个类实例被创建时， __init__() 方法会自动执行， 在类实例创建完毕后执行， 类似构建函数。__init__() 可以被当成构建函数， 不过不象其它语言中的构建函数， 它并不创建实例--它仅仅是你的对象创建后执行的第一个方法。它的目的是执行一些该对象的必要的初始化工作。通过创建自己的 __init__() 方法， 你可以覆盖默认的 __init__()方法（默认的方法什么也不做），从而能够修饰刚刚创建的对象。在这个例子里， 我们初始化了一个名为 name 的类实例属性（或者说成员）。这个变量仅在类实例中存在， 它并不是实际类本身的一部分。 __init__()需要一个默认的参数， 前一节中曾经介绍过。毫无疑问，你也注意到每个方法都有的一个参数， self.

What is self? It is basically an instance’s handle to itself, the instance on
which  a  method  was  called.  Other  OO  languages  often  use  an  identifier called this.
什么是 self ? 它是类实例自身的引用。其他语言通常使用一个名为 this  的标识符。

How to Create Class Instances
如何创建类实例

>>> foo1 = FooClass()
Created a class instance for John Doe

The string that is displayed is a result of a call to the __init__() method which  we  did  not  explicitly  have  to  make.  When  an  instance  is  created, __init__() is  automatically  called,  whether  we  provided  our  own  or  the interpreter used the default one.
屏幕上显示的字符串正是自动调用 __init__() 方法的结果。当一个实例被创建， __init__()就会被自动调用。不管这个__int__()是自定义的还是默认的。

Creating instances looks just like calling a function and has the exact same syntax. They are both known as “callables.” Class instantiation uses the same functional operator as invoking a function or method.
Now  that  we  have  successfully  created  our  first  class  instance,  we  can make some method calls, too:
创建一个类实例就像调用一个函数， 它们确实拥有一样的语法。它们都是可调用对象。类实例使用同样的函数运算符调用一个函数或方法。既然我们成功创建了第一个类实例， 那现在来进行一些方法调用:

>>> foo1.showname() Your name is John Doe
My name is __main__.FooClass
>>>
>>> foo1.showver()
0.1
>>> print foo1.addMe2Me(5)
10
>>> print foo1.addMe2Me('xyz')
xyzxyz
The result of each function call is as we expected. One interesting piece
of  data  is  the  class  name.  In  the  showname() method,  we  displayed  the self.__class__.__name__ variable  which,  for  an  instance,  represents the name of the class from which it has been instantiated. (self.__class__ refers to the actual class.) In our example, we did not pass in a name to create our  instance,  so  the  'John Doe' default  argument  was  used.  In  our  next example, we do not use it.
每个方法的调用都返回我们期望的结果。比较有趣的数据是类名字。在showname()方法中， 我们显示 self.__class__.__name__ 变量的值。对一个实例来说， 这个变量表示实例化它的类的名字。（self.__class__引用实际的类）。在我们的例子里， 创建类实例时我们并未传递名字参数， 因此默认参数 'John Doe' 就被自动使用。在我们下一个例子里， 我们将指定一个参数。

>>> foo2 = FooClass('Jane Smith') Created a class instance for Jane Smith
>>> foo2.showname()
Your name is Jane Smith
My name is FooClass
There is plenty more on Python classes and instances in Chapter 13.
第十三章将详细介绍Python类和类实例。


2.19  Modules
      模块

A module is a logical way to physically organize and distinguish related pieces of Python code into individual files. A module can contain executable code, functions, classes, or any and all of the above.
模块是一种组织形式， 它将彼此有关系的Python代码组织到一个个独立文件当中。
模块可以包含可执行代码， 函数和类或者这些东西的组合。

When you create a Python source file, the name of the module is the same
as the file except without the trailing .py extension. Once a module is created, you  may  import  that  module  for  use  from  another  module  using  the import statement.
当你创建了一个 Python 源文件，模块的名字就是不带  .py 后缀的文件名。一个模块创建之后， 你可以从另一个模块中使用 import 语句导入这个模块来使用。

How to Import a Module
如何导入模块

import 模块名

How to Call a Module Function or Access a Module Variable
如何访问一个模块函数或访问一个模块变量


Once imported, a module’s attributes (functions and variables) can be accessed using the familiar dotted attribute notation:
一旦导入完成， 一个模块的属性（函数和变量）可以通过熟悉的 .句点属性标识法访问。

module.function()
module.variable

We will now present our Hello World! example again, but using the output functions inside the sys module.
现在我们再次提供 Hello World! 例子， 不过这次使用 sys 模块中的输出函数。

>>> import sys
>>> sys.stdout.write('Hello World!\n') Hello World!
>>> sys.platform
'win32'
>>> sys.version
'2.4.2 (#67, Sep 28 2005, 10:51:12) [MSC v.1310 32 bit
(Intel)]'

This code behaves just like our original Hello World! using the print
statement.  The  only  difference  is  that  the  standard  output  write()
method  is  called,  and  the  NEWLINE  character  needs  to  be  stated
explicitly because, unlike the print statement, write() does not do that
for you.
这些代码的输出与我们使用 print 语句完全相同。 唯一的区别在于这次调用了标准输出的 write()方法，而且这次需要显式的在字符串中提供换行字符， 不同于print语句， write()不会自动在字符串后面添加换行符号。

You can find out more information on modules and importing in Chapter 12. We will cover all of the above topics in much greater detail throughout the text, but hopefully we have provided enough of a “quick dip in the pool” to facilitate  your  needs  if  your  primary  goal  is  to  get  started  working  with Python as quickly as possible without too much serious reading.
关于模块和导入， 你可以在第12章中得到更多有用的信息。在那里会详细介绍本章上面所有提到的主题，希望我们提供的快速入门能达到你迅速使用Python开始工作的目标。


CORE NOTE: What is a “PEP” ?
核心笔记：什么是“PEP”？
You will find references throughout the book to PEP. A PEP is a Python
Enhancement Proposal, and this is the way new features are introduced
to future versions of Python.They are usually advanced reading from the beginner’s point of view, but they provide a full description of a new feature, the rationale or motivation behind it, a new syntax if that is necessary, technical implementation details, backwards-compatibility information, etc. Agreement
has to be made between the Python development community, the PEP authors and implementors, and finally, the creator of Python itself, Guido van Rossum, adoringly referred to as the BDFL (Benevolent Dictator for Life), before any new feature is integrated. PEP 1 introduces the PEP, its purpose and guidelines. You can find all of the PEPs in PEP 0, the PEP
index, at: http://python.org/dev/peps.
在本书中你会经常看到 PEP 这个字眼。 一个 PEP 就是一个 Python 增强提案(Python Enhancement Proposal)， 这也是在新版Python中增加新特性的方式。 从初学者的角度看， 它们是一些高级读物， 它们不但提供了新特性的完整描述， 还有添加这些新特性的理由， 如果需要的话， 还会提供新的语法、 技术实现细节、向后兼容信息等等。在一个新特性被整合进Python之前， 必须通过Python开发社区， PEP作者及实现者， 还有Python的创始人， Guido van Rossum(Python终身的仁慈的独裁者）的一致同意。PEP1阐述了PEP的目标及书写指南。在PEP0中可以找到所有的PEP。 PEP索引的网址是： http://python.org/dev/peps.

2.19    Useful Functions
实用的函数

In this chapter, we have seen some useful built-in functions. We summarize them in Table 2.1 and present a few other useful ones (note that these may not be the full syntax, only what we feel would be useful for you now).
本章中， 我们用到了很多实用的内建函数。我们在表2.1中总结了这些函数， 并且提供了一些其它的有用函数。（注意我们并没有提供完整的使用语法，仅提供了我们认为可能对你有用的部分）

Table 2.1  Useful Built-In Functions for New Python Programmers
表2.1 对新Python程序员有用的内建函数

Function        Description
函数            描述
dir([obj])      Display attributes of object or the names of global variables if no parameter given
                显示对象的属性，如果没有提供参数， 则显示全局变量的名字
help([obj])     Display object’s documentation string in a pretty-printed format or enters interactive help if no parameter given
                以一种整齐美观的形式 显示对象的文档字符串， 如果没有提供任何参数， 则会进入交互式帮助。
int(obj)        Convert object to an integer
                将一个对象转换为整数
len(obj)        Return length of object
                返回对象的长度
open(fn, mode)  Open file fn with mode ('r' = read, 'w' = write)
                以 mode('r' = 读， 'w'= 写)方式打开一个文件名为 fn 的文件
 
range([[start,]stop[,step]) Return a list of integers that begin at start up to but not including stop in increments of step; start defaults to 0, and step defaults to 1 
返回一个整数列表。起始值为 start, 结束值为 stop - 1; start 默认值为 0， step默认值为1。

raw_input(str)  Wait for text input from the user, optional prompt string can be provided。
        等待用户输入一个字符串， 可以提供一个可选的参数 str 用作提示信息。
str(obj)        Convert object to a string
        将一个对象转换为字符串
type(obj)       Return type of object (a type object itself !)
        返回对象的类型（返回值本身是一个type对象！）


2.21  Exercises
     练习

2C1.   Variables, print, and the String Format Operator. Start the interactive interpreter. Assign values to some variables (strings, numbers, etc.) and display them within the inter- preter by typing their names. Also try doing the same thing with the print statement. What is the difference between giving just a variable name versus using it in conjunction with print? Also try using the string format operator ( % ) to become familiar with it.
变量， print 和字符串格式化运算符。启动交互式解释器。给一些变量赋值（字符串，数值等等）并通过输入变量名显示它们的值。再用 print 语句做同样的事。这二者有何区别？ 也尝试着使用字符串格式运算符 %， 多做几次， 慢慢熟悉它。
2C2.   Program Output. Take a look at the following Python script:
程序输出， 阅读下面的Python脚本：

#!/usr/bin/env python
1 + 2 * 4

(a)  What do you think this script does?
你认为这段脚本是用来做什么的？
(b)  What do you think this script will output?
你认为这段脚本会输出什么？
(c)  Type the code in as a script program and execute it. Did it do what you expected? Why or why not?
输入以上代码，并保存为脚本，然后运行它。它所做的与你的预期一样吗？为什么一样/不一样？
(d)  How does execution differ if you are running this code from within the interactive interpreter? Try it and write down the results.
这段代码单独执行和在交互解释器中执行有何不同？试一下，然后写出结果
(e)  How can you improve the output of the script version so that it does what you expect/want?
如何改进这个脚本， 以便它能和你想像的一样工作？
2C3.   Numbers and Operators. Enter the interpreter. Use Python to add, subtract, multiply, and divide two numbers (of any type). Then use the modulus operator to determine the remainder when dividing one number by another, and finally, raise one number to the power of another by using the expo- nentiation operator.
数值和运算符
启动交互解释器，使用Python对两个数值(任意类型）进行加、减、乘、除运算。然后使用取余运算符来得到两个数相除的余数， 最后使用乘方运算符求A数的B次方。
2C4.   User Input with raw_input().
(a)  Create a small script to use raw_input() built-in
function to take a string input from the user, then display to
the user what he/she just typed in.
(b)  Add another piece of similar code, but have the input be numeric. Convert the value to a number (using either int() or any of the other numeric conversion functions), and display the value back to the user. (Note that if your version of Python is older than 1.5, you will need to use
the string.ato*() functions to perform the conversion.)
使用raw_input()函数得到用户输入
(a) 创建一段脚本使用 raw_input() 内建函数从用户输入得到一个字符串，然后显示这个用户刚刚键入的字符串。
(b) 添加一段类似的代码，不过这次输入的是数值。将输入数据转换为一个数值对象，（使用int()或其它数值转换函数） 并将这个值显示给用户看。（注意，如果你用的是早于1.5的版本，你需要使用string.ato*() 函数执行这种转换）


2C5.   Loops and Numbers. Create some loops using both while and for.
(a)  Write a loop that counts from 0 to 10 using a while loop.
(Make sure your solution really does count from 0 to 10,
not 0 to 9 or 1 to 10.)
(b)  Do the same loop as in part (a), but use a for loop and the range() built-in function.
循环和数字
分别使用while和for创建一个循环:
(a) 写一个while循环，输出整数从0到10。（要确保是从0到10， 而不是从0到9或从1到10）
(b) 做同 (a) 一样的事， 不过这次使用 range() 内建函数。
2C6.   Conditionals. Detect whether a number is positive, negative, or zero. Try using fixed values at first, then update your pro- gram to accept numeric input from the user.
条件判断  判断一个数是正数，还是负数， 或者等于0. 开始先用固定的数值，然后修改你的代码支持用户输入数值再进行判断。
2C7.   Loops and Strings. Take a user input string and display string, one character at a time. As in your above solution, perform this task with a while loop first, then with a for loop.
循环和字串 从用户那里接受一个字符串输入，然后逐字符显示该字符串。先用while循环实现，然后再用 for 循环实现。
2C8.   Loops and Operators. Create a fixed list or tuple of five num- bers and output their sum. Then update your program so that this set of numbers comes from user input. As with the prob- lems above, implement your solution twice, once using while and again with for.
循环和运算符 创建一个包含五个固定数值的列表或元组，输出他们的和。然后修改你的代码为接受用户输入数值。 分别使用while和for循环实现。
2C9.   More Loops and Operators. Create a fixed list or tuple of five
numbers and determine their average. The most difficult part of this exercise is the division to obtain the average. You will discover that integer division truncates and that you must use floating point division to obtain a more accurate result. The float() built-in function may help you there.
循环和运算符 创建一个包含五个固定数值的列表或元组，输出他们的平均值。本练习的难点之一是通过除法得到平均值。 你会发现整数除会截去小数，因此你必须使用浮点除以得到更精确的结果。 float()内建函数可以帮助你实现这一功能。
2C10.   User Input with Loops and Conditionals. Use raw_input()
to prompt for a number between 1 and 100. If the input matches criteria, indicate so on the screen and exit. Other- wise, display an error and reprompt the user until the correct input is received.
带循环和条件判断的用户输入 使用raw_input()函数来提示用户输入一个1和100之间的数，如果用户输入的数满足这个条件，显示成功并退出。否则显示一个错误信息然后再次提示用户输入数值，直到满足条件为止。
2C11.   Menu-Driven Text Applications. Take your solutions to any number of the previous five problems and upgrade your pro- gram to present a menu-driven text-based application that presents the user with a set of choices, e.g., (1) sum of five numbers, (2) average of five numbers, . . . (X) Quit. The user makes a selection, which is then executed. The program exits when the user chooses the “quit” option. The great advantage of a program like this is that it allows the user to run as many iterations of your solutions without necessarily having to restart the same program over and over again. (It is also good for the developer who is usually the first user and tester of
their applications!)
带文本菜单的程序 写一个带文本菜单的程序，菜单项如下（1）取五个数的和 (2) 取五个数的平均值....（X）退出。由用户做一个选择，然后执行相应的功能。当用户选择退出时程序结束。这个程序的有用之处在于用户在功能之间切换不需要一遍一遍的重新启动你的脚本。（这对开发人员测试自己的程序也会大有用处）
2C12.   The dir() Built-In Function.
(a)  Start up the Python interpreter. Run the dir() built-in
function by simply typing dir() at the prompt. What do
you see? Print the value of each element in the list you see.
Write down the output for each and what you think each is.
(b)  You may be asking, so what does dir() do? We have already seen that adding the pair of parentheses after dir causes the function to run. Try typing just the name dir
at the prompt. What information does the interpreter give you? What do you think it means?
(c)  The type() built-in function takes any Python object and returns its type. Try running it on dir by entering type(dir) into the interpreter. What do you get?
(d)  For the final part of this exercise, let us take a quick look
at Python documentation strings. We can access the doc- umentation for the dir() function by appending .__doc__ after its name. So from the interpreter, display the document string for dir() by typing the following at
the prompt: print dir.__doc__. Many of the built-in
functions, methods, modules, and module attributes have
a documentation string associated with them. We invite you to put in your own as you write your code; it may help another user down the road.
dir()内建函数
(a) 启动Python交互式解释器， 通过直接键入dir()回车以执行 dir()内建函数。你看到什么？ 显示你看到的每一个列表元素的值，记下实际值和你想像的值
(b) 你会问, dir()函数是干什么的？我们已经知道在dir后边加上一对括号可以执行dir()内建函数， 如果不加括号会如何？ 试一试。 解释器返回给你什么信息？ 你认为这个信息表示什么意思 ？
(c) type() 内建函数接收任意的Python对象做为参数并返回他们的类型。 在解释器中键入 type(dir)， 看看你得到的是什么？
(d) 本练习的最后一部分， 我们来瞧一瞧 Python的文档字符串。 通过 dir.__doc__ 可以访问dir()内建函数的文档字符串。print dir.__doc__可以显示这个字符串的内容。 许多内建函数，方法，模块及模块属性都有相应的文档字符串。我们希望你在你的代码中也要书写文档字符串， 它会对使用这些代码的人提供及时方便的帮助。

2C13.   Finding Out More About the sys Module with dir().
(a)  Start the Python interpreter again. Run the dir() com-
mand as in the previous exercise. Now import the sys
module by typing import sys at the prompt. Run the
dir() command again to verify that the sys module
now shows up. Now run the dir() command on the
sys module by typing  dir(sys). Now you see all the
attributes of the sys module.
(b)  Display the version and platform variables of the sys
module. Be sure to prepend the names with sys to indi-
cate that they are attributes of sys. The version variable
contains information regarding the version of the Python
interpreter you are using, and the platform attribute con- tains the name of the computer system that Python believes you are running on.
 (c)  Finally, call the sys.exit() function. This is another
way to quit the Python interpreter in case the keystrokes
described above in problem 1C4 do not get you out of
Python.
利用 dir()  找出 sys 模块中更多的东西。
(a) 启动Python交互解释器， 执行dir()函数， 然后键入 import sys 以导入 sys 模块。再次执行dir()函数以确认sys模块被正确的导入。 然后执行 dir(sys) ， 你就可以看到sys模块的所有属性了。
(b) 显示 sys 模块的版本号属性及平台变量。记住在属性名前一定要加 sys. ，这表示这个属性是sys模块的。其中 version变量保存着你使用的Python解释器版本， platform 属性则包含你运行Python时使用的计算机平台信息。
(c) 最后， 调用 sys.exit() 函数。 这是一种热键之外的另一种退出Python解释器的方式 。
2C14.   Operator Precedence and Grouping with Parentheses.
Rewrite the mathematical expression of the print statement in Section 2.4, but try to group pairs of operands correctly, using parentheses.
重写2.4小节中 print 语句里的算术表达式， 试着在这个表达式中添加合适的括号以便它能正常工作。
2C15.   Elementary Sorting.
(a)  Have the user enter three numeric values and store them in three different variables. Without using lists or sorting algorithms, manually sort these three numbers from smallest to largest.
(b)  How would you change your solution in part (a) to sort from largest to smallest?
元素排序
(a)让用户输入三个数值并将分别将它们保存到3个不同的变量中。不使用列表或排序算法，自己写代码来对这三个数由小到大排序。(b)修改(a)的解决方案,使之从大到小排序
2C16.   Files. Type in and/or run the file display code in Section 2.15. Verify that it works on your system and try different input
files as well.
文件
键入2.15节的文件显示的代码， 然后运行它， 看看能否在你的系统上正常工作，然后试一下其它的输入文件。