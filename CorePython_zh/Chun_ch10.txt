Errors and Exceptions
错误和异常

:- andelf (gt:andelf@gmail.com)已认领
:- 张沈鹏 (gt:zsp007@gmail.com)认领“CORE STYLE: Follow exception argument protocol 核心风格: 遵循异常参数协议”以下部分（619行）
:- andelf (gt:andelf@gmail.com)继续完成 练习 相关内容

// 存在问题, 风格不一致...怎么办

Chapter Topics
    What Are Exceptions?
    Exceptions in Python
    Detecting and Handling Exceptions
    Context Management
    Raising Exceptions
    Assertions
    Standard Exceptions
    Creating Exceptions
    Related Modules

本章主题
	什么是异常？
	Python 中的异常
	探测和处理异常
	上下文管理
	引发异常
	断言
	标准异常
	创建异常
	相关模块

Errors are an everyday occurrence in the life of a programmer. In days
hopefully long since past, errors were either fatal to the program (or perhaps the machine) or produced garbage output that was not recognized as valid input by other computers or programs or by the humans who submitted the job to be run. Any time an error occurred, execution was halted until  the  error  was  corrected  and  code  was  re-executed.  Over  time,  demand surged for a “softer” way of dealing with errors other than termination. Programs evolved such that not every error was malignant, and when they did happen, more diagnostic information was provided by either the compiler or the pro- gram during runtime to aid the programmer in solving the problem as quickly as possible. However, errors are errors, and any resolution usually took place after the program or compilation process was halted. There was never really anything a piece of code could do but exit and perhaps leave some crumbs hinting at a possible cause—until exceptions and exception handling came along.

程序员的一生中, 错误几乎每天都在发生. 在过去的一个时期, 错误要么对程序(可能还有机器)是致命的, 要么产生一大堆无意义的输出, 无法被其他计算机或程序识别, 连程序远自己也可能搞不懂它的意义. 一旦出现错误, 程序就会终止执行, 直到错误被修正, 程序重新执行. 所以, 人们需要一个"柔和"的处理错误的方法, 而不是终止程序. 同时, 程序本身也在不断发展, 并不是每个错误都是致命的, 即使错误发生, 编译器或是在执行中的程序也可以提供更多更有用的诊断信息, 帮助程序员尽快解决问题. 然而, 错误毕竟是错误, 一般都是停止编译或执行后才能去解决它. 一小段代码只能让程序终止执行, 也许还能打印出一些模糊的提示. 当然, 这一切都是在异常和异常处理出现之前的事了.

　Although we have yet to cover classes and object-oriented programming in Python,  many  of  the  concepts  presented  here  involve  classes  and  class instances.1 We conclude the chapter with an optional section on how to create your own exception classes.

虽然目前还没有讨论到 Python 中的类和面向对象编程(OOP), 但我们这里要介绍的许多概念已经涉及了类和类实例.[脚注1] 我们提供了一小节介绍如何创建自定义的异常类.

----------------------------脚注：---------
1.    As of Python 1.5, all standard exceptions are implemented as classes. If new to classes, instances,
and other object-oriented terminology, the reader should see Chapter 13 for clarification.

1 . 从 Python 1.5 开始, 所有的标准异常都使用类来实现. 如果你对类, 实例, 以及其他面向对象相关术语不太了解, 请参阅第 13 章
----------------------------

　This chapter begins by exposing the reader to exceptions, exception handling, and how they are supported in Python. We also describe how programmers can generate exceptions within their code. Finally, we reveal how programmers can create their own exception classes.

本章将介绍什么是异常, 异常处理, 以及 Python 对异常的支持. 我们还会介绍如何在代码里生成异常. 最后, 我们会涉及如何创建自定义的异常类.

10.1  What Are Exceptions?
=什么是异常=

10.1.1  Errors
==错误==

Before we get into detail about what exceptions are, let us review what errors are.  In  the  context  of  software,  errors  are  either  syntactical  or  logical  in nature. Syntax errors indicate errors with the construct of the software and cannot  be  executed  by  the  interpreter  or  compiled  correctly.  These  errors must be repaired before execution can occur.

在深入介绍异常之前, 我们来看看什么是错误. 从软件方面来说, 错误是语法或是逻辑上的. 语法错误指示软件的结构上有错误, 导致不能被解释器解释或编译器无法编译. 这些错误必须在程序执行前纠正.

　Once programs are semantically correct, the only errors that remain are logical. Logical errors can either be caused by lack of or invalid input, or, in other cases, by the inability of the logic to generate, calculate, or otherwise produce the desired results based on the input. These errors are sometimes known as domain and range failures, respectively.

当程序的语法正确后, 剩下的就是逻辑错误了. 逻辑错误可能是由于不完整或是不合法的输入所致; 在其他情况下, 还可能是逻辑无法生成, 计算, 或是输出结果需要的过程无法执行. 这些错误通常分别被称为域错误和范围错误.

　When errors are detected by Python, the interpreter indicates that it has reached a point where continuing to execute in the current flow is no longer possible. This is where exceptions come into the picture.

当 Python 检测到一个错误时, 解释器就会指出当前流已经无法继续执行下去. 这时候就出现了异常.

10.1.2  Exceptions
==异常==

Exceptions can best be described as action that is taken outside of the normal flow of control because of errors. This action comes in two distinct phases: The first is the error that causes an exception to occur, and the second is the detection (and possible resolution) phase.

对异常的最好描述是: 它是因为程序出现了错误而在正常控制流以外采取的行为. 这个行为又分为两个阶段: 首先是引起异常发生的错误, 然后是检测(和采取可能的措施)阶段.

　The  first  phase  takes  place  when  an  exception  condition  (sometimes referred to as exceptional condition) occurs. Upon detection of an error and recognition of the exception condition, the interpreter performs an operation called raising an exception. Raising is also known as triggering, throwing, or generating, and is the process whereby the interpreter makes it known to the current control flow that something is wrong. Python also supports the ability of  the  programmer  to  raise  exceptions.  Whether  triggered  by  the  Python interpreter or the programmer, exceptions signal that an error has occurred. The current flow of execution is interrupted to process this error and take appropriate action, which happens to be the second phase.

第一个阶段是在发生了一个异常条件(有时候也叫做例外的条件)后发生的. 只要检测到错误并且意识到异常条件, 解释器会引发一个异常. 引发也可以叫做触发, 引发或者生成. 解释器通过它通知当前控制流有错误发生. Python 也允许程序员自己引发异常. 无论是 Python 解释器还是程序员引发的, 异常就是错误发生的信号. 当前流将被打断, 用来处理这个错误并采取相应的操作. 这就是第二阶段.

The second phase is where exception handling takes place. Once an exceptionis raised, a variety of actions can be invoked in response to that exception. These can range anywhere from ignoring the error, to logging the error but otherwise taking no action, performing some corrective measures and aborting the program, or alleviating the problem to allow for resumption of execution. Any of these actions represents a  continuation, or an alternative branch of control. The key is that the programmer can dictate how the program operates when an error occurs.

对异常的处理发生在第二阶段. 异常引发后, 可以调用很多不同的操作. 可以是忽略错误(记录错误但不采取任何措施, 采取补救措施后终止程序), 或是减轻问题的影响后设法继续执行程序. 所有的这些操作都代表一种继续, 或是控制的分支. 关键是程序员在错误发生时可以指示程序如何执行.

As you may have already concluded, errors during runtime are primarily caused by external reasons, such as poor input, a failure of some sort, etc. These causes are not under the direct control of the programmer, who can anticipate only a few of the errors and code the most general remedies.

你可能已经得出这样一个结论: 程序运行时发生的错误主要是由于外部原因引起的, 例如非法输入或是其他操作失败等等. 这些因素并不在程序员的直接控制下, 而程序员只能预见一部分错误, 编写常见的补救措施代码.

Languages like Python, which support the raising and—more importantly— the  handling  of  exceptions,  empower  the  developer  by  placing  them  in  a more direct line of control when errors occur. The programmer not only has the  ability  to  detect  errors,  but  also  to  take  more  concrete  and  remedial actions when they occur. Due to the ability to manage errors during runtim e, application robustness is increased.

类似 Python 这样支持引发和处理异常(这更重要)的语言, 可以让开发人员可以在错误发生时更直接地控制它们. 程序员不仅仅有了检测错误的能力, 还可以在它们发生时采取更可靠的补救措施. 由于有了运行时管理错误的能力, 应用程序的健壮性有了很大的提高.

　Exceptions and exception handling are not new concepts. They are also present in Ada, Modula-3, C++, Eiffel, and Java. The origins of exceptions probably come from operating systems code that handles exceptions such as system errors and hardware interruptions. Exception handling as a software tool made its debut in the mid-1960s with PL/1 being the first major pro- gramming  language  that  featured  exceptions.  Like  some  of  the  other  lan- guages supporting exception handling, Python is endowed with the concepts of a “try” block and “catching” exceptions and, in addition, provides for more “disciplined” handling of exceptions. By this we mean that you can create dif- ferent handlers for different exceptions, as opposed to a general “catch-all” code where you may be able to detect the exception that occurred in a post- mortem fashion.

异常和异常处理并不是什么新概念. 它们同样存在于 Ada, Modula-3, C++, Eiffel, 以及 Java 中. 异常的起源可以追溯到处理系统错误和硬件中断这类异常的操作系统代码. 在 1965 年左右, PL/1 作为第一个支持异常的主要语言出现, 而异常处理是作为一个它提供的软件工具. 和其他支持异常处理的语言类似, Python 采用了 "try/尝试" 块和 "catching/捕获" 块的概念, 而且它在异常处理方面更有"纪律性". 我们可以为不同的异常创建不同的处理器, 而不是盲目地创建一个"catch-all/捕获所有"的代码.

10.2  Exceptions in Python
=Python 中的异常=

As you were going through some of the examples in the previous chapters, you no doubt noticed what happens when your program “crashes” or terminates due to unresolved errors. A “traceback” notice appears along with a notice containing  as  much  diagnostic  information  as  the  interpreter  can  give  you, including the error name, reason, and perhaps even the line number near or exactly where the error occurred. All errors have a similar format, regardless of whether running within the Python interpreter or standard script execution, providing a consistent error interface. All errors, whether they be syntactical or logical, result from behavior incompatible with the Python interpreter and cause exceptions to be raised.

在先前的一些章节里你已经执行了一些代码, 你一定遇到了程序"崩溃"或因未解决的错误而终止的情况. 你会看到"traceback/跟踪返回"消息, 以及随后解释器向你提供的信息, 包括错误的名称, 原因, 以及发生错误的行号. 不管你是通过 Python 解释器执行还是标准的脚本执行, 所有的错误都符合相似的格式, 这提供了一个一致的错误接口. 所有错误, 无论是语意上的还是逻辑上的, 都是由于和 Python 解释器不相容导致的, 其后果就是引发异常.

Let us take a look at some exceptions now.

我们来看几个异常的例子.



NameError: attempt to access an undeclared variable
    尝试访问一个未申明的变量
>>> foo
Traceback (innermost last): File "<stdin>", line 1, in ?
NameError: name 'foo' is not defined


NameError indicates access to an uninitialized variable. The offending identifier was not found in the Python interpreter’s symbol table. We will be  discussing  namespaces  in  the  next  two  chapters,  but  as  an  introduc- tion, regard them as “address books” linking names to objects. Any object that  is  accessible  should  be  listed  in  a  namespace.  Accessing  a  variable entails a search by the interpreter, and if the name requested is not found in any of the namespaces, a NameError exception will be generated.

NameError 表示我们访问了一个没有初始化的变量. 在 Python 解释器的符号表没有找到那个另人讨厌的变量. 我们将在后面的两章讨论名称空间, 现在大家可以认为它们是连接名字和对象的"地址簿"就可以了. 任何可访问的变量必须在名称空间里列出. 访问变量需要由解释器进行搜索, 如果请求的名字没有在任何名称空间里找到, 那么将会生成一个 NameError 异常.

ZeroDivisionError: division by any numeric zero
    除数为零
    
>>> 1/0
Traceback (innermost last): File "<stdin>", line 1, in ?
ZeroDivisionError: integer division or modulo by zero
　
Our example above used floats, but in general, any numeric division-by-zero will result in a ZeroDivisionError exception.

// 此处有错误 float 其实应为整数// 

我们边的例子使用的是整数, 但事实上, 任何数值被零除都会导致一个 ZeroDivisionError 异常.

SyntaxError: Python interpreter syntax error
    Python 解释器语法错误

>>> for
File "<string>", line 1
for
^
SyntaxError: invalid syntax
　
SyntaxError exceptions  are  the  only  ones  that  do  not  occur  at  run- time. They indicate an improperly constructed piece of Python code which cannot  execute  until  corrected.  These  errors  are  generated  at  compile- time,  when  the  interpreter  loads  and  attempts  to  convert  your  script  to Python  bytecode.  These  may  also  occur  as  a  result  of  importing  a  faulty module.

SyntaxError 异常是唯一不是在运行时发生的异常. 它代表 Python 代码中有一个不正确的结构, 在它改正之前程序无法执行. 这些错误一般都是在编译时发生, Python 解释器无法把你的脚本转化为 Python 字节代码. 当然这也可能是你导入一个有缺陷的模块的时候. 


IndexError: request for an out-of-range index for sequence
        请求的索引超出序列范围
>>> aList = []
>>> aList[0]
Traceback (innermost last): File "<stdin>", line 1, in ?
IndexError: list index out of range

   IndexError is raised when attempting to access an index that is outside the valid range of a sequence.

IndexError 在你尝试使用一个超出范围的值索引序列时引发.

KeyError: request for a non-existent dictionary key
    请求一个不存在的字典关键字

>>> aDict = {'host': 'earth', 'port': 80}
>>> print aDict['server'] Traceback (innermost last):
　File "<stdin>", line 1, in ? KeyError: server
　
Mapping types such as dictionaries depend on keys to access data values. Such values are not retrieved if an incorrect/nonexistent key is requested. In this case, a KeyError is raised to indicate such an incident has occurred.

映射对象, 例如字典, 是依靠关键字(keys)访问数据值的. 如果使用错误的或是不存在的键请求字典就会引发一个 KeyError 异常.

IOError: input/output error
    输入/输出错误
>>> f = open("blah") Traceback (innermost last):
File "<stdin>", line 1, in ?
IOError: [Errno 2] No such file or directory: 'blah'

Attempting to open a nonexistent disk file is one example of an operating system  input/output  (I/O)  error.  Any  type  of  I/O  error  raises  an  IOError exception.

类似尝试打开一个不存在的磁盘文件一类的操作会引发一个操作系统输入/输出(I/O)错误. 任何类型的 I/O 错误都会引发 IOError 异常.

AttributeError: attempt to access an unknown object attribute
    尝试访问未知的对象属性
>>> class myClass(object):
...    pass
...
>>> myInst = myClass()
>>> myInst.bar = 'spam'
>>> myInst.bar
'spam'
>>> myInst.foo
Traceback (innermost last): File "<stdin>", line 1, in ?
AttributeError: foo

　In our example, we stored a value in myInst.bar, the bar attribute of instance myInst. Once an attribute has been defined, we can access it using the familiar dotted-attribute notation, but if it has not, as in our case with the foo (non-)attribute, an AttributeError occurs.

在我们的例子中, 我们在 myInst.bar 储存了一个值, 也就是实例 myInst 的 bar 属性. 属性被定义后, 我们可以使用熟悉的点/属性操作符访问它, 但如果是没有定义属性, 例如我们访问 foo 属性, 将导致一个 AttributeError 异常.


10.3  Detecting and Handling Exceptions
=检测和处理异常=

Exceptions can be detected by incorporating them as part of a try statement. Any code suite of a try statement will be monitored for exceptions.

异常可以通过 try 语句来检测. 任何在 try 语句块里的代码都会被监测, 检查有无异常发生.

There  are  two  main  forms  of  the  try statement:  try-except and  try- finally. These statements are mutually exclusive, meaning that you pick only one of them. A try statement can be accompanied by one or more except clauses, exactly one finally clause, or a hybrid try-except-finally combination.

try 语句有两种主要形式: try-except 和 try-finally . 这两个语句是互斥的, 也就是说你只能使用其中的一种. 一个 try 语句可以对应一个或多个 except 子句, 但只能对应一个 finally 子句, 或是一个 try-except-finally 复合语句.

try-except statements allow one to detect and handle exceptions. There
is even an optional else clause for situations where code needs to run only when no exceptions are detected. Meanwhile, try-finally statements allow only for detection and processing of any obligatory cleanup (whether or not exceptions occur), but otherwise have no facility in dealing with exceptions. The combination, as you might imagine, does both.

你可以使用 try-except 语句检测和处理异常. 你也可以添加一个可选的 else 子句处理没有探测到异常的时执行的代码. 而 try-finally 只允许检测异常并做一些必要的清除工作(无论发生错误与否), 没有任何异常处理设施. 正如你想像的,复合语句两者都可以做到. 

10.3.1  try-except Statement
==try-except 语句==

The try-except statement (and more complicated versions of this statement) allows  you  to  define  a  section  of  code  to  monitor  for  exceptions  and  also provides the mechanism to execute handlers for exceptions.

try-except 语句(以及其更复杂的形式)定义了进行异常监控的一段代码, 并且提供了处理异常的机制.

The syntax for the most general try-except statement is given below. It consists of the keywords along with the try and except blocks (try_suite and except_suite) as well as optionally saving the reason of failure:

最常见的 try-except 语句语法如下所示. 它由 try 块和 except 块(try_suite 和 except_suite )组成, 也可以有一个可选的错误原因.

try:
    try_suite    # watch for exceptions here 监控这里的异常
except Exception[, reason]:
    except_suite    # exception-handling code  异常处理代码

Let us give one example, then explain how things work. We will use our
IOError example from above. We can make our code more robust by adding
a try-except “wrapper” around the code:

我们用一个例子说明这一切是如何工作的. 我们将使用上边的 IOError 例子, 把我们的代码封装在 try-except 里, 让代码更健壮:

>>> try:
...        f = open('blah', 'r')
... except IOError, e:
...        print 'could not open file:', e
...
could not open file: [Errno 2] No such file or directory


As you can see, our code now runs seemingly without errors. In actual-
ity, the same IOError still occurred when we attempted to open the non- existent  file.  The  difference?  We  added  code  to  both  detect  and  handle the error. When the IOError exception was raised, all we told the inter- preter to do was to output a diagnostic message. The program continues and does not “bomb out” as our earlier example—a minor illustration of the power of exception handling. So what is really happening codewise?

如你所见, 我们的代码运行时似乎没有遇到任何错误. 事实上我们在尝试打开一个不存在的文件时仍然发生了 IOError . 有什么区别么?  我们加入了探测和错误错误的代码. 当引发 IOError 异常时, 我们告诉解释器让它打印出一条诊断信息. 程序继续执行, 而不像以前的例子那样被"轰出来" - 异常处理小小地显了下身手. 那么在代码方面发生了什么呢?

During runtime, the interpreter attempts to execute all the code within the try statement. If an exception does not occur when the code block has completed, execution resumes past the except statement. When the speci- fied exception named on the except statement does occur, we save the reason, and control flow immediately continues in the handler (all remaining code in the try clause is skipped) where we display our error message along with the cause of the error.

在程序运行时, 解释器尝试执行 try 块里的所有代码, 如果代码块完成后没有异常发生, 执行流就会忽略 except 语句继续执行. 而当 except 语句所指定的异常发生后, 我们保存了错误的原因, 控制流立即跳转到对应的处理器( try 子句的剩余语句将被忽略), 本例中我们显示出一个包含错误原因的错误信息.

　In  our  example  above,  we  are  catching  only  IOError exceptions.  Any other  exception  will  not  be  caught  with  the  handler  we  specified.  If,  for example, you want to catch an OSError, you have to add a handler for that particular exception. We will elaborate on the try-except syntax more as we progress further in this chapter.

在我们上边的例子中, 我们只捕获 IOError 异常. 任何其他异常不会被我们指定的处理器捕获. 举例说, 如果你要捕获一个 OSError , 你必须加入一个特定的异常处理器. 我们将在本章后面详细地介绍 try-except 语法.

//--------------------
CORE NOTE: Skipping code, continuation, and upward propagation

核心笔记: 忽略代码, 继续执行, 和向上移交

The remaining code in the try suite from the point of the exception is
never reached (hence never executed). Once an exception is raised, the
race is on to decide on the continuing flow of control. The remaining code is skipped, and the search for a handler begins. If one is found, the program continues in the handler.

try 语句块中异常发生点后的剩余语句永远不会到达(所以也永远不会执行). 一旦一个异常被引发, 就必须决定控制流下一步到达的位置. 剩余代码将被忽略, 解释器将搜索处理器, 一旦找到, 就开始执行处理器中的代码.

If the search is exhausted without finding an appropriate handler, the exception is then propagated to the caller’s level for handling, meaning the stack frame immediately preceding the current one. If there is no handler
at the next higher level, the exception is yet again propagated to its caller. If the top level is reached without an appropriate handler, the exception is considered unhandled, and the Python interpreter will display the traceback and exit.

如果没有找到合适的处理器, 那么异常就向上移交给调用者去处理, 这意味着堆栈框架立即回到之前的那个. 如果在上层调用者也没找到对应处理器, 该异常会继续被向上移交, 直到找到合适处理器. 如果到达最顶层仍然没有找到对应处理器, 那么就认为这个异常是未处理的, Python 解释器会显示出跟踪返回消息, 然后退出.

// 核心笔记结束

10.3.2  Wrapping a Built-in Function
==封装内建函数==

We will now present an interactive example—starting with the bare necessity of detecting an error, then building continuously on what we have to further improve the robustness of our code. The premise is in detecting errors while trying to convert a numeric string to a proper (numeric object) representation of its value.

我们现在给出一个交互操作的例子 - 从最基本的错误检测开始, 然后逐步改进它, 增强代码的健壮性. 这里的问题是把一个用字符串表示的数值转换为正确的数值表示形式, 而且在过程中要检测并处理可能的错误.

　The float() built-in function has a primary purpose of converting any numeric type to a float. In Python 1.5, float() was given the added feature
of being able to convert a number given in string representation to an actual float value, obsoleting the use of the atof() function of the string module. Readers  with  older  versions  of  Python  may  still  use  string.atof(), replacing float(), in the examples we use here.

float() 内建函数的基本作用是把任意一个数值类型转换为一个浮点数. 从 Python 1.5 开始, float() 增加了把字符串表示的数值转换为浮点数的功能, 没必要使用 string 模块中的 atof() 函数. 如果你使用的老版本的 Python , 请使用 string.atof() 替换这里的 float() .

>>> float(12345)
12345.0
>>> float('12345')
12345.0
>>> float('123.45e67')
1.2345e+069

Unfortunately, float() is not very forgiving when it comes to bad input:

不幸的是, float() 对输入很挑剔:

>>> float('foo')
Traceback (innermost last): File "<stdin>", line 1, in ?
float('foo')
ValueError: invalid literal for float(): foo
>>>
>>> float(['this is', 1, 'list']) Traceback (innermost last):
File "<stdin>", line 1, in ?
float(['this is', 1, 'list'])
TypeError: float() argument must be a string or a number

　Notice  in  the  errors  above  that  float() does  not  take  too  kindly  to strings  that  do  not  represent  numbers  or  non-strings.  Specifically,  if  the correct  argument  type  was  given  (string  type)  but  that  type  contained  an invalid value, the exception raised would be  ValueError because it was the value that was improper, not the type. In contrast, a list is a bad argu- ment  altogether,  not  even  being  of  the  correct  type;  hence,  TypeError was thrown.

从上面的错误我们可以看出, float() 对不合法的参数很不客气. 例如, 如果参数的类型正确(字符串), 但值不可转换为浮点数, 那么将引发 ValueError 异常, 因为这是值的错误. 列表也是不合法的参数, 因为他的类型不正确, 所以, 引发一个 TypeError 异常.

Our  exercise  is  to  call  float() “safely,”  or  in  a  more  “safe  manner,” meaning that we want to ignore error situations because they do not apply to our task of converting numeric string values to floating point numbers, yet are not severe enough errors that we feel the interpreter should aban- don  execution.  To  accomplish  this,  we  will  create  a  “wrapper”  function, and, with the help of  try-except, create the environment that we envi- sioned. We shall call it safe_float(). In our first iteration, we will scan and  ignore  only  ValueErrors,  because  they  are  the  more  likely  culprit. TypeErrors rarely happen since somehow a non-string must be given to float().

我们的目标是"安全地"调用 float() 函数, 或是使用一个"安全的方式" 忽略掉错误, 因为它们与我们转换数值类型的目标没有任何联系, 而且这些错误也没有严重到要让解释器终止执行. 为了实现我们的目的, 这里我们创建了一个"封装"函数, 在 try-except 的协助下创建我们预想的环境, 我们把他叫做 safe_float() . 在第一次改进中我们搜索并忽略 ValueError , 因为这是最常发生的. 而 TypeError 并不常见, 我们一般不会把非字符串数据传递给 float().


def safe_float(obj):
    try:
        return float(obj)
    except ValueError:
        pass

　The first step we take is to just “stop the bleeding.” In this case, we make the error go away by just “swallowing it.” In other words, the error will be detected, but since we have nothing in the except suite (except the pass statement,  which  does  nothing  but  serve  as  a  syntactical  placeholder  for where code is supposed to go), no handling takes place. We just ignore the error.

我们采取的第一步只是"止血". 在上面的例子中, 我们把错误"吞了下去". 换句话说, 错误会被探测到, 而我们在 except 从句里没有放任何东西(除了一个 pass , 这是为了语法上的需要.), 不进行任何处理, 忽略这个错误.

　One obvious problem with this solution is that we did not explicitly return anything to the function caller in the error situation. Even though  None is returned (when a function does not return any value explicitly, i.e., completing execution without encountering a return object statement), we give little or no hint that anything wrong took place. The very least we should do is to explicitly return None so that our function returns a value in both cases and makes our code somewhat easier to understand:

这个解决方法有一个明显的不足, 它在出现错误的时候没有明确地返回任何信息. 虽然返回了 None(当函数没有显式地返回一个值时, 例如没有执行到 return object 语句函数就结束了, 它就返回 None), 我们并没有得到任何关于出错信息的提示. 我们至少应该显式地返回 None , 来使代码更容易理解:

def safe_float(obj):
    try:
        retval = float(obj)
    except ValueError:
        retval = None
        return retval

　Bear in mind that with our change above, nothing about our code changed except  that  we  used  one  more  local  variable.  In  designing  a  well-written application programmer interface (API), you may have kept the return value more flexible. Perhaps you documented that if a proper argument was passed to safe_float(), then indeed, a floating point number would be returned, but in the case of an error, you chose to return a string indicating the prob- lem with the input value. We modify our code one more time to reflect this change:

注意我们刚才做的修改, 我们只是添加了一个局部变量. 在设计良好的应用程序接口(Application Programmer Interface, API)时, 返回值可以更灵活. 你可以在文档中这样写, 如果传递给 safe_float() 合适的参数, 它将返回一个浮点数; 如果出现错误, 将返回一个字符串说明输入数据有什么问题. 我们按照这个方案再修改一次代码, 如下所示:

def safe_float(obj):
    try:
        retval = float(obj)
    except ValueError:
        retval = 'could not convert non-number to float'
        return retval

The only thing we changed in the example was to return an error string as opposed to just None. We should take our function out for a test drive to see how well it works so far:

这里我们只是把 None 替换为一个错误字符串. 下面我们试试这个函数看看它表现如何:

>>> safe_float('12.34')
12.34
>>> safe_float('bad input')
'could not convert non-number to float'

We made a good start—now we can detect invalid string input, but we are still vulnerable to invalid objects being passed in:

我们有了一个好的开始 - 现在我们已经可以探测到非法的字符串输入了, 可如果传递的是一个非法的对象, 还是会"受伤":

>>> safe_float({'a': 'Dict'}) 
Traceback (innermost last):
File "<stdin>", line 3, in ?
retval = float(obj)
TypeError: float() argument must be a string or a number
　
We  will  address  this  final  shortcoming  momentarily,  but  before  we  further modify our example, we would like to highlight the flexibility of the try-except syntax, especially the except statement, which comes in a few more flavors.

我们暂时只是指出这个缺点, 在进一步改进程序之前, 首先来看看 try-except 的其他灵活的语法, 特别是 except 语句, 它有好几种变化形式.

10.3.3  try Statement with Multiple excepts
==带有多个 except 的 try 语句==

Earlier in this chapter, we introduced the following general syntax for except:

在本章的前边, 我们已经介绍了 except 的基本语法:

except Exception[, reason]:
    suite_for_exception_Exception
　
The  except statement  in  such  formats  specifically  detects  exceptions named Exception. You can chain multiple except statements together to handle different types of exceptions with the same try:

这种格式的 except 语句指定检测名为 Exception 的异常. 你可以把多个 except 语句连接在一起, 处理一个 try 块中可能发生的多种异常, 如下所示:

except Exception1[, reason1]:
    suite_for_exception_Exception1
except Exception2[, reason2]:
    suite_for_exception_Exception2
    :
    
This  same  try clause  is  attempted,  and  if  there  is  no  error,  execution continues,  passing  all  the  except clauses.  However,  if  an  exception  does occur, the interpreter will look through your list of handlers attempting to match the exception with one of your handlers (except clauses). If one is found, execution proceeds to that except suite.
　
同样, 首先尝试执行 try 子句, 如果没有错误, 忽略所有的 except 从句继续执行.  如果发生异常, 解释器将在这一串处理器(except 子句)中查找匹配的异常. 如果找到对应的处理器, 执行流将跳转到这里.

Our  safe_float() function  has  some  brains  now  to  detect  specific exceptions. Even smarter code would handle each appropriately. To do that, we have to have separate except statements, one for each exception type. That  is  no  problem  as  Python  allows  except statements  can  be  chained together. We will now create separate messages for each error type, providing even more detail to the user as to the cause of his or her problem:

我们的 safe_float() 函数已经可以检测到指定的异常了. 更聪明的代码能够处理好每一种异常. 这就需要多个 except 语句, 每个 except 语句对应一种异常类型. Python 支持把 except 语句串连使用 我们将分别为每个异常类型分别创建对应的错误信息, 用户可以得到更详细的关于错误的信息:

def safe_float(obj):
    try:
    retval = float(obj)
    except ValueError:
    retval = 'could not convert non-number to float'
    except TypeError:
    retval = 'object type cannot be converted to float'
    return retval

Running the code above with erroneous input, we get the following:

使用错误的参数调用这个函数, 我们得到下面的输出结果:

>>> safe_float('xyz') 
'could not convert non-number to float'
>>> safe_float(())
'argument must be a string'
>>> safe_float(200L)
200.0
>>> safe_float(45.67000)
45.67

10.3.4  except Statement with Multiple Exceptions
==处理多个异常的 except 语句==

We  can  also  use  the  same  except clause  to  handle  multiple  exceptions. except statements that process more than one exception require that the set of exceptions be contained in a tuple:

我们还可以在一个 except 子句里处理多个异常. except 语句在处理多个异常时要求异常被放在一个元组里:

except (Exception1, Exception2)[, reason]:
    suite_for_Exception1_and_Exception2

　The above syntax example illustrates how two exceptions can be handled by  the  same  code.  In  general,  any  number  of  exceptions  can  follow  an except statement as long as they are all properly enclosed in a tuple:

上边的语法展示了如何处理同时处理两个异常. 事实上 except 语句可以处理任意多个异常, 前提只是它们被放入一个元组里 , 如下所示:

except (Exc1[, Exc2[, ... ExcN]])[, reason]:
    suite_for_exceptions_Exc1_to_ExcN

If for some reason, perhaps due to memory constraints or dictated as part
of the design that all exceptions for our  safe_float() function must be handled by the same code, we can now accommodate that requirement:

如果由于其他原因, 也许是内存规定或是设计方面的因素, 要求 safe_float() 函数中的所有异常必须使用同样的代码处理, 那么我们可以这样满足需求:

def safe_float(obj):
    try:
    retval = float(obj)
    except (ValueError, TypeError):
    retval = 'argument must be a number or numeric string'
    return retval


Now there is only the single error string returned on erroneous input:

现在, 错误的输入会返回相同的字符串:

>>> safe_float('Spanish Inquisition')
'argument must be a number or numeric string'
>>> safe_float([])
'argument must be a number or numeric string'
>>> safe_float('1.6')
1.6
>>> safe_float(1.6)
1.6
>>> safe_float(932)
932.0

10.3.5  Catching All Exceptions
==捕获所有异常==

Using the code we saw in the previous section, we are able to catch any num- ber of specific exceptions and handle them. What about cases where we want to catch all exceptions? The short answer is yes, we can definitely do it. The code for doing it was significantly improved in 1.5 when exceptions became classes. Because of this, we now have an exception hierarchy to follow.
　
使用前一节的代码, 我们可以捕获任意数目的指定异常, 然后处理它们. 如果我们想要捕获所有的异常呢? 当然可以! 自版本 1.5 后, 异常成为类, 实现这个功能的代码有了很大的改进. 也因为这点(异常成为类),我们现在有一个异常继承结构可以遵循. 


If we go all the way up the exception tree, we find Exception at the top, so our code will look like this:

如果查询异常继承的树结构, 我们会发现 Exception 是在最顶层的, 所以我们的代码可能看起来会是这样:

try:
    :
except Exception, e:
    # error occurred, log 'e', etc.

Less preferred is the bare except clause:

另一个我们不太推荐的方法是使用 裸except子句:

try:
    :
except:
    # error occurred, etc.
　
This syntax is not as “Pythonic” as the other. Although this code catches the most exceptions, it does not promote good Python coding style. One of the chief reasons is that it does not take into account the potential root causes of  problems  that  may  generate  exceptions.  Rather  than  investigating  and discovering what types of errors may occur and how they may be prevented from happening, we have a catch-all that may not do the right thing.

这个语法不如前个 "Pythonic" . 虽然这样的代码捕获大多异常, 但它不是好的 Python 编程样式. 一个主要原因是它不会考虑潜在的会导致异常的主要原因. 我们的 catch-all 语句可能不会如你所想的那样工作, 它不会调查发生了什么样的错误, 如何避免它们. 

// 最好在这里加入对 Pythonic 的解释
　We are not naming any specific exceptions to catch—it does not give us any  information  about  the  possible  errors  that  could  happen  in  our  try block. Another thing is that by catching all errors, you may be silently drop- ping important errors that really should be sent to the caller to properly take care of them. Finally, we do not have the opportunity to save the reason for the exception. Yes, you can get it through  sys.exc_ info(), but then you would have to import sys and execute that function—both of which can be avoided, especially if all we wanted was the instance telling us why the exception occurred. It is a distinct possibility that the bare exception clause  will  be  deprecated  in  a  future  release  of  Python.  (See  also  Core Style note).

我们没有指定任何要捕获的异常 - 这不会给我们任何关于可能发生的错误的信息. 另外它会捕获所有异常, 你可能会忽略掉重要的错误, 正常情况下这些错误应该让调用者知道并做一定处理. 最后, 我们没有机会保存异常发生的原因. 当然, 你可以通过sys.exc_info() 获得它, 但这样你就不得不去导入 sys 模块, 然后执行函数 - 这样的操作本来是可以避免的, 尤其当我们需要立即告诉用户为什么发生异常的时候.在Python 的未来版本中很可能不再支持裸except子句.  (参见“核心风格”)

One aspect of catching all exceptions that you need to be aware of is that there are several exceptions that are not due to an error condition. These two excep- tions are SystemExit and KeyboardInterrupt. SystemExit is for when the  current  Python  application  wants  to  quit,  and  KeyboardInterrupt is when a user presses CTRL-C (^C) to terminate Python. These will be caught by both code snippets above when we really want to pass them upward. A typical workaround code pattern will look like this:

关于捕获所有异常, 你应当知道有些异常不是由于错误条件引起的. 它们是 SystemExit 和 KeyboardInterupt . SystemExit 是由于当前 Python 应用程序需要退出, KeyboardInterupt 代表用户按下了 CTRL-C (^C) , 想要关闭 Python . 在真正需要的时候, 这些异常却会被异常处理捕获. 一个典型的迂回工作法代码框架可能会是这样:

try:
    :
except (KeyboardInterupt, SystemExit):
    # user wants to quit
    raise    # reraise back to caller
except Exception:
    # handle real errors

　A few things regarding exceptions did change in Python 2.5. Exceptions were  moved  to  new-style  classes,  a  new  “mother  of  all  exception”  classes named  BaseException was  installed,  and  the  exception  hierarchy  was switched around (very slightly) to get rid of that idiom of having to create two handlers. Both KeyboardInterrupt and SystemExit have been pulled out from being children of Exception to being its peers:

关于异常的一部分内容在 Python 2.5 有了一些变化. 异常被迁移到了 new-style class 上, 启用了一个新的"所有异常的母亲", 这个类叫做 BaseException , 异常的继承结构有了少许调整, 为了让人们摆脱不得不除创建两个处理器的惯用法. KeyboardInterrupt 和 SystemExit 被从 Exception 里移出, 和 Exception 平级:

- BaseException
    |- KeyboardInterrupt
    |- SystemExit
    |- Exception
    |- (all other current built-in exceptions) 所有当前内建异常

You  can  find  the  entire  exception  hierarchy  (before  and  after  these changes) in Table 10.2.

你可以在表 10.2 找到整个异常继承结构(变化前后).

The end result is that now you do not have to write the extra handler for those two exceptions if you have a handler for just  Exception. This code will suffice:

这样, 当你已经有了一个 Exception 处理器后, 你不必为这两个异常创建额外的处理器. 代码将会是这样:

try:
    :
except Exception, e:
    # handle real errors

If  you  really  want  to  catch  all  errors,  you  can  still  do  that  too,  but  use BaseException instead:

如果你确实需要捕获所有异常, 那么你就得使用新的 BaseException :

try:
    :
except BaseException, e:
    # handle all errors

And of course, there is the less preferred bare except.

当然, 也可以使用不被推荐的裸except语句.

// 核心风格
CORE STYLE: Do not handle and ignore all errors

核心风格: 不要处理并忽略所有错误

The try-except statement has been included in Python to provide a powerful mechanism for programmers to track down potential errors and perhaps to provide logic within the code to handle situations where it may not otherwise be possible, for example, in C. The main idea is to minimize the number of errors and still maintain program correctness. As with all tools, they must be used properly.

Python 提供给程序员的 try-except 语句是为了更好地跟踪潜在的错误并在代码里准备好处理异常的逻辑. 这样的机制在其他语言(例如 C ) 是很难实现的. 它的目的是减少程序出错的次数并在出错后仍能保证程序正常执行. 作为一种工具而言, 只有正确得当地使用它, 才能使其发挥作用.

One incorrect use of try-except is to serve as a giant bandage over large pieces of code. By that we mean putting large blocks, if not your entire source code, within a try and/or have a large generic except to “filter” any fatal errors by ignoring them:

一个不正确的使用方法就是把它作为一个大绷带"绑定"到一大片代码上. 也就是说把一大段程序(如果还不是整个程序源代码的话)放入一个 try 块中, 再用一个通用的 except 语句 "过滤" 掉任何致命的错误, 忽略它们.

# this is really bad code
try:
    large_block_of_code  # bandage of large piece of code
except Exception:    # same as except:
    pass    # blind eye ignoring all errors

Obviously, errors cannot be avoided, and the job of try-except is to provide a mechanism whereby an acceptable problem can be remedied or properly dealt with, and not be used as a filter. The construct above will
hide many errors, but this type of usage promotes a poor engineering practice that we certainly cannot endorse.

很明显, 错误无法避免, try-except 的作用是提供一个可以提示错误或处理错误的机制, 而不是一个错误过滤器.  上边这样的结构会忽略许多错误, 这样的用法是缺乏工程实践的表现, 我们不赞同这样做.

Bottom line: Avoid using try-except around a large block of code with a
pass just to hide errors. Instead, either handle specific exceptions and
ignore them (pass), or handle all errors and take a specific action. Do not
do both (handle all errors, ignore all errors).

底线: 避免把大片的代码装入 try-except 中然后使用 pass 忽略掉错误. 你可以捕获特定的异常并忽略它们, 或是捕获所有异常并采取特定的动作. 不要捕获所有异常,然后忽略掉它们.

// 核心风格 ends

10.3.6  “Exceptional Arguments”
==异常参数==

No,  the  title  of  this  section  has  nothing  to  do  with  having  a  major  fight. Instead, we are referring to the fact that an exception may have an argument or reason passed along to the exception handler when they are raised. When an exception is raised, parameters are generally provided as an additional aid for the exception handler. Although reasons for exceptions are optional, the stan- dard built-in exceptions do provide at least one argument, an error string indi- cating the cause of the exception.

// 第一句好像是和 argument 的另个意思有关.
异常也可以有参数, 异常引发后它会被传递给异常处理器. 当异常被引发后参数是作为附加帮助信息传递给异常处理器的. 虽然异常原因是可选的, 但标准内建异常提供至少一个参数, 指示异常原因的一个字符串.

Exception parameters can be ignored in the handler, but the Python pro- vides syntax for saving this value. We have already seen it in the syntax above: to access any provided exception reason, you must reserve a variable to hold the argument. This argument is given on the except header line and follows the exception type you are handling. The different syntaxes for the except statement can be extended to the following:

异常的参数可以在处理器里忽略, 但 Python 提供了保存这个值的语法. 我们已经在上边接触到相关内容: 要想访问提供的异常原因, 你必须保留一个变量来保存这个参数. 把这个参数放在 except 语句后, 接在要处理的异常后面. except 语句的这个语法可以被扩展为:

# single exception
except Exception[, reason]:
    suite_for_Exception_with_Argument

# multiple exceptions
except (Exception1, Exception2, ..., ExceptionN)[, reason]:
    suite_for_Exception1_to_ExceptionN_with_Argument

　reason is a class instance containing diagnostic information from the code raising the exception. The exception arguments themselves go into a tuple that is stored as an attribute of the class instance, an instance of the exception class from which it was instantiated. In the first alternate syntax above, rea- son is an instance of the Exception class.

reason 将会是一个包含来自导致异常的代码的诊断信息的类实例. 异常参数自身会组成一个元组,并存储为类实例(异常类的实例)的属性. 上边的第一种用法中, reason 将会是一个 Exception 类的实例.

For  most  standard  built-in  exceptions,  that  is,  exceptions  derived
from  StandardError,  the  tuple  consists  of  a  single  string  indicating the  cause  of  the  error.  The  actual  exception  name  serves  as  a  satisfactory clue, but the error string enhances the meaning even more. Operating  system  or  other  environment  type  errors,  i.e.,  IOError,  will  also include an operating system error number that precedes the error string in the tuple.

对于大多内建异常, 也就是从 StandardError 派生的异常, 这个元组只包含一个指示错误原因的字符串. 一般说来, 异常的名字已经是一个满意的线索了, 但这个错误字符串会提供更多的信息. 操作系统或其他环境类型的错误, 例如 IOError , 元组中会把操作系统的错误编号放在错误字符串前.

　Whether a reason contains just a string or a combination of an error num- ber  and  a  string,  calling  str(reason) should  present  a  human-readable cause  of  an  error.  However,  do  not  lose  sight  that  reason is  really  a  class instance—you are only getting the error information via that class’s special method __str__(). We have a complete treatment of special methods as we explore object-oriented programming in Chapter 13.

无论 reason 只包含一个字符串或是由错误编号和字符串组成的元组, 调用 str(reason) 总会返回一个良好可读的错误原因. 不要忘记 reason 是一个类实例 - 这样做你其实是调用类的特殊方法 __str__() . 我们将在第 13 章探索面向对象编程中的这些特殊方法.

The only caveat is that not all exceptions raised in third-party or otherwise external  modules  adhere  to  this  standard  protocol  of  error  string  or  error number and error string. We recommend you follow such a standard when raising your own exceptions (see Core Style note).

唯一的问题就是某些第三方或是其他外部库并不遵循这个标准协议. 我们推荐你在引发你自己的异常时遵循这个标准(参见核心风格笔记).

// 核心风格
CORE STYLE: Follow exception argument protocol

核心风格: 遵循异常参数规范

When you raise built-in exceptions in your own code, try to follow the protocol established by the existing Python code as far as the error information that is part of the tuple passed as the exception argument. In other words, if you raise a ValueError, provide the same argument information as when the interpreter raises a ValueError exception, and so on. This helps keep the code consistent and will prevent other applications that use your module from breaking.

当你在自己的代码中引发内建(built-in)的异常时, 尽量遵循规范, 用和已有 Python 代码一致错误信息作为传给异常的参数元组的一部分. 简单地说, 如果你引发一个 ValueError , 那么最好提供和解释器引发 ValueError 时一致的参数信息, 如此类推. 这样可以在保证代码一致性,同时也能避免其他应用程序在使用你的模块时发生错误. 

// 核心风格结束

The example below is when an invalid object is passed to the  float() built-in function, resulting in a TypeError exception:

如下边的例子, 它传参给内建 float 函数一个无效的对象, 引发TypeError异常:

>>> try:
...        float(['float() does not', 'like lists', 2])
... except TypeError, diag:# capture diagnostic info
...        pass
...
>>> type(diag)
<class 'exceptions.TypeError'>
>>>
>>> print diag
float() argument must be a string or a number

The first thing we did was cause an exception to be raised from within the try statement. Then we passed cleanly through by ignoring but saving the error information. Calling the type() built-in function, we were able to confirm that our exception was indeed an instance of the TypeError exception class. Finally, we displayed the error by calling print with our diagnostic exception argument.

我们首先在一个try语句块中引发一个异常，随后简单的忽略了这个异常，但保留了错误的信息。调用内置的type()函数，我们可以确认我们的异常对象的确是TypeError异常类的实例。最后我们对异常诊断参数调用print以显示错误。

To obtain more information regarding the exception, we can use the special __class__ instance attribute, which identifies which class an instance was instantiated from. Class objects also have attributes,	 such as a documentation string and a string name that further illuminate the error type:

为了获得更多的关于异常的信息,我们可以调用该实例的 __class__ 属性,它标示了实例是从什么类实例化而来. 类对象也有属性, 比如文档字符串(documentation string)和进一步阐明错误类型的名称字符串:

>>> diag    # exception instance object
<exceptions.TypeError instance at 8121378>
>>> diag.__class__    # exception class object
<class exceptions.TypeError at 80f6d50>
>>> diag.__class__.__doc__    # exception class documentation string
'Inappropriate argument type.'
>>> diag.__class__.__name__    # exception class name
'TypeError'

As we will discover in Chapter 13—Classes and OOP—the special instance attribute  __class__ exists  for  all  class  instances,  and  the  __doc__ class attribute is available for all classes that define their documentation strings.

我们会在第13章"类和面向对象编程"发现, __class__ 属性存在于所有的类实例中,而__doc__ 类属性存在于所有的定义了文档字符串的类中.

We will now update our safe_float() one more time to include the exception argument, which is passed from the interpreter from within float() when exceptions are generated. In our last modification to safe_float(), we merged both the handlers for the  ValueError and TypeError exceptions into one because we had to satisfy some requirement. The problem, if any, with this solution is that no clue is given as to which exception was raised or what caused the error. The only thing returned is an error string that indicated some form of invalid argu- ment. Now that we have the exception argument, this no longer has to be the case. 

我们现在再次来改进我们的saft_float()以包含异常参数,当float()发生异常时传给解释器.在前一次改进中,我们在一句话中同时捕获了ValueError和TypeError异常以满足某些需求.但还是有瑕疵,那个解决方案中没有线索表明是哪一种异常引发了错误.它仅仅是返回了一个错误字符串指出有无效的参数.现在,通过异常参数,可以改善这种状况.

Because each exception will generate its own exception argument, if we chose to return this string rather than a generic one we made up, it would provide a bet- ter clue as to the source of the problem. In the following code snippet, we replace our single error string with the string representation of the exception argument.

因为每一个异常都将生成自己的异常参数,如果我们选择用这个字符串来而不是我们自定义的信息,可以提供一个更好的线索来指出问题.下面的代码片段中,我们用字符串化(string representation)的异常参数来替换单一的错误信息.

def safe_float(object):
    try:
        retval = float(object)
    except (ValueError, TypeError), diag:
        retval = str(diag)
    return retval

Upon running our new code, we obtain the following (different) messages when providing improper input to safe_float(), even if both exceptions are managed by the same handler:

在此基础上运行我们的新代码,当我们提供sofe_float()的参数给不恰当时,虽然还是只有一条捕获语句,但是可以获得如下(不同的)信息.
 
>>> safe_float('xyz')
'invalid literal for float(): xyz'
>>> safe_float({})
'object can't be converted to float'

10.3.7  Using Our Wrapped Function in an Application

10.3.7  在应用使用我们封装的函数

We will now feature safe_float() in a mini application that takes a credit card transaction  data  file  (carddata.txt)  and  reads  in  all  transactions,  including explanatory strings. Here are the contents of our example carddata.txt file:

我们将在一个迷你应用中特地的使用这个函数.它将打开信用卡交易的数据文件(carddata.txt),加载所有的交易,包括解释的字符串.下面是一个示例的carddate.txt文件:

% cat carddata.txt
# carddata.txt previous balance
25
debits
21.64
541.24
25
credits
-25
-541.24
finance charge/late fees
7.30
5

Our program, cardrun.py, is given in Example 10.1.
我们的程序,cardrun.py,见示例10.1



Example 10.1  Credit Card Transactions (cardrun.py)

示例 10.1 信用卡交易系统(cardrun.py)

We use safe_float() to process a set of credit card transactions given in a file and read in as strings. A log file tracks the processing.

我们用safe_float()来处理信用卡交易文件,将其作为字符串读入.并用一个日志文件跟踪处理进程.

1    #!/usr/bin/env python
2
3    def safe_float(obj):
4        'safe version of float()'
5        try:
6            retval = float(obj)
7        except (ValueError, TypeError), diag:
8            retval = str(diag)
9            return retval
10
11 def main():
12      'handles all the data processing'
13        log = open('cardlog.txt', 'w')
14        try:
15            ccfile = open('carddata.txt', 'r')
16        except IOError, e:
17            log.write('no txns this month\n')
18        log.close()
19        return
20
21        txns = ccfile.readlines()
22        ccfile.close()
23        total = 0.00
24        log.write('account log:\n')
25
26        for eachTxn in txns:
27            result = safe_float(eachTxn)
28            if isinstance(result, float):
29                total += result
30                log.write('data... processed\n')
31            else:
32              log.write('ignored: %s' % result)
33      print '$%.2f (new balance)' % (total)
34                log.close()
35
36  if __name__ == '__main__':
37        main()



Line-by-Line Explanation

逐行解读

Lines 3–9
This chunk of code contains the body of our safe_float() function.

行 3-9
这段代码是safe_float()函数的主体

Lines 11–34
The  core  part  of  our  application  performs  three  major  tasks:  (1)  read  the credit card data file, (2) process the input, and (3) display the result. 

行 11-34
我们应用的核心部分有3个主要任务
(1)读入信用卡的数据文件
(2)处理输入
(3)显示结果

Lines 14–22 

行 14-22

perform the extraction of data from the file. You will notice that there is a try-except statement surrounding the file open.

从文件中提取数据.你可以看到这里的文件打开被置于try-except语句段中.

A log file of the processing is also kept. In our example, we are assuming the log file can be opened for write without any problems. You will find that our progress is kept by the log. If the credit card data file cannot be accessed, we will assume there are no transactions for the month (lines 16–19).

同时还有一个处理的日志文件.在我们的例子中,我们假设这个日志文件可以不出错的打开.你可以看到我们的处理进程伴随着这个日志文件.如果信用卡的数据文件不能够被访问,我们可以假设该月没有信用卡交易(行 16 - 19).

The data are then read into the txns (transactions) list where it is iterated over in lines 26–32. After every call to safe_float(), we check the result type using the isinstance() built-in function. In our example, we check
to  see  if  safe_float() returns  a  string  or  float.  Any  string  indicates  an error situation with a string that could not be converted to a number, while all other values are floats that can be added to the running subtotal. The final new balance is then displayed as the final line of the main() function.

数据被读入txns(transactions 交易)列表,随后在26-32行遍历它.每次调用safe_float()后,我们用内建的isinstance函数检查结果类型.在我们例子中,我们检查safe_float是返回字符串还是浮点数.任何字符串都意味着错误,表明该行不能转换为数字,同时所有的其他数字可以作为浮点数累加入total.在main()函数的尾行会显示最终生成的余额.

Lines 36–37
These lines represent the general “start only if not imported” functionality. Upon running our program, we get the following output:

行 36-37
这两行通常表明"仅在非导入时启动"的功能.运行我们程序,可以得到如下的输出

$ cardrun.py
$ 58.94 (new balance)

Taking a peek at the resulting log file (cardlog.txt), we see that it con- tains the following log entries after cardrun.py processed the transactions found in carddata.txt:

我们再看看log文件(cardlog.txt),我们可以看到在处理完carddata.txt中的交易后有其有如下的记录条目:

$ cat cardlog.txt
account log:
ignored: invalid literal for float(): # carddata.txt
ignored: invalid literal for float(): previous balance
data... processed
ignored: invalid literal for float(): debits
data... processed
data... processed
data... processed
ignored: invalid literal for float(): credits
data... processed

10.3.8  else Clause

10.3.8  else子句

We have seen the else statement with other Python constructs such as conditionals and loops. With respect to try-except statements, its functionality is not that much different from anything else you have seen: The else clause executes if no exceptions were detected in the preceding try suite.

我们已经看过else语句段配合其他的Python语句,比如条件和循环.至于try-except语句段,它的功能和你所见过的其他else没有太多的不同:在try范围中没有异常被检测到时,执行else子句.

All code within the try suite must have completed successfully (i.e., concluded with no exceptions raised) before any code in the else suite begins execution. Here is a short example in Python pseudocode:

在else范围中的任何代码运行前,try范围中的所有代码必须完全成功(也就是,结束前没有引发异常).下面是用Python伪代码写的简短例子.

import 3rd_party_module

log = open('logfile.txt', 'w')

try:
    3rd_party_module.function()
except:
    log.write("*** caught exception in module\n")
else:
    log.write("*** no exceptions caught\n")
    
log.close()
    
In the preceding example, we import an external module and test it for errors.  A  log  file  is  used  to  determine  whether  there  were  defects  in  the third-party module code. Depending on whether an exception occurred dur- ing execution of the external function, we write differing messages to the log.

在前面的例子中,我们导入了一个外部的模块然后测试是否有错误.用一个日志文件来确定这个第三方模块是有无缺陷.根据运行时是否引发异常,我们将在日志中写入不同的消息.

10.3.9  finally Clause
10.3.9  finally子句

A finally clause is one where its suite or block of code is executed regardless of whether an exception occurred or whether it was caught (or not). You may use a finally clause with try by itself or with try-except (with or with- out  an  else clause).  The  standalone  try-finally is  covered  in  the  next section, so we will just focus on the latter here.

finally子句是无论异常是否发生,是否捕捉都会执行的一段代码.你可以将finally仅仅配合try一起使用,也可以和try-except(else也是可选的)一起使用.独立的try-finally将会在下一章介绍,我们稍后再来研究. 

Starting in Python 2.5, you can use the finally clause (again) with try- except or try-except-else. We say “again” because believe it or not, it is not a new feature. This was a feature available in Python back in the early days but was removed in Python 0.9.6 (April 1992). At the time, it helped simplify the bytecode generation process and was easier to explain, and van Rossum believed  that  a  unified  try-except(-else)-finally would  not  be  very popular anyway. How things change well over a decade later!

从Python 2.5开始,你可以用finally子句(再一次)与try-except或try-except-else一起使用.之所以说是"再一次"是因为无论你相信与否,这并不是一个新的特性.回顾Python初期,这个特性在早已存在,但是在Python 0.9.6(1992 四月)中被移除.那时,这样可以简化字节码的生成,并方便解析,另外就是范·罗萨姆认为一个标准化的try-except(-else)-finally无论如何不会太流行.然而,十年时间改变了一切!

Here is what the syntax would look like with try-except-else-finally:

下面是try-except-else-finally语法的示例:

try:
    A
except MyException: B
else: C
finally: D

The equivalent in Python 0.9.6 through 2.4.x. is the longer:

等价于Python 0.9.6至2.4.x中如下的写法:

try:
    try:
        A
    except MyException:
        B
    else: C
finally:
    D

Of course, in either case, you can have more than one except clause, how- ever the syntax requires at least one except clause and both the else and finally clauses are optional. A, B, C, and D are suites (code blocks). The suites will execute in that order as necessary. (Note the only flows possible are A-C-D
[normal]  and  A-B-D [exception].)  The  finally block  will  be  executed whether exceptions occur in A, B, and/or C. Code written with the older idiom will continue to run, so there are no backward-compatibility problems.

当然,无论如何,你都可以有不止一个的except子句,但最少有一个except语句,而else和finally都是可选的.A,B,C和D是程序(代码块).程序会按预期的顺序执行.(注意:可能的顺序是A-C-D[正常]或A-B-D[异常]).无论异常发生在A,B,和/或C都将执行finally块.旧式写法依然有效,所以没有向后兼容的问题.


10.3.10  try-finally Statement

10.3.10  try-finally语句

An alternative is to use finally alone with try. The try-finally state- ment differs from its try-except brethren in that it is not used to handle exceptions. Instead it is used to maintain consistent behavior regardless of whether or not exceptions occur. We know that the finally suite executes regardless of an exception being triggered within the try suite.

另一种使用finally的方式是finally单独和try连用.这个try-finally语句和try-except区别在于它不是用来捕捉异常的.作为替代,它常常用来维持一致的行为而无论异常是否发生.我们得知无论try中是否有异常触发,finally代码段都会被执行

try:
    try_suite
finally:
    finally_suite    #无论如何都执行


When  an  exception  does  occur  within  the  try suite,  execution  jumps immediately to the finally suite. When all the code in the finally suite completes, the exception is reraised for handling at the next higher layer. Thus
it is common to see a try-finally nested as part of a try-except suite.
One place where we can add a try-finally statement is by improving our
code in cardrun.py so that we catch any problems that may arise from reading
the data from the carddata.txt file. In the current code in Example 10.1, we
do not detect errors during the read phase (using readlines()):

当在try范围中产生一个异常时,(这里)会立即跳转到finally语句段.当finally中的所有代码都执行完毕后,会继续向上一层引发异常.
因而常常看到嵌套在try-except中的try-finally语句.当在读取carddata.txt中文本时可能引发异常,我们可以在cardrun.py的这一处添加try-finally语句段来改进代码.在当前示例10.1的代码中,我们在读取阶段没有探测到错误(通过readlines())

try:
    ccfile = open('carddata.txt')
except IOError:
    log.write('no txns this month\n')

txns = ccfile.readlines()
ccfile.close()

It is possible for readlines() to fail for any number of reasons, one of which  is  if  carddata.txt was  a  file  on  the  network  (or  a  floppy)  that became  inaccessible.  Regardless,  we  should  improve  this  piece  of  code  so that the entire input of data is enclosed in the try clause:

但有很多原因会导致readlines()失败,其中一种就是carddata.txt存在于网络(或软盘)上,但是变得不能读取.无论怎样,我们可以把这一小段读取数据的代码整个放入try子句的范围中:

try:
    ccfile = open('carddata.txt', 'r')
    txns = ccfile.readlines()
    ccfile.close()
except IOError:
    log.write('no txns this month\n')

All we did was to move the readlines() and close() method calls to the try suite. Although our code is more robust now, there is still room for improvement. Notice what happens if there was an error of some sort.
If  the  open  succeeds,  but  for  some  reason  the  readlines() call  does not,  the  exception  will  continue  with  the  except clause.  No  attempt  is made to close the file. Wouldn’t it be nice if we closed the file regardless of whether an error occurred or not? We can make it a reality using try- finally:

我们所做的一切不过是将readline()和close()方法调用都移入了try语句段.尽管我们代码变得更加的健壮了,但还有改进的空间.注意如果按照这样的顺序发生错误:打开成功,但是出于一些原因readlines()调用失败,异常处理会去继续执行except中的子句,而不去尝试关闭文件.难道没有一种好的方式来关闭文件而无论错误是否发生?我们可以通过try-finally来实现:

ccfile = None
try:
    try:
        ccfile = open('carddata.txt', 'r')
        txns = ccfile.readlines()
    except IOError:
        log.write('no txns this month\n')
finally:
    if ccfile:
        ccfile.close()

This code snippet will attempt to open the file and read in the data. If an
error occurs during this step, it is logged, and then the file is properly closed.
If  no  errors  occur,  the  file  is  still  closed.  (The  same  functionality  can  be achieved  using  the  unified  try-except-finally statement  above.)  An alternative  implementation  involves  switching  the  try-except and  try- finally clauses:

代码片段会尝试打开文件并且读取数据.如果在其中的某步发生一个错误,会写入日志,随后文件被正确的关闭.如果没有错误发生,文件也会被关闭.(同样的功能可以通过上面标准化的try-except-finally语句段实现).另一种可选的实现切换了try-except和try-finally包含的方式,如:

ccfile = None
try:
    try:
	    ccfile = open('carddata.txt', 'r')
	    txns = ccfile.readlines()
    finally:
	    if ccfile:
	        ccfile.close()
except IOError:
    log.write('no txns this month\n')


// 这里或许应该加入脚注, 说明下为什么要要 ccfile = None 
// 和 if ccfile:

The code works virtually the same with some differences. The most obvi- ous one is that the closing of the file happens before the exception handler writes  out  the  error  to  the  log.  This  is  because  finally automatically reraises the exception.

代码本质上干的是同一种工作,除了一些小小的不同.最显著的是关闭文件发生在异常处理器将错误写入日志之前.这是因为finally会自动的重新引发异常.

One argument for doing it this way is that if an exception happens within the  finally block,  you  are  able  to  create  another  handler  at  the  same outer level as the one we have, so in essence, be able to handle errors in both the original try block as well as the finally block. The only thing you lose when you do this is that if the finally block does raise an excep- tion, you have lost context of the original exception unless you have saved it somewhere.

一个这样写的理由是如果在finally的语句块内发生了一个异常,你可以创建一个同现有的异常处理器在同一个(外)层次的异常处理器来处理它.这样,从本质上来说,就可以同时处理在原始的try语句块和finally语句块中发生的错误.这种方法唯一的问题是,当finally语句块中的确发生异常时,你会丢失原来异常的上下文信息,除非你在某个地方保存了它.

An  argument  against  having  the  finally inside  the  except is  that  in many cases, the exception handler needs to perform some cleanup tasks as well,  and  if  you  release  those  resources  with  a  finally block  that  comes before  the  exception  handler,  you  have  lost  the  ability  to  do  so.  In  other words, the finally block is not as “final” as one would think.

反对这种写法的一个理由是:在很多情况下,异常处理器需要做一些扫尾工作,而如果你在异常处理之前,用finally语句块中释放了某些资源,你就不能再去做这项工作了.简单的说,finally语句块并不是如你所想的是"最终的(final)"了.

One final note: If the code in the finally suite raises another exception,
or is aborted due to a return, break, or continue statement, the original
exception is lost and cannot be reraised.

一个最终的注意点:如果finally中的代码引发了另一个异常或由于return,break,continue语法而终止,原来的异常将丢失而且无法重新引发.

10.3.11  try-except-else-finally: aka the Kitchen Sink

10.3.11  try-except-else-finally:厨房一锅端

We can combine all the varying syntaxes that we have seen so far in this chapter to highlight all the different ways you can handle exceptions:

我们综合了这一章目前我们所见过的所有不同的可以处理异常的语法样式:

try:
    try_suite

except Exception1:
    suite_for_Exception1

except (Exception2, Exception3, Exception4):
    suite_for_Exceptions_2_3_and_4

except Exception5, Argument5:
    suite_for_Exception5_plus_argument

except (Exception6, Exception7), Argument67:
    suite_for_Exceptions6_and_7_plus_argument

except:
    suite_for_all_other_exceptions

else:
    no_exceptions_detected_suite

finally:
    always_execute_suite
    
Recall  from  above  that  using  a  finally clause  combined  with  try- except or try-except-else is “new” as of Python 2.5. The most impor- tant  thing  to  take  away  from  this  section  regarding  the  syntax  is  that  you must have at least one except clause; both the else and finally clauses are optional.

回顾上面的,finally子句和 try-except或try-except-else联合使用是Python 2.5的"新"有的.这一节最重要的是无论你选择什么语法,你至少要有一个except子句,而else和finally都是可选的.


10.4  Context Management

10.4  上下文管理

10.4.1  with Statement

10.4.1  with语句

The  unification  of  try-except and  try-finally as  described  above makes programs more “Pythonic,” meaning, among many other characteristics, simpler to write and easier to read. Python already does a great job at hiding things under the covers so all you have to do is worry about how to solve  the  problem  you  have.  (Can  you  imagine  porting  a  complex  Python application into C++ or Java?!?)
　Another example of hiding lower layers of abstraction is the  with state- ment, made official as of Python 2.6. (It was introduced in 2.5 as a preview and to serve warnings for those applications using with as an identifier that it will become a keyword in 2.6. To use this feature in 2.5, you must import it with from __future__ import with_statement.)

如上所述的标准化的try-except和try-finally可以使得程序更加"Pythonic",其含义是,在许多的其他特性之外,更加写地轻松,读地自在.Python对隐藏细节已经做了大量的工作,因此需要你操心的仅是如何解决你所遇到问题.(你能假想移植一个复杂的Python应用到C++或Java吗?!?)
另一个隐藏低层次的抽象的例子是with 语句,它在Python 2.6中正式启用.(Python2.5尝试性的引入了with, 并对使用with 作为标识符的应用程序发出这样的警告 - 在Python 2.6 中,with 将会成为关键字. 如果你想在Python 2.5 使用 with语句, 你必须用from __future__ import with_statement 来导入它.)
Like try-except-finally, the with statement, has a purpose of sim-
plifying  code  that  features  the  common  idiom  of  using  the  try-except
and try-finally pairs in tandem. The specific use that the  with state-
ment targets is when try-except and try-finally are used together in
order to achieve the sole allocation of a shared resource for execution, then
releasing it once the job is done. Examples include files (data, logs, data- base,  etc.),  threading  resources  and  synchronization  primitives,  database connections, etc.

类似try-except-finally , with语句也是用来简化代码的,这与用try-except和try-finally所想达到的目的前后呼应.try-except和try-finally的一种特定的配合用法是保证共享的资源的唯一分配,并在任务结束的时候释放它.比如文件(数据,日志,数据库等等),线程资源,简单同步,数据库连接,等等. with语句的目标就是应用在这种场景.



　However, instead of just shortening the code and making it easier to use like try-except-finally,  the  with statement’s  goal  is  to  remove  the  try, except, and finally keywords and the allocation and release code from the picture altogether. The basic syntax of the with statement looks like this:

然而，with语句的目的在于从流程图中把 try,except和finally关键字和资源分配释放相关代码统统去掉, 而不是像 try-except-finally 那样仅仅简化代码使之易用. with语法的基本用法看上去如下:

with context_expr [as var]:
    with_suite

　It looks quite simple, but making it work requires some work under the covers. The reason is it not as simple as it looks is because you cannot use the with statement  merely  with  any  expression  in  Python.  It  only  works  with objects  that  support  what  is  called  the  context  management  protocol.  This simply means that only objects that are built with “context management” can be used with a with statement. We will describe what that means soon.


看起来如此简单,但是其背后还有一些工作要做.这并不如看上去的那么容易,因为你不能对Python的任意符号使用with语句.它仅能工作于支持上下文管理协议(context  management  protocol)的对象.这显然意味着只有内建了"上下文管理"的对象可以和with一起工作.我们过一会再来阐明它的含义.


Now, like any new video game hardware, when this feature was released,
some folks out there took the time to develop new games for it so that you can play when you open the box. Similarly, there were already some Python objects that support the protocol. Here is a short list of the first set:

现在,正如一个新的游戏硬件,每当有一个新的特性推出时,第一时间总有人开发出相应的新游戏,从而你打开盒子就可以开始玩了.类似,目前已经有了一些支持该协议的对象.下面是第一批成员的简短列表:

?    file
?    decimal.Context
?    thread.LockType
?    threading.Lock
?    threading.RLock
?    threading.Condition
?    threading.Semaphore
?    threading.BoundedSemaphore

　Since  files  are  first  on  the  list  and  the  simplest  example,  here  is  a  code snippet of what it looks like to use a with statement:

既然file是上面的列表上的第一个也是最易于演示的,下面就给出一段和with一起使用的代码片段.


with open('/etc/passwd', 'r') as f:
    for eachLine in f:
        # ...do stuff with eachLine or f...



What this code snippet will do is... well, this is Python, so you can probably already guess. It will do some preliminary work, such as attempt to open the file, and if all goes well, assign the file object to f. Then it iterates over each line in the file and does whatever processing you need to do. Once the file has been exhausted, it is closed. If an exception occurs either at the beginning, middle, or end of the block, then some cleanup code must be done, but the file will still be closed automatically.

这个代码片段干了什么呢...嗯,这是Python,因而你很可能的已经猜到了.它会完成准备工作,比如试图打开一个文件,如果一切正常,把文件对象赋值给f.然后用迭代器遍历文件中的每一行,当完成时,关闭文件.无论的在这一段代码的开始,中间,还是结束时发生异常,会执行清理的代码,此外文件仍会被自动的关闭.

Now,  because  a  lot  of  the  details  have  been  pushed  down  and  away
from  you,  there  are  really  two  levels  of  processing  that  need  to  occur:
First, the stuff at the user level—as in, the things you need to take care
of as the user of the object—and second, at the object level. Since this
object  supports  the  context  management  protocol,  it  has  to  do  some
“context management.”

因为已经从你手边拿走了一堆细节,所以实际上只是进行了两层处理:
第一,发生用户层 —— 和 in 类似,你所需要关心的只是被使用的对象
第二,在对象层.既然这个对象支持上下文管理协议,它干的也就是"上下文管理".

10.4.2  *Context Management Protocol

10.4.2  *上下文管理协议

Unless  you  will  be  designing  objects  for  users  of  the  with statement,  i.e., programmers who will be using your objects to design their applications with, most Python programmers are going to be just users of the with statement and can skip this optional section.

除非你打算自定义可以和with一起工作的类,比如:别的程序员会在他们的设计的应用中使用你的对象.
绝大多数Python程序员仅仅需要使用with语句,可以跳过这一节.

We are not going into a full and deep discussion about context manage- ment here, but we will explain the types of objects and the functionality that are necessary to be protocol-compliant and thus be eligible to be used with the with statement.

我们不打算在这里对上下文管理做深入且详细的探讨,但会介绍兼容协议所必须的对象类型与功能,使其能和with一起工作.

Previously, we described a little of how the protocol works in our example
with the file object. Let us elaborate some more here.

前面,我们在例子中描述了一些关于协议如何和文件对象协同工作.让我们在此进一步地研究.

Context Expression (context_expr), Context Manager

上下文表达式(context_expr),上下文管理器

When the with statement is executed, the context expression is evaluated
to  obtain  what  is  called  a  context  manager.  The  job  of  the  context  man-
ager  is  to  provide  a  context  object.  It  does  this  by  invoking  its  required
__context__() special method. The return value of this method is the context  object  that  will  be  used  for  this  particular  execution  of  the with_suite. One side note is that a context object itself can be its own manager, so context_expr can really be either a real context manager or
a context object serving as its own manager. In the latter case, the context object  also  has  a   __context__() method,  which  returns   self,  as expected.

当with语句执行时,便执行上下文符号(译者注:就是with与as间内容)来获得一个上下文管理器.上下文管理器的职责是提供一个上下文对象.这是通过调用__context__()方法来实现的.该方法返回一个上下文对象,用于在with语句块中处理细节.有点需要注意的是上下文对象本身就可以是上下文管理器.所以context_expr既可以为一个真正的上下文管理器,也可以是一个可以自我管理的上下文对象.在后一种情况时,上下文对象仍然有__context__()方法,返回其自身,如你所想.

Context Object, with_suite

上下文对象,with语句块

Once we have a context object, its __enter__() special method is invoked. This does all the preliminary stuff before the with_suite executes. You will notice in the syntax above that there is an optional  as var piece following context_expr on the with statement line. If var is provided, it is assigned the return value of __enter__(). If not, the return value is thrown away. So for our file object example, its context object’s __enter__() returns the file object so it can be assigned to f.

一旦我们获得了上下文对象,就会调用它的__enter()__方法.它将完成with语句块执行前的所有准备工作.你可以注意到在上面的with行的语法中有一个可选的as声明变量跟随在context_expr之后.如果提供提供了变量,以__enter()__返回的内容来赋值;否则,丢弃返回值.在我们的文件对象例子中,上下文对象的__enter()__返回文件对象并赋值给f.

Now  the  with_suite executes.  When  execution  of  with_suite termi- nates, whether “naturally” or via exception, the context object’s __exit__() special method is called. __exit__() takes three arguments. If with_suite terminates normally, all three parameters passed in are None. If an exception occurred, then the three arguments are the same three values returned when calling the sys.exc_info() function (see section 10.12): type (exception class), value (this exception’s instance), and traceback, the corresponding traceback object.

现在,执行了with语句块.当with语句块执行结束,无论是"和谐地"还是由于异常,都会调用上下文对象的__exit()__方法.__exit__()有三个参数.如果with语句块正常结束,三个参数全部是None.如果发生异常,三个参数的值的分别等于调用sys.exc_info()函数(见10.12)返回的三个值:类型(异常类),值(异常实例),和回溯(traceback),相应的回溯对象.

It is up to you to decide how you want to handle the exception here in
__exit__(). The usual thing to do after you are done is not to return any- thing  from  __exit__() or  return  None or  some  other  Boolean  False object. This will cause the exception to be reraised back to your user for han- dling. If you want to explicitly silence the exception, then return any object that has a Boolean True value. If an exception did not occur or you returned True after  handling  an  exception,  the  program  will  continue  on  the  next statement after the with clause.

你可以自己决定如何在__exit__()里面处理异常.惯例是当你处理完异常时不返回任何值,或返回None,或返回其他布尔值为False对象.这样可以使异常抛给你的用户来处理.如果你明确的想屏蔽这个异常,返回一个布尔为True的值.如果没有发生异常或你在处理异常后返回True,程序会继续执行with子句后的下一段代码.

　Since context management makes the most sense for shared resources, you  can  imagine  that  the  __enter__() and  __exit__() methods  will primarily be used for doing the lower-level work required to allocate and release  resources,  i.e.,  database  connections,  lock  allocation,  semaphore decrement,  state  management,  opening/closing  of  files,  exception  han- dling, etc.

因为上下文管理器主要作用于共享资源,你可以想象到__enter()__和__exit()__方法基本是干的需要分配和释放资源的低层次工作,比如:
数据库连接,锁分配,信号量加减,状态管理,打开/关闭文件,异常处理,等等.

　To help you with writing context managers for objects, there is the con- textlib module,  which  contains  useful  functions/decorators  with  which you  can  apply  over  your  functions  or  objects  and  not  have  to  worry  about implementing   a   class   or   separate   __context__(),   __enter__(),__exit__() special methods.

为了帮助你编写对象的上下文管理器,有一个contextlib模块,包含了实用的functions/decorators,你可以用在你的函数/对象上而不用去操心关于类或__context__(),__enter()__,__enter()__,__exit()__这些方法的实现.

For  more  information  or  more  examples  of  context  management,
check out the official Python documentation on the  with statement and contextlib module, class special methods (related to with and contexts), PEP 343, and the “What’s New in Python 2.5” document.

想了解更多关于上下文管理器的信息,查看官方的Python文档的with语法和contextlib模块,类的指定方法(与with和contexts相关的),PEP 343,和“What’s New in Python 2.5(Python 2.5的更新)”的文档.

10.5  *Exceptions as Strings

10.5  *字符串作为异常

Prior to Python 1.5, standard exceptions were implemented as strings. How- ever, this became limiting in that it did not allow for exceptions to have rela- tionships to each other. With the advent of exception classes, this is no longer the case. As of 1.5, all standard exceptions are now classes. It is still possible for programmers to generate their own exceptions as strings, but we recom- mend using exception classes from now on.

早在Python 1.5前,标准的异常是基于字符串实现的.然而,这样就限制了异常之间不能有相互的关系.这种情况随着异常类的来临而不复存在.到1.5为止,所有的标准异常都是类了.程序员还是可以用字符串作为自己的异常的,但是我们建议从现在起使用异常类.

For backward compatibility, it is possible to revert to string-based excep- tions. Starting the Python interpreter with the command-line option -X will provide you with the standard exceptions as strings. This feature will be obsolete beginning with Python 1.6.

为了向后兼容性,还是可以启用基于字符串的异常.从命令行以-X为参数启动Python可以提供你字符串方式的标准异常.从Python1.6起这个特性被视为废弃的.

Python  2.5  begins  the  process  of  deprecating  string  exceptions  from Python forever. In 2.5, raise of string exceptions generates a warning. In 2.6, the catching of string exceptions results in a warning. Since they are rarely used and are being deprecated, we will no longer consider string exceptions within the scope of this book and have removed it. (You may find the original text in prior editions of this book.) The only point of relevance and the final thought is a caution: You may use an external or third-party module, which may  still  have  string  exceptions.  String  exceptions  are  a  bad  idea  anyway. One reader vividly recalls seeing Linux RPM exceptions with spelling errors in the exception text.

Python 2.5开始处理向来不赞成使用的字符串异常.在2.5中,触发字符串异常会导致一个警告.在2.6,捕获字符串异常会导致一个警告.由于它很少被使用而且已经被废弃,我们将不再在本书范围内考虑字符串异常并且已经去除相关文字.(在本书的早期的版本中你会找到这些.)唯一也是最后的中肯警告是:你可能用到仍然使用着字符串异常的外部或第三方的模块.字符串异常总而言之是一个糟糕的想法.读者可以回想,有着拼写错误的Linux RPM异常如在眼前.

10.6  Raising Exceptions

10.6  触发异常

The interpreter was responsible for raising all of the exceptions we have seen
so far. These exist as a result of encountering an error during execution. A programmer writing an API may also wish to throw an exception on erroneous input, for example, so Python provides a mechanism for the programmer to explicitly generate an exception: the raise statement.

到目前为止,我们所见到的异常都是由解释器引发的.由于执行期间的错误而引发.程序员在编写API时也希望在遇到错误的输入时触发异常,为此,Python提供了一种机制让程序员明确的触发异常:这就是raise语句.

10.6.1  raise Statement

10.6.1  raise语句

Syntax and Common Usage

语法与惯用法

The raise statement is quite flexible with the arguments it supports, translating  to  a  large  number  of  different  formats  supported  syntactically.  The general syntax for raise is:

raise语句对所支持是参数十分灵活,对应到语法上就是支持许多不同的格式.rasie一般的用法是:

raise [SomeException [, args [, traceback]]]

The first argument, SomeException, is the name of the exception to raise.
If present, it must either be a string, class, or instance (more below). SomeEx-
ception must be given if any of the other arguments (args or traceback)
are present. A list of all Python standard exceptions is given in Table 10.2.

第一个参数,SomeExcpetion,是触发异常的名字.如果有,它必须是一个字符串,类或实例(详见下文).如果有其他参数(arg或traceback),就必须提供SomeExcpetion.Python所有的标准异常见表10.2.

   The second expression contains optional  args (aka parameters, values) for the exception. This value is either a single object or a tuple of objects. When exceptions are detected, the exception arguments are always returned
as  a  tuple.  If  args is  a  tuple,  then  that  tuple  represents  the  same  set  of exception arguments that are given to the handler. If args is a single object, then the tuple will consist solely of this one object (i.e., a tuple with one ele- ment). In most cases, the single argument consists of a string indicating the cause of the error. When a tuple is given, it usually equates to an error string,
an error number, and perhaps an error location, such as a file, etc.

第二个符号为可选的args(比如参数,值),来传给异常.这可以是一个单独的对象也可以是一个对象的元组.当异常发生时,异常的参数总是作为一个元组传入.如果args原本就是元组,那么就将其传给异常去处理;如果args是一个单独的对象,就生成只有一个元素的元组(就是单元素元组).大多数情况下,单一的字符串用来指示错误的原因.如果传的是元组,通常的组成是一个错误字符串,一个错误编号,可能还有一个错误的地址,比如文件,等等.

　The final argument, traceback, is also optional (and rarely used in prac- tice),  and,  if  present,  is  the  traceback  object  used  for  the  exception—normally a traceback object is newly created when an exception is raised. This third argument is useful if you want to reraise an exception (perhaps to point
to  the  previous  location  from  the  current).  Arguments  that  are  absent  are represented by the value None.

最后一项参数,traceback,同样是可选的(实际上很少用它),如果有的话,则是当异常触发时新生成的一个用于异常-正常化(exception—normally)的追踪(traceback)对象.当你想重新引发异常时,第三个参数很有用(可以用来区分先前和当前的位置).如果没有这个参数,就填写None.

The most common syntax used is when SomeException is a class. No addi-
tional parameters are ever required, but in this case, if they are given, they can be
a single object argument, a tuple of arguments, or an exception class instance. If the argument is an instance, then it can be an instance of the given class or a derived class (subclassed from a pre-existing exception class). No additional argu- ments (i.e., exception arguments) are permitted if the argument is an instance.

最常见的用法为SomeException是一个类.不需要其他的参数,但如果有的话,可以是一个单一对象参数,一个参数的元组,或一个异常类的实例.如果参数是一个实例,可以由给出的类及其派生类实例化(已存在异常类的子集).若参数为实例,则不能有更多的其他参数.

More Exotic/Less Common Usage

更多的特殊/少见的惯用法

What happens if the argument is an instance? No problems arise if instance
is an instance of the given exception class. However, if instance is not an
instance  of  the  class  or  an  instance  of  a  subclass  of  the  class,  then  a  new
instance of the exception class will be created with exception arguments copied from  the  given  instance.  If  instance is  an  instance  of  a  subclass  of  the exception  class,  then  the  new  exception  will  be  instantiated  from  the  sub- class, not the original exception class.

当参数是一个实例的时候会发生什么呢? 该实例若是给定异常类的实例当然不会有问题, 然而, 如果该实例并非这个异常类或其子类的实例时, 那么解释器将使用该实例的异常参数创建一个给定异常类的新实例. 如果该实例是给定异常类子类的实例, 那么新实例将作为异常类的子类出现, 而不是原来的给定异常类.


　If the additional parameter to the raise statement used with an exception class is not an instance—instead, it is a singleton or tuple—then the class is instantiated and args is used as the argument list to the exception. If the second parameter is not present or None, then the argument list is empty.
　
如果raise语句的额外参数不是一个实例——作为替代,是一个单件(singleton)或元组—那么,将用这些作为此异常类的初始化的参数列表.如果不存在第二个参数或是None,则参数列表为空.

If SomeException is an instance, then we do not need to instantiate any- thing. In this case, additional parameters must not be given or must be None.The exception type is the class that  instance belongs to; in other words, this   is   equivalent   to   raising   the   class   with   this   instance,   i.e.,   raise instance.__class__, instance.

如果SomeException是一个实例,我们就无需对什么进行实例化了.这种情况下,不能有额外的参数或只能是None.
异常的类型就是实例的类;也就是说,等价于触发此类异常,并用该实例为参数:比如 raise instance.__class__,instance.

Use of string exceptions is deprecated in favor of exception classes, but if SomeException is  a  string,  then  it  raises  the  exception  identified  by string, with any optional parameters (args) as arguments.

我们建议用异常类,不赞成用字符串异常.但如果用字符串作为SomeException,那么会触发一个用字符串标识的异常,还有一个可选的参量(args)作参数.

Finally, the raise statement by itself without any parameters is a new construct, introduced in Python 1.5, and causes the last exception raised in the current
code block to be reraised. If no exception was previously raised, a TypeError
exception will occur, because there was no previous exception to reraise.

最后,这种不含任何参数的raise语句结构是在Python1.5中新引进的,会引发当前代码块(code block)最近触发的一个异常.如果之前没有异常触发,会因为没可以有重新触发的异常而生成一个TypeError异常.

　Due to the many different valid syntax formats for raise (i.e., SomeException can be either a class, instance, or a string), we provide Table 10.1 to illuminate all the different ways which raise can be used.

由于raise有许多不同格式有效语法(比如:SomeException可以是类,实例或一个字符串),我们提供表10.1来阐明rasie的不同用法.

Table 10.1  Using the raise Statement

表10.1  raise语句的用法

raise syntax    Description

rasie语法       描述

raise exclass
Raise an exception, creating an instance of exclass (without any exception arguments)
触发一个异常,从exclass生成一个实例(不含任何异常参数)

raise exclass()
Same as above since classes are now exceptions; invoking the class name with the function calloperator instantiates an instance of exclass, also with no arguments
同上,除了现在不是类;通过函数调用操作符(function calloperator: "()")作用于类名生成一个新的exclass实例,同样也没有异常参数

raise exclass, args
Same as above, but also providing exception arguments args, which can be a single argu- ment or a tuple
同上,但同时提供的异常参数args,可以是一个参数也可以元组

raise exclass(args)
Same as above
同上

raise exclass,args, tb
Same as above, but provides traceback object tb to use
同上,但提供一个追踪(traceback)对象tb供使用

raise exclass,instance
Raise exception using instance (normally an instance of exclass); if instance is an instance of a subclass of exclass, then the new exception will be of the subclass type (not of exclass); if instance is not an instance
of exclass or an instance of a subclass of exclass, then a new instance of exclass will be created with exception arguments cop- ied from instance
通过实例触发异常(通常是exclass的实例);如果实例是exclass的子类实例,那么这个新异常的类型会是子类的类型(而不是exclass);如果实例既不是exclass的实例也不是exclass子类的实例,那么会复制此实例为异常参数去生成一个新的exclass实例.

raise instance
Raise exception using instance: the exception type is the class that instantiated instance; equivalent to raise instance.__class__, instance (same as above)
通过实例触发异常:异常类型是实例的类型;等价于raise instance.__class__, instance (同上).

raise string    
(Archaic) Raises string exception
(过时的) 触发字符串异常

raise string, args
Same as above, but raises exception with args
同上,但触发伴随着args

raise string, args, tb
Same as above, but provides traceback object tb to use
同上,但提供了一个追踪(traceback)对象tb供使用

raise    
(New in 1.5) Reraises previously raised excep- tion; if no exception was previously raised, a TypeError is raised
(1.5新增)重新触发前一个异常,如果之前没有异常,触发TypeError.

10.7  Assertions

10.7  断言

Assertions are diagnostic predicates that must evaluate to Boolean True; other- wise, an exception is raised to indicate that the expression is false. These work similarly to the assert macros, which are part of the C language preprocessor, but
in Python these are runtime constructs (as opposed to precompile directives).

断言是一句必须等价于布尔真的判定;此外,发生异常也意味着表达式为假.这些工作类似于C语言预处理器中assert宏,但在Python中它们在运行时构建(与之相对的是编译期判别).

　If you are new to the concept of assertions, no problem. The easiest way to think of an assertion is to liken it to a raise-if statement (or to be more accurate,  a  raise-if-not statement).  An  expression  is  tested,  and  if  the result comes up false, an exception is raised.

如果你刚刚接触断言这个概念,无妨.断言可以简简单单的想象为raise-if语句(更准确的说是raise-if-not语句).测试一个表达式,如果返回值是假,触发异常.

　Assertions are carried out by the  assert statement, introduced back in version 1.5.

断言通过assert语句实现,在1.5版中引入.

10.7.1  assert Statement

10.7.1  断言语句

The assert statement evaluates a Python expression, taking no action if the assertion  succeeds  (similar  to  a  pass statement),  but  otherwise  raising  an AssertionError exception. The syntax for assert is:

断言语句等价于这样的Python表达式,如果断言成功不采取任何措施(类似语句),否则触发AssertionError(断言错误)的异常.assert的语法如下:

assert expression[, arguments]

Here are some examples of the use of the assert statement:
下面有一些演示assert用法的语句:

assert 1 == 1
assert 2 + 2 == 2 * 2
assert len(['my list', 12]) < 10
assert range(3) == [0, 1, 2]

AssertionError exceptions can be caught and handled like any other exception using the try-except statement, but if not handled, they will ter- minate the program and produce a traceback similar to the following:

AssertionError异常和其他的异常一样可以用try-except语句块捕捉,但是如果没有捕捉,它将终止程序运行而且提供一个如下的traceback:

>>> assert 1 == 0
Traceback (innermost last): File "<stdin>", line 1, in ?
AssertionError

As with the raise statement we investigated in the previous section, we can provide an exception argument to our assert command:

如同先前章节我们研究的raise语句,我们可以提供一个异常参数给我们的assert命令:

>>> assert 1 == 0, 'One does not equal zero silly!' Traceback (innermost last):
File "<stdin>", line 1, in ?
AssertionError: One does not equal zero silly!

Here is how we would use a try-except statement to catch an AssertionError exception:

下面是我们如何用try-except语句捕获AssertionError异常:

try:
    assert 1 == 0, 'One does not equal zero silly!'
except AssertionError, args:
    print '%s: %s' % (args.__class__.__name__, args)

Executing the above code from the command line would result in the following output:

从命令行执行上面的代码会导致如下的输出:

AssertionError: One does not equal zero silly!

To give you a better idea of how assert works, imagine how the assert statement may be implemented in Python if written as a function. It would probably look something like this:

为了让你更加了解assert如何运作,想象一下断言语句在Python中如何用函数实现.可以像下面这样:

def assert(expr, args=None):
    if __debug__ and not expr:
            raise AssertionError, args

The  first  if statement  confirms  the  appropriate  syntax  for  the  assert, meaning that expr should be an expression. We compare the type of expr to a real expression to verify. The second part of the function evaluates the expression and raises AssertionError, if necessary. The built-in variable__debug__ is  1  under  normal  circumstances,  0  when  optimization  is requested (command-line option -O).

此处的 if 语句检查 assert 的语法是否合适,也就是expr必须是一个表达式.我们比较expr的类型和真正的表达式来确认.函数的第二部分对表达式求值然后根据结果选择性的引发异常.内建的变量__debug__在通常情况下为True,如果开启优化后为False(命令行选项-O)(Python 2.2 后为 布尔值True 和False.)

10.8  Standard Exceptions

10.8  标准异常

Table 10.2 lists all of Python’s current set of standard exceptions. All exceptions are loaded into the interpreter as built-ins so they are ready before your script starts or by the time you receive the interpreter prompt, if running interactively.

表10.2列出了所有的Python当前的标准异常集,所有的异常都是内建的. 所以它们在脚本启动前或在互交命令行提示符出现时已经是可用的了.

Table 10.2  Python Built-In Exceptions

表10.2  Python内建异常

Exception Name    Description
异常名称        描述

BaseExceptiona  Root class for all exceptions
所有异常的基类                

SystemExitb    Request termination of Python interpreter 
python解释器请求退出

KeyboardInterruptc    
User interrupted execution (usually by typing ^C)
用户中断执行(通常是输入^C)

Exceptiond    
Root class for regular exceptions 
常规错误的基类

    StopIteratione
    Iteration has no further values 
    迭代器没有更多的值
    
    GeneratorExita
    Exception sent to generator to tell it to quit
    生成器(generator)发生异常来通知退出 
    
    SystemExith
    Request termination of Python interpreter
    Python解释器请求退出

    StandardErrorg    
    Base class for all standard built-in exceptions
    所有的内建标准异常的基类

        ArithmeticErrord
        Base class for all numeric calculation errors
        所有数值计算错误的基类
        
            FloatingPointErrord
            Error in floating point calculation
            浮点计算错误

            OverflowError
            Calculation exceeded maximum limit for numerical type
            数值运算超出最大限制

            ZeroDivisionError    
            Division (or modulus) by zero error
            (all numeric types)
            除(或取模)零
            (所有数据类型)
            
        AssertionErrord
        Failure of assert statement
        断言语句失败
         
        AttributeError
        No such object attribute
        对象没有这个属性

        EOFError
        End-of-file marker reached without input from built-in
        没有内建输入,到达EOF标记

        EnvironmentErrord
        Base class for operating system environment errors
        操作系统错误的基类
        
　          IOError
　          Failure of input/output operation 
　          输入/输出操作失败
　     
　          OSErrord
            Operating system error
　          操作系统错误
　     
　              WindowsErrorh
　              MS Windows system call failure
　              Windows系统调用失败
　     
　     ImportError
　     Failure to import module or object
　     导入模块/对象失败
　     
　     KeyboardInterruptf
    　 User interrupted execution (usually by typing ^C)
       用户中断执行(通常是输入^C)
       
       LookupErrord
       Base class for invalid data lookup errors
　     无效数据查询的基类
　     
　          IndexError
            No such index in sequence
            序列中没有没有此索引(index)
            
            KeyError　      
            No such key in mapping
            映射中没有这个键
            
      MemoryError
      Out-of-memory error (non-fatal to Python interpreter)
      内存溢出错误(对于Python解释器不是致命的)

      NameError
      Undeclared/uninitialized object
      (non-attribute)
      未声明/初始化对象
      (没有属性)
    
UnboundLocalErrorh
Access of an uninitialized local variable
访问未初始化的本地变量

ReferenceErrore
Weak reference tried to access a garbage-collected object
弱引用(Weak reference)试图访问已经垃圾回收了的对象

RuntimeError    Generic default error during execution
一般的运行时错误

NotImplementedErrord
Unimplemented method 
尚未实现的方法

SyntaxError
Error in Python syntax 
Python语法错误

IndentationErrorg
Improper indentation
缩进错误

TabErrorg
Improper mixture of tabs and spaces
Tab和空格混用

SystemError
Generic interpreter system error
一般的解释器系统错误

TypeError    
Invalid operation for type 
对类型无效的操作

ValueError    
Invalid argument given 
传入无效的参数

UnicodeErrorh
Unicode-related error
Unicode相关的错误

UnicodeDecodeErrori
Unicode error during decoding
Unicode解码时的错误

UnicodeEncodeErrori
Unicode error during encoding
Unicode编码时错误

UnicodeTranslateErrorf
Unicode error during translation
Unicode转换时错误

Warningj
Root class for all warnings
警告的基类

DeprecationWarningj
Warning about deprecated features
关于被弃用的特征的警告

FutureWarningi
Warning about constructs that will change semantically in the future
关于构造将来语义会有改变的警告

OverflowWarningk    
Old warning for auto-long upgrade
旧的关于自动提升为长整型(long)的警告

PendingDeprecationWarningi 
Warning about features that will be deprecated in the future
关于特性将会被废弃的警告

RuntimeWarningj
Warning about dubious runtime behavior
可疑的运行时行为(runtime behavior)的警告

SyntaxWarningj
Warning about dubious syntax
可疑的语法的警告

UserWarningj
Warning generated by user code
用户代码生成的警告

a.    New in Python 2.5.
a. Python2.5新增

b. Prior to Python 2.5, SystemExit subclassed .
b. 在Python2.5前,Exception的子类SystemExit

c.    Prior to Python 2.5, KeyboardInterrupt subclassed StandardError.
c.在Python2.5前,StandardError的子类KeyboardInterrupt

 d.     New in Python 1.5, when class-based exceptions replaced strings.
d.Python1.5新增,用基于类的异常来替代字符串

e.     New in Python 2.2. 
e.Python2.2新增

f.    New in Python 1.6.
f.Python1.6新增

g.     New in Python 2.0.
g.Python2.0新增

h. New in Python 1.6.
h.Python1.6新增

i.    New in Python 2.3.
i.Python2.3新增

j.    New in Python 2.1.
j.Python2.1新增

k. New in Python 2.2 but removed in Python 2.4.
k.Python2.2新增,但在Python2.4时移除

 
 

　All standard/built-in exceptions are derived from the root class BaseEx- ception. There are currently three immediate subclasses of BaseExcep- tion:  SystemExit,  KeyboardInterrupt,  and  Exception.  All  other built-in exceptions are subclasses of Exceptions. Every level of indentation  of  an  exception  listed  in  Table  10.2  indicates  one  level  of  exception class derivation.

所有的标准/内建异常都是从根异常派生的.目前,有3个直接从BaseException派生的异常子类:SystemExit,KeyboardInterrupt和Exception.其他的所有的内建异常都是Exception的子类.表10.2中的每一层缩进都代表一次异常类的派生.
　
　As  of  Python  2.5,  all  exceptions  are  new-style  classes  and  are  ultimately subclassed from BaseException. At this release, SystemExit and Key- boardInterrupt were  taken  out  of  the  hierarchy  for  Exception and moved up to being under BaseException. This is to allow statements like except Exception to catch all errors and not program exit conditions.
　
到了Python2.5,所有的异常的都是新风格(new-style)的类,并且最终都是BaseException的子类.在这一版中,SystemExit和KeyboardInterrupt从Exception的继承中移到BaseException的继承下.这样可以允许如except Exception的语句捕获所有非控制程序退出的异常.
　
　From  Python  1.5  through  Python  2.4.x,  exceptions  were  classic  classes, and  prior  to  that,  they  were  strings.  String-based  exceptions  are  no  longer acceptable constructs and are officially deprecated beginning with 2.5, where you will not be able to raise string exceptions. In 2.6, you cannot catch them. There  is  also  a  requirement  that  all  new  exceptions  be  ultimately  sub- classed  from  BaseException so  that  all  exceptions  will  have  a  common interface.  This  will  transition  will  begin  with  Python  2.7  and  continue through the remainder of the 2.x releases.

从Python1.5到Python2.4.x,异常是标准的类,在这之前,他们是字符串.从Python2.5开始,不再支持构建基于字符串的异常并且被正式的弃用,也就是说你不能再触发一个字符串异常了.在2.6,你将不能捕获他们.还有一个要求就是所有新的异常最终都是BaseException的子类,以便于他们有一个统一的接口.这将从Python2.7开始,并在余下的Python2.x发布版中延续.

10.9  *Creating Exceptions
10.9  *创建异常

Although  the  set  of  standard  exceptions  is  fairly  wide-ranging,  it  may  be advantageous  to  create  your  own  exceptions.  One  situation  is  where  you would like additional information from what a standard or module-specific exception provides. We will present two examples, both related to IOError. IOError is  a  generic  exception  used  for  input/output  problems,  which may arise from invalid file access or other forms of communication. Suppose we wanted to be more specific in terms of identifying the source of the prob- lem. For example, for file errors, we want to have a FileError exception that behaves like IOError, but with a name that has more meaning when performing file operations.

尽管标准异常集包含的内容已经相当广泛,你还是可以创建自己的异常.一种情况是你想在特定的标准异常和模块异常中添加额外的信息.我们将介绍两个例子,都与IOError有关.IOError是一个用于输入/输出的通用异常,可能在无效的文件访问或其他形式的通信中触发.假如我们想要更加明确的标明问题的来源,比如:对于文件错误,我们希望有行为类似IOError的一个FileError异常,但是名字表明是在执行文件操作.

Another exception we will look at is related to network programming with sockets.   The   exception   generated   by   the   socket module   is   called socket.error and  is  not  a  built-in  exception.  It  is  subclassed  from  the generic  Exception exception.  However,  the  exception  arguments  from socket.error closely  resemble  those  of  IOError exceptions,  so  we  are going  to  define  a  new  exception  called  NetworkError,  which  subclasses from   IOError  but   contains   at   least   the   information   provided   by socket.error.

我们将查看的另一个异常与套接字(socket)网络编程有关.socket模块生成的异常叫socket.error,不是内建的异常.它从通用Exception类派生.然而socket.error这个异常的宗旨和IOError很类似,所以我们打算定义一个新的从IOError派生的NetworkError的异常,但是其包含了socket.error提供的信息.

Like classes and object-oriented programming, we have not formally covered network programming at this stage, but skip ahead to Chapter 16 if you need to.

如同类和面向对象编程,我们暂时不会正式介绍网络编程,如果你需要的话可以跳到16章.

We now present a module called myexc.py with our newly customized exceptions FileError and NetworkError. The code is in Example 10.2.

我们现在给出一个叫做myexc.py的模块和我们自定义的新异常FileError与NetworkError.代码如10.2.

Example 10.2  Creating Exceptions (myexc.py)

例:10.2 创建异常(myexc.py)

This module defines two new exceptions, FileError and NetworkError, as well as reimplements more diagnostic versions of open() [myopen()] and socket.connect() [myconnect()]. Also included is a test function
[test()] that is run if this module is executed directly.

此模块定义了两个新的异常,FileError和NetworkError,也重新实现了一个诊断版的open()[myopen()]和socket.connect()[myconnect()].同时包含了一个测试函数[test()],当直接运行文件时执行.

1    #!/usr/bin/env python
2
3    import os, socket, errno, types, tempfile
4
5    class NetworkError(IOError):
6    pass
7
8    class FileError(IOError):
9    pass
10
11    def updArgs(args, newarg=None):
12    if isinstance(args, IOError):
13    myargs = []
14    myargs.extend([arg for arg in args])
15    else:
16    myargs = list(args)
17
18    if newarg:
19    myargs.append(newarg)
20
21    return tuple(myargs)
22
23    def fileArgs(file, mode, args):
24    if args[0] == errno.EACCES and \
25    'access' in dir(os):
26    perms = ''
27    permd = { 'r': os.R_OK, 'w': os.W_OK,
28    'x': os.X_OK}
29    pkeys = permd.keys()
30    pkeys.sort()
31    pkeys.reverse()
32
33    for eachPerm in 'rwx':
34    if os.access(file, permd[eachPerm]):
35    perms += eachPerm
36    else:
37    perms += '-'
38
39    if isinstance(args, IOError):
40    myargs = []
41    myargs.extend([arg for arg in args])
42    else:
43    myargs = list(args)
44
45    myargs[1] = "'%s' %s (perms: '%s')" % \
46    (mode, myargs[1], perms)
47
48    myargs.append(args.filename)
49
50    else:
51    myargs = args
52
53    return tuple(myargs)
54
55    def myconnect(sock, host, port):
56    try:
57    sock.connect((host, port))
58
59    except socket.error, args:
60    myargs = updArgs(args)    # conv inst2tuple
61    if len(myargs) == 1:    # no #s on some errs
62    myargs = (errno.ENXIO, myargs[0])
63
64    raise NetworkError, \
65    updArgs(myargs, host + ':' + str(port))
66
67 def myopen(file, mode='r'):
68     try:
69    fo = open(file, mode)
70    except IOError, args:
71    raise FileError, fileArgs(file, mode, args)
72
73    return fo
74
75    def testfile():
76
77    file = mktemp()
78    f = open(file, 'w')
79    f.close()
80
81    for eachTest in ((0, 'r'), (0100, 'r'),
82    (0400, 'w'), (0500, 'w')):
83    try:
84    os.chmod(file, eachTest[0])
85    f = myopen(file, eachTest[1])
86
87    except FileError, args:
88    print "%s: %s" % \
89    (args.__class__.__name__, args)
90    else:
91    print file, "opened ok... perm ignored"
92    f.close()
93
94    os.chmod(file, 0777)# enable all perms
95    os.unlink(file)
96
97 def testnet():
98     s = socket.socket(socket.AF_INET,
99         socket.SOCK_STREAM)
100
101    for eachHost in ('deli', 'www'):
102    try:
103    myconnect(s, 'deli', 8080)
104    except NetworkError, args:
105    print "%s: %s" % \
106    (args.__class__.__name__, args)
107
108    if __name__ == '__main__':
109    testfile()
110    testnet()

Lines 1–3

行1-3

The Unix startup script and importation of the socket, os, errno, types, and tempfile modules help us start this module.

模块的开始部分是Unix启动脚本和socket,os,errno,types和tempfile模块的导入.

Lines 5–9

行5-9

Believe it or not, these five lines make up our new exceptions. Not just one, but both of them. Unless new functionality is going to be introduced, creating a  new  exception  is  just  a  matter  of  subclassing  from  an  already  existing exception. In our case, that would be IOError. EnvironmentError, from which IOError is derived, would also work, but we wanted to convey that our exceptions were definitely I/O-related.

无论你是否相信,这5行代码定义了我们的新异常.不是仅仅一个,而是两个.除了将要介绍的一个新功能,创建一个新的异常仅需要从一个已经存在的异常类派生一个出子类.本例中,这个基类是IOError. 我们也可以从IOError的基类EnvironmentError派生,但我们想明确表明我们的异常是I/O相关的.

We chose IOError because it provides two arguments, an error number and an error string. File-related [uses  open()] IOError exceptions even support a third argument that is not part of the main set of exception argu- ments,  and  that  would  be  the  filename.  Special  handling  is  done  for  this third argument, which lives outside the main tuple pair and has the name filename.

我们选择IOError是因为它提供了两个参数,一个错误编号和一个错误字符串.文件相关[用open()]的IOError异常甚至支持大部分异常没有的第三个参数,那个可以是文件名.我们将对这个在主要元组之外的,名字叫"filename"的参数执行一些特定的操作.

Lines 11–21

行 11-21

The entire purpose of the updArgs() function is to “update” the exception arguments. What we mean here is that the original exception is going to provide us a set of arguments. We want to take these arguments and make them part
of  our  new  exception,  perhaps  embellishing  or  adding  a  third  argument (which is not added if nothing is given—None is a default argument, which we will study in the next chapter). Our goal is to provide the more informative details  to  the  user  so  that  if  and  when  errors  occur,  the  problems  can  be tracked down as quickly as possible.

updArgs()函数的全部意图就是"更新"异常的参数.我们这里的意思是原来的异常提供给我们一个参数集.我们希望获取这些参数并让其成为我们新的异常的一部分,可能是嵌入或添加第三个参数(如果没有传入,什么也不添加—None是其默认值,我们下一章将会学习).我们的目标是提供更多的细节信息给用户,这样当问题发生时能够尽快的捕捉到.

Lines 23–53

The fileArgs() function is used only by myopen() (see below). In particu- lar, we are seeking error EACCES, which represents “permission denied.” We pass all other IOError exceptions along without modification (lines 54–55). If you are curious about ENXIO, EACCES, and other system error numbers, you can hunt them down by starting at file /usr/include/sys/errno.h on a Unix system, or C:\Msdev\include\Errno.h if you are using Visual C++ on Windows.

函数fileArgs()仅在myopen()中使用(如下).实际上,我们寻找表示"permissiondenied.(没有权限.)"的错误EACCES.其他所有的IOError异常我们将不加修改(行54-55)的传递.如果你对ENXIO, EACCES和其他的系统错误号感到好奇,你可以从Unix系统下/usr/include/sys/errno.h或Windows系统下Visula C++的C:\Msdev\include\Errno.h文件来对它们刨根究底.

　In  line  27,  we  are  also  checking  to  make  sure  that  the  machine  we  are using supports the os.access() function, which helps you check what kind of file permissions you have for any particular file. We do not proceed unless we receive both a permission error as well as the ability to check what kind of permissions we have. If all checks out, we set up a dictionary to help us build a string indicating the permissions we have on our file.

在第27行,我们也确认了我们当前使用的机器支持os.access()函数,它用来检查对任意一个特定文件你所拥有的权限.除非我们收到权限错误同时也能够检查我们拥有的权限,否则我们什么不做.当一切完毕,我们设置一个字典来帮助构建表示我们对文件所拥有的权限的字符串.

The  Unix  file  system  uses  explicit  file  permissions  for  the  user,  group
(more than one user can belong to a group), and other (any user other than the owner or someone in the same group as the owner) in read, write, and execute (‘r’, ‘w’, ‘x’) order. Windows supports some of these permissions.
Now it is time to build the permission string. If the file has a permission,
its corresponding letter shows up in the string, otherwise a dash ( - ) appears. For example, a string of “rw-” means that you have read and write access to
it. If the string reads “r-x”, you have only read and execute access; “---”
means no permission at all.

Unix文件系统清晰标明用户(user),组(group,可以有多个用户属于一个组)和其他(other,不是所有者,也不和所有者同组的用户)对文件的读,写,执行(‘r’, ‘w’, ‘x’)的权限.
Windows支持这些权限中的一部分.现在可以来构建权限字符串了.如果对文件有某种权限,字符串中就有相应的字母,否则用'-'替代..比如,字符串'rw-'标明你可以对其进行读/写访问.如果字符串是'r-x',你仅可以对其进行读和执行操作;'---'标示没有任何权限.

After  the  permission  string  has  been  constructed,  we  create  a  temporary argument list. We then alter the error string to contain the permission string, something  that  standard  IOError exception  does  not  provide.  “Permission denied” sometimes seems silly if the system does not tell you what permissions you  have  to  correct  the  problem.  The  reason,  of  course,  is  security.  When intruders do not have permission to access something, the last thing you want them to see is what the file permissions are, hence the dilemma. However, our example here is merely an exercise, so we allow for the temporary “breach of security.” The point is to verify whether or not the os.chmod() functions call affected file permissions the way they are supposed to.
当权限字符串构建完成后,我们创建了一个临时的参数列表.我们随后更改了错误字符串使之包含权限字符串.(标准的IOError异常并没有提供权限字符串相关信息). 如果系统并没有告诉你具有什么权限才能来解决这个问题，而只是显示"Permission denied(没有权限)" 这个错误信息，这似乎是很愚蠢。 当然这是出于安全的考虑. 当入侵者没有权限访问某个数据的时候, 最好不要让他们看到这个文件的权限是什么。不过, 我们的例子仅仅是一个练习, 所以我们可以暂时"违背安全"信条。 问题的关键在于确认调用 os.chmod() 函数，它能够按照你的意愿来修改文件的权限。


　The  final  thing  we  do  is  to  add  the  filename  to  our  argument  list  and return the set of arguments as a tuple.

最后一件事情我们把文件名加入参数列表,并以元组形式返回参数.

Lines 55–65

行55-65

Our new myconnect() function simply wraps the standard socket method connect() to provide an IOError-type exception if the network connec- tion fails. Unlike the general socket.error exception, we also provide the hostname and port number as an added value to the programmer.

我们新的myconnect()函数仅仅是简单的对套接字的函数conect()进行包装当网络连接失败时提供一个IOError类型的异常.和一般的socket.error不一样,我们还提供给程序员主机名和端口号.

　For those new to network programming, a hostname and port number pair are analogous to an area code and telephone number when you are trying to contact someone. In this case, we are trying to contact a program running on the remote host, presumably a server of some sort; therefore, we require the host’s name and the port number that the server is listening on.

对于刚刚接触网络编程的,主机名和端口号可以想象为当你联系某人时的区号和电话号.在这个例子中,我们试着去连接一个在远程主机上运行的程序,可能是某种服务. 因此我们需要知道主机名和服务器监听的端口. 

　When a failure occurs, the error number and error string are quite helpful, but it would be even more helpful to have the exact host-port combination as well, since this pair may be dynamically generated or retrieved from some database or name service. That is the value-add we are bestowing on our ver- sion of connect(). Another issue arises when a host cannot be found. There is no direct error number given to us by the socket.error exception, so to
make  it  conform  to  the  IOError protocol  of  providing  an  error  number-
error string pair, we find the closest error number that matches. We choose ENXIO.

当失败发生时,错误号和错误字符很有帮助,但是如果结合更精确的主机-端口会更有帮助,因为这一对可能是由某个数据库或名称服务动态生成或重新获得.这些值由我们版本的connect()加入.另一种情形是无法找到主机,socket.error异常没有直接提供的错误号,我们为了遵循IOError协议,提供了一个错误号-错误字符串对,我们查找最接近的错误号.我们选用的ENXIO.

Lines 67–73

行67-73

Like  its  sibling  myconnect(),  myopen() also  wraps  around  an  existing piece of code. Here, we have the open() function. Our handler catches only  IOError exceptions.  All  others  will  pass  through  and  on  up  to  the next  level  (when  no  handler  is  found  for  them).  Once  an  IOError is caught,  we  raise  our  own  error  and  customized  arguments  as  returned from fileArgs().

类似同类myconnect(),myopen()也封装了已经存在的一些代码.这里,我们用的是open()函数.我们仅仅捕捉IOError异常.所有的其他都忽略并传给下一层(因为没有与他们相关的处理器).一旦捕捉到IOError我们引发我们自己的异常并通过fileArgs()返回值来定制参数.

Lines 75–95

行75-95

We shall perform the file testing first, here using the testfile() function. In order to begin, we need to create a test file that we can manipulate by changing its permissions to generate permission errors. The tempfile mod- ule  contains  code  to  create  temporary  file  names  or  temporary  files  them- selves. We just need the name for now and use our new myopen() function
to create an empty file. Note that if an error occurred here, there would be
no  handler,  and  our  program  would  terminate  fatally—the  test  program should not continue if we cannot even create a test file.

我们首先测试文件,这里使用testfile()函数.开始之前,我们需要新建一个测试文件,以便我们可以手工的修改其权限来造成权限错误.这个tempfile模块包含了创建临时文件文件名和临时文件的代码.当前我们仅仅需要文件名,然后用myopen()函数来创建一个空的文件.注意,如果此次产生了错误,我们不会捕获,我们的程序将致命的终止——测试程序当我们连文件都无法创建时不会继续.

　Our test uses four different permission configurations. A zero means no per- missions at all, 0100 means execute-only, 0400 indicates read-only, and 0500 means read- and execute-only (0400 + 0100). In all cases, we will attempt to open a file with an invalid mode. The os.chmod() function is responsible for updating a file’s permission modes. (Note: These permissions all have a leading zero in front, indicating that they are octal [base 8] numbers.)
　If an error occurs, we want to display diagnostic information similar to the way the Python interpreter performs the same task when uncaught excep- tions occur, and that is giving the exception name followed by its arguments. The __class__ special variable represents the class object from which an instance  was  created.  Rather  than  displaying  the  entire  class  name  here
(myexc.FileError), we use the class object’s  __name__ variable to just display the class name (FileError), which is also what you see from the interpreter  in  an  unhandled  error  situation.  Then  the  arguments  that  we arduously put together in our wrapper functions follow.

我们的测试用了4种不同的权限配置.零标示没有任何权限,0100表示仅能执行,0400表示只读,0500表示只可读或执行(0400+0100).在所有的情况下,我们试图用一种无效的方式打开文件.os.chmod()被用来改变文件的权限(注意:这些权限有前导的零,表明他们是八进制[基数8]数)
如果发生错误,我们希望可以显示诊断的信息,类似Python解释器捕获异常时所做的那样. 这就是给出异常名和紧跟其后的异常的参数.__class__属性表示实例化该实例的类对象. 比在此显示完整的类名(myexc.FileError)更好的做法是通过类对象的__name__属性来显示类名(FileError),这也是异常未被捕获时你在解释器所见到的.随后是我们在封装函数中辛辛苦苦聚到一起的参数.

　If the file opened successfully, that means the permissions were ignored for some reason. We indicate this with a diagnostic message and close the file. Once all tests have been completed, we enable all permissions for the file and remove it with the os.unlink() function. (os.remove() is equiva- lent to os.unlink().)

如果文件被打开成功,也就是权限由于某种原因被忽略.我们通过诊断信息指明并关闭文件.当所有的测试都完成时,我们对文件开启所有的权限然后用os.unlink()移除(os.remove()等价于os.unlink()).

Lines 97–106
The next section of code (testnet()) tests our NetworkError exception. A socket is a communication endpoint with which to establish contact with another host. We create such an object, then use it in an attempt to connect to a host with no server to accept our connect request and a host not on our network.

行97-106

下一段代码(testnet())测试了我们的网络异常.套接字是一个用来与其他主机建立连接的通信端点.我们创建一个套接字,然后用它连接一个没有接受我们连接的服务器的主机和一个不存在于我们网络的主机.

Lines 108–110
We want to execute our test*() functions only when invoking this script directly, and that is what the code here does. Most of the scripts given in this text utilize the same format.

行108-110
我们希望仅在直接调用我们脚本时执行test*()函数,此处的代码完成了该功能.大多数脚本用同样的格式给出了这段文本.

Running this script on a Unix-flavored box, we get the following output:

在Unix系的机器上运行这段脚本,我们得到了如下的输出:

$myexc.py
FileError: [Errno 13] 'r' Permission denied (perms: '---'):
'/usr/tmp/@18908.1'
FileError: [Errno 13] 'r' Permission denied (perms: '--x'):
'/usr/tmp/@18908.1'
FileError: [Errno 13] 'w' Permission denied (perms: 'r--'):
'/usr/tmp/@18908.1'
FileError: [Errno 13] 'w' Permission denied (perms: 'r-x'):
'/usr/tmp/@18908.1'
NetworkError: [Errno 146] Connection refused: 'deli:8080' NetworkError: [Errno 6] host not found: 'www:8080'

The results are slightly different on a Win32 machine:
在Win32的机器上有些许的不同:

D:\python> python myexc.py
C:\WINDOWS\TEMP\~-195619-1 opened ok... perms ignored C:\WINDOWS\TEMP\~-195619-1 opened ok... perms ignored FileError: [Errno 13] 'w' Permission denied (perms: 'r-x'):
'C:\\WINDOWS\\TEMP\\~-195619-1'
FileError: [Errno 13] 'w' Permission denied (perms: 'r-x'):
'C:\\WINDOWS\\TEMP\\~-195619-1'
NetworkError: [Errno 10061] winsock error: 'deli:8080' NetworkError: [Errno 6] host not found: 'www:8080'

You  will  notice  that  Windows  does  not  support  read  permissions  on  files, which  is  the  reason  why  the  first  two  file  open  attempts  succeeded.  Your mileage may vary (YMMV) on your own machine and operating system.

你可以看到Windows不支持文件的读权限,这就是前两次尝试文件打开成功的原因.在你的机器和操作系统上的结果可能会大相径庭。

10.10  Why Exceptions (Now)?

10.10  为什么用异常(现在)?

There is no doubt that errors will be around as long as software is around. The difference in today’s fast-paced computing world is that our execution environments have changed, and so has our need to adapt error-handling to accurately  reflect  the  operating  context  of  the  software  that  we  develop. Modern-day applications generally run as self-contained graphical user interfaces (GUIs) or in a client/server architecture such as the Web.

毫无疑问,错误的存在会伴随着软件的存在.区别在于当今快节奏的计算世界, 我们的执行环境已经改变, 所以我们需要改变错误处理, 以准确反映我们软件的开发环境. 就现今应用来说, 普遍的是自洽(self-contained)的图形用户界面（GUIs）或是客户机/服务器体系, 例如Web. 

The ability to handle errors at the application level has become even more important recently in that users are no longer the only ones directly running applications. As the Internet and online electronic commerce become more pervasive, Web servers will be the primary users of application software. This means that applications cannot just fail or crash outright anymore, because if they do, system errors translate to browser errors, and these in turn lead to frustrated users. Losing eyeballs means losing advertising revenue and potentially significant amounts of irrecoverable business.
    
在应用层处理错误的能力近来变得更为重要, 用户已不再是应用程序的的唯一的直接运行者.  随着互联网和网上电子商业应用越来越普及, web服务器将成为应用软件的主要客户. 这意味着应用程序再也不能只是直接的失败或崩溃, 因为如果这样, 系统错误导致浏览器的错误, 这反过来又会让用户沮丧. 失去眼球意味着失去广告收入和和潜在的大量无可挽回的生意. 

　If errors do occur, they are generally attributed to some invalid user input. The execution environment must be robust enough to handle the application- level  error  and  be  able  to  produce  a  user-level  error  message.  This  must translate to a “non-error” as far as the Web server is concerned because the application must complete successfully, even if all it does is return an error message  to  present  to  the  user  as  a  valid  Hypertext  Markup  Language(HTML) Web page displaying the error.
　
如果错误的确发生了, 它们一般都归因于用户输入的数据无效. 运行环境必须足够强健,来处理应用级别的错误,并提供用户级别的错误信息.就服务器而言,这必须转化为一个"非错误" . 因为应用必须要成功的完成, 即使所做的不过是返回一个错误的信息, 向用户是提供一个有效的超文本标记语言(HTML)的网页指明错误.

　If  you  are  not  familiar  with  what  I  am  talking  about,  does  a  plain  Web browser  screen  with  the  big  black  words  saying,  “Internal  Server  Error” sound familiar? How about a fatal error that brings up a pop-up that declares “Document contains no data”? As a user, do either of these phrases mean anything to you? No, of course not (unless you are an Internet software engi- neer), and to the average user, they are an endless source of confusion and frustration. These errors are a result of a failure in the execution of an application.  The  application  either  returns  invalid  Hypertext  Transfer  Protocol (HTTP) data or terminates fatally, resulting in the Web server throwing its hands up into the air, saying, “I give up!”

如果你不清楚我在说什么, 那个一个简单的网页浏览器窗口,用大而黑的字体写到"内部服务器错误"是否更耳熟？用一个弹出式窗口宣告"文件中没有数据"的致命错误如何？作为一个用户, 这些词语对你有意义吗？没有, 当然没有（除非你是一个互联网软件工程师）, 至于对普通用户来说, 这些是无休止的混乱和挫折感的来源. 这些错误导致在执行的程序时的失败. 应用不论是返回无效的超文本传输协议（ http）数据还是致命地终止, 都会导致Web服务器举手投降, 说： "我放弃" ！

　This type of faulty execution should not be allowed, if at all possible. As systems become more complex and involve more apprentice users, additional care should be taken to ensure a smooth user application experience. Even in the face of an error situation, an application should terminate successfully, as to not affect its execution environment in a catastrophic way. Python’s exception handling promotes mature and correct programming.

这种类型的执行错误不应该被允许, 无论情况如何. 随着系统变得更加复杂, 又牵涉到更多的新手用户, 要采取额外的措施, 确保用户平滑的学到应用经验. 即使面对一个错误, 应用应该成功的中止, 不至于灾难性的影响其执行环境. Python异常处理促使成熟和正确的编程. 

10.11  Why Exceptions at All?

10.11 到底为什么要异常?

If  the  above  section  was  not  motivation  enough,  imagine  what  Python  pro- gramming might be like without program-level exception handling. The first thing that comes to mind is the loss of control client programmers have over their code. For example, if you created an interactive application that allocates and utilizes a large number of resources, if a user hit ^C or other keyboard interrupt, the application would not have the opportunity to perform cleanup, resulting in perhaps loss of data or data corruption. There is also no mechanism to take alternative action such as prompting the users to confirm whether they really want to quit or if they hit the Control key accidentally.

如果上文的动机不够充分, 试想Python编程没有程序级的异常处理. 第一件事需要担心的是客户端程序员在自己的代码中遗忘控制. 举例来说, 如果你创造了一个交互的应用程序分配并使用了大量的资源, 如果一个用户击中Ctrl+C或其他键盘中断, 应用程序将不会有机会执行清理工作, 可能导致数据丢失或数据损坏. 此外, 也没有机制来给出可选的行为, 诸如提示用户, 以确认他们真的是想退出或是他们意外的按下了Ctrl键. 

Another drawback would be that functions would have to be rewritten to return a “special” value in the face of an error situation, for example, None. The  engineer  would  be  responsible  for  checking  each  and  every  return value from a function call. This may be cumbersome because you may have to check return values, which may not be of the same type as the object you are  expecting  if  no  errors  occurred.  And  what  if  your  function  wants  to return None as a valid data value? Then you would have to come up with another return value, perhaps a negative number. We probably do not need to  remind  you  that  negative  numbers  may  be  valid  in  a  Python  context, such as an index into a sequence. As a programmer of application program- mer  interfaces  (APIs),  you  would  then  have  to  document  every  single return error your users may encounter based on the input received. Also, it is difficult (and tedious) to propagate errors (and reasons) of multiple layers of code.

另一个缺点就是函数必须重写来为错误的情形返回一个"特殊"的值, 如:None. 程序员要负责检查每一个函数调用的返回值. 这可能是个麻烦, 因为你可能不得不检查返回值, 这和没有发生错误时你期待结果也许不是同一类型的对象. 什么,你的函数要把None作为一个有效的数值返回？那么, 你将不得不拿出另一个返回值, 也许是负数.我们也许并不需要提醒你, 在Python的环境下负数下可能是有效的, 比如作为一个序列的索引. 作为一个写应用程序接口（ API ）的程序员, 你不得不为每个一个用户输入可能遇到的返回错误写文档. 同时, 我们难以（而且乏味）在多层次的代码中以传播错误（和原因）. 

　There  is  no  simple  propagation  like  the  way  exceptions  do  it.  Because error data needs to be transmitted upwards in the call hierarchy, it is possi- ble to misinterpret the errors along the way. A totally unrelated error may be stated as the cause when in fact it had nothing to do with the original problem to begin with. We lose the bottling-up and safekeeping of the orig- inal error that exceptions provide as they are passed from layer to layer, not to  mention  completely  losing  track  of  the  data  we  were  originally  concerned about! Exceptions simplify not only the code, but the entire error management scheme, which should not play such a significant role in application  development.  And  with  Python’s  exception  handling  capabilities,  it does not have to.

没有一个简单的传播方法像异常一样做到这一点. 因为错误的数据需要在调用层次中向上转发, 但在前进的道路上可能被曲解. 一个不相干的错误可能会被宣布为起因,而实际上它与原始问题完全无关.在一层一层的传递中,我们失去了对原始错误封装和保管的能力,更不用说完全地失去我们原本关心的数据的踪影!异常不仅简化代码, 而且简化整个错误管理体系 --- 它不该在应用开发中如此重要角色;而有了Python的异常处理能力, 也的确没有必要了. 

10.12  Exceptions and the sys Module
10.12  异常和sys模块

An  alternative  way  of  obtaining  exception  information  is  by  accessing  the exc_info() function in the sys module. This function provides a 3-tuple of  information,  more  than  what  we  can  achieve  by  simply  using  only  the exception argument. Let us see what we get using sys.exc_info():

另一种获取异常信息的途径是通过sys模块中exc_info()函数. 此功能提供了一个3元组(3-tuple)的信息, 多于我们单纯用异常参数所能获得. 让我们看看如何用sys.exc_info() :


>>> try:
...     float('abc123')
... except:
...     import sys
...     exc_tuple = sys.exc_info()
...
>>> print exc_tuple
(<class exceptions.ValueError at f9838>, <exceptions. ValueError instance at 122fa8>,
<traceback object at 10de18>)
>>>

>>> for eachItem in exc_tuple:
...    print eachItem
... exceptions.ValueError
invalid literal for float(): abc123
<traceback object at 10de18>

What we get from sys.exc_info() in a tuple are:
我们从sys.exc_info()得到的元组中是:

?    exc_type: exception class object
?    exc_value: (this) exception class instance object
?    exc_traceback: traceback object

?    exc_type: 异常类
?    exc_value: 异常类的实例
?    exc_traceback: 追踪(traceback)对象

The first two items we are familiar with: the actual exception class and this particular exception’s instance (which is the same as the exception argument which  we  discussed  in  the  previous  section).  The  third  item,  a  traceback object, is new. This object provides the execution context of where the exception  occurred.  It  contains  information  such  as  the  execution  frame  of  the code that was running and the line number where the exception occurred.

我们所熟悉的前两项：实际的异常类, 和这个异常类的实例（和在上一节我们讨论的异常参数是一样的） . 第三项, 是一个新增的追踪(traceback)对象. 这一对象提供了的发生异常的上下文. 它包含诸如代码的执行帧,异常发生时的行号等信息. 

In older versions of Python, these three values were available in the sys module   as   sys.exc_type,   sys.exc_value,   and   sys.exc_traceback. Unfortunately, these three are global variables and not thread-safe. We recom mendusing sys.exc_info() instead. All three will be phased out and eventually removed in a future version of Python.
    
在旧版本中的Python中, 这三个值分别存在于sys模块, 为sys.exc_type ,  sys.exc_value ,  sys.exc_traceback . 不幸的是, 这三者是全局变量而不是线程安全的. 我们建议亡羊补牢, 用sys.exc_info()来代替. 在未来版本Python中,所有这三个变量都将被逐步停用,并最终移除. 

10.13  Related Modules

10.13  相关模块

Table 10.3 lists some of the modules related to this chapter.

表10.3 此章的相关模块

Table 10.3  Exception-Related Standard Library Modules

表10.3 异常相关的标准库

Module    Description

模块    描述

exceptions    Built-in exceptions (never need to import this module)

            内建异常(永远不用导入这个模块)

contextliba Context object utilities for use with the with statement
           为使用with语句的上下文对象工具
            
sys        Contains various exception-related objects and func- tions (see sys.ex*)
        包含各种异常相关的对象和函数(见sys.ex*)
        
a.    New in Python 2.5.

a.  Python2.5新增

10.14  Exercises
练习

10–1.    Raising Exceptions. Which of the following can raise exceptions during program execution? Note that this question does not ask what may cause exceptions.

引发异常. 以下的哪个因素会在程序执行时引发异常? 注意这里我们问的并不是异常的原因.

(a) The user (of your program)
(b) The interpreter
(c) The program(er)
(d) All of the above
(e) Only (b) and (c)
(f) Only (a) and (c)

a) 用户
b) 解释器
c) 程序
d) 以上所有
e) 只有 b) 和 c)
f) 只有 a) 和 c)

10–2.    Raising Exceptions. Referring to the list in the problem above, which could raise exceptions while running within the inter- active interpreter?

引发异常. 参考上边问题的列表, 哪些因素会在执行交互解释器时引发异常?

10–3.    Keywords. Name the keyword(s) which is (are) used to raise exceptions.

关键字. 用来引发异常的关键字有那些?

10–4.    Keywords. What is the difference between try-except and
try-finally?

关键字. try-except 和 try-finally 有什么不同?

10–5.    Exceptions. Name the exception that would result from exe-
cuting the following pieces of Python code from within the interactive interpreter (refer back to Table 10.2 for a list of all built-in exceptions):

异常. 下面这些交互解释器下的 Python 代码段分别会引发什么异常(参阅表 10.2 给出的内建异常清单):

(a)    
>>> if 3 < 4 then: print '3 IS less than 4!'

(b)    
>>> aList = ['Hello', 'World!', 'Anyone', 'Home?']
>>> print 'the last string in aList is:', aList[len(aList)]

(c)    
>>> x

(d)    
>>> x = 4 % 0

(e)    
>>> import math
>>> i = math.sqrt(-1)

10–6.    Improving open(). Create a wrapper for the open() func-
tion. When a program opens a file successfully, a file handle
will be returned. If the file open fails, rather than generating an error, return None to the callers so that they can open files without an exception handler.

改进的 open(). 为内建的 open() 函数创建一个封装. 使得成功打开文件后, 返回文件句柄; 若打开失败则返回给调用者 None , 而不是生成一个异常. 这样你打开文件时就不需要额外的异常处理语句.

10–7.    Exceptions. What is the difference between Python pseudocode snippets (a) and (b)? Answer in the context of statements A and B, which are part of both pieces of code.(Thanks to Guido for this teaser!)
异常. 下面两段 Python 伪代码 a) 和 b) 有什么区别? 考虑语句 A 和 B 的上下文环境. (这么细致的区别要感谢  Guido )

(a)    
try:
    statement_A
except . . .:
    . . .
else:
    statement_B

(b)    
try: 
    statement_A 
    statement_B
except . . .:
    . . .
10–8.        Improving raw_input(). At the beginning of this chapter, we presented a “safe” version of the float() built-in func- tion to detect and handle two different types of exceptions that
float() generates. Likewise, the raw_input() function can generate two different exceptions, either EOFError or KeyboardInterrupt on end-of-file (EOF) or cancelled input, respectively. Create a wrapper function, perhaps safe_ input(); rather than raising an exception if the user entered EOF (^D in Unix or ^Z in DOS) or attempted to break out using ^C, have your function return None that the calling function can check for.

改进的 raw_input() . 本章的开头, 我们给出了一个"安全"的 float() 函数, 它建立在内建函数 float() 上, 可以检测并处理 float() 可能会引发的两种不同异常. 同样, raw_input() 函数也可能会生成两种异常, EOFError (文件末尾 EOF, 在 Unix 下是由于按下了 Ctrl+D 在 Dos 下是因为 Ctrl+Z)或是 KeyboardInterrupt (取消输入, 一般是由于按下了 Ctrl+C). 请创建一个封装函数 safe_input() , 在发生异常时返回 None .

10–9.    Improving math.sqrt(). The math module contains many functions and some constants for performing various mathe- matics-related operations. Unfortunately, this module does
not recognize or operate on complex numbers, which is the reason why the cmath module was developed. Create a function, perhaps safe_sqrt(), which wraps math.sqrt(), but is smart enough to handle a negative parameter and return
a complex number with the correct value back to the caller.

改进的 math.sqrt(). math 模块包含大量用于处理数值相关运算的函数和常量. 不幸的是, 它不能识别复数, 所以我们创建了 cmath 模块来支持复数相关运算. 请创建一个 safe_sqrt() 函数, 它封装 math.sqrt() 并能处理负值, 返回一个对应的复数.
