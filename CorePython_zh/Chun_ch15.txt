Regular Expressions
正则表达式


Chapter Topics
	Introduction/Motivation
	Special Characters and Symbols
	Regular Expressions and Python
	re Module
	15
	
本章主题
	* 引言/动机
	* 特别的字符和符号
	* 正则表达式与Python
	* re模块
	
15.1 Introduction/Motivation
介绍/动机

Manipulating text/data is a big thing. If you don’t believe me, look very carefully at what computers primarily do today. Word processing, “fill-out-form” Web pages, streams of information coming from a database dump, stock quote information, news feeds—the list goes on and on. Because we may not know the exact text or data that we have programmed our machines to process, it becomes advantageous to be able to express this text or data in patterns that a machine can recognize and take action upon.
处理文本和数据是件大事。如果您不相信我说的话，请仔细看看现如今的计算机主要都在做些什么工作。文字处理、网页填表、来自数据库的信息流、股票报价信息、新闻列表，这个清单还会不断地增长。因为我们可能不知道这些需要计算机编程处理文本或数据的具体内容，所以能把这些文本或数据以某种可被计算机识别和处理的模式表达出来是非常有用的。

　If I were running an electronic mail (e-mail) archiving company, and you were  one  of  my  customers  who  requested  all  his  or  her  e-mail  sent  and received last February, for example, it would be nice if I could set a computer program to collate and forward that information to you, rather than having a human being read through your e-mail and process your request manually. You would be horrified (and infuriated) that someone would be rummaging through your messages, even if his or her eyes were supposed to be looking only at time-stamp. Another example request might be to look for a subject line like “ILOVEYOU” indicating a virus-infected message and remove those e-mail messages from your personal archive. So this begs the question of how we can program machines with the ability to look for patterns in text.
			假设我在运营一个电子邮件档案公司，而您是我的一位顾客，比如说，您想获得自己去年二月间收发的所有邮件，如果我能设计一个计算机程序来整理信息然后将它转发给您，而不是通过人工方法通读您的邮件后再手动地处理您的请求，如此处理将会非常不错。因为如果有人会看遍您的邮件信息，哪怕只是是用眼睛看一下邮件上的时间，您可能都会对此感到担心(甚至愤怒)。又比如，您可能会认为凡是带有“ILOVEYOU”这样主题的邮件都是已感染病毒的信息，并要求从您的个人邮箱中删除它们。这就引出一个问题，我们如何通过编程使计算机具有在文本中检索某种模式的能力。
			
　Regular expressions (REs) provide such an infrastructure for advanced text pattern matching, extraction, and/or search-and-replace functionality. REs are simply strings that use special symbols and characters to indicate pattern repetition or to represent multiple characters so that they can “match” a set of strings with  similar  characteristics  described  by  the  pattern  (Figure  15–1).  In  other words, they enable matching of multiple strings—an RE pattern that matched only one string would be rather boring and ineffective, wouldn’t you say?

　正则表达式(RE)为高级文本模式匹配，以及搜索-替代等功能提供了基础。正则表达式(RE)是一些由字符和特殊符号组成的字符串，它们描述了这些字符和字符的某种重复方式，因此能按某种模式匹配一个有相似特征的字符串的集合，因此能按某模式匹配一系列有相似特征的字符串，见图15–1。换句话说，它们能匹配多个字符串 - 一个只能匹配一个字符串的RE模式是乏味且毫无作用的，你说是不是?


Regular Expression Engine
正则表达式引擎

Figure 15–1    You can use regular expressions, such as the one here, which recognizes valid Python identifiers. ‘‘[A-Za-z]\w+ ” means the first character should be alphabetic, i.e., either A–Z or a–z, followed by at least one (+) alphanumeric character (\w). In our filter, notice how many strings go into the filter, but the only ones to come out are the ones we asked for via the RE. One example that did not make it was “4xZ” because it starts with a number.
图15-1		 你可以用这个正则表达式匹配有效的Python标志符。 "[A-Za-z]\w+ " 的含义是: 第一个字符是字母，即，由大写字母A到Z或是小写字母a到z组成, 它后面至少(+)跟有一个由字母或数字组成的字符(\w). 如图，你看到有很多字符串被过滤，只有那些符合我们要求的RE模式的字符串被筛选出来。比如，“4xZ”，因为它是以数字开头的，所以被过滤了。


Python  supports  REs  through  the  standard  library  re module.  In  this introductory  subsection,  we  will  give  you  a  brief  and  concise  introduction. Due to its brevity, only the most common aspects of REs used in everyday Python programming will be covered. Your experience will, of course, vary. We highly recommend reading any of the official supporting documentation as  well  as  external  texts  on  this  interesting  subject.  You  will  never  look  at strings the same way again!
Python通过标准库的re模块支持正则表达式(RE)。本节我们将向你简要地介绍这。限于篇幅，内容将仅涉及Python编程中正则表达式(RE)方面最常见的内容。你们(对正则)的经验(熟悉程度)肯定不同。我们强烈建议您阅读一些官方帮助文档和与此主题有关的文本。那么你对字符串的理解方式就会有所改变。

CORE NOTE: Searching versus matching
核心笔记：查找与匹配的比较

Throughout this chapter, you will find references to searching and matching. When we are strictly discussing regular expressions with respect to patterns in strings, we will say “matching,” referring to the term pattern-matching. In Python terminology, there are two main ways to accomplish pattern-matching: searching, i.e., looking for a pattern match in any part of a string, and matching, i.e., attempting to match a pattern to an entire string (starting from the beginning). Searches are accomplished using the search() function or method, and matching is done with the match() function or method. In summary, we keep the term “matching” universal when referencing patterns, and we differentiate between “searching” and “matching” in terms of how Python accomplishes pattern-matching.
本章通篇涉及到对查找和匹配用法的讲述。当我们完全讨论与字符串中模式有关的正则表达式时，我们会用术语 “matching”(“匹配”)，指的是术语pattern-matching(模式匹配)。在Python专门术语中，有两种主要方法完成模式匹配：搜索(searching)和匹配(matching)。搜索，即在字符串任意部分中查找匹配的模式，而匹配是指，判断一个字符串能否从起始处全部或部分的匹配某个模式。搜索通过search()函数或方法来实现，而匹配是以调用match()函数或方法实现的。
总之，当我们说模式的时候，我们全部使用术语“matching”(“匹配”)；我们按照Python如何完成模式匹配的方式来区分“搜索”和“匹配”。


15.1.1 Your First Regular Expression
您的第一个正则表达式

As we mentioned above, REs are strings containing text and special characters that describe a pattern with which to recognize multiple strings. We also briefly  discussed  a  regular  expression  alphabet  and  for  general  text,  the alphabet used for regular expressions is the set of all uppercase and lowercase letters plus numeric digits. Specialized alphabets are also possible, for instance,  one  consisting  of  only  the  characters  “0”  and  “1”.  The  set  of  all strings over this alphabet describes all binary strings, i.e., “0,” “1,” “00,” “01,” “10,” “11,” “100,” etc.
我们上面已经提到，正则表达式是含有文本和特别字符的字符串，这些文本和特别字符描述的模式可以识别各种字符串。我们还简单阐述了正则表达式字母表，以及用于匹配通用文本的正则表达式字母表——所有大小写字母及数字的集合。也存在特别的字母表，比如，只含有字符"0"和"1"的字母表. 该字母表可以表示所有二进制整数的集合，即，"0," "1," "00," "01," "10," "11," "100," 等. 

　Let us look at the most basic of regular expressions now to show you that although REs are sometimes considered an “advanced topic,” they can also be rather simplistic. Using the standard alphabet for general text, we present some simple REs and the strings that their patterns describe. The following regular expressions are the most basic, “true vanilla,” as it were. They simply consist of a string pattern that matches only one string, the string defined by the regular expression. We now present the REs followed by the strings that match them:
  让我们看看正则表达式的基本情况，虽然正则表达式常被视为是“高级主题”，有时候它们也是非常简单的。我们列出一些用一般文本的标准字母组成简单的正则表达式及它们所描述的字符串。以下的正则表达式是最基本，最普通的。它们仅由一个字符串定义了一个模式,该模式仅匹配这个字符串本身，该字符串由正则表达式定义。以下是正则表达式(RE)和匹配它们的字符串。
　

RE Pattern	String(s) Matched
foo	foo Python	Python abc123	abc123
　The first regular expression pattern from the above chart is “foo.” This pattern  has  no  special  symbols  to  match  any  other  symbol  other  than  those described, so the only string that matches this pattern is the string “foo.” The same thing applies to “Python” and “abc123.” The power of regular expressions comes in when special characters are used to define character sets, subgroup matching, and pattern repetition. It is these special symbols that allow an RE to match a set of strings rather than a single one.
  上表中第一个正则表达式模式是"foo"。这个模式不包含任何特殊符号去匹配其他符号，它仅匹配自身所描述的，所以只有字符串"foo"匹配此模式。同理，“Python”和“abc123.”也一样。正则表达式的强大之处在于特殊符号的应用，特殊符号定义了字符集合，子组匹配，模式重复次数。正是这些特殊符号使得一个正则表达式可以匹配字符串集合而不只是一个字符串。

15.2 Special Symbols and Characters
正则表达式使用的特殊符号和字符

We will now introduce the most popular of the metacharacters, special characters and symbols, which give regular expressions their power and flexibility. You will find the most common of these symbols and characters in Table 15.1.
现在,我们来介绍最常用的元字符(metacharacters)——特殊字符和符号，正是它们赋予了正则表达式强大的功能和灵活性。正则表达式中最常见的符号和字符见表15.1.

Table 15.1  Common Regular Expression Symbols and Special Characters
表15.1 常用正则表达式符号和特殊字符

Notation  
记号

Description
说明

Example RE
举例
Symbols


literal
Match literal string value literal
匹配字符串的值
foo
re1|re2
Match regular expressions re1 or re2
匹配正则表达式 re1 或 re2
foo|bar
.
Match any character (except NEWLINE)
匹配任何字符 (换行符除外)
b.b
^
Match start of string
匹配字符串的开始
^Dear
$
Match end of string
匹配字符串的结尾
/bin/*sh$
*
Match 0 or more occurrences of preceding RE
匹配前面出现的正则表达式零次 或 多次
[A-Za-z0-9]*
+
Match 1 or more occurrences of preceding RE
匹配前面出现的正则表达式一次 或 多次
[a-z]+\.com
?
Match 0 or 1 occurrence(s) of preceding RE
匹配前面出现的正则表达式零次 或 一次
goo?
{N}
Match N occurrences of preceding RE
匹配前面出现的正则表达式N次
[0-9]{3}


Notation   Description	Example RE

	
Symbols    描述	                              正则表达式样例		
记法
符号

{M,N}	Match from M to N occurrences of preceding RE	[0-9]{5,9}
匹配重复出现M次 到 N次的的正则表达式


[...]	Match any single character from character class	[aeiou]
匹配字符组里出现的任意一个字符

[..x- y..]

Match any single character in the range from x to y
匹配从字符x到y中的任意一个字符

[0-9], [A- Za-z]


[^...]	Do not match any character from character class, including any ranges, if present
不匹配此字符集中出现的任何一个字符，包括某一范围的字符(如果在此字符集中出现).

[^aeiou],
[^A-Za-z0-9_]


(*|+|?|
{})?

Apply “non-greedy” versions of above occurrence/
用于上面出现的任何“非贪婪” 版本
repetition symbols ( *, +, ?, {})
重复匹配次数符号

.*?[a-z]

(...)	Match enclosed RE and save as subgroup	([0-9]{3})?, f(oo|u)bar
匹配封闭括号中正则表达式(RE)，并保存为子组

Special Characters
特殊字符

\d	Match any decimal digit, same as [0-9] (\D is inverse of \d: do not match any numeric digit)
\d	匹配任何数字, 和 [0-9] 一样 (\D 是 \d 的反义: 任何非数符字)
\w	Match any alphanumeric character, same as [A- Za-z0-9_] (\W is inverse of \w)
\w  匹配任何数字字母字符，和[A- Za-z0-9_] 相同 (\W 是 \w 的反义)
\s	Match any whitespace character, same as [ \n\t\r\v\f] (\S is inverse of \s)
\s  匹配任何空白符，和 [ \n\t\r\v\f] 相同，(\S 是 \s 的反义) 


data\d+.txt


[A-Za-z_]\w+


of\sthe

\b	Match any word boundary (\B is inverse of \b)	\bThe\b
匹配单词边界(\B 是 \b 的反义) 

\nn	Match saved subgroup nn (see (...) above)	price: \16
匹配已保存的子组(请参考上面的正则表达式符号: (...))

\c	Match any special character c verbatim (i.e., with- out its special meaning, literal)
逐一匹配特殊字符 c (即，取消它的特殊含义, 按字面匹配)

\., \\, \*
\A (\Z) Match start (end) of string (also see ^ and $ above)   \ADear
匹配字符串的起始(结束)


15.2.1 Matching More Than One RE Pattern with Alternation ( | )
用管道符号( | )匹配多个正则表达式模式

The pipe symbol ( | ), a vertical bar on your keyboard, indicates an alternation operation, meaning that it is used to choose from one of the different regular expressions, which are separated by the pipe symbol. For example, below are some patterns that employ alternation, along with the strings they match:
管道符号( | )， 就是您键盘上的竖杠，表示一个或操作，它的意思是选择被管道符号分隔的多个不同的正则表达式中的一个。例如，下面的一些使用或操作的模式，和它们所匹配的字符串：

RE Pattern		StringsMatched
正则表达式模式	 匹配的字符串

at|home	at, home 
r2d2|c3po	r2d2, c3po 
bat|bet|bit	bat, bet, bit

　With this one symbol, we have just increased the flexibility of our regular expressions, enabling the matching of more than just one string. Alternation is also sometimes called union or logical OR.
  有了这个符号，正则表达式的灵活性增强了，使得它可以匹配不止一个字符串，“或”(操作)有时候也被叫做“联合”(union)或者逻辑或(OR)。

15.2.2 Matching Any Single Character ( . )
匹配任意一个单个的字符( . )

The dot or period ( . ) symbol matches any single character except for NEWLINE (Python REs have a compilation flag [S or DOTALL], which can override this to include NEWLINEs.). Whether letter, number, whitespace not including “\n,” printable, non-printable, or a symbol, the dot can match them all.
点字符或句号(.)符号匹配除换行符(NEWLINE)外的任意一个单个字符(Python 的正则表达式有一个编译标识 [S or DOTALL]，该标识能 去掉 这一限制，使 ( . ) 在匹配时包括换行符(NEWLINEs)。) (这里括号缺一半) 无论是字母、数字、不包括“\n”的空白符、可打印的字符、还是非打印字符，或是一个符号，“点”，( . )都可以匹配他们。

RE Pattern	    Strings Matched
正表达式模式    匹配的字符串
f.o	            Any character between “f ” and “o”, e.g., fao,f9o, f#o, etc.
f.o             在"f"和"o"中间的任何字符，如fao, f9o, f#o等

..	            Any pair of characters 
..              任意两个字符

.end	        Any character before the string end
.end            匹配在字符串end前面的任意一个字符

Q: What if I want to match the dot or period character?
问：我怎样才能匹配点号(dot)或句号(period)?

A: In order to specify a dot character explicitly, you must escape its functionality with a backslash, as in “\.”.

答：为了明确地匹配一个点号(dot)本身，你必须（在前面)使用反斜线“\”对它进行转义。

15.2.3 Matching from the Beginning or End of Strings or Word Boundaries ( ^/$ /\b /\B )
15.2.4 从字符串的开头或结尾或单词边界开始匹配( ^/$ /\b /\B )



There are also symbols and related special characters to specify searching for patterns at the beginning and ending of strings. To match a pattern starting from the beginning, you must use the caret symbol ( ^ ) or the special character \A (backslash-capital “A”). The latter is primarily for keyboards that do not have the caret symbol, i.e., international. Similarly, the dollar sign ( $ ) or \Z will match a pattern from the end of a string.
还有些符号和特殊字符是用来从字符串的开头或结尾开始搜索正则表达式模式的。如果想从字符串的开头开始匹配一个模式，你必须用脱字符号( ^ , 即，Caret)或特殊字符 \A (大写字母A前面加上一个反斜线). 后者主要是为那些没有caret 符号的键盘使用的，比如说国际键盘。类似，美元符号 ( $ ) 或 \Z 是用来(零宽度)匹配字符串的结尾的。

Patterns that use these symbols differ from most of the others we describe in  this  chapter  since  they  dictate  location  or  position.  In  the  Core  Note above, we noted that a distinction is made between “matching,” attempting matches of entire strings starting at the beginning, and “searching,” attempting matches from anywhere within a string. With that said, here are some examples of “edge-bound” RE search patterns:
用这些符号的模式与我们将在本章讲述的其它大多数符号是不同的，因为这些符号指定了(匹配字符)的位置。在上面的核心笔记里，我们曾说过 “matching”和“searching” 之间的区别，“matching”是试图从整个字符串的开头进行匹配，而 “searching” 则可从一个字符串的任意位置开始匹配。正因为这几个字符和搜索的位置有关，所以需要和搜索模式一起使用。下面是几个“擦边球”的正则表达式搜索模式:

RE Pattern			Strings Matched
正则表达式模式		匹配的字符串

^From				Any string that starts with From
^From				匹配任何以From开始的字符串

/bin/tcsh$			Any string that ends with /bin/tcsh
/bin/tcsh$			匹配任何以 /bin/tcsh 结束的字符串

^Subject: hi$		Any string consisting solely of the string Subject: hi
^Subject: hi$		匹配仅由 Subject: hi 组成的字符串

　Again, if you want to match either (or both) of these characters verbatim, you must use an escaping backslash. For example, if you wanted to match any string that ended with a dollar sign, one possible RE solution would be the pattern “.*\$$”.
  特别说明，如果你想匹配这两个字符中的任何一个(或全部)，就必须用反斜线进行转义。例如，如果你想匹配任何以 美元符号($) 结尾的字符串，一个可行的解决办法是用正则表达式模式 “.*\$$”.
  
The \b and \B special characters pertain to word boundary matches. The difference between them is that \b will match a pattern to a word boundary, meaning that a pattern must be at the beginning of a word, whether there are any characters in front of it (word in the middle of a string) or not (word at the  beginning  of  a  line).  And  likewise,  \B will  match  a  pattern  only  if  it appears starting in the middle of a word (i.e., not at a word boundary). Here are some examples:

特殊字符 \b and \B 用来匹配单词边界。两者之间的区别是，\b 匹配的模式是一个单词边界，就是说，与之对应的模式一定在一个单词的开头，不论这个单词的前面是有字符(该词在一个字符串的中间)，还是没有字符(该单词在一行的起始处)。同样地，\B只匹配出现在一个单词中间的模式(即，不在单词边界上的字符)。看下面几个例子：

RE Pattern			Strings Matched
the					Any string containing the
the					任何包含有"the"的字符串

\bthe				Any word that starts with the
\bthe				任何以"the"开始的字符串

\bthe\b				Matches only the word the
\bthe\b				仅匹配单词 “the”

\Bthe				Any string that contains but does not begin with the
\Bthe				任意包含“the”但不以“the”开头的单词


15.2.5 Creating Character Classes ( [ ] )
创建字符类( [ ] )

While  the  dot  is  good  for  allowing  matches  of  any  symbols,  there  may  be occasions  where  there  are  specific  characters  you  want  to  match.  For  this reason, the bracket symbols ( [ ] ) were invented. The regular expression will match any of the enclosed characters. Here are some examples:
尽管点号可用来匹配任意字符，但有时候你需要匹配某些个特殊的字符。正因为如此，方括号( [ ] )被发明出来。使用方括号的正则表达式会匹配方括号里的任何一个字符。几个例子如下：

RE Pattern			Strings Matched
正则表达式模式		匹配的字符串

b[aeiu]t			bat, bet, bit, but

[cr][23][dp][o2] 	A string of 4 characters: first is “r” or “c,” then “2” or “3,” followed by “d” or “p,” and finally, either “o” or “2,” e.g., c2do, r3p2, r2d2, c3po, etc.

[cr][23][dp][o2] 	一个包含4个字符的字符串: 第一个字符是 “r” 或 “c”，后面是 “2” 或 “3”，再接下来是 “d” 或 “p”，最后是 “o” 或 “2“ ，例如：c2do, r3p2, r2d2, c3po, 等等。

　One   side   note   regarding   the   RE   “[cr][23][dp][o2]” — a more restrictive  version  of  this  RE  would  be  required  to  allow  only  “r2d2”  or “c3po” as valid strings. Because brackets merely imply “logical OR” functionality, it is not possible to use brackets to enforce such a requirement. The only solution is to use the pipe, as in “r2d2|c3po”.
关于正则表达式  “[cr][23][dp][o2]” 的一点要说明: 如果只让 “r2d2”  或 “c3po” 成为有效的字符串，就需要限定更为严格的正则表达式。但因为方括号只有"逻辑或"(“logical OR”)的功能，所以用方括号不能实现这一限定要求。唯一的解决办法是用管道符号(pipe), 例如：“r2d2|c3po”.
  

For single-character REs, though, the pipe and brackets are equivalent. For example, let’s start with the regular expression “ab,” which matches only the string with an “a” followed by a “b”. If we wanted either a one-letter string, i.e., either “a” or a “b,” we could use the RE “[ab].” Because “a” and “b” are individual strings, we can also choose the RE “a|b”. However, if we wanted to match the string with the pattern “ab” followed by “cd,” we cannot use the brackets because they work only for single characters. In this case, the only solution is “ab|cd”, similar to the “r2d2/c3po” problem just mentioned.
对仅有单个字符的正则表达式 ，使用管道符号和方括号的效果是等价的。举例来说，正则表达式“ab” , 只匹配以"a"开头后面再跟一个"b"的字符串。如果我们只想要一个字母的字符串，即，“a” 或者 “b” 中的一个，就可以使用正则表达式 “[ab]” 。因为 “a” 和 “b” 是单个的字符串，我们也可以用正则表达式 “a|b”。但是，如果我们想用模式匹配"ab"，后面接着是"cd"的字符串，就不能用方括号了，因为方括号只适用于单个字符的情况。这样，唯一的办法是用“ab|cd”, 这和我们刚才提到的 “r2d2|c3po”的道理是相同的。

15.2.5  Denoting Ranges ( - ) and Negation ( ^ )
15.2.5  指定范围 ( - ) 和 否定( ^ )

In addition to single characters, the brackets also support ranges of characters. A hyphen between a pair of symbols enclosed in brackets is used to indicate a range of characters, e.g., A–Z, a–z, or 0–9 for uppercase letters, lowercase letters, and numeric digits, respectively. This is a lexicographic range, so you are not restricted to using just alphanumeric characters. Additionally, if a caret ( ^ )
is the first character immediately inside the open left bracket, this symbolizes a directive not to match any of the characters in the given character set.

方括号除匹配单个字符外，还可以支持所指定的字符范围。方括号里一对符号中间的连字符(-)用来表示一个字符的范围，例如，A–Z, a–z, 或 0–9 分别代表大写字母、小写字母和十进制数字。这是一个按字母顺序排序的范围，所以它不限于只用在字母和十进制数字上。另外，如果在左方括号后第一个字符是上箭头符号(^)，就表示不匹配指定字符集里的任意字符。

RE Pattern				Strings Matched
正则表达式模式 			匹配的字符

z.[0-9]					“z”  followed  by  any  character  then  followed  by  a  single digit
z.[0-9]					字符"z"，后面跟任意一个字符，然后是一个十进制数字

[r-u][env-y][us]			“r” “s,” “t” or “u” followed by “e,” “n,” “v,” “w,” “x,” or “y” followed by “u” or “s”

[r-u][env-y][us]			“r” “s,” “t” 或 “u” 中的任意一个字符，后面跟的是 “e,” “n,” “v,” “w,” “x,” 或 “y”中的任意一个字符，再后面是字符“u” 或 “s”.

[^aeiou]					A  non-vowel  character  (Exercise:  Why  do  we  say  “non-vowels” rather than “consonants”?)
[^aeiou]					一个非元音字符 (练习： 为什么我们说”非元音“, 而不说”辅音字母“?)

[^\t\n]						Not a TAB or NEWLINE
[^\t\n]						除TAB制表符和换行符以外的任意一个字符 

["-a]						In an ASCII system, all characters that fall between ‘"‘ and “a,” i.e., between ordinals 34 and 97

["-a]						在使用ASCII字符集的系统中，顺序值在‘"‘ 和 “a”之间的任意一个字符，即，顺序号在34 和97之间的某一个字符。

15.2.6  Multiple Occurrence/Repetition Using Closure Operators ( *, +, ?, { } )
15.2.6  使用闭包操作符 ( *, +, ?, {} ) 实现多次出现/重复匹配

We will now introduce the most common RE notations, namely, the special symbols *, +, and ?, all of which can be used to match single, multiple, or no occurrences of string patterns. The asterisk or star operator ( * ) will match zero or more occurrences of the RE immediately to its left (in language and compiler  theory,  this  operation  is  known  as  the  Kleene  Closure).  The  plus operator ( + ) will match one or more occurrences of an RE (known as Positive Closure), and the question mark operator ( ? ) will match exactly 0 or 1 occurrences of an RE.

现在我们来介绍最常用的正则表达式符号，即，特殊符号 “*”, “+”, 和 “?”, 它们可以用于匹配字符串模式出现一次、多次、或未出现的情况。星号或称星号操作符匹配它左边那个正则表达式出现
零次或零次以上的情况(在计算机语言和编译器原理里，此操作符被叫做 Kleene 闭包操作符)。加号(+)操作符匹配它左边那个正则表达式模式至少出现一次的情况(它也被称为正闭包操作符)，而问号操作符( ? )匹配它左边那个正则表达式模式出现零次或一次的情况。

　There  are  also  brace  operators  ({ })  with  either  a  single  value  or  a comma-separated pair of values. These indicate a match of exactly N occurrences (for {N}) or a range of occurrences, i.e., {M, N} will match from M to N occurrences. These symbols may also be escaped with the backslash, i.e., “\*” matches the asterisk, etc.
  还有花括号操作符({ })， 花括号里可以是单个的值，也可以是由逗号分开的一对值。如果是一个值，如，{N}，则表示匹配N次出现；如果是一对值，即，{M, N}，就表示匹配M次到N次出现。可以在这些符号前用反斜线进行转义，使它们失去特殊作用，即， “\*” 将匹配星号本身等。

In the table above, we notice the question mark is used more than once (overloaded), meaning either matching 0 or 1 occurrences, or its other meaning: if it follows any matching using the close operators, it will direct the reg- ular expression engine to match as few repetitions as possible.
在上表中，我们注意到问号出现了不只一次(被重载),问号有两种含义:1.单独使用时表示匹配出现零次或一次的情况，2.紧跟在表示重复的元字符后面时，表示要求搜索引擎匹配的字符串越短越好。例如：(+?) 

　What does that last part mean, “as few . . . as possible?” When pattern-matching is employed using the grouping operators, the regular expression engine will try to “absorb” as many characters as possible which match the pattern. This is known as being greedy. The question mark tells the engine to lay off and if possible, take as few characters as possible in the current match, leaving the rest to match as many of succeeding characters of the next pattern (if applicable). We will show you a great example where non-greediness is required toward the end of the chapter. 
前面提到"越短越好..."是什么意思呢?当使用了表示重复的元字符(*+?{m,n})时，正则表达式引擎在匹配模式时会尽量"吸收"更多的字符。这就叫做"贪心"。问号告诉正则表达式引擎尽可能地偷懒，要求当前匹配消耗的字符越少越好，留下尽可能多的字符给后面的模式(如果存在)。 - 在本章末尾，我们举一个有代表性的例子来说明必须使用非贪心模式的情况。
  
For now, let us continue to look at the closure operators:
现在，让我们接着来看一些使用闭包操作符的例子:

RE Pattern			Strings Matched 

[dn]ot?				“d” or “n,” followed by an “o” and, at most, one “t” after that, i.e., do, no, dot, not 

[dn]ot?				字符"d"或"o", 后面是一个"o", 最后是最多一个字符"t"，即，do, no, dot, not

0?[1-9]				Any  numeric  digit,  possibly  prepended with a “0,” e.g., the set of numeric representations of the months January to Sep- tember, whether single- or double-digits
0?[1-9]				从1到9中的任意一位数字，前面可能还有一个"0". 例如：可以把它看成一月到九月的数字表示形式，不管是一位数字还是两位数字的表示形式。

[0-9]{15,16}		Fifteen or sixteen digits, e.g., credit card numbers
[0-9]{15,16}		15或16位数字表示，例如：信用卡号码

</?[^>]+>			Strings that match all valid (and invalid) HTML tags
</?[^>]+>			匹配所有合法(和无效的)HTML标签的字符串

[KQRBNP][a-h][1-8]-[a-h][1-8] 		Legal   chess   move   in   “long   algebraic” notation  (move  only,  no  capture,  check, etc.), i.e., strings which start with any of “K,” “Q,” “R,” “B,” “N,” or “P” followed by a hyphenated-pair of chess board grid locations  from  “a1”  to  “h8”  (and  everything in between), with the first coordinate  indicating  the  former  position  and the second being the new position.
[KQRBNP][a-h][1-8]-[a-h][1-8] 		在“长代数”记谱法中，表示的国际象棋合法的棋盘移动(仅移动，不包括吃子和将军)。 即， “K,” “Q,” “R,” “B,” “N,” 或 “P” 等字母后面加上两个用连字符连在一起的"a1"到"h8"之间的棋盘坐标。前面的编号表示从哪里开始走棋，后面的编号代表走到哪个位置(棋格)去。 


15.2.7  Special Characters Representing
15.2.7  特殊字符表示

Character Sets
字符集

We  also  mentioned  that  there  are  special  characters  that  may  represent character sets. Rather than using a range of “0–9,” you may simply use “\d” to indicate the match of any decimal digit. Another special character “\w”
can be used to denote the entire alphanumeric character class, serving as a shortcut for “A-Za-z0-9_”, and “\s” for whitespace characters. Uppercase versions of these strings symbolize non-matches, i.e., “\D” matches any non- decimal digit (same as “[^0-9]”), etc. Using these shortcuts, we will present a few more complex examples:
我们还提到有一些特殊字符可以用来代表字符集合。例如，你可以不使用  “0–9”这个范围表示十进制数字，而改用简写“\d”表示。另一个特殊的字符 “\w” 可用来表示整个 字符数字的字符集，即相当于“A-Za-z0-9_”的简写形式，特殊字符“\s” 代表空白字符。这些特殊字符的大写形式表示不匹配，比如，“\D” 表示非十进制数字的字符(等价于 “[^0-9]”)，等等。 我们来看几个运用这些简写形式的稍复杂的例子：

RE Pattern				Strings Matched
正则表达式模式 			匹配的字符串 

\w+-\d+					Alphanumeric  string  and  number  separated  by  a hyphen
\w+-\d+					一个由字母或数字组成的字符串，和至少一个数字，两部分中间由连字符连接

[A-Za-z]\w*				Alphabetic first character, additional characters (if present) can be alphanumeric (almost equivalent to the set of valid Python identifiers [see exercises])

[A-Za-z]\w*	

第一个字符是字母，其余字符(如果存在的话)，是字母或数字(它几乎等价于Python语言中合法的标识符[见参考练习])

\d{3}-\d{3}-\d{4}		(American) telephone numbers with an area code prefix, as in 800-555-1212
\d{3}-\d{3}-\d{4}		(美国)电话号码，前面带区号前缀，例如 800-555-1212

\w+@\w+\.com			Simple e-mail addresses of the form XXX@YYY.com
\w+@\w+\.com			简单的XXX@YYY.com 格式的电子邮件地址 

15.2.8  Designating Groups with Parentheses ( ( ) )
15.2.8  用圆括号(()) 组建组

Now, perhaps we have achieved the goal of matching a string and discarding non-matches, but in some cases, we may also be more interested in the data that we did match. Not only do we want to know whether the entire string matched our criteria, but also whether we can extract any specific strings
or  substrings  that  were  part  of  a  successful  match.  The  answer  is  yes.  To accomplish this, surround any RE with a pair of parentheses.
现在，或许我们可以匹配一个字符串和丢弃那些不匹配的字符串了，但有时候，我们也许对匹配的数据本身更有兴趣。我们不仅想知道是否整个字符串匹配我们的条件(正则表达式)，还想在匹配成功时取出某个特定的字符串或子字符串。要达到这个目的，只需要给正则表达式的两边加上一对圆括号。

　A pair of parentheses ( ( ) ) can accomplish either (or both) of the below when used with regular expressions:
  一对圆括号(()) 和正则表达式一起使用时可以实现以下任意一个(或两个)功能：

	Grouping regular expressions 
	对正则表达式进行分组
	
	Matching subgroups 
	匹配子组

　One good example for wanting to group regular expressions is when you have two different REs with which you want to compare a string. Another reason is to group an RE in order to use a repetition operator on the entire RE (as opposed to an individual character or character class).
  有时你需要对正则表达式进行分组，其中一个很好的例子就是，你要用两个不同的正则表达式去比较一个字符串。另一个理由是为整个正则表达式添加一个重复操作符(即不是仅重复单个字符或单一字符集)。

　One side effect of using parentheses is that the substring that matched the pattern is saved for future use. These subgroups can be recalled for the same match or search, or extracted for post-processing. You will see some examples of pulling out subgroups at the end of Section 15.3.9.
使用圆括号的一个额外好处就是匹配的子串会被保存到一个子组，便于今后使用。这些子组可以在同一次匹配或搜索中被重复调用，或被提取出来做进一步处理。在小节15.3.9的结尾你会读到一些提取子组的例子。

　Why are matches of subgroups important? The main reason is that there are times where you want to extract the patterns you match, in addition to making  a  match.  For  example,  what  if  we  decided  to  match  the  pattern “\w+-\d+” but wanted save the alphabetic first part and the numeric second part individually? This may be desired because with any successful match, we may want to see just what those strings were that matched our RE patterns. 

为什么需要使用子组匹配呢? 主要是有时除了进行匹配操作外，你还想要提取匹配模式的内容。如果想知道在成功的匹配中，是哪些字符串匹配了我们的正则表达式模式。例如，我们想用正则表达式“\w+-\d+”匹配一些内容，但又想把第一部分的字符和第二部分的数字分别保存，该怎么做呢?

  If we add parentheses to both subpatterns, i.e., “(\w+)-(\d+),” then we can access each of the matched subgroups individually. Subgrouping is preferred because the alternative is to write code to determine we have a match, then execute another separate routine (which we also had to create) to parse the entire match just to extract both parts. Why not let Python do it, since it is a supported feature of the re module, instead of reinventing the wheel?
　
如果我们给两个子模式都加上圆括号，即，将它写成 “(\w+)-(\d+)” ， 那我们就可以对这两个匹配的子组分别进行访问了。当然你也可以使用其他方法达到同样目的,比如,先写一段代码判断是否找到匹配的对象，然后再执行另一个程式(也必须再写一段代码)来解析整个匹配的部分，从中提取出两个部分来。然而相比之下把正则表达式划分为子组是更好的实现办法，因为Python已经在re模块里支持此功能，那为什么不让Python来做这项工作，而非要重复发明一个轮子呢？

RE Pattern				Strings Matched
正则表达式模式			匹配的字符串

\d+(\.\d*)?				Strings representing simple floating point number, that is, any number of digits followed optionally by a single decimal point and  zero  or  more  numeric  digits,  as  in “0.004,” “2,” “75.”, etc.

\d+(\.\d*)? 			表示简单的浮点数，即， 任意个十进制数字，后面跟一个可选的小数点，然后再接零或多个十进制数字。例如：“0.004,” “2,” “75.”,等等。

(Mr?s?\. )?[A-Z][a-z]* [ A-Za-z-]+ 				First name and last name, with a restricted first name (must start with uppercase; lowercase  only  for  remaining  letters,  if  any), the  full  name  prepended  by  an  optional title of “Mr.,” “Mrs.,” “Ms.,” or “M.,” and a flexible  last  name,  allowing  for  multiple words, dashes, and uppercase letters

(Mr?s?\. )?[A-Z][a-z]* [ A-Za-z-]+

名字和姓氏，对名字的限制(首字母大写，其它字母(如果存在)小写), 全名前有可选的称谓(“Mr.,” “Mrs.,” “Ms.,” 或 “M.,”)，姓氏没有什么限制，允许有多个单词、横线、大写字母。


15.3 REs and Python
15.3 正则表达式和Python语言

Now that we know all about regular expressions, we can examine how Python currently  supports  regular  expressions  through  the  re module.  The  re module was introduced to Python in version 1.5. If you are using an older version of Python, you will have to use the now-obsolete regex and regsub modules—these  older  modules  are  more  Emacs-flavored,  are  not  as  full-featured, and are in many ways incompatible with the current  re module. Both modules were removed from Python in 2.5, and import either of the modules from 2.5 and above triggers Import Error exception.
既然我们已知道了有关正则表达式本身的所有知识，那让我们来详细研究当前Python的默认正则表达式模块 re模块吧. re模块在Python1.5版本被引入。如果你正在使用Python的早期版本，你将只能用已过时的regex、regsub模块。这些模块具有Emacs风格，功能不丰富，而且与现在的re模块也不兼容。regex 和regsub这两个模块已在Python 2.5版本时被移除了，在 Python2.5及其后续版本，引入这两个模块中的任何一个将会引发Import Error异常。

However, regular expressions are still regular expressions, so most of the
basic concepts from this section can be used with the old regex and reg-sub software. In contrast, the new re module supports the more powerful and regular Perl-style (Perl5) REs, allows multiple threads to share the same compiled RE objects, and supports named subgroups. In addition, there is a transition  module  called   reconvert to  help  developers  move  from regex/regsub to re. However, be aware that although there are different flavors of regular expressions, we will primarily focus on the current incarnation for Python.
但正则表达式本身是不变的，所以本小节中的大多数基本概念仍然适用于旧版的regex 和reg-sub模块。与旧模块形成鲜明对比的是，新的re模块支持功能更强大、更通用的Perl 风格(具体说是Perl5的风格)的正则表达式，允许多线程共享同一经过编译的正则表达式对象，同时它还支持对正则表达式分组进行命名和按名字调用。另外, 有一个名叫reconvert的转换模块是帮助开发者从regex/regsub模块 迁移到re模块的。但请注意，正则表达式有不同的风格，我们主要研究当今Python语言中使用的正则表达式。

The re engine was rewritten in 1.6 for performance enhancements as well as adding Unicode support. The interface was not changed, hence the reason the module name was left alone. The new re engine—known internally as sre—thus replaces the existing 1.5 engine—internally called pcre.
re引擎已在Python1.6版本中被重写，改进了它的性能并添加了对Unicode的支持。接口并没有改变，因此模块的名字也保持不变。新的re引擎，内部被叫做sre, 替代了1.5版本中内部名为pcre的re引擎。


15.3.1  re Module: Core Functions and Methods
15.3.1  re 模块: 核心函数和方法

The chart in Table 15.2 lists the more popular functions and methods from the  re module.  Many  of  these  functions  are  also  available  as  methods  of compiled regular expression objects “regex objects” and RE “match objects.”
表15.2列出了re模块最常用的函数和方法。其中有很多函数也与已编译的正则表达式对象(regex objects) 和正则"匹配对象"(RE “match objects”)的方法同名并且具有相同功能。

In this subsection, we will look at the two main functions/methods, match() and search(), as well as the compile() function. We will introduce several more in the next section, but for more information on all these and the others that we do not cover, we refer you to the Python documentation.
在本小节，我们来看两个主要的函数/方法，match() 和 search(), 以及compile()函数。在下一节我们还会再介绍更多个，但如果想进一步了解我们涉及或没有涉及的更多相关信息，我们建议你参阅Python的文档。

Table 15.2  Common Regular Expression Functions and Methods
表15.2 常见的正则表达式函数与方法

Function/Method	Description
函数/方法 描述

re Module Function Only
re模块的函数

compile(pattern,flags=0)
Compile RE pattern with any optional flags and return a regex object
对正则表达式模式pattern进行编译，flags是可选标志符，并返回一个regex对象

re Module Functions and regex Object Methods
re模块的函数和regex对象的方法

match(pattern,string, flags=0)
Attempt to match RE pattern to string with optional flags; return match object on success, None on failure 
尝试用正则表达式模式pattern匹配字符串string，flags是可选标志符，如果匹配成功，则返回一个匹配对象；否则返回None

search(pattern,string, flags=0)
Search for first occurrence of RE pattern within string with optional flags; return match object on success, None on failure
在字符串string中查找正则表达式模式pattern的第一次出现，flags是可选标志符，如果匹配成功，则返回一个匹配对象；否则返回None

findall(pattern,string[,flags])a
Look for all (non-overlapping) occurrences of pattern in string; return a list of matches
在字符串string中查找正则表达式模式pattern的所有(非重复)出现；返回一个匹配对象的列表

finditer(pattern,string[, flags])b
Same as findall() except returns an iterator instead of a list; for each match, the iterator returns a match object
和findall()相同，但返回的不是列表而是迭代器；对于每个匹配，该迭代器返回一个匹配对象

Table 15.3  Common Regular Expression Functions and Methods
(continued)
表 15.3 常见的正则表达式函数与方法(继续)

Function/Method	Description 
函数/方法       描述

Match Object Methods
匹配对象的方法

split(pattern,string, max=0)

Split string into a list according to RE pattern delimiter and return list of successful matches, splitting at most max times (split all occurrences is the default)
根据正则表达式pattern中的分隔符把字符string分割为一个列表，返回成功匹配的列表，最多分割max次(默认是分割所有匹配的地方)。


sub(pattern, repl, string, max=0)

Replace all occurrences of the RE pattern in string with repl, substituting all occurrences unless max provided (also see subn() which, in addition, returns the number of substitutions made)
把字符串string中所有匹配正则表达式pattern的地方替换成字符串repl,如果max的值没有给出，则对所有匹配的地方进行替换(另外，请参考subn(),它还会返回一个表示替换次数的数值)。


group(num=0)	Return entire match (or specific subgroup num) 
group(num=0)    返回全部匹配对象(或指定编号是num的子组)

groups()	Return all matching subgroups in a tuple (empty if there weren’t any)
groups()    返回一个包含全部匹配的子组的元组(如果没有成功匹配，就返回一个空元组)

a.	New in Python 1.5.2; flags parameter added in 2.4.
a. Python 1.5.2中新增； 2.4中增加标识参数

b.  New in Python 2.2; flags parameter added in 2.4.
b. Python 2.2新增；2.4中增加标识参数

CORE NOTE: RE compilation (to compile or not to compile?)
核心笔记: RE 编译(何时应该使用compile函数?)

In Chapter 14, we described how Python code is eventually compiled into bytecode, which is then executed by the interpreter. In particular, we mentioned that calling eval() or exec with a code object rather than a string provides a significant performance improvement due to the fact that the compilation process does not have to be performed. In other words, using precompiled code objects is faster than using strings because the interpreter will have to compile it into a code object (anyway) before execution.
在第十四章，我们曾说过Python的代码最终会被编译为字节码,然后才被解释器执行。我们特别提到用调用eval() 或 exec()调用一个代码对象而不是一个字符串，在性能上会有明显地提升，这是因为对前者来说, 编译过程不必执行。换句话说，使用预编译代码对象要比使用字符串快，因为解释器在执行字符串形式的代码前必须先把它编译成代码对象。

The same concept applies to REs—regular expression patterns must be compiled into regex objects before any pattern matching can occur. For REs, which are compared many times during the course of execution, we highly recommend using precompilation first because, again, REs have to be compiled anyway, so doing it ahead of time is prudent for performance reasons. re.compile() provides this functionality.
这个概念也适用于正则表达式，在模式匹配之前，正则表达式模式必须先被编译成regex对象。由于正则表达式在执行过程中被多次用于比较，我们强烈建议先对它做预编译，而且，既然正则表达式的编译是必须的，那使用么预先编译来提升执行性能无疑是明智之举。re.compile() 就是用来提供此功能的。

The module functions do cache the compiled objects, though, so it’s not as if every search() and match() with the same RE pattern requires compilation. Still, you save the cache lookups and do not have to make function calls with the same string over and over. In Python 1.5.2, this cache held up to 20 compiled RE objects, but in 1.6, due to the additional overhead of Unicode awareness, the compilation engine is a bit slower, so the cache has been extended to 100 compiled regex objects.
其实模块函数会对已编译对象进行缓存，所以不是所有使用相同正则表达式模式的search()和match()都需要编译。即使这样，你仍然节省了查询缓存，和用相同的字符串反复调用函数的性能开销。 在Python1.5.2版本里, 缓存区可以容纳20个已编译的正则表达式对象，而在1.6 版本里，由于另外添加了对Unicode的支持，编译引擎的速度变慢了一些，所以缓存区被扩展到可以容纳100个已编译的regex对象。

15.3.2  Compiling REs with compile()
15.3.2  使用compile()编译正则表达式 

Almost all of the re module functions we will be describing shortly are available as methods for regex objects. Remember, even with our recommendation, precompilation is not required. If you compile, you will use methods; if you don’t, you will just use functions. The good news is that either way, the names are the same whether a function or a method. (This is the reason why there are module functions and methods that are identical, e.g., search(), match(), etc., in case you were wondering.) Since it saves one small step for most of our examples, we will use strings instead. We will throw in a few with compilation, though, just so you know how it is done.
我们稍后要讲到的大多数re模块函数都可以作为regex对象的方法。注意，尽管我们建议预编译，但它并不是必需的。如果你需要编译，就用方法，如果不需要，可以使用函数。幸运的是无论你用哪种方式-函数还是方法，名字都是相同的。(也许你曾对此好奇，这正是模块函数和方法完全一样的原因，例如，search(), match()等等) 在后面的例子里，我们将用字符串，这样可以省去一个小步骤。我们仍会用到几个预编译代码对象，这样你可以知道它的过程是怎么回事。

　Optional  flags  may  be  given  as  arguments  for  specialized  compilation. These flags allow for case-insensitive matching, using system locale settings for matching alphanumeric characters, etc. Please refer to the documentation  for  more  details.  These  flags,  some  of  which  have  been  briefly  mentioned (i.e., DOTALL, LOCALE), may also be given to the module versions of match() and  search() for  a  specific  pattern  match  attempt — these  flags are mostly for compilation reasons, hence the reason why they can be passed to the module versions of match() and search(), which do compile an RE pattern once. If you want to use these flags with the methods, they must already be integrated into the compiled regex objects.
编译rex对象时给出一些可选标志符，可以得到特殊的编译对象。这些对象将允许不区别大小写的匹配，或使用系统的本地设置定义的字母表进行匹配等。详情请参阅有关文档。这些标志符也可以做为参数传给模块 (改字)  版本的match()和search()进行特定模式的匹配，其中一些标志符已在前面做过简短介绍(例如，DOTALL,LOCALE) - 这些标志符多数用于编译，也正因如此它们可以被传给模块版本的match()和search()，而match()和search()肯定要对正则表达式模式编译一次。如果你想在regex对象的方法中使用这些标志符，则必须在编译对象时传递这些参数。

　In  addition  to  the  methods  below,  regex  objects  also  have  some  data attributes, two of which include any compilation flags given as well as the regular expression pattern compiled.
除下面的方法外，regex对象还有一些数据属性，其中两个是创建时给定的编译标志符和正则表达式模式。

15.3.3  Match Objects and the group() and groups() Methods
15.3.3  匹配对象 和 group(), groups() 方法

There  is  another  object  type  in  addition  to  the  regex  object  when  dealing with regular expressions, the match object. These are the objects returned on successful calls to match() or search(). Match objects have two primary methods, group() and groups().
在处理正则表达式时，除regex对象外，还有另一种对象类型 - 匹配对象。这些对象是在match()或search()被成功调用之后所返回的结果。匹配对象有两个主要方法：group() 和 groups().

group() will  either  return  the  entire  match,  or  a  specific  subgroup,  if requested.  groups() will  simply  return  a  tuple  consisting  of  only/all  the subgroups. If there are no subgroups requested, then groups() returns an empty tuple while group() still returns the entire match.

group()方法或者返回所有匹配对象或是根据要求返回某个特定子组。groups()则很简单，它返回一个包含唯一或所有子组的元组。如果正则表达式中没有子组的话， groups() 将返回一个空元组，而group()仍会返回全部匹配对象。

Python REs also allow for named matches, which are beyond the scope of this introductory section on REs. We refer you to the complete  re module documentation regarding all the more advanced details we have omitted here.
Python语言中的正则表达式支持对匹配对象进行命名的功能，这部分内容超出了本介绍性小节对正则表达式的讨论范围。我们建议你阅读re模块的文档，里面有我们省略掉的关于这些高级主题的详细内容。

15.3.4 Matching Strings with match()
用match()匹配字符串

match() is  the  first  re module  function  and  RE  object  (regex  object) method we will look at. The match() function attempts to match the pattern  to  the  string,  starting  at  the  beginning.  If  the  match  is  successful,  a match  object  is  returned,  but  on  failure,  None is  returned.  The  group() method of a match object can be used to show the successful match. Here is an example of how to use match() [and group()]:
我们先来研究re模块的函数、正则表达式对象(regex  object)的方法: match(). match()函数尝试从字符串的开头开始对模式进行匹配。如果匹配成功，就返回一个匹配对象，而如果匹配失败了，就返回None。匹配对象的group() 方法可以用来显示那个成功的匹配。下面是如何运用match() [及 group()]的一个例子：

>>> m = re.match('foo', 'foo')	# pattern matches string  ，模式匹配字符串
>>> if m is not None:	# show match if successful 如果成功，显示匹配
...	m.group()
...
'foo'
The  pattern  “foo”  matches  exactly  the  string  “foo.”  We  can  also  confirm  that  m is  an example  of  a  match  object  from  within  the  interactive interpreter:
模式"foo"完全匹配字符串"foo"。在交互解析器中，我们能确定 m 就是一个匹配对象的实例。

>>> m	# confirm match object returned   确定返回匹配对象
<re.MatchObject instance at 80ebf48>
Here is an example of a failed match where None is returned:
这是当匹配失败时的例子，它返回None：

>>> m = re.match('foo', 'bar')# pattern does not match string  模式不匹配字符串
>>> if m is not None: m.group()# (1-line version of if clause) 一行的if子句
...
>>>
　The match above fails, thus None is assigned to m, and no action is taken due to the way we constructed our if statement. For the remaining examples, we will try to leave out the if check for brevity, if possible, but in practice  it  is  a  good  idea  to  have  it  there  to  prevent  AttributeError exceptions  (None is returned on failures, which does not have a  group() attribute [method].)   上面的匹配失败，所以m被赋值为None,因为我们写的if语句中没有什么行动，所以也没有什么指令动作被执行。在以后的例子中，为了简洁，在可能的情况下，我们会省去if检查语句，但在实际编程中，最好写上它，以防止出现AttributeError异常(失败后返回None, 此时它是没有group()属性[方法]的)。

　A match will still succeed even if the string is longer than the pattern as long as the pattern matches from the beginning of the string. For example, the pattern “foo” will find a match in the string “food on the table” because it matches the pattern from the beginning:
  即使字符串比模式要长，匹配也可能成功；只要模式是从字符串的开始进行匹配的。例如，模式"foo" 在字符串“food on the table”中找到一个匹配，因为它是从该字符串开头进行匹配的:

>>> m = re.match('foo', 'food on the table') # match succeeds		# 匹配成功
>>> m.group()
'foo'
　As you can see, although the string is longer than the pattern, a successful match was made from the beginning of the string. The substring “foo” represents the match, which was extracted from the larger string.
  如你看到的，尽管字符串比模式要长，但从字符串开头有一个成功的匹配。 子串 "foo"是从那个较长的字符串中抽取出来的匹配部分。
  
　We can even sometimes bypass saving the result altogether, taking advantage of Python’s object-oriented nature:
我们甚至可以充分利用Python语言面向对象的特性，间接省略中间结果，将最终结果保存到一起：
  
  
>>> re.match('foo', 'food on the table').group()
'foo'
　Note  from  a  few  paragraphs  above  that  an  AttributeError will  be generated on a non-match.
  注意，上面的例子中，如果匹配失败，会引发一个AttributeError异常.
  
15.3.5  Looking for a Pattern within a String with search() (Searching versus Matching)
15.3.5  search() 在一个字符串中查找一个模式 (搜索与匹配的比较)

The chances are greater that the pattern you seek is somewhere in the middle of a string, rather than at the beginning. This is where search() comes in handy. It works exactly in the same way as match except that it searches for the first occurrence of the given RE pattern anywhere with its string argument. Again, a match object is returned on success and None otherwise.
其实，你要搜索的模式出现在一个字符串中间的机率要比出现在字符串开头的机率更大一些。这正是search()派上用场的时候。search和match的工作方式一样，不同之处在于search会检查参数字符串任意位置的地方给定正则表达式模式的匹配情况。如果搜索到成功的匹配，会返回一个匹配对象，否则返回None。

We will now illustrate the difference between  match() and search(). Let us try a longer string match attempt. This time, we will try to match our string “foo” to “seafood”:

现在我们来举例说明match()和search()之间的区别。让我们举一个对长字符串进行匹配的例子。这次，我们用字符串"foo"去匹配“seafood”:

>>> m = re.match('foo', 'seafood')	# no match 匹配失败
>>> if m is not None: m.group()
...
>>>

　As you can see, there is no match here. match() attempts to match the pattern to the string from the beginning, i.e., the “f” in the pattern is matched against  the  “s”  in  the  string,  which  fails  immediately.  However,  the  string “foo” does appear (elsewhere) in “seafood,” so how do we get Python to say “yes”? The answer is by using the search() function. Rather than attempting a match, search() looks for the first occurrence of the pattern within the string. search() searches strictly from left to right.
如你所见，这里没有匹配成功。match()尝试从字符串起始处进行匹配模式，即，模式中的"f"试匹配到字符串中首字母"s"上, 这样匹配肯定是失败的。但字符串"foo" 确实出现在“seafood”中，那我们如何才能让Python得出肯定的结果呢? 答案是用search()函数。search() 查找字符串中模式首次出现的位置，而不是尝试(在起始处)匹配。严格地说，search() 是从左到右进行搜索。

>>> m = re.search('foo', 'seafood')	# use search() instead  改用search()
>>> if m is not None: m.group()
...
'foo'	# search succeeds where match failed  用search成功匹配，用match 匹配失败
>>>

　We will be using the match() and search() regex object methods and the  group() and  groups() match  object  methods  for  the  remainder  of this subsection, exhibiting a broad range of examples of how to use regular expressions with Python. We will be using almost all of the special characters and symbols that are part of the regular expression syntax.
在本小节以后的内容里，将通过大量的例子展示如何在Python语言中运用正则表达式,我们会用到regex对象的方法match()和search()，匹配对象的方法group()、groups()，以及正则表达式语法中的绝大多数特殊字符和符号。

15.3.5 Matching More than One String ( | )
15.3.6 匹配多个字符串( | )

In Section 15.2, we used the pipe in the RE “bat|bet|bit.” Here is how we would use that RE with Python:
在15.2小节里，我们在正则表达式“bat|bet|bit”中使用了管道符号. 下面，我们把这个正则表达式用到Python的代码里：

>>> bt = 'bat|bet|bit'	# RE pattern: bat, bet, bit		#正则表达式模式： bat, bet, bit
>>> m = re.match(bt, 'bat')	# 'bat' is a match  		#'bat' 是匹配的
>>> if m is not None: m.group()
...
'bat'
>>> m = re.match(bt, 'blt')	# no match for 'blt' 		#没有匹配'blt'的模式
>>> if m is not None: m.group()
...
>>> m = re.match(bt, 'He bit me!')# does not match string  		#不匹配字符串
>>> if m is not None: m.group()
...
>>> m = re.search(bt, 'He bit me!')# found 'bit' via search  	#搜索到'bit'
>>> if m is not None: m.group()
...
'bit'



15.3.7 Matching Any Single Character  ( . )
15.3.8 匹配任意单个字符( . )


In the examples below, we show that a dot cannot match a NEWLINE or a non-character, i.e., the empty string:
以下的例子中，我们将说明点号是不能匹配换行符或非字符(即,空字符串)的:

>>> anyend = '.end'
>>> m = re.match(anyend, 'bend')	# dot matches 'b' 		#点号匹配'b'
>>> if m is not None: m.group()
...
'bend'
>>> m = re.match(anyend, 'end')	# no char to match 			#没有字符匹配
>>> if m is not None: m.group()
...
>>> m = re.match(anyend, '\nend')	# any char except \n   	#匹配字符(\n除外)
>>> if m is not None: m.group()
...
>>> m = re.search('.end', 'The end.')# matches ' ' in search . 		#匹配' '
>>> if m is not None: m.group()
...
' end'

　The following is an example of searching for a real dot (decimal point) in a regular expression where we escape its functionality with a backslash:
下面的例子是来搜索一个真正点号(小数点)的正则表达式，在正则表达式中，用反斜线对它进行转义，使点号失去它的特殊意义：
  
>>> patt314 = '3.14'	# RE dot  			#正则表达式点号
>>> pi_patt = '3\.14'	# literal dot (dec. point)    		#浮点(小数点)
>>> m = re.match(pi_patt, '3.14')  # exact match    		#完全匹配
>>> if m is not None: m.group()
...
'3.14'
>>> m = re.match(patt314, '3014')  # dot matches '0'   		#点号匹配 '0'
>>> if m is not None: m.group()
...
'3014'
>>> m = re.match(patt314, '3.14')  # dot matches '.'  		#点号匹配 '.'
>>> if m is not None: m.group()
...
'3.14'

15.3.9 Creating Character Classes ( [ ] )
     创建字符集合( [ ] )


Earlier,  we  had  a  long  discussion  about  “[cr][23][dp][o2]”  and  how  it differs  from  “r2d2|c3po.”  With  the  examples  below,  we  will  show  that “r2d2|c3po” is more restrictive than “[cr][23][dp][o2]”:
前面，我们曾讨论过 “[cr][23][dp][o2]”和“r2d2|c3po”是不同的。 从下面的例子中，可以看出“r2d2|c3po” 与“[cr][23][dp][o2]” 相比有更加严格的限制:

>>> m = re.match('[cr][23][dp][o2]', 'c3po')# matches 'c3po'    #匹配'c3po'
>>> if m is not None: m.group()
...
'c3po'
>>> m = re.match('[cr][23][dp][o2]', 'c2do')# matches 'c2do'    #匹配'c2do'
>>> if m is not None: m.group()
...
'c2do'
>>> m = re.match('r2d2|c3po', 'c2do')# does not match 'c2do'    #不匹配'c2do'
>>> if m is not None: m.group()
...
>>> m = re.match('r2d2|c3po', 'r2d2')# matches 'r2d2'           #匹配'r2d2'
>>> if m is not None: m.group()
...
'r2d2'

15.3.10 Repetition, Special Characters, and Grouping
重复、特殊字符和子组

The  most  common  aspects  of  REs  involve  the  use  of  special  characters, multiple occurrences of RE patterns, and using parentheses to group and extract submatch patterns. One particular RE we looked at related to simple e-mail addresses (“\w+@\w+\.com”). Perhaps we want to match more e-mail addresses than this RE allows. In order to support an additional hostname in  front  of  the  domain,  i.e.,  “www.xxx.com”  as  opposed  to  accepting only  “xxx.com”  as  the  entire  domain,  we  have  to  modify  our  existing RE.  To  indicate  that  the  hostname  is  optional,  we  create  a  pattern  that matches the hostname (followed by a dot), use the ? operator indicating zero or one copy of this pattern, and insert the optional RE into our previous  RE  as  follows:  “\w+@(\w+\.)?\w+\.com.”  As  you  can  see  from the examples below, either one or two names are now accepted in front of the “.com”:
正则表达式中最常见的情况包括特殊字符的使用，正则表达式模式的重复出现，以及使用圆括号对匹配模式的各部分进行分组和提取操作。我们曾看到过一个关于简单电子邮件地址的正则表达式(“\w+@\w+\.com”). 或许我们想要匹配的邮件地址比这个正则表达式的允许的要多。比如，为了在域名前添加主机名称支持，即， 支持“www.xxx.com”，而不只是允许“xxx.com”做整个域名，我们就必须修改现有的正则表达式。为了表示主机名是可选的，我们要写一个模式匹配主机名(后面跟一个点号)，然后用问号“?”表示此模式可出现0次或1次，表示此部分是可选的，再把这个可选的正则表达式插入到我们前面的那个正则表达式中去：“\w+@(\w+\.)?\w+\.com” 。 从下面的例子中可以看出，这个表达式容许“.com”前面有一个或两个名字:

>>> patt = '\w+@(\w+\.)?\w+\.com'
>>> re.match(patt, 'nobody@xxx.com').group()
'nobody@xxx.com'
>>> re.match(patt, 'nobody@www.xxx.com').group()
'nobody@www.xxx.com'

　Furthermore,  we  can  even  extend  our  example  to  allow  any  number  of intermediate subdomain names with the  pattern below. Take special note of our slight change from using ? to *. : “\w+@(\w+\.)*\w+\.com”:
接下来，我们用以下模式进一步扩展我们的例子，允许任意数量的子域名存在。请特别注意细节的变化，将 ? 改为 *：“\w+@(\w+\.)*\w+\.com”:

>>> patt = '\w+@(\w+\.)*\w+\.com'
>>> re.match(patt, 'nobody@www.xxx.yyy.zzz.com').group()
'nobody@www.xxx.yyy.zzz.com'

　However, we must add the disclaimer that using solely alphanumeric characters does not match all the possible characters that may make up e-mail addresses. The above RE patterns would not match a domain such as “xxx-yyy.com” or other domains with “\W” characters.
但我们必须要说明的是仅用字母或数字组成的字符不能满足邮件地址中可能出现的各种字符。 上述正则表达式不匹配如“xxx-yyy.com” 这样的域名或其他带有非单词字符(如“\W”等)的域名。

Earlier, we discussed the merits of using parentheses to match and save subgroups  for  further  processing  rather  than  coding  a  separate  routine  to manually parse a string after an RE match had been determined. In particular, we discussed a simple RE pattern of an alphanumeric string and a number  separated  by  a  hyphen,  “\w+-\d+,”  and  how  adding  subgrouping  to form a new RE, “(\w+)-(\d+),” would do the job. Here is how the original RE works:
前面，我们曾讨论过用括号匹配并保存子组做进一步处理的好处，这样做比在确定正则表达式匹配后，再单写一个子程序来解析一个字符串要好。我们还特别提到用来匹配 以"-"分隔的字母或数字组成的字符串和数字串的正则表达式 “\w+-\d+” ，以及如何通过对此正则表达式划分子组以构建一个新的正则表达式, “(\w+)-(\d+)” 来完成任务,下面是旧版正则表达式的执行情况:

>>> m = re.match('\w\w\w-\d\d\d', 'abc-123')
>>> if m is not None: m.group()
...
'abc-123'

>>> m = re.match('\w\w\w-\d\d\d', 'abc-xyz')
>>> if m is not None: m.group()
...
>>>
　In  the  above  code,  we  created  an  RE  to  recognize  three  alphanumeric characters  followed  by  three  digits.  Testing  this  RE  on  “abc-123,”  we obtained positive results while “abc-xyz” fails. We will now modify our RE as discussed before to be able to extract the alphanumeric string and number. Note  how  we  can  now  use  the  group() method  to  access  individual  subgroups  or  the  groups() method  to  obtain  a  tuple  of  all  the  subgroups matched:
上面的代码中,一个正则表达式被用来匹配由三个字母或数字组成的字符串，再接着三个数字的字符串。这个正则表达式匹配“abc-123”，但不匹配“abc-xyz”。我们现在来修改正则表达式，使它能分别提取包含字母或数字的部分和仅含数字的部分。请注意我们是如何用group()方法访问每个子组以及用groups()方法获取一个包含所有匹配子组的元组的：

>>> m = re.match('(\w\w\w)-(\d\d\d)', 'abc-123')
>>> m.group()	# entire match  所有匹配部分
'abc-123'
>>> m.group(1)	# subgroup 1    匹配的子组1
'abc'
>>> m.group(2)	# subgroup 2    匹配的子组2
'123'
>>> m.groups()	# all subgroups   所有匹配子组
('abc', '123')
　As  you  can  see,  group() is  used  in  the  normal  way  to  show  the  entire match, but can also be used to grab individual subgroup matches. We can also  use  the  groups() method  to  obtain  a  tuple  of  all  the  substring matches.
如你所见，group()通常用来显示所有匹配部分，也可用来获取个别匹配的子组。我们可用groups()方法获得一个包含所有匹配子组的元组。
  
　Here is a simpler example showing different group permutations, which will hopefully make things even more clear:
  下面这个简单的例子通过子组的不同排列组合，帮助我们理解得更透彻:

>>> m = re.match('ab', 'ab')	# no subgroups    	#无子组
>>> m.group()	# entire match
'ab'
>>> m.groups()	# all subgroups   				 	#所有匹配的子组 
()
>>>
>>> m = re.match('(ab)', 'ab')	# one subgroup   	#一个子组
>>> m.group()	# entire match                      #所有匹配
'ab'
>>> m.group(1)	# subgroup 1    					#匹配的子组1
'ab'
>>> m.groups()	# all subgroups    					#所有匹配子组
('ab',)
>>>
>>> m = re.match('(a)(b)', 'ab')	# two subgroups 	#两个子组
>>> m.group()	# entire match
'ab'
>>> m.group(1)	# subgroup 1    匹配的子组1
'a'
>>> m.group(2)	# subgroup 2    匹配的子组2
'b'
>>> m.groups()	# all subgroups    所有匹配子组的元组
 ('a', 'b')
>>>
>>> m = re.match('(a(b))', 'ab')	# two subgroups    		#两个子组
>>> m.group()	# entire match   						 	#所有匹配部分
'ab'
>>> m.group(1)	# subgroup 1    							#匹配的子组1
'ab'
>>> m.group(2)	# subgroup 2    							#匹配的子组2
'b'
>>> m.groups()	# all subgroups    							#所有匹配的子组的元组
('ab', 'b')



15.3.11 Matching from the Beginning and End of Strings and on Word Boundaries
15.3.11 从字符串的开头或结尾匹配及在单词边界上的匹配      

The following examples highlight the positional RE operators. These apply more  for  searching  than  matching  because  match() always  starts  at  the beginning of a string.
下面的例子强调了锚点性正则表达式操作符。这些锚点性正则表达式操作符主要被用于搜索而不是匹配，因为match()总是从字符串的开头进行匹配的。

>>> m = re.search('^The', 'The end.')	# match 				#匹配
>>> if m is not None: m.group()
...
'The'
>>> m = re.search('^The', 'end. The')	# not at beginning  	#不在开头
>>> if m is not None: m.group()
...
>>> m = re.search(r'\bthe', 'bite the dog') # at a boundary 	#在词边界
>>> if m is not None: m.group()
...
'the'
>>> m = re.search(r'\bthe', 'bitethe dog')  # no boundary 		#无边界
>>> if m is not None: m.group()
...
>>> m = re.search(r'\Bthe', 'bitethe dog')  # no boundary 		#无边界
>>> if m is not None: m.group()
...
'the'

   You will notice the appearance of raw strings here. You may want to take a look at the Core Note toward the end of the chapter for clarification on why they  are  here.  In  general,  it  is  a  good  idea  to  use  raw  strings  with  regular expressions.
   你可能在这里注意到了原始字符串(raw strings) 的出现。在本章末尾的核心笔记中，有关于它的说明。通常，在正则表达式中使用原始字符串是个好主意。
   
　There are four other re module functions and regex object methods we think   you   should   be   aware   of:   findall(), sub(), subn(), and split().
  你还应该了解另外四个re模块函数和regex对象方法: findall(), sub(), subn() 和 split().

15.3.12 Finding Every Occurrence with findall()
用findall()找到每个出现的匹配部分

findall() is new to Python as of version 1.5.2. It looks for all non-overlapping occurrences of an RE pattern in a string. It is similar to search() in that it performs a string search, but it differs from match() and search() in that findall() always returns a list. The list will be empty if no occurrences are found but if successful, the list will consist of all matches found(grouped in left-to-right order of occurrence).

findall()自Python1.5.2版本被引入。它用于非重叠地查找某字符串中一个正则表达式模式出现的情况。findall()和search()相似之处在于二者都执行字符串搜索，但findall()和match()与search()不同之处是，findall()总返回一个列表。如果findall()没有找到匹配的部分，会返回空列表；如果成功找到匹配部分，则返回所有匹配部分的列表(按从左到右出现的顺序排列)。

>>> re.findall('car', 'car')
['car']
>>> re.findall('car', 'scary')
['car']
>>> re.findall('car', 'carry the barcardi to the car')
['car', 'car', 'car']

　Subgroup searches result in a more complex list returned, and that makes sense, because subgroups are a mechanism that allow you to extract specific patterns from within your single regular expression, such as matching an area code that is part of a complete telephone number, or a login name that is part of an entire e-mail address.
包含子组的搜索会返回更复杂的一个列表，这样做是有意义的，因为子组是允许你从单个正则表达式中抽取特定模式的一种机制，比如，匹配一个完整电话号码中的一部分(例如，区号)，或完整电子邮件地址的一部分(例如，登录名)。

　For a single successful match, each subgroup match is a single element of the resulting list returned by findall(); for multiple successful matches, each subgroup match is a single element in a tuple, and such tuples (one for each successful match) are the elements of the resulting list. This part may sound confusing at first, but if you try different examples, it will help clarify things.
正则表达式仅有一个子组时，findall()返回子组匹配的字符串组成的列表；如果表达式有多个子组，返回的结果是一个元组的列表，元组中每个元素都是一个子组的匹配内容，像这样的元组(每一个成功的匹配对应一个元组)构成了返回列表中的元素。这些内容初次听到可能令人费解，但如果你看看各种例子，就会明白了。

15.3.12  Searching and Replacing with sub() [and subn()]
15.3.12  用sub()[和 subn()]进行搜索和替换

There are two functions/methods for search-and-replace functionality: sub() and  subn().  They  are  almost  identical  and  replace  all  matched occurrences of the RE pattern in a string with some sort of replacement. The replacement is usually a string, but it can also be a function that returns a replacement string. subn() is exactly the same as sub(), but it also returns the total number of substitutions made—both the newly substituted string and the substitution count are returned as a 2-tuple.
有两种函数/方法用于完成搜索和代替的功能: sub()和subn(). 二者几乎是一样的，都是将某字符串中所有匹配正则表达式模式的部分进行替换。用来替换的部分通常是一个字符串，但也可能是一个函数，该函数返回一个用来替换的字符串。subn()和sub()一样，但它还返回一个表示替换次数的数字，替换后的字符串和表示替换次数的数字作为一个元组的元素返回。


>>> re.sub('X', 'Mr. Smith', 'attn: X\n\nDear X,\n')
'attn: Mr. Smith\012\012Dear Mr. Smith,\012'
>>>
>>> re.subn('X', 'Mr. Smith', 'attn: X\n\nDear X,\n')

('attn: Mr. Smith\012\012Dear Mr. Smith,\012', 2)
>>>
>>> print re.sub('X', 'Mr. Smith', 'attn: X\n\nDear X,\n')
attn: Mr. Smith

Dear Mr. Smith,

>>> re.sub('[ae]', 'X', 'abcdef')
'XbcdXf'
>>> re.subn('[ae]', 'X', 'abcdef')
('XbcdXf', 2)


15.3.13 Splitting (on Delimiting Pattern)with split()
用split()分割(分隔模式)

The re module and RE object method split() work similarly to its string counterpart,  but  rather  than  splitting  on  a  fixed  string,  they  split  a  string based  on  an  RE  pattern,  adding  some  significant  power  to  string  splitting capabilities. If you do not want the string split for every occurrence of the pattern,  you  can  specify  the  maximum  number  of  splits  by  setting  a  value (other than zero) to the max argument.
re模块和正则表达式对象的方法split()与字符串的split()方法相似，前者是根据正则表达式模式分隔字符串，后者是根据固定的字符串分割,因此与后者相比，显著提升了字符分割的能力。如果你不想在每个模式匹配的地方都分割字符串，你可以通过设定一个值参数(非零)来指定分割的最大次数。

If the delimiter given is not a regular expression that uses special symbols to  match  multiple  patterns,  then  re.split() works  in  exactly  the  same manner  as  string.split(),  as  illustrated  in  the  example  below  (which splits on a single colon):
如果分隔符没有使用由特殊符号表示的正则表达式来匹配多个模式，那re.split()和string.split()的执行过程是一样的，见以下的例子(在每一个冒号处分隔):

>>> re.split(':', 'str1:str2:str3')
['str1', 'str2', 'str3']

　But  with  regular  expressions  involved,  we  have  an  even  more  powerful tool. Take, for example, the output from the Unix who command, which lists all the users logged into a system:
  但运用正则表达式后，我们会发现re.split()成了一个功能更强大的工具。比如，Unix系统下who命令输出所有已登录系统的用户的信息:

% who
wesc	console		Jun 20 20:33
wesc	pts/9		Jun 22 01:38(192.168.0.6)
wesc	pts/1		Jun 20 20:33(:0.0)
wesc	pts/2		Jun 20 20:33(:0.0)
wesc	pts/4		Jun 20 20:33(:0.0)
wesc	pts/3		Jun 20 20:33(:0.0)
wesc	pts/5		Jun 20 20:33(:0.0)
wesc	pts/6		Jun 20 20:33(:0.0)
wesc	pts/7		Jun 20 20:33(:0.0)
wesc	pts/8		Jun 20 20:33(:0.0)

　Perhaps we want to save some user login information such as login name, teletype  they  logged  in  at,  when  they  logged  in,  and  from  where.  Using string.split() on the above would not be effective, since the spacing is erratic and inconsistent. The other problem is that there is a space between the month, day, and time for the login timestamps. We would probably want to keep these fields together.
  假如我们想要保存用户的登录信息，比如说，登录名，用户登录时的电传，他们的登录的时间以及登录地址。用上面的string.split()很难有效果，因为分隔这些数据的空白符号是毫无规律且不确定的。还有一个问题，就是在登录时间的数据中，月，日，时之间有一个空格。而我们一般想把这些有关时间的数据排在一起。
  
   You need some way to describe a pattern such as, “split on two or more spaces.” This is easily done with regular expressions. In no time, we whip up the RE pattern “\s\s+,” which does mean at least two whitespace characters.  Let’s  create  a  program  called  rewho.py that  reads  the  output  of  the who command,  presumably  saved  into  a  file  called  whodata.txt.  Our rewho.py script initially looks something like this:
   你需要用某种方式来描述这样一种模式：“在两个或更多个空格符处进行分隔”。正则表达式很容易做到这一点。我们能很快写出这个正则表达式模式：“\s\s+”,含义是至少2个空白字符。我们来写一个名为rewho.py的程序，它读入who命令的输出 - 假设已保存到名为whodata.txt的文件中。起初，我们写的rewho.py脚本看起来像这样:

import re
f = open('whodata.txt', 'r')
for eachLine in f.readlines():
    print re.split('\s\s+', eachLine)
f.close()

　We  will  now  execute  the  who command,  saving  the  output  into  whodata.txt, and then call rewho.py and take a look at the results:
  我们现在执行who命令，将输出结果保存到文件whodata.txt，然后调用rewho.py来看看结果：

% who > whodata.txt
% rewho.py
['wesc', 'console', 'Jun 20 20:33\012']
['wesc', 'pts/9', 'Jun 22 01:38\011(192.168.0.6)\012']
['wesc', 'pts/1', 'Jun 20 20:33\011(:0.0)\012']
['wesc', 'pts/2', 'Jun 20 20:33\011(:0.0)\012']
['wesc', 'pts/4', 'Jun 20 20:33\011(:0.0)\012']
['wesc', 'pts/3', 'Jun 20 20:33\011(:0.0)\012']
['wesc', 'pts/5', 'Jun 20 20:33\011(:0.0)\012']
['wesc', 'pts/6', 'Jun 20 20:33\011(:0.0)\012']
['wesc', 'pts/7', 'Jun 20 20:33\011(:0.0)\012']
['wesc', 'pts/8', 'Jun 20 20:33\011(:0.0)\012']
　It  was  a  good  first  try,  but  not  quite  correct.  For  one  thing,  we  did  not anticipate a single TAB (ASCII \011) as part of the output (which looked like at least two spaces, right?), and perhaps we aren’t really keen on saving the NEWLINE (ASCII \012), which terminates each line. We are now going to fix those problems as well as improve the overall quality of our application by making a few more changes.
  这是不错的尝试，但还不完全正确。首先，我们原先没有预料到输出中会包含一个TAB符号(ASCII \011) (它看上去像是至少两个空格，对不?)。而且, 我们可能对保存用来结束每行的换行符NEWLINE (ASCII \012)  也没什么兴趣。我们现在就做些改动来修正这些问题，同时提升程序的整体质量。
  
　First,  we  would  rather  run  the  who command  from  within  the  script, instead  of  doing  it  externally  and  saving  the  output  to  a  whodata.txt file—doing this repeatedly gets tiring rather quickly. To accomplish invoking another program from within ours, we call upon the os.popen() command, discussed briefly in Section 14.5.2. Although  os.popen() is available only on Unix systems, the point is to illustrate the functionality of re.split(), which is available on all platforms.
  首先，我们改从脚本里执行who命令，而不是从外部调用它后将命令的输出结果保存到文件whodata.txt - 这样重复的步骤很快会令人厌烦的。要从我们写的脚本里调用另一个程序，可以用os.popen()命令，这个命令在14.5.2小节已介绍过。尽管 os.popen()只能在Unix系统中使用，但本例子意在阐明re.split()的用法，它可是跨系统平台的。
　
We get rid of the trailing NEWLINEs and add the detection of a single TAB  as  an  additional,  alternative re.split() delimiter. Presented in Example 15.1 is the final version of our rewho.py script:
我们去掉每行行尾的换行符(NEWLINE)，并添加检查单个TAB符号的模式，把TAB做为re.split()的可选分隔符。例15.1，是脚本rewho.py的最终版本:


Example 15.1 Split Output of Unix who Command (rewho.py)
例 15.1 Unix下who命令输出结果进行分隔 (rewho.py)

This script calls the who command and parses the input by splitting up its data along various types of whitespace characters.
此脚本调用who命令，解析命令的输出结果，根据不同的空白符号分隔数据。

1	#!/usr/bin/env python
2
3	from os import popen
4	from re import split
5
6	f = popen('who', 'r')
7	for eachLine in f.readlines():
8	print split('\s\s+|\t', eachLine.strip())
9	f.close()

f.readlines() can be shortened to the file iterator f. 
注：f.readlines()可以被简写成文件的迭代器f.

Running this script, we now get the following (correct) output:
运行脚本，我们得到如下(正确)结果:

% rewho.py
['wesc', 'console', 'Jun 20 20:33']
['wesc', 'pts/9', 'Jun 22 01:38', '(192.168.0.6)']
['wesc', 'pts/1', 'Jun 20 20:33', '(:0.0)']
['wesc', 'pts/2', 'Jun 20 20:33', '(:0.0)']
['wesc', 'pts/4', 'Jun 20 20:33', '(:0.0)']
['wesc', 'pts/3', 'Jun 20 20:33', '(:0.0)']
['wesc', 'pts/5', 'Jun 20 20:33', '(:0.0)']
['wesc', 'pts/6', 'Jun 20 20:33', '(:0.0)']
['wesc', 'pts/7', 'Jun 20 20:33', '(:0.0)']
['wesc', 'pts/8', 'Jun 20 20:33', '(:0.0)']
　A similar exercise can be achieved in a DOS/Windows environment using the dir command in place of who.
  在DOS/Windows环境下，用dir命令代替who命令，也可完成此练习。

While the subject of ASCII characters is still warm, we would like to note that  there  can  be  confusion  between  regular  expression  special  characters and special ASCII symbols. We may use  \n to represent an ASCII NEW- LINE character, but we may use \d meaning a regular expression match of a single numeric digit. Problems may occur if there is a symbol used by both ASCII and regular expressions, so in the Core Note on the following page, we recommend the use of Python raw strings to prevent any problems. One more caution: the “\w” and “\W” alphanumeric character sets are affected by the L or LOCALE compilation flag and in Python 1.6 and newer, by Unicode flags starting in 2.0 (U or UNICODE).
  趁我们还熟悉ASCII字符，我们要提醒注意的是正则表达式的特殊字符和特殊ASCII字符是容易混淆的。我们可能用\n来表示一个ASCII换行字符，但也可以用\d表示匹配一个数字的正则表达式。如果同一个符号在ASCII和正则表达式中都可以用，就容易出问题了，所以在下页的核心笔记中，我们推荐使用Python语言中的"原始字符串"来避免混淆。还要注意：“\w” and “\W”这两个表示字母或数字的字符受L 或 LOCALE 编译标志符的影响，在Python 1.6至Python 2.0以后的版本中受(U 或 UNICODE的)Unicode标志符号影响。

CORE NOTE: Use of Python raw strings
核心笔记 ： Python 原始字符串(raw strings)的用法

    You may have seen the use of raw strings in some of the examples above. Regular expressions were a strong motivation for the advent of raw strings.The reason is because of conflicts between ASCII characters and regular expression special characters. As a special symbol,“\b” represents the ASCII character for backspace, but “\b” is also a regular expression special symbol, meaning “match” on a word boundary. In order for the RE compiler to see the two characters “\b” as your string and not a (single) backspace, you need to escape the backslash in the string by using another backslash, resulting in “\\b.”
	你可能已经看到前面关于原始字符串用法的一些例子了。原始字符串的产生正是由于有正则表达式的存在。原因是ASCII字符和正则表达式特殊字符间所产生的冲突。比如，特殊符号“\b”在ASCII字符中代表退格键，但同时“\b”也是一个正则表达式的特殊符号，代表“匹配一个单词边界”。为了让RE编译器把两个字符“\b”当成你想要表达的字符串，而不是一个退格键，你需要用另一个反斜线对它进行转义，即可以这样写：“\\b”。
	
This can get messy, especially if you have a lot of special characters in your string, adding to the confusion.We were introduced to raw strings back in Chapter 6, and they can be (and are often) used to help keep REs looking somewhat manageable. In fact, many Python programmers swear by these and only use raw strings when defining regular expressions.
但这样做会把问题复杂化，特别是当你的正则表达式字符串里有很多特殊字符时，就更容易令人困惑了。在第六章，我们曾介绍过原始字符串，它经常被用于简化正则表达式的复杂程度。事实上，很多Python程序员在定义正则表达式时都只使用原始字符串。

Here are some examples of differentiating between the backspace “\b” and the regular expression “\b,” with and without raw strings:
下面的例子用来说明退格键“\b” 和正则表达式“\b”(包含或不包含原始字符串)之间的区别：

>>> m = re.match('\bblow', 'blow') # backspace, no match    	#退格键,没有匹配
>>> if m is not None: m.group()
...
>>> m = re.match('\\bblow', 'blow') # escaped \, now it works   #用\转义后，现在匹配了
>>> if m is not None: m.group()
...
'blow'
>>> m = re.match(r'\bblow', 'blow') # use raw string instead    #改用原始字符串   
>>> if m is not None: m.group()
...
'blow'

You may have recalled that we had no trouble using “\d” in our regular expressions without using raw strings.That is because there is no ASCII equivalent special character, so the regular expression compiler already knew you meant a decimal digit.
你可能注意到我们在正则表达式里使用“\d”，没用原始字符串，也没出现什么问题。那是因为ASCII里没有对应的特殊字符，所以正则表达式编译器能够知道你指的是一个十进制数字。


15.4 Regular Expressions Example
正则表达式示例

We will now run through an in-depth example of the different ways of using regular expressions for string manipulation. The first step is to come up with some code that actually generates some random (but-not-so-random) data on which to operate. In Example 15.2, we present gendata.py, a script that generates a data set. Although this program simply displays the generated set of strings to standard output, this output may very well be redirected to a test file.

现在我们来通读一个详细完整的例子，它展示了用正则表达式处理字符串的不同办法。第一步：拿出一段代码用来生成随机数据，生成的数据用于以后操作。例15.2中,脚本gendata.py生成一个数据集。虽然程序只是将生成的字符串显示到标准输出，但此输出结果也可以重定向到一个测试文件中。

Example 15.2 Data Generator for RE Exercises (gendata.py)
例15.2 正则表达式练习的数据生成代码(gendata.py)

Create random data for regular expressions practice and output the generated data to the screen.
为练习使用正则表达式生成随机数据，并将产生的数据输出到屏幕.

1	#!/usr/bin/env python
2
3	from random import randint, choice
4	from string import lowercase
5	from sys import maxint
6	from time import ctime
7
8	doms = ( 'com', 'edu', 'net', 'org', 'gov' )
9
10  for i in range(randint(5, 10)):
11     randint(0, maxint-1)	# pick date
12     ctime(dtint)	# date string
13
14	shorter = randint(4, 7)	# login shorter
15	em = ''
16	for j in range(shorter):	# generate login
17	em += choice(lowercase)
18
19	longer = randint(shorter, 12) # domain longer
20	dn = ''
21	for j in range(longer):	# create domain
22	dn += choice(lowercase)
23
24	print '%s::%s@%s.%s::%d-%d-%d' % (dtstr, em,
25	dn, choice(doms), dtint, shorter, longer)


　This  script  generates  strings  with  three  fields,  delimited  by  a  pair  of colons, or a double-colon. The first field is a random (32-bit) integer, which is converted to a date (see the accompanying Core Note). The next field is a randomly generated electronic mail (e-mail) address, and the final field is a set of integers separated by a single dash ( - ).
  这个脚本生成3个字段，字段由一对冒号，或双冒号分隔。第一个字段是一个随机(32位)整数，被转换为一个日期(见旁边的核心笔记)。第二个字段是一个随机产生的电子邮件(e-mail)地址,最后一个字段是由单个横线( - )分隔的一个整数集合。

Running  this  code,  we  get  the  following  output  (your  mileage  will  definitely vary) and store it locally as the file redata.txt:
执行这段代码，我们得到以下输出(你得到的输出肯定和本书中的不同)，并把数据保存到本地文件redata.txt中:

Thu Jul 22 19:21:19 2004::izsp@dicqdhytvhv.edu::1090549279-4-11
Sun Jul 13 22:42:11 2008::zqeu@dxaibjgkniy.com::1216014131-4-11
Sat May	5 16:36:23 1990::fclihw@alwdbzpsdg.edu::641950583-6-10
Thu Feb 15 17:46:04 2007::uzifzf@dpyivihw.gov::1171590364-6-8
Thu Jun 26 19:08:59 2036::ugxfugt@jkhuqhs.net::2098145339-7-7
Tue Apr 10 01:04:45 2012::zkwaq@rpxwmtikse.com::1334045085-5-10

   You may or may not be able to tell, but the output from this program is ripe  for  regular  expression  processing.  Following  our  line-by-line  explanation, we will implement several REs to operate on these data, as well as leave plenty for the end-of-chapter exercises.
   你或许能看出来，这个程序的输出数据适合用正则表达式来处理。在我们逐行解释后，会用几个正则表达式对这些数据的进行操作，也为本章后面的练习做好准备。

Line-by-Line Explanation
逐行解释

Lines 1–6
第1-6行
In our example script, we require the use of multiple modules. But since we are  utilizing  only  one  or  two  functions  from  these  modules,  rather  than importing the entire module, we choose in this case to import only specific attributes  from  these  modules.  Our  decision  to  use  from-import rather than import was based solely on this reasoning. The from-import lines follow the Unix startup directive on line 1.
在这个示例脚本里，我们要使用多个模块。但因为我们只需要用到这些模块中的一两个函数，所以不必引入整个模块，只须引入模块中某些属性即可。我们用from-import而不是import正是基于这个原因。代码第一行是Unix起始提示符，后面是from-import这几行。

Line 8
第8行
doms is simply a set of higher-level domain names from which we will randomly pick for each randomly generated e-mail address.
domes是一组简单的包含顶级域名的集合，我们将从中随机挑选一个来随机生成电子邮件地址。

Lines 10–12
第10-12行
Each time gendata.py executes, between 5 and 10 lines of output are generated.  (Our  script  uses  the  random.randint() function  for  all  cases where we desire a random integer.) For each line, we choose a random integer from the entire possible range (0 to 231  - 1 [sys.maxint]), then convert that integer to a date using time.ctime(). System time in Python and most  Unix-based  computers  is  based  on  the  number  of  seconds  that  have elapsed since the “epoch,” midnight UTC/GMT on January 1, 1970. If we choose a 32-bit integer, that represents one moment in time from the epoch to the maximum possible time, 232 seconds after the epoch.
每次gendata.py执行都会产生5-10行的输出。(这个脚本用函数random.randint()生成我们需要的所有随机整数。) 在每个输出行中，我们从整个可能的范围(0 到 2^31-1  即，[sys.maxint])里，随机选一个整数，然后把这个整数用time.ctime()转换成一个日期。大多数安装Python的基于Unix系统的计算机上，系统时间是根据1970年一月一日零点-纪元(“epoch”)至今的秒数来计算的。如果我们选择32位整数，那系统日期就代表从纪元(epoch) 到纪元后2^32秒之间的某个时刻。

Lines 14–22
第14-22行
The login name for the fake e-mail address should be between 4 and 7 characters in length. To put it together, we randomly choose between 4 and 7 random lowercase letters, concatenating each letter to our string one at a time. The  functionality  of  the  random.choice() function  is  given  a  sequence, return a random element of that sequence. In our case, the sequence is the set of all 26 lowercase letters of the alphabet, string.lowercase. We decided that the main domain name for the fake e-mail address should be between 4 and 12 characters in length, but at least as long as the login name.  Again,  we  use  random  lowercase  letters  to  put  this  name  together letter by letter.
我们规定随机生成的邮箱地址中登录名的长度必须在4到7个字符之间。我们随机选择4到7个小写字母，依次将它们连结到一个字符串中。函数random.choice()的用处就是根据指定序列，随机返回该序列中的一个元素。在这里我们指定序列是26个小写字母，string.lowercase.我们规定虚拟邮箱地址的域名长度在4到12个字符之间，但不能短于登录名的长度。最后，我们随机选择一些小写字母，依次将它们连接起来组成域名。

Lines 24–25
第24-25行
The key component of our script puts together all of the random data into the output line. The date string comes first, followed by the delimiter. We then put together the random e-mail address by concatenating the login name,  the  “@”  symbol,  the  domain  name,  and  a  randomly  chosen  high-level  domain.  After  the  final  double-colon,  we  put  together  a  random integer  string  using  the  original  time  chosen  (for  the  date  string),  followed  by  the  lengths  of  the  login  and  domain  names,  all  separated  by  a single hyphen.
这是本脚本的关键步骤：把随机数据组合到一起显示到输出行。以日期字符串开头，后面是分隔符，然后是随机生成的电子邮件地址。这个任意的电子邮件地址是我们把登录名,“@”符号，域名和一个随机选择的顶级域名连接到一起组成的。在最后一个双冒号后面，我们还加了一个随机整数字符串，它的前部分是与所选随机日期对应是整数，后面的部分分别是登录名和域名的长度，这几个整数之间由连字符分隔。


15.4.1  Matching a String
15.4.1  匹配一个字符串

For the following exercises, create both permissive and restrictive versions of your REs. We recommend you test these REs in a short application that utilizes  our  sample  redata.txt file  above  (or  use  your  own  generated  data from running gendata.py). You will need to use it again when you do the exercises.

在下面的练习里，写出你的正则表达式，包括宽松和限制性强的两个版本。我们建议你用前面的例子redata.txt(或你自己运行gendata.py生成的随机数据)来测试小程序里的这些正则表达式。在做练习的时候，你还会再次用到这些数据。

　To  test  the  RE  before  putting  it  into  our  little  application,  we  will import the re module and assign one sample line from redata.txt to a string variable data. These statements are constant across both illustrated examples.
  在把正则表达式写入到我们的小程序之前，我们先要对它进行测试。我们先引入re模块，将redata.txt中的一行数据赋值到一个字符串变量中。下面的语句在以下的两个示例中都是这样，没有变化。

>>> import re
>>> data = 'Thu Feb 15 17:46:04 2007::uzifzf@dpyivihw.gov::1171590364-6-8'

　In our first example, we will create a regular expression to extract (only) the  days  of  the  week  from  the  timestamps  from  each  line  of  the  data  file redata.txt. We will use the following RE:
“^Mon|^Tue|^Wed|^Thu|^Fri|^Sat|^Sun”
  在第一个例子中，我们将写一个正则表达式，用它从文件redata.txt的每一行中(仅)提取时间戳中的有关星期的数据字段。我们将用到以下这个正则表达式:
  “^Mon|^Tue|^Wed|^Thu|^Fri|^Sat|^Sun”

　This example requires that the string start with (“^” RE operator) any of the seven strings listed. If we were to “translate” the above RE to English, it would read something like, “the string should start with “Mon,” “Tue,”. . . , “Sat,” or “Sun.”
  上例要求字符串是以所列出的七个字符串之一作为开头(“^”正则表达式操作符)。如果我们想把上面的正则表达式“翻译”过来，它的意思大概是: ”字符串必须以“Mon,” “Tue,”. . . , “Sat,” 或 “Sun” 之一打头“。

　Alternatively, we can bypass all the carat operators with a single carat if we group the day strings like this:
“^(Mon|Tue|Wed|Thu|Fri|Sat|Sun)”
  或者，我们可以只用一个"^"符号，将日期字符串归为一组：“^(Mon|Tue|Wed|Thu|Fri|Sat|Sun)”.

　The parentheses around the set of strings mean that one of these strings must be encountered for a match to succeed. This is a “friendlier” version of the original RE  we came up with, which did not have the parentheses. Using our modified RE, we can take advantage of the fact that we can access the matched string as a subgroup:
  在这组字符串集合两边的圆括号表示是只有满足这些字符串之一匹配才能成功。这是比我们前面看到的那个没有圆括号的正则表达式"更友好"。而且，使用这个修改后的正则表达式还有一个好处，能使我们方便地访问被匹配字符串的那个子组:

>>> patt = '^(Mon|Tue|Wed|Thu|Fri|Sat|Sun)'
>>> m = re.match(patt, data)
>>> m.group()	# entire match
'Thu'
>>> m.group(1)	# subgroup 1
'Thu'
>>> m.groups()	# all subgroups
('Thu',)

　This feature may not seem as revolutionary as we have made it out to be for this example, but it is definitely advantageous in the next example or anywhere you provide extra data as part of the RE to help in the string matching process, even though those characters may not be part of the string you are interested in. Both of the above REs are the most restrictive, specifically requiring a set number of strings. This may not work well in an internationalization environment where localized days and abbreviations are used. A looser RE would be: “^\w{3}.”

我们在这个例子里所看到的功能似乎没有那么新鲜或与众不同，但它对于下面的例子或是通过在正则表达式中添加额外数据来处理字符串匹配时就很有帮助了，即使这些字符并不是你感兴趣的字符串中的某部分。上面的两个正则表达式都是限制性很强的，特别要求只含有某些字符串。但在国际语言的系统环境中，使用各地区本地化时间和缩写的情况下，可能就行不通了。限制性更宽松的正则表达式是：“^\w{3}”。

This one requires only that a string begin with three consecutive alphanumeric characters. Again, to translate the RE into English, the carat indicates “begins with,” the “\w” means any single alphanumeric character, and the “{3}” means that there should be 3 consecutive copies of the RE which  the  “{3}”  embellishes.  Again,  if  you  want  grouping,  parentheses should be used, i.e., “^(\w{3})”:
  这个正则表达式只要求字符串以三个由字符或数字组成的字符作开头。要是把它翻译成白话，就是，上箭头(^carat)表示以...开始，“\w”指任意一个由字符或数字组成的字符，“{3}”表示它左边描述的正则表达式模式必须连续出现三次。注意，如果你要对这个正则表达式分组，请用圆括号()，即，“^(\w{3})”:

>>> patt = '^(\w{3})'
>>> m = re.match(patt, data)
>>> if m is not None: m.group()
...
'Thu'
>>> m.group(1)
'Thu'
　Note that an RE of “^(\w){3}” is not correct. When the “{3}” was inside the parentheses, the match for three consecutive alphanumeric characters was made first, then represented as a group. But by moving the “{3}” outside, it is now equivalent to three consecutive single alphanumeric characters:
  注意，要是把正则表达式写成“^(\w){3}”是不正确的。如果把“{3}”写在圆括号里((\w{3}))，表示匹配三个连续的由字符或数字组成的字符，再把这三个字符视为一个组。但如果把“{3}”挪到圆括号的外边((\w){3}), 那现在它的含义就变成三个连续的单个由字符或数字组成的字符：

>>> patt = '^(\w){3}'
>>> m = re.match(patt, data)
>>> if m is not None: m.group()
...
'Thu'
>>> m.group(1)
'u'
　The reason why only the “u” shows up when accessing subgroup 1 is that subgroup  1  was  being  continually  replaced  by  the  next  character.  In  other words, m.group(1) started out as “T,” then changed to “h,” then finally was replaced by “u.” These are three individual (and overlapping) groups of a single alphanumeric character, as opposed to a single group consisting of three consecutive alphanumeric characters.
  访问子组1的数据时，只看到“u”是因为子组1中的数据被不断地替换成下一个字符。也就是说，m.group(1)开始的结果是“T”，然后是“h”,最后又被替换成“u”。它们是三个独立(而且重复)的组，每个组是由字符或数字所组成的字符，而不是由连续的三个字符或数字组成的字符所形成的单个组。
  
　In  our  next  (and  final)  example,  we  will  create  a  regular  expression  to extract the numeric fields found at the end of each line of redata.txt.
  在下一个(也是最后的)例子中，我们将写一个正则表达式来提取文件redata.txt中每行末尾的数值字段。

15.4.2 Search versus Match, and Greediness too
15.4.2 搜索与匹配的比较，“贪婪”匹配

Before we create any REs, however, we realize that these integer data items are at the end of the data strings. This means that we have a choice of using either  search  or  match.  Initiating  a  search  makes  more  sense  because  we know exactly what we are looking for (set of three integers), that what we seek is not at the beginning of the string, and that it does not make up the entire string. If we were to perform a match, we would have to create an RE to match the entire line and use subgroups to save the data we are interested in.  To  illustrate  the  differences,  we  will  perform  a  search  first,  then  do  a match to show you that searching is more appropriate.
在我们写正则表达式前，先明确这些整数数据项是在字符串数据的末尾。这意味着我们有两种选择：搜索(search)或匹配(match)。使用搜索更合适，因为我们确切地知道要查找的数据是什么(三个整数的集合)，它不在字符串的开头，也不是字符串的全部内容。如果我们用匹配(match)的方法，就不得不写一个正则表达式来匹配整行内容，并用子组保存我们感兴趣的那部分数据。为说明它们之间的区别，我们先用搜索查找，再尝试用匹配来做，向你证明搜索查找更适合。

　Since we are looking for three integers delimited by hyphens, we create our  RE  to  indicate  as  such:  “\d+-\d+-\d+”.  This  regular  expression means, “any number of digits (at least one, though) followed by a hyphen, then more digits, another hyphen, and finally, a final set of digits.” We test our RE now using search():
因为我们要查找的是三个由连字符号(-)分隔的整数集，所以我们写出如下正则表达式：“\d+-\d+-\d+”。这个正则表达式描述的是，“任意数字(至少有一个)，后面有连字符号(-),然后是任意个数的数字(至少有一个)，接着是另一个连字符号(-)，最后还是任意数字(至少有一个)的集合。”，我们用search()来测试这个正则表达式：

>>> patt = '\d+-\d+-\d+'
>>> re.search(patt, data).group()	# entire match    	#全部匹配部分
'1171590364-6-8'
　A match attempt, however, would fail. Why? Because matches start at the beginning of the string, the numeric strings are at the rear. We would have to create  another  RE  to  match  the  entire  string.  We  can  be  lazy  though,  by using “.+” to indicate just an arbitrary set of characters followed by what we are really interested in:
  尝试用这个正则表达式来匹配数据会失败，这是为什么呢？因为匹配从字符串的起始位置开始进行的，而我们要找的数值字符串在末尾。我们只能再写一个匹配全部字符串的正则表达式。还有一个偷懒的办法，就是用“.+”来表示任意个字符集，后面再接上我们真正感兴趣的数据:

patt = '.+\d+-\d+-\d+'
>>> re.match(patt, data).group()	# entire match    	#全部匹配部分
'Thu Feb 15 17:46:04 2007::uzifzf@dpyivihw.gov::1171590364-6-8'

　This works great, but we really want the number fields at the end, not the entire string, so we have to use parentheses to group what we want:
  这个方法不错，可是我们只想获得每行末尾数字的字段，而不是整个字符串，所以需要用圆括号将我们感兴趣的那部分数据分成一组：

>>> patt = '.+(\d+-\d+-\d+)'
>>> re.match(patt, data).group(1)	# subgroup 1    	#子组1
'4-6-8'

+ is a greedy operator
+ 是”贪婪“操作符


Thu Feb 15 17:46:04 2007::uzifzf@dpyivihw.gov::1171590364-6-8


.+	\d+-\d+-\d+


Figure 15–2    Why our match went awry: + is a greedy operator
图15–2         为什么匹配错了：+ 是贪心的量词(操作符)

What  happened?  We  should  have  extracted  “1171590364-6-8,”  not just  “4-6-8.”  Where  is  the  rest  of  the  first  integer?  The  problem  is  that regular expressions are inherently greedy. That means that with wildcard patterns, regular expressions are evaluated in left-to-right order and try to “grab” as many characters as possible which match the pattern. In our case above, the “.+” grabbed every single character from the beginning of the string,  including  most  of  the  first  integer  field  we  wanted.  The  “\d+” needed only a single digit, so it got “4”, while the “.+” matched everything from  the  beginning  of  the  string  up  to  that  first  digit:  “Thu  Feb  15 17:46:04  2007::uzifzf@dpyivihw.gov::117159036”,  as  indicated  below  in Figure 15–2.

到底怎么回事呢? 我们本应该得到数据“1171590364-6-8”，而不应该是“4-6-8”啊。第一个整数字段的前半部分到哪里去了呢? 原因是：正则表达式本身默认是贪心匹配的。也就是说，如果正则表达式模式中使用到通配字，那它在按照从左到右的顺序求值时，会尽量“抓取”满足匹配的最长字符串。在我们上面的例子里，“.+”会从字符串的起始处抓取满足模式的最长字符，其中包括我们想得到的第一个整数字段的中的大部分。“\d+”只需一位数字就可以匹配，所以它匹配了数字“4”,而“.+” 则匹配了从字符串起始到这个第一位数字“4”之间的所有字符: “Thu  Feb  15 17:46:04  2007::uzifzf@dpyivihw.gov::117159036”, 如下图 15–2.所示。

　One solution is to use the “don’t be greedy” operator, “?”. It can be used after “*”, “+”, or “?”. This directs the regular expression engine to match as few characters as possible. So if we place a “?” after the “.+”, we obtain the desired result illustrated in Figure 15–3.
  一个解决办法是用“非贪婪”操作符，“?”. 这个操作符可以用在 “*”, “+”, 或 “?” 的后面。它的作用是要求正则表达式引擎匹配的字符越少越好。因此，如果我们把“?”放在“.+”的后面，我们就得到了想要的结果，见图 15–3.

>>> patt = '.+?(\d+-\d+-\d+)'
>>> re.match(patt, data).group(1)	# subgroup 1  		# 子组1
'1171590364-6-8'

? requests non-greedy operation   
? 要求非“贪婪”匹配

Thu Feb 15 17:46:04 2007::uzifzf@dpyivihw.gov::1171590364-6-8

.+ ?	\d+-\d+-\d+

Figure 15–3    Solving the greedy problem: ? requests non-greediness
图15–3         解决“贪婪”匹配问题: ? 要求非“贪婪”匹配

Another solution, which is actually easier, is to recognize that “::” is our field separator. You can then just use the regular string  strip('::') method and get all the parts, then take another split on the dash with strip('-') to obtain the three integers you were originally seeking. Now, we did not choose this solution first because this is how we put the strings together to begin with using gendata.py!
另一种办法，更简单，注意运用 “::”做字段分隔符号。你可以用一般字符串的strip('::') 方法，得到全部字符，然后用strip('-')得到你要找的三个整数字段。我们现在不采用这种方法，因为我们的脚本gendata.py正是通过这种方法把字符组合到一起的。

One final example: let us say we want to pull out only the middle integer of the three-integer field. Here is how we would do it (using a search so we don’t have to match the entire string): “-(\d+)-”. Trying out this pattern, we get:

最后一个例子：假设我们只想抽取三个整数字段里中间的那个整数部分。我们是这么做的(用搜索，这样就不必匹配整个字符了)：“-(\d+)-”。用这个模式“-(\d+)-”，我们得到：

>>> patt = '-(\d+)-'
>>> m = re.search(patt, data)
>>> m.group()	# entire match		#整个匹配
'-6-'
>>> m.group(1)	# subgroup 1   		#子组1
'6'
　We barely touched upon the power of regular expressions, and in this limited space we have not been able to do them justice. However, we hope that we have given an informative introduction so that you can add this powerful tool to your programming skills. We suggest you refer to the documentation for more details on how to use REs with Python. For more complete immersion into the world of regular expressions, we recommend Mastering Regular Expressions by Jeffrey E. F. Friedl.
在本章中，有很多正则表达式的强大功能我们未能涉及，由于篇幅所限，我们无法详细介绍它们。但我们希望所提供的信息和技巧对你的编程实践有所帮助。我们建议你参阅有关文档以获得更多在Python语言中使用正则表达式的知识。要精通正则表达式，我们建议你阅读Jeffrey E. F. Friedl所编写的Mastering Regular Expressions一书。

15.5 Exercises
15.5 练习

Regular  Expressions.  Create  regular  expressions  in  Exercises  15–1  to 15–12 to:
正则表达式. 根据要求写出 练习15–1至15–12相应的正则表达式

15–1.   Recognize the following strings: “bat,” “bit,” “but,” “hat,” “hit,” or “hut.”
15-1.   识别下列字符串：“bat,” “bit,” “but,” “hat,” “hit,” 或 “hut”

15–2.   Match any pair of words separated by a single space, i.e., first and last names.
15–2.   匹配用一个空格分隔的任意一对单词，比如，名和姓。

15–3.   Match any word and single letter separated by a comma and single space, as in last name, first initial.
15–3.   匹配用一个逗号和一个空格分开的一个单词和一个字母。例如，英文人名中的姓和名的首字母。

15–4.   Match the set of all valid Python identifiers.
15-4    匹配所有合法的Python标识符。

15–5.   Match a street address according to your local format (keep your RE general enough to match any number of street words, including the type designation). For example, American street addresses use the format: 1180 Bordeaux Drive. Make your RE general enough to support multi-word street names like:
3120 De la Cruz Boulevard.
请根据您(读者)本地关于地址的格式写法匹配一个街道地址(你写出的正则表达式要尽可能通用以匹配任意数目的表示街道名字的单词，包括类型指示)。比如，美国的街道地址使用这样的格式：1180 Bordeaux Drive. 使你写的正则表达式尽可能通用，要求能够匹配多个单词的街道名字，如：3120 De la Cruz Boulevard.

15–6.   Match simple Web domain names that begin with “www.” and end with a “.com” suffix, e.g., www.yahoo.com. Extra credit if your RE also supports other high-level domain names: .edu, .net, etc., e.g., www.ucsc.edu.
15–6. 匹配简单的以“www.”开头，以“.com”作结尾的Web域名，例如：www.yahoo.com. 附加题：使你写的正则表达式还支持其他顶级域名：.edu, .net 等，比如：www.ucsc.edu.

15–7.   Match the set of the string representations of all Python integers.
15-7. 匹配全体Python整数的字符串表示形式的集合。

15–8.   Match the set of the string representations of all Python longs.
15–8. 匹配全体Python长整数的字符串表示形式的集合。

15–9.   Match the set of the string representations of all Python floats.
15–9. 匹配全体Python浮点数的字符串表示形式的集合。

15–10.   Match the set of the string representations of all Python complex numbers.
15–10. 匹配全体Python复数的字符串表示形式的集合。

15–11.   Match the set of all valid e-mail addresses (start with a loose RE, then try to tighten it as much as you can, yet maintain correct functionality).
15–11. 匹配所有合法的电子邮件地址(先写出一个限制比较宽松的正则表达式，然后尽可能加强限制条件，但要保证功能的正确性)。

15–12.   Match the set of all valid Web site addresses (URLs) (start with a loose RE, then try to tighten it as much as you can, yet maintain correct functionality).
15–12.匹配所有合法的Web网站地址(URLs)(先写出一个限制比较宽松的正则表达式，然后尽可能加强限制条件，但要保证功能的正确性)。

15–13.   type(). The type() built-in function returns a type object, which is displayed as a Pythonic-looking string:
15–13.   type(). type()内建函数返回一个对象类型，此对象显示为Python的字符串形式，如下所示： 

>>> type(0)
<type 'int'>
>>> type(.34)
<type 'float'>
>>> type(dir)
<type 'builtin_function_or_method'>

Create an RE that would extract out the actual type name from the string. Your function should take a string like this “<type 'int'>” and return “int”. (Ditto for all other types, i.e., ‘float’, ‘builtin_function_or_method’, etc.) Note: You are implementing the value that is stored in the __name__ attribute for classes and some built-in types.
请写一个正则表达式，能从这个字符串中提取出类型的名字。 你的函数能实现以下功能：如果以字符串“<type 'int'>”做输入，会返回类型“int”.(返回其他类型也同理，如，返回类型‘float’, ‘builtin_function_or_method’等) 提示：正确的结果保存在类和某些内建类型的__name__属性里。


15–14.   Regular Expressions. In Section 15.2, we gave you the RE pattern that matched the single- or double-digit string representations of the months January to September (“0?[1-9]”). Create the RE that represents the remaining three months in the standard calendar.
15–14.正则表达式。在15.2小节里，我们给出一个匹配由一位或两位数字代表一月到九月的字符串形式(“0?[1-9]”)。 请写出一个正则表达式表示标准日历上其它的三个月(十月、十一月、十二月)。

15–15.   Regular Expressions. Also in Section 15.2, we gave you the RE pattern that matched credit card (CC) numbers(“[0-9]{15,16}”). However, this pattern does not allow for hyphens separating blocks of numbers. Create the RE that allows hyphens, but only in the correct locations. For example, 15-digit CC numbers have a pattern of 4-6-5, indicating four digits-hyphen-six digits-hyphen-five digits,
and 16-digit CC numbers have a 4-4-4-4 pattern. Remember to “balloon” the size of the entire string correctly. Extra credit: There is a standard algorithm for determining whether a CC number is valid. Write some code not only to recognize a correctly formatted CC number, but also a valid one.
15–15. 正则表达式。在15.2小节里，我们给出一个匹配信用卡卡号的模式：(“[0-9]{15,16}”). 但这个模式不允许用连字符号分割信用卡卡号中的数字。请写出一个允许使用连字符的正则表达式，但要求连字符必须出现在正确的位置。例如，15位的信用卡卡号的格式是4-6-5,表示四个数字，一个连字符，后面接六个数字、一个连字符，最后是五个数字。16位的信用卡卡号的格式是4-4-4-4，数位不足时，添0补位。附加题：有一个用于确定某个信用卡卡号是否合法的算法。请写一段代码，它不但能识别格式正确的信用卡卡号，还能验证它的有效性。

The  next  set  of  problems  (15–16  through  15–27)  deal  specifically  with  the data that are generated by gendata.py. Before approaching problems 15–17 and 15–18, you may wish to do 15–16 and all the regular expressions first.
下面几个问题(练习15–16到15–27)专门处理gendata.py生成的数据。在做练习15–17 和15–18之前，请先把练习15–16 和所有正则表达式做出来。

15–16.   Update the code for gendata.py so that the data are written directly to redata.txt rather than output to the screen.
15–16. 修改脚本gendata.py的代码，使数据直接写入文件redata.txt中，而不是输出到屏幕上。

15–17.   Determine how many times each day of the week shows up for any incarnation of redata.txt. (Alternatively, you can also count how many times each month of the year was chosen.)
15–17.  统计生成的redata.txt文件中，星期中的每一天出现的次数(或统计各月份出现的次数)。

15–18.   Ensure there is no data corruption in redata.txt by confirming that the first integer of the integer field matches the timestamp given at the front of each output line.
15–18.通过检查每个输出行中整数字段部分的第一个整数是否和该行开头的时间戳相匹配来验证redata.txt中的数据是否完好。

Create regular expressions to:
根据各练习的要求写出相应的正则表达式：

15–19.   Extract the complete timestamps from each line.
15–19.   提取出每行中完整的时间戳字段。

15–20.   Extract the complete e-mail address from each line.
15–20.   提取出每行中完整的电子邮件地址。

15–21.   Extract only the months from the timestamps.
15–21.   只提取出时间戳字段中的月份。

15–22.   Extract only the years from the timestamps.
15-22.   只提取出时间戳字段中的年份。

15–23.   Extract only the time (HH:MM:SS) from the timestamps.
15–23.   只提取出时间戳字段中的值(格式：HH:MM:SS)。

15–24.   Extract only the login and domain names (both the main domain name and the high-level domain together) from the e-mail address.
15-24.   只从电子邮件地址中提取出登录名和域名(包括主域名和顶级域名,二者连在一起)。

15–25.   Extract only the login and domain names (both the main domain name and the high-level domain) from the e-mail address.
15-25.   只从电子邮件地址中提取出登录名和域名(包括主域名和顶级域名，二者分别提取)。

15–26.   Replace the e-mail address from each line of data with your e-mail address.
15–26.   将每行中的电子邮件地址替换为你自己的电子邮件地址。

15–27.   Extract the months, days, and years from the timestamps and output them in “Mon Day, Year” format, iterating over each line only once.
15–27.   提取出时间戳中的月、日、年，并按照格式“月 日，年”显示出来，且每行仅遍历一次。

For problems 15–28 and 15–29, recall the regular expression introduced in Section 15.2, which matched telephone numbers but allowed for an optional area  code  prefix:  \d{3}-\d{3}-\d{4}.  Update  this  regular  expression  so that:
我们在小节15.2中使用的一个匹配电话号码的正则表达式，其中电话号码允许包含可选的区号前缀 ： \d{3}-\d{3}-\d{4}. 请在练习15–28 和 15–29中, 修改这个正则表达式，使它满足：

15–28.   Area codes (the first set of three-digits and the accompanying hyphen) are optional, i.e., your RE should match both 800-555-1212 as well as just 555-1212.
15–28.区号(第一组的三个数字和它后面的连字符)是可选的，即，你写的正则表达式对800-555-1212和555-1212都可以匹配。

15–29.   Either parenthesized or hyphenated area codes are supported, not to mention optional; make your RE match 800-555-1212, 555-1212, and also (800) 555-1212.
15–29.区号中可以包含圆括号或是连字符，而且它们是可选的，就是说你写的正则表达式可以匹配800-555-1212, 或 555-1212, 或(800) 555-1212.
