Mapping and Set Types
映射和集合类型


Chapter Topics
	Mapping Type: Dictionaries
	Operators
	Built-in Functions
	Built-in Methods
	Dictionary Keys
	Set Types
	Operators
	Built-in Functions
	Built-in Methods
	Related Modules
	7
	
*本章主题
	* 映射类型: 字典
	  * 操作符
	  * 内建函数
	  * 内建方法
	  * 字典的键
	* 集合类型
	  * 操作符
	  * 内建函数
	  * 内建方法
	* 相关模块
	
	

第七章

in this chapter, we take a look at Python’s mapping and set types. As in earlier chapters, an introduction is followed by a discussion of the applicable operators and factory and built-in functions (BIFs) and methods. We then go into more specific usage of each data type.
本章中，我们来讨论Python语言中的映射类型和集合类型。和前面的章节一样，我们首先做一个介绍，然后在来讨论可用操作符，工厂函数、内建函数(BIF)和方法。然后我们再来看看每种数据类型的详细用法。


7.1 Mapping Type: Dictionaries
映射类型：字典

Dictionaries are the sole mapping type in Python. Mapping objects have a one-to-many correspondence between hashable values (keys) and the objects they represent (values). They are similar to Perl hashes and can be generally considered as mutable hash tables. A dictionary object itself is mutable and is yet another container type that can store any number of Python objects, including other container types. What makes dictionaries different from sequence type containers like lists and tuples is the way the data are stored and accessed. Sequence types use numeric keys only (numbered sequentially as indexed offsets from the beginning of the sequence). Mapping types may use most other object types as keys; strings are the most common. Unlike sequence type keys, mapping keys are often, if not directly, associated with the data value that is stored. But because we are no longer using “sequentially ordered” keys with mapping types, we are left with an unordered collection of data. 
字典是Python语言中唯一的映射类型。映射类型对象里哈希值(键) 和指向的对象(值)是一对多的关系。 它们与Perl中的哈希类型(译者注：又称关联数组)相似，通常被认为是可变的哈希表。一个字典对象是可变的，它是一个容器类型，能存储任意个数的Python对象，其中也包括其他容器类型。字典类型和序列类型容器类(列表、元组)的区别是存储和访问数据的方式不同。序列类型只用数字类型的键(从序列的开始起按数值顺序索引)。映射类型可以用其他对象类型做键；一般最常见的是用字符串做键(keys)。和序列类型的键不同，映射类型的键(keys)直接，或间接地和存储的数据值相关联。但因为在映射类型中，我们不再用"序列化排序"的键(keys),所以映射类型中的数据是无序排列的。

As it turns out, this does not hinder our use because mapping types do not require a numeric value to index into a container to obtain the desired item. With a key, you are “mapped” directly to your value, hence the term “mapping type.” The reason why they are commonly referred to as hash tables is because that is the exact type of object that dictionaries are. Dictionaries are one of Python’s most powerful data types. 
显然，这并不影响我们使用映射类型，因为映射类型不要求用数字值做索引以从一个容器中获取对应的数据项。你可以用键(key)直接 "映射" 到值, 这就是为什么叫映射类型(“mapping type”)的原因。映射类型通常被称做哈希表的原因是字典对象就是哈希类型的。字典是Python中最强大的数据类型之一。
  

CORE NOTE: What are hash tables and how do they relate to dictionaries?
核心笔记：什么是哈希表？它们与字典的关系是什么？

Sequence types use sequentially ordered numeric keys as index offsets to store your data in an array format. The index number usually has nothing to do with the data value that is being stored. There should also be a way to store data based on another associated value such as a string. We do this all the time in everyday living. You file people’s phone numbers in your address book based on last name, you add events to your calendar or appointment book based on date and time, etc. For each of these examples, an associated value to a data item was your key.
序列类型用有序的数字键做索引将数据以数组的形式存储。一般，索引值与所存储的数据毫无关系。还可以用另一种方式来存储数据：基于某种相关值，比如说一个字符串。我们在日常生活中一直这么做。你把人们的电话号码按照他们的姓记录在电话簿上，你按照时间在日历或约会簿上添加事件，等等。在这些例子中，你的键(key)就是和数据项相关的值。

Hash tables are a data structure that does exactly what we described. They store each piece of data, called a value, based on an associated data item, called a key. Together, these are known as key-value pairs. The hash table algorithm takes your key, performs an operation on it, called a hash function, and based on the result of the calculation, chooses where in the data structure to store your value. Where any one particular value is stored depends on what its key is. Because of this randomness, there is no ordering of the values in the hash table. You have an unordered collection of data.

哈希表是一种数据结构：它按照我们所要求的去工作。哈希表中存储的每一条数据，叫做一个值(value)，是根据与它相关的一个被称作为键(key)的数据项进行存储的。键和值合在一起被称为“键-值 对”(key-value pairs)。  哈希表的算法是获取键，对键执行一个叫做哈希函数的操作，并根据计算的结果，选择在数据结构的某个地址中来存储你的值。任何一个值存储的地址皆取决于它的键。正因为这种随意性，哈希表中的值是没有顺序的。你拥有的是一个无序的数据集。

The only kind of ordering you can obtain is by taking either a dictionary’s set of keys or values.The keys() or values() method returns lists, which are sortable. You can also call items() to get a list of keys and values as tuple pairs and sort that. Dictionaries themselves have no implicit ordering because they are hashes.
你所能获得的有序集合只能是字典中的键的集合或者值的集合。方法Keys() 或 values() 返回一个列表，该列表是可排序的。 你还可以用 items()方法得到包含键、值对的元组的列表来排序。由于字典本身是哈希的，所以是无序的。

Hash tables generally provide good performance because lookups occur fairly quickly once you have a key.
哈希表一般有很好的性能， 因为用键查询相当快。

　Python dictionaries are implemented as resizeable hash tables. If you are familiar with Perl, then we can say that dictionaries are similar to Perl’s associative arrays or hashes.
  Python的字典是作为可变的哈希表实现的。如果你熟悉Perl的话, 就可以发现字典与Perl中的"关系数组"或散列相似。
  
　We  will  now  take  a  closer  look  at  Python  dictionaries.  The  syntax  of  a dictionary  entry  is  key:value. Also,  dictionary  entries  are  enclosed  in braces ( { } ).
  现在我们就来研究Python字典。一个字典条目的语法格式是 键:值。 而且，多条字典条目被包含在( { } ) 里。

How to Create and Assign Dictionaries
如何创建字典和给字典赋值

Creating  dictionaries  simply  involves  assigning  a  dictionary  to  a  variable, regardless of whether the dictionary has elements or not:
创建字典只需要把字典赋值给一个变量，不管这个字典是否包含元素：

>>> dict1 = {}
>>> dict2 = {'name': 'earth', 'port': 80}
>>> dict1, dict2
({}, {'port': 80, 'name': 'earth'})

In Python versions 2.2 and newer, dictionaries may also be created using the factory  function  dict().  We  discuss  more  examples  later  when  we  take  a closer look at dict(), but here’s a sneak peek for now:
从Python 2.2版本起， 可以用工厂方法 dict() 来创建字典。 当我们详细讨论dict()的时候会看到更多的例子，现在来看一个小例子：

>>> fdict = dict((['x', 1], ['y', 2]))
>>> fdict
{'y': 2, 'x': 1}

In Python versions 2.3 and newer, dictionaries may also be created using a very convenient built-in method for creating a “default” dictionary whose elements all have the same value (defaulting to None if not given), fromkeys():
从Python 2.3版本起, 可以用一个很方便的内建方法fromkeys() 来创建一个"默认"字典, 字典中元素具有相同的值 (如果没有给出， 默认为None):

>>> ddict = {}.fromkeys(('x', 'y'), -1)
>>> ddict
{'y': -1, 'x': -1}
>>>
>>> edict = {}.fromkeys(('foo', 'bar'))
>>> edict
{'foo': None, 'bar': None}

How to Access Values in Dictionaries
如何访问字典中的值

To traverse a dictionary (normally by key), you only need to cycle through its keys, like this:
要想遍历一个字典(一般用键), 你只需要循环查看它的键, 像这样：

>>> dict2 = {'name': 'earth', 'port': 80}
>>>
>>>> for key in dict2.keys():
...	print 'key=%s, value=%s' % (key, dict2[key])
...
key=name, value=earth key=port, value=80

Beginning with Python 2.2, you no longer need to use the keys() method to extract a list of keys to loop over. Iterators were created to simplify accessing  of  sequence-like  objects  such  as  dictionaries  and  files.  Using  just the dictionary name itself will cause an iterator over that dictionary to be used in a for loop:
从Python 2.2 开始， 你可以不必再用keys()方法获取供循环使用的键值列表了。 可以
用迭代器来轻松地访问类序列对象(sequence-like objects)，比如字典和文件。只需要用字典的名字就可以在 for 循环里遍历字典。

>>> dict2 = {'name': 'earth', 'port': 80}
>>>
>>>> for key in dict2:
...	print 'key=%s, value=%s' % (key, dict2[key])
...
key=name, value=earth key=port, value=80

　To  access  individual  dictionary  elements,  you  use  the  familiar  square brackets along with the key to obtain its value:
  要得到字典中某个元素的值， 可以用你所熟悉的字典键加上中括号来得到：

>>> dict2['name']
'earth'
>>>
>>> print 'host %s is running on port %d' % \
...	(dict2['name'], dict2['port'])
host earth is running on port 80

　Dictionary dict1 defined above is empty while dict2 has two data items. The keys in dict2 are 'name' and 'port', and their associated value items are 'earth' and 80, respectively. Access to the value is through the key, as you can see from the explicit access to the 'name' key.
  字典dict1是空的，字典dict2有两个数据元素。字典dict2的键是 'name' 和 'port'，它们对应的值分别是'earth' 和 80。就像你看到的，通过键'name'可以得到字典中的元素的值。
  
　If we attempt to access a data item with a key that is not part of the dictionary, we get an error:
  如果我们想访问该字典中的一个数据元素，而它在这个字典中没有对应的键，将会产生一个错误：

>>> dict2['server'] Traceback (innermost last):
　File "<stdin>", line 1, in ? KeyError: server

　In this example, we tried to access a value with the key 'server' which, as you know from the code above, does not exist. The best way to check if a dictionary has a specific key is to use the dictionary’s  has_key() method, or better yet,  the  in or  not in operators  starting  with  version  2.2.  The has_key() method will be obsoleted in future versions of Python, so it is best to just use in or not in.
   在这个例子中，我们试图获得字典中'server'键所对应的值。你从上面的代码知道，'server'这个键并不存在。检查一个字典中是否有某个键的最好方法是用字典的 has_key()方法， 或者另一种比较好的方法就是从2.2版本起用的，in 或  not in 操作符。 has_key() 方法将会在未来的Python版本中弃用，所以用in 或  not in是最好的方法。

We  will  introduce  all  of  a  dictionary’s  methods  below.  The  Boolean has_key() and the in and not in operators are Boolean, returning True if a dictionary has that key and False otherwise. (In Python versions preceding Boolean constants [older than 2.3], the values returned are 1 and 0, respectively.)
下面我们将介绍字典所有的方法。方法has_key()和 in 以及 not in 操作符都是布尔类型的。对于前两者而言，如果字典中有该键就返回真(True)，否则返回假(False)。(Python 2.3版本以前，没有布尔常量，为真时返回1，假时返回0。)

>>> 'server' in dict2 # or dict2.has_key('server') Falser
>>> 'name' in dict # or dict2.has_key('name') True
>>> dict2['name']
'earth'

>>> 'server' in dict2 	# 或 dict2.has_key('server') 
False
>>> 'name' in dict 	# 或 dict2.has_key('name') 
True
>>> dict2['name']
'earth'

　Here is another dictionary example mixing the use of numbers and strings as keys:
  一个字典中混用数字和字符串的例子：

>>> dict3 = {}
>>> dict3[1] = 'abc'
>>> dict3['1'] = 3.14159
>>> dict3[3.2] = 'xyz'
>>> dict3
{3.2: 'xyz', 1: 'abc', '1': 3.14159}

　Rather  than  adding  each  key-value  pair  individually,  we  could  have  also entered all the data for dict3 at the same time:
  除了逐一地添加每个键-值对外，我们也可以给dict3整体赋值。

dict3 = {3.2: 'xyz', 1: 'abc', '1': 3.14159}

　Creating the dictionary with a set key-value pair can be accomplished if all the data items are known in advance (obviously). The goal of the examples using dict3 is to illustrate the variety of keys that you can use. If we were to pose the question of whether a key for a particular value should be allowed to change, you would probably say, “No.” Right? 如果事先已经知道所有的数据就可以用键-值对来创建一个字典(这是显而易见的)。通过字典dict3的示例说明你可以采用各种类型的数据作为字典的键。如果我们被问到是否可以改变某个字典值的键(key) 时，你可能会说，“不”，对吗？
  
  
　Not allowing keys to change during execution makes sense if you think of it this way: Let us say that you created a dictionary element with a key and value. Somehow during execution of your program, the key changed, perhaps due to an altered variable. When you went to retrieve that data value again with the original key, you got a KeyError (since the key changed), and you had no idea how to obtain your value now because the key had somehow been altered. For this reason, keys must be hashable, so numbers and strings are fine, but lists and other dictionaries are not. (See Section 7.5.2 for why keys must be hashable.)
  为什么在执行中字典中的键不允许被改变呢？你这样想就会明白： 比方说， 你创建了一个字典，字典中包含一个元素(一个键和一个值)。可能是由于某个变量的改变导致键发生了改变。这时候你如果用原来的键来取出字典里的数据，会得到KeyError(因为键的值已经改变了)，现在你没办法从字典中获取该值了，因为键本身的值发生了变化。由于上面的原因，字典中的键必须是可哈希的， 所以数字和字符串可以作为字典中的键， 但是列表和其他字典不行。(见7.5.2小节 字典的键必须是可哈希的) 

  
How to Update Dictionaries
如何更新字典

You can update a dictionary by adding a new entry or element (i.e., a key-value pair),  modifying  an  existing  entry,  or  deleting  an  existing  entry  (see below for more details on removing an entry).
你可以通过以下几种方式对一个字典做修改：添加一个新数据项或新元素(即，一个键-值对)；修改一个已存在的数据项；或删除一个已存在的数据项(下面有关于数据项删除操作的详细讲述).

>>> dict2['name'] = 'venus' # update existing entry
>>> dict2['port'] = 6969	# update existing entry
>>> dict2['arch'] = 'sunos5'# add new entry
>>>
>>> print 'host %(name)s is running on port %(port)d' %dict2
host venus is running on port 6969

>>> dict2['name'] = 'venus' # 更新已有条目
>>> dict2['port'] = 6969	# 更新已有条目
>>> dict2['arch'] = 'sunos5'# 增加新条目
>>>
>>> print 'host %(name)s is running on port %(port)d' %dict2
host venus is running on port 6969


　If the key does exist, then its previous value will be overridden by its new value. The print statement above illustrates an alternative way of using the string  format  operator  (  %  ),  specific  to  dictionaries.  Using  the  dictionary argument, you can shorten the print request somewhat because naming of the dictionary occurs only once, as opposed to occurring for each element using a tuple argument.
  如果字典中该键已经存在，则字典中该键对应的值将被新值替代。上面的print语句展示了另一种在字典中使用字符串格式符( %)的方法。用字典参数可以简化print语句，因为这样做你只须用到一次该字典的名字，而不用在每个元素出现的时候都用元组参数表示。
 
  You may also add the contents of an entire dictionary to another dictionary by using the update() built-in method. We will introduce this method in Section 7.4.
  你也可以用内建方法update()将整个字典的内容添加到另一个字典。我们将在7.4节介绍此方法。


How to Remove Dictionary Elements and Dictionaries
如何删除字典元素和字典

Removing  an  entire  dictionary  is  not  a  typical  operation.  Generally,  you either remove individual dictionary elements or clear the entire contents of a dictionary. However, if you really want to “remove” an entire dictionary, use the  del statement  (introduced  in  Section  3.5.5).  Here  are  some  deletion examples for dictionaries and dictionary elements:
删除整个字典的操作不常见。通常，你删除字典中的单个元素或是清除整个字典的内容。但是，如果你真想"删除"一个字典，用del 语句 (介绍见小节 3.5.5)。 以下是删除字典和字典元素的例子。

del dict2['name']	# remove entry with key 'name' 
dict2.clear()	# remove all entries in dict2 
del dict2	# delete entire dictionary 
dict2.pop('name')	# remove & return entry w/key

del dict2['name']	# 删除键为“name”的条目 
dict2.clear()		# 删除dict2中所有的条目
del dict2			# 删除整个dict2字典
dict2.pop('name')	# 删除并返回键为“name”的条目


CORE TIP: Avoid using built-in object names as identifiers for variables!
核心笔记：避免使用内建对象名字作为变量的标识符

For those of you who began traveling in the Python universe before version 2.3, you may have once used dict as an identifier for a dictionary. However, because dict() is now a type and factory function, overriding it may cause you headaches and potential bugs.The interpreter will allow such overriding—hey, it thinks you seem smart and
look like you know what you are doing! So be careful. Do NOT use variables named after built-in types like: dict, list, file, bool, str, input, or len!
如果在Python 2.3 前，你已经开始使用Python，你可能用dict 作为一个字典的标识符。但是，因为 dict() 现在已成为 Python 的类型和工厂方法，重载dict()会给你带来麻烦和潜在的bugs。编译器允许你做这样的重载，它认为你是聪明的，知道自己正在做什么！小心。请不要用 dict, list, file, bool, str, input, len 这样的内建类型为变量命名。


7.2 Mapping Type Operators
映射类型操作符

Dictionaries will work with all of the standard type operators but do not support operations such as concatenation and repetition. Those operations, although they make sense for sequence types, do not translate to mapping types. In the next two subsections, we introduce you to the operators you can use with dictionaries.
字典可以和所有的标准类型操作符一起工作,但却不支持像拼接（concatenation）和重复(repetition)这样的操作。这些操作对序列有意义，可对映射类型行不通。在接下来的两小节里，我们将向你讲述字典中的操作符。


7.2.1 Standard Type Operators
标准类型操作符

The standard type operators were introduced in Chapter 4. Here are some basic examples using some of those operators:
标准类型操作符已在第四章介绍。 下面是一些使用操作符的简单示例：

>>> dict4 = {'abc': 123}
>>> dict5 = {'abc': 456}
>>> dict6 = {'abc': 123, 98.6: 37}
>>> dict7 = {'xyz': 123}
>>> dict4 < dict5
True
>>> (dict4 < dict6) and (dict4 < dict7) True
>>> (dict5 < dict6) and (dict5 < dict7) True
>>> dict6 < dict7
False

　How are all these comparisons performed? Like lists and tuples, the process is a bit more complex than it is for numbers and strings. The algorithm is detailed in Section 7.3.1.
字典是如何比较的呢？ 与列表和元组一样，这个过程比数字和字符串的比较更复杂些。详细算法请见第7.3.1小节。


7.2.2 Mapping Type Operators
映射类型操作符

Dictionary Key-Lookup Operator ( [ ] )
字典的键查找操作符（[ ]）
The only operator specific to dictionaries is the key-lookup operator, which works very similarly to the single element slice operator for sequence types. For sequence types, an index offset is the sole argument or subscript to access a single element of a sequence. For a dictionary, lookups are by key, so that is the argument rather than an index. The key-lookup operator is used for both assigning values to and retrieving values from a dictionary:
键查找操作符是唯一仅用于字典类型的操作符，它和序列类型里单一元素的切片(slice)操作符很相象。对序列类型来说，用索引做唯一参数或下标(subscript)以获取一个序列中某个元素的值。对字典类型来说，是用键(key)查询(字典中的元素),所以键是参数(argument), 而不是一个索引(index)。键查找操作符既可以用于给字典赋值，也可以用于从字典中取值：
 
set value 'v' in dictionary with key 'k' 
通过键'k'，给字典中某元素赋值'v'
lookup value in dictionary with key 'k'  
通过键'k'，查询字典中某元素的值
(Key) Membership (in, not in) 
(键)成员关系操作( in ,not in)
Beginning with Python 2.2, programmers can use the in and not in operators to check key membership instead of the has_key() method:
从Python 2.2起，程序员可以不用has_key()方法，而用 in 和 not in 操作符来检查某个键是否存在于字典中：

>>> 'name' in dict2
True
>>> 'phone' in dict2
False

7.3  Mapping Type Built-in and FactoryFunctions
映射类型的内建函数和工厂函数

7.3.1 Standard Type Functions [type(), str(), and cmp()]
标准类型函数[type()、str()和cmp()]


The type() factory function, when applied to a dict, returns, as you might expect, the dict type, “<type 'dict'>”. The str() factory function will produce  a  printable  string  representation  of  a  dictionary.  These  are  fairly straightforward.
如你所料，对一个字典调用type()工厂方法，会返回字典类型,  “<type 'dict'>”. 调用str()工厂方法将返回该字典的字符串表示形式，这些都很容易理解。
　In each of the last three chapters, we showed how the cmp() BIF worked with numbers, strings, lists, and tuples. So how about dictionaries? Comparisons of dictionaries are based on an algorithm that starts with sizes first, then keys, and finally values. However, using cmp() on dictionaries isn’t usually very useful.
  在前面的三个章节里，我们已经讲述了用 cmp() 内建函数来操作数字、字符串、列表和元组。那么字典又是如何比较的呢? 字典是通过这样的算法来比较的： 首先是字典的大小，然后是键，最后是值。可是，用 cmp() 做字典的比较一般不是很有用。
  
The next subsection goes into further detail about the algorithm used to compare  dictionaries,  but  this  is  advanced  reading,  and  definitely  optional since comparing dictionaries is not very useful or very common.
接下来的小节里，将进一步详细说明字典比较的算法，但这部分是高层次的阅读内容，可以跳过，因为字典的比较不是很有用也不常见。

*Dictionary Comparison Algorithm
字典比较算法

　In the following example, we create two dictionaries and compare them, then slowly modify the dictionaries to show how these changes affect their comparisons:
接下来的例子中，我们建立两个字典进行比较，然后慢慢修改，来看看这些修改对它们之间的比较带来的影响：

>>> dict1 = {}
>>> dict2 = {'host': 'earth', 'port': 80}
>>> cmp(dict1, dict2)
-1
>>> dict1['host'] = 'earth'
>>> cmp(dict1, dict2)
-1
　In  the  first  comparison,  dict1 is  deemed  smaller  because  dict2 has more elements (2 items vs. 0 items). After adding one element to dict1, it is still smaller (2 vs. 1), even if the item added is also in dict2.
  在第一个比较中，dict1 比 dict2小，因为dict2有更多元素(2 个 vs. 0 个)。在向dict1添加一个元素后，dict1仍然比dict2小 (2 vs. 1)，虽然添加的元素在dict2中也存在。

>>> dict1['port'] = 8080
>>> cmp(dict1, dict2)
1
>>> dict1['port'] = 80
>>> cmp(dict1, dict2)
0
　After we add the second element to dict1, both dictionaries have the same size, so their keys are then compared. At this juncture, both sets of keys match, parison proceeds to checking their values. The values for the  'host' keys are the same, but when we get to the 'port' key, dict2 is deemed larger because its value is greater than that of dict1’s 'port' key (8080 vs. 80). When resetting dict2’s 'port' key to the same value as dict1’s 'port' key, then both dictionaries form equals: They have the same size, their keys match, and so do their values, hence the reason that 0 is returned by cmp().
  在向dict1中添加第二个元素后，两个字典的长度相同，所以用键比较大小。这时键相等，则通过它们的值比较大小。键 'host'的值相同，对于键 'port'，dict1中值比dict2中的值大(8080 vs. 80)。当把dict2中'port'的值设成和dict1中的值一样，那么两个字典相等：它们有相同的大小、相同的键、相同的值，所以cmp() 返回值是0。
{译者注： 原文有误：dict2 is deemed larger because its value is greater than that of dict1’s 'port' key (8080 vs. 80). 应为： dict1 is deemed larger because its value is greater than that of dict2’s 'port' key (8080 vs. 80). }

>>> dict1['prot'] = 'tcp'
>>> cmp(dict1, dict2)
1
>>> dict2['prot'] = 'udp'
>>> cmp(dict1, dict2)
-1
　As soon as an element is added to one of the dictionaries, it immediately becomes the “larger one,” as in this case with dict1. Adding another key- value pair to dict2 can tip the scales again, as both dictionaries’ sizes match and comparison progresses to checking keys and values.
 当向两个字典中的任何一个添加新元素时，这个字典马上会成为大的那个字典，就像例子中的dict1一样。向dict2添加键-值对后，因为两个字典的长度又相等了，会继续比较它们的键和值。
 
>>> cdict = {'fruits':1}
>>> ddict = {'fruits':1}
>>> cmp(cdict, ddict)
0
>>> cdict['oranges'] = 0
>>> ddict['apples'] = 0
>>> cmp(cdict, ddict)
14
Our final example reminds as that cmp() may return values other than ?1, 0,
or 1. The algorithm pursues comparisons in the following order.
上面的例子表明cmp()可以返回除-1,0,1外的其他值。算法按照以下的顺序。


(1) Compare Dictionary Sizes
比较字典长度

If the dictionary lengths are different, then for cmp(dict1, dict2), cmp() will return a positive number if dict1 is longer and a negative number if dict2 is longer. In other words, the dictionary with more keys is greater, i.e.,
如果字典的长度不同，那么用 cmp(dict1, dict2) 比较大小时，如果字典 dict1 比 dict2 长，cmp()返回正值，如果 dict2 比 dict1 长，则返回负值。也就是说，字典中的键的个数越多，这个字典就越大，即:

len(dict1) > len(dict2) ==>  dict1 > dict2

(2) Compare Dictionary Keys
比较字典的键

If both dictionaries are the same size, then their keys are compared; the order in which the keys are checked is the same order as returned by the keys() method. (It is important to note here that keys that are the same will map to the same locations in the hash table. This keeps key-checking consistent.) At the point where keys from both do not match, they are directly compared and cmp() will return a positive number if the first differing key for dict1 is greater than the first differing key of dict2.
如果两个字典的长度相同，那就按字典的键比较；键比较的顺序和 keys()方法返回键的顺序相同。 (注意: 相同的键会映射到哈希表的同一位置，这保证了对字典键的检查的一致性。) 这时，如果两个字典的键不匹配时，对这两个(不匹配的键)直接进行比较。当dict1中第一个不同的键大于dict2中第一个不同的键，cmp()会返回正值。



(3) Compare Dictionary Values
比较字典的值

If both dictionary lengths are the same and the keys match exactly, the values for each key in both dictionaries are compared. Once the first key with non- matching values is found, those values are compared directly. Then  cmp() will return a positive number if, using the same key, the value in  dict1 is greater than the value in dict2.
如果两个字典的长度相同而且它们的键也完全匹配，则用字典中每个相同的键所对应的值进行比较。一旦出现不匹配的值，就对这两个值进行直接比较。若dict1比dict2中相同的键所对应的值大，cmp()会返回正值。

(4) Exact Match

If we have reached this point, i.e., the dictionaries have the same length, the same  keys,  and  the  same  values  for  each  key,  then  the  dictionaries  are  an exact match and 0 is returned.
到此为止，即，每个字典有相同的长度、相同的键、每个键也对应相同的值，则字典完全匹配，返回0值。
Figure 7–1 illustrates the dictionary compare algorithm we just outlined.
图 7-1 说明了上述字典比较的算法


START with both dictionaries

Comparing dictionaries


Lengths	No
differ?
Keys	No
differ?
Values	No
differ?


Yes	Yes	Yes

return(cmp(len(dict1),len(dict2))




return(cmp(dict1KeyN,dict2KeyN))




return(cmp(dict1ValN,dict2ValN))




return(0)

Figure 7–1   How dictionaries are compared
图 7-1 字典是如何进行比较的



7.3.2 Mapping Type Related Functions
映射类型相关的函数

dict()
The dict() factory function is used for creating dictionaries. If no argument is provided, then an empty dictionary is created. The fun happens when a container object is passed in as an argument to dict(). If the argument is an iterable, i.e., a sequence, an iterator, or an object that supports iteration, then each element of the iterable must come in pairs. For each pair, the first element will be a new key in the dictionary with the second item as its value. Taking a cue from the official Python documentation for dict():

dict() 
工厂函数被用来创建字典。如果不提供参数，会生成空字典。当容器类型对象做为一个参数传递给方法dict() 时很有意思。如果参数是可以迭代的，即，一个序列，或是一个迭代器，或是一个支持迭代的对象，那每个可迭代的元素必须成对出现。在每个值对中，第一个元素是字典的键、第二个元素是字典中的值。见Python文档里关于dict()的例子:




>>> dict(zip(('x', 'y'), (1, 2)))
{'y': 2, 'x': 1}
>>> dict([['x', 1], ['y', 2]])
{'y': 2, 'x': 1}
>>> dict([('xy'[i-1], i) for i in range(1,3)])
{'y': 2, 'x': 1}

　If  it  is  a(nother)  mapping  object,  i.e.,  a  dictionary,  then  dict() will just  create  a  new  dictionary  and  copy  the  contents  of  the  existing  one. The new dictionary is actually a shallow copy of the original one and the same results can be accomplished by using a dictionary’s copy() built-in method.  Because  creating  a  new  dictionary  from  an  existing  one  using dict() is  measurably  slower  than  using  copy(),  we  recommend  using the latter.
  如果输入参数是(另)一个映射对象，比如，一个字典对象，对其调用dict()会从存在的字典里复制内容来生成新的字典。新生成的字典是原来字典对象的浅复制版本， 它与用字典的内建方法 copy() 生成的字典对象是一样的。但是从已存在的字典生成新的字典速度比用copy()方法慢，我们推荐使用copy()。

　Starting in Python 2.3, it is possible to call dict() with an existing dictionary or keyword argument dictionary (function operator, covered in Chapter 11):
  从Python 2.3 开始，调用dict()方法可以接受字典或关键字参数字典(函数操作符，第11章)：

>>> dict(x=1, y=2)
{'y': 2, 'x': 1}
>>> dict8 = dict(x=1, y=2)
>>> dict8
{'y': 2, 'x': 1}
>>> dict9 = dict(**dict8)
>>> dict9
{'y': 2, 'x': 1}

　We remind viewers that the dict9 example is only an exercise in understanding the calling semantics of dict() and not a realistic example. It would be wiser (and better performance-wise) to execute something more along the lines of:
我们提醒读者dict9的例子只作为了解dict()方法的用途，它不是现实中的例子。使用下面这些行的方法更聪明(效率更好):

>>> dict9 = dict8.copy()
>>> dict9
{'y': 2, 'x': 1}

len()
The len() BIF is flexible. It works with sequences, mapping types, and sets
(as we will find out later on in this chapter). For a dictionary, it returns the
total number of items, that is, key-value pairs:
内建函数len()很灵活。它可用在序列、映射类型和集合上(在本章的后面我们会看到)。对字典调用len()，它会返回所有元素(键-值对)的数目：

>>> dict2 = {'name': 'earth', 'port': 80}
>>> dict2
{'port': 80, 'name': 'earth'}
>>> len(dict2)
2

　We  mentioned  earlier  that  dictionary  items  are  unordered.  We  can  see that  above,  when  referencing  dict2,  the  items  are  listed  in  reverse  order from which they were entered into the dictionary.
  我们前面提到字典中的元素是没有顺序的。从上面的例子中可以看到，dict2的元素显示的顺序和输入时的顺序正相反。

hash()
The hash() BIF is not really meant to be used for dictionaries per se, but it can be used to determine whether an object is fit to be a dictionary key (or not). Given an object as its argument, hash() returns the hash value of that object. The object can only be a dictionary key if it is hashable (meaning this function  returns  a[n  integer]  value  without  errors  or  raising  an  exception).

内建函数hash()本身并不是为字典设计的方法，但它可以判断某个对象是否可以做一个字典的键。将一个对象作为参数传递给 hash(), 会返回这个对象的哈希值。 只有这个对象是可哈希的，才可作为字典的键 (函数的返回值是整数，不产生错误或异常)。

  Numeric values that are equal (when pitted against each other using a comparison operator) hash to the same value (even if their types differ). 
  如果用比较操作符来比较两个数值，发现它们是相等的，那么即使二者的数据类型不同， 它们也会得到相同的哈希值。
  
 A TypeError will occur if an unhashable type is given as the argument to hash() (and consequently if an attempt is made to use such an object as the key when assigning a value to a dictionary):
如果非可哈希类型作为参数传递给hash()方法，会产生TypeError错误(因此，如果使用这样的对象作为键给字典赋值时会出错):


>>> hash([])
Traceback (innermost last): File "<stdin>", line 1, in ?
TypeError: list objects are unhashable
>>>
>>> dict2[{}] = 'foo'
Traceback (most recent call last): File "<stdin>", line 1, in ?
TypeError: dict objects are unhashable
In Table 7.1, we summarize these three mapping type related functions.
在表7.1中，我们列出以下三个映射类型的相关函数。

Table 7.1  Mapping Type Related Functions
表7.1	   映射类型的相关函数

Function	Operation
函数		操作

dict([container]) Factory function for creating a dictionary populated with items from container, if provided; if not, an empty dict is created
dict([container]) 创建字典的工厂函数。如果提供了容器类(container)，就用其中的条目填充字典，否则就创建一个空字典。

len(mapping)	Returns the length of mapping (number of key-value pairs)
len(mapping)	返回映射的长度(键-值对的个数)

hash(obj)	Returns hash value of obj
hash(obj)   返回obj的哈希值

7.4 Mapping Type Built-in Methods
映射类型内建方法

Dictionaries have an abundance of methods to help you get the job done, as indicated in Table 7.2.
字典提供了大量方法来帮你做事情，见表 7.2.

　Below, we showcase some of the more common dictionary methods. We have already seen has_key() and its replacements in and not in at work above.  Attempting  to  access  a  nonexistent  key  will  result  in  an  exception(KeyError) as we saw in Section 7.1.
  下面，我们说明字典的一些很常见的方法。在上面的例子里，我们已经看到 has_key() 和它的替代方法 in 和 not in。如我们在7.1小节看到，试图查找一个字典里没有的键值会产生KeyError异常。

Basic  dictionary  methods  focus  on  their  keys  and  values.  These  are keys(),  which  returns  a  list  of  the  dictionary’s  keys,  values(), which returns a list of the dictionary’s values, and items(), which returns a list of (key, value) tuple pairs. These are useful when you wish to iterate through a dictionary’s keys or values, albeit in no particular order.
基本的字典方法关注他们的键和值。它们有：keys()方法，返回一个列表，包含字典中所有的键，values()方法，返回一个列表，包含字典中所有的值，items(), 返回一个包含所有(键, 值)元组的列表。这些方法在不按任何顺序遍历字典的键或值时很有用。

>>> dict2.keys()
['port', 'name']
>>>
>>> dict2.values()
[80, 'earth']
>>>
>>> dict2.items()
[('port', 80), ('name', 'earth')]
>>>
>>> for eachKey in dict2.keys():
...	print 'dict2 key', eachKey, 'has value', dict2[eachKey]
...
dict2 key port has value 80
dict2 key name has value earth

The keys() method is fairly useful when used in conjunction with a for loop to retrieve a dictionary’s values as it returns a list of a dictionary’s keys.
keys()方法很有用，它返回一个包含字典中所有键的列表，此方法可以与for 循环一起使用来获取字典中的值。



Table 7.2  Dictionary Type Methods
表 7.2 字典类型方法

Method Name	    Operation
方法名字		操作

dict.clear() a	Removes all elements of dict 
dict.clear()    删除字典中所有元素

dict.copy() a	Returns a (shallow b) copy of dict
dict.copy()		返回字典(浅复制)的一个副本

dict.fromkeys(seq, val=None)  c
Creates and returns a new dictionary with the elements of seq as the keys and val as the initial value (defaults to None if not given) for all keys
创建并返回一个新字典，以seq中的元素做该字典的键，val做该字典中所有键对应的初始值(如果不提供此值，则默认为None)

dict.get(key, default=None)a
For key key, returns value or default if key not in dict (note that default’s default is None)
对字典dict中的键key,返回它对应的值value，如果字典中不存在此键，则返回default的值(注意，参数default的默认值为None)

dict.has_key(key)	
Returns True if key is in dict, False otherwise; partially deprecated by the in and not in operators in 2.2 but still provides a functional interface
dict.has_key(key)
如果键(key)在字典中存在，返回True，否则返回False. 在Python2.2版本引入in和not in 后，此方法几乎已废弃不用了，但仍提供一个可工作的接口。

dict.items()	Returns a list of the (key, value) tuple pairs of dict 
dict.items()	返回一个包含字典中(键, 值)对元组的列表

dict.keys()		Returns a list of the keys of dict
dict.keys()		返回一个包含字典中键的列表

dict.iter()	d   
iteritems(), iterkeys(),  itervalues() are all methods that behave the same as their non-iterator counterparts but return an iterator instead of a list
dict.iter() d
方法iteritems(), iterkeys(), itervalues()与它们对应的非迭代方法一样，不同的是它们返回一个迭代子，而不是一个列表。

dict.pop(key[, default])  c
Similar to get() but removes and returns dict[key] if key present and raises KeyError if key not in dict and default not given
和方法get()相似，如果字典中key键存在，删除并返回dict[key]，如果key键不存在，且没有给出default的值，引发KeyError异常。

dict.setdefault(key, default=None)
Similar to set(), but sets dict[key]=default if key is not already in dict
dict.setdefault(key, default=None)
和方法set()相似，如果字典中不存在key键，由dict[key]=default为它赋值。

dict.update(dict2)	Add the key-value pairs of dict2 to dict
dict.update(dict2)  将字典dict2的键-值对添加到字典dict 

dict.values()	Returns a list of the values of dict
dict.values()	返回一个包含字典中所有值的列表

a.	New in Python 1.5.
a.  Python 1.5新增

b.	More information regarding shallow and deep copies can be found in Section 6.19.
b.  关于深复制和浅复制的详细信息请参见6.19节.

c.	New in Python 2.3. 
c.  Python 2.3新增

d.	New in Python 2.2. 
d.  Python 2.2新增

e.	New in Python 2.0.
e.  Python 2.0新增


However, because its items (as with any keys of a hash table) are unordered, imposing some type of order is usually desired.
但是，它返回的元素是没有顺序的(和哈希表中的键(keys)一样)，我们通常希望它们能按某种方式排序。
　In  Python  versions  prior  to  2.4,  you  would  have  to  call  a  dictionary’s keys() method to get the list of its keys, then call that list’s sort() method to get  a  sorted  list  to  iterate  over.  Now  a  built-in  function  named  sorted(), made especially for iterators, exists, which returns a sorted iterator:
  在Python 2.4 版本以前，   你只能调用字典的keys()方法获得键的列表，然后调用列表的sort()方法得到一个有序可遍历的列表。现在特别为迭代子设计了一个名为 sorted()的内建函数，它返回一个有序的迭代子：
 
>>> for eachKey in sorted(dict2):
...	print 'dict2 key', eachKey, 'has value', dict2[eachKey]

The update() method can be used to add the contents of one directory{原文错误，应为dictionary} to another. Any existing entries with duplicate keys will be overridden by the new incoming entries. Nonexistent ones will be added. All entries in a dictionary can be removed with the clear() method.
update()方法可以用来将一个字典的内容添加到另外一个字典中。字典中原有的键如果与新添加的键重复，那么重复键所对应的原有条目的值将被新键所对应的值所覆盖。原来不存在的条目则被添加到字典中。clear()方法可以用来删除字典中的所有的条目。

>>> dict2= {'host':'earth', 'port':80}
>>> dict3= {'host':'venus', 'server':'http'}
>>> dict2.update(dict3)
>>> dict2
{'server': 'http', 'port': 80, 'host': 'venus'}
>>> dict3.clear()
>>> dict3
{}
　The copy() method simply returns a copy of a dictionary. Note that this is a shallow copy only. Again, see Section 6.19  regarding shallow and deep copies. Finally, the get() method is similar to using the key-lookup operator ( [ ] ), but allows you to provide a default value returned if a key does not exist. If a key does not exist and a default value is not given, then None is returned. This is a more flexible option than just using key-lookup because you do not have to worry about an exception being raised if a key does not exist.
  copy() 方法返回一个字典的副本。注意这只是浅复制。关于浅复制和深复制请阅读小节 6.19。最后要说明，get()方法和键查找(key-lookup)操作符( [ ] )相似，不同的是它允许你为不存在的键提供默认值。如果该键不存在，也未给出它的默认值，则返回None。此方法比采用键查找(key-lookup)更灵活，因为你不必担心因键不存在而引发异常。
  
>>> dict4 = dict2.copy()
>>> dict4
{'server': 'http', 'port': 80, 'host': 'venus'}
>>> dict4.get('host')
'venus'
>>> dict4.get('xxx')
>>> type(dict4.get('xxx'))
<type 'None'>
>>> dict4.get('xxx', 'no such key')
'no such key'

　The built-in method, setdefault(), added in version 2.0, has the sole purpose of making code shorter by collapsing a common idiom: you want to check if a dictionary has a key. If it does, you want its value. If the dictionary does not have the key you are seeking, you want to set a default value and then return it. That is precisely what setdefault() does:
  setdefault()是自 2.0 才有的内建方法, 使得代码更加简洁，它实现了常用的语法: 检查字典中是否含有某键。 如果字典中这个键存在，你可以取到它的值。 如果所找的键在字典中不存在，你可以给这个键赋默认值并返回此值。这正是执行setdefault()方法的目的：
  
>>> myDict = {'host': 'earth', 'port': 80}
>>> myDict.keys()
['host', 'port']
>>> myDict.items()
[('host', 'earth'), ('port', 80)]
>>> myDict.setdefault('port', 8080)
80
>>> myDict.setdefault('prot', 'tcp')
'tcp'
>>> myDict.items()
[('prot', 'tcp'), ('host', 'earth'), ('port', 80)]
　Earlier, we took a brief look at the fromkeys() method, but here are a few more examples:
  前面，我们曾简要介绍过fromkeys()方法，下面是更多的示例：

>>> {}.fromkeys('xyz')
{'y': None, 'x': None, 'z': None}
>>>
>>> {}.fromkeys(('love', 'honor'), True)
{'love': True, 'honor': True}
　Currently,  the  keys(),  items(),  and  values() methods  return  lists. This can be unwieldy if such data collections are large, and the main reason why iteritems(), iterkeys(), and itervalues() were added to Python in 2.2. They function just like their list counterparts only they return iterators, which by lazier evaluation, are more memory-friendly. In future versions of Python, even more flexible and powerful objects will be returned, tentatively called  views.  Views  are  collection  interfaces  which  give  you  access  to  container  objects.  For  example,  you  may  be  able  to  delete  a  key  from  a  view, which would then alter the corresponding dictionary accordingly.
  目前，keys(),  items(),  和 values()方法的返回值都是列表。数据集如果很大会导致很难处理，这也正是iteritems(), iterkeys(), 和itervalues() 方法被添加到 Python 2.2 的主要原因。这些函数与返回列表的对应方法相似，只是它们返回惰性赋值的迭代器，所以节省内存。未来的Python版本中，甚至会更灵活，那时这些方法将会返回强大的对象，暂叫做视图(views)。视图(views)是访问容器对象的接口集。举例来说，你可以从一个视图(views)中删除某个字典的键，从而改变某个字典。


7.5 Dictionary Keys
字典的键

Dictionary  values  have  no  restrictions.  They  can  be  any  arbitrary  Python object, i.e., from standard objects to user-defined objects. However, the same cannot be said of keys.
字典中的值没有任何限制。 他们可以是任意Python对象，即，从标准对象到用户自定义对象皆可。但是字典中的键是有类型限制的。


7.5.1  More Than One Entry per Key Not Allowed
7.5.1  不允许一个键对应多个值 

One rule is that you are constrained to having only one entry per key. In other words, multiple values per the same key are not allowed. (Container objects such as lists, tuples, and other dictionaries are fine.) When key collisions are detected (meaning duplicate keys encountered during assignment), the last (most recent) assignment wins.
你必须明确一条原则：每个键只能对应一个项。也就是说，一键对应多个值是不允许的。(像列表、元组和其他字典这样的容器对象是可以的。) 当有键发生冲突(即，字典键重复赋值)，取最后(最近)的赋值。

>>> dict1 = {' foo':789, 'foo': 'xyz'}
>>> dict1
{'foo': 'xyz'}
>>>
>>> dict1['foo'] = 123
>>> dict1
{'foo': 123}

　Rather than producing an error, Python does not check for key collisions because  that  would  involve  taking  up  memory  for  each  key-value  pair assigned. In the above example where the key 'foo' is given twice on the same line, Python applies the key-value pairs from left to right. The value 789 may have been set at first, but is quickly replaced by the string 'xyz'. When assigning a value to a nonexistent key, the key is created for the dictionary and value added, but if the key does exist (a collision), then its current value  is  replaced.  In  the  above  example,  the  value  for  the  key  'foo' is replaced twice; in the final assignment, 'xyz' is replaced by 123.
 Python并不会因字典中的键存在冲突而产生一个错误，它不会检查键的冲突是因为，如果真这样做的话，在每个键-值对赋值的时候都会做检查，这将会占用一定量的内存。在上面的例子里，键'foo'被列出两次，Python从左到右检查键-值对。首先值789被赋值(给键'foo'所对应的值)，然后又很快被字符串'xyz'替代。当给字典中一个不存在的键赋值时，键和值会被创建和添加，但如果该键已经存在(键冲突)，那此键所对应的值将被替换。上面例子中，键 'foo' 所对应的值被替换了两次；最后的赋值语句，值123代替了值'xyz'。

7.5.2 Keys Must Be Hashable
键必须是可哈希的

As  we  mentioned  earlier  in  Section  7.1,  most  Python  objects  can  serve  as keys; however they have to be hashable objects—mutable types such as lists and dictionaries are disallowed because they cannot be hashed.
我们在小节7.1说过，大多数Python对象可以作为键；但它们必须是可哈希的对象。像列表和字典这样的可变类型，由于它们不是可哈希的，所以不能作为键。

  All immutable types are hashable, so they can definitely be used as keys. One caveat is numbers: Numbers of the same value represent the same key. In other words, the integer 1 and the float 1.0 hash to the same value, mean- ing that they are identical as keys.  所有不可变的类型都是可哈希的，因此它们都可以做为字典的键。一个要说明的是问题是数字：值相等的数字表示相同的键。换句话来说，整型数字 1 和 浮点数 1.0 的哈希值是相同的，即它们是相同的键。
  
　Also, there are some mutable objects that are (barely) hashable, so they are eligible as keys, but there are very few of them. One example would be a class that has implemented the __hash__() special method. In the end, an immutable value is used anyway as __hash__() must return an integer.
  同时，也有一些可变对象(很少)是可哈希的，它们可以做字典的键，但很少见。举一个例子，一个实现了__hash__() 特殊方法的类。因为__hash__()方法返回一个整数，所以仍然是用不可变的值(做字典的键)。
  
Why must keys be hashable? The hash function used by the interpreter to calculate where to store your data is based on the value of your key. If the key was a mutable object, its value could be changed. If a key changes, the hash function will map to a different place to store the data. If that was the case, then the hash function could never reliably store or retrieve the associated value. Hashable keys were chosen for the very fact that their values cannot change. (This question can also be found in the Python FAQ.)
为什么键必须是可哈希的？解释器调用哈希函数，根据字典中键的值来计算存储你的数据的位置。如果键是可变对象，它的值可改变。如果键发生变化，哈希函数会映射到不同的地址来存储数据。如果这样的情况发生，哈希函数就不可能可靠地存储或获取相关的数据。选择可哈希的键的原因就是因为它们的值不能改变。(此问题在Python FAQ中也能找到答案)

　We  know  that  numbers  and  strings  are  allowed  as  keys,  but  what  about tuples? We know they are immutable, but in Section 6.17.2, we hinted that they might not be as immutable as they could be. The clearest example of that was when we modified a list object that was one of our tuple elements. To allow tuples as valid keys, one more restriction must be enacted: Tuples are valid keys only if they only contain immutable arguments like numbers and strings.
  我们知道数字和字符串可以被用做字典的键，但元组又怎么样呢？我们知道元组是不可变的，但在小节6.17.2, 我们提示过它们也可能不是一成不变的。用元组做有效的键，必须要加限制：元组中只包括像数字和字符串这样的不可变参数，才可以作为字典中有效的键。
  
We conclude this chapter on dictionaries by presenting a program(userpw.py as in Example 7.1) that manages usernames and passwords in a mock login entry database system. This script accepts new users given that
我们用一个程序(userpw.py 例 7.1)， 来为本章关于字典的讲述做个小结。这个程序是用于管理用户名和密码的模拟登录数据系统。脚本接受新用户的信息：


Example 7.1  Dictionary Example (userpw.py)
示例 7.1 字典示例(userpw.py)

This application manages a set of users who join the system with a login name and a password. Once established, existing users can return as long as they remember their login and password. New users cannot create an entry with someone else’s login name.
这个程序管理用于登录系统的用户信息：登录名字和密码。登录用户帐号建立后，已存在用户可以用登录名字和密码重返系统。新用户不能用别人的登录名建立用户帐号。

1	#!/usr/bin/env python
2
3	db = {}
4
5	def newuser():
6	    prompt = 'login desired: '
7	    while True:
8	        name = raw_input(prompt)
9	        if db.has_key(name):
10      	    prompt = 'name taken, try another: '
11	            continue
12	        else:
13	            break
14	    pwd = raw_input('passwd: ')
15	    db[name] = pwd
16  
17  def olduser():     
18      name = raw_input('login: ')
19	    pwd = raw_input('passwd: ')
20      passwd = db.get(name)
21      if passwd == pwd:
22	        print 'welcome back', name
23	    else:
24	        print 'login incorrect'
25
26  def showmenu():
27      prompt = """
28  (N)ew User Login
29  (E)xisting User Login
30  (Q)uit
Example 7.1 Dictionary Example (userpw.py) (continued)

31
32	Enter choice: """
33
34	done = False
35	    while not done:
36
37	        chosen = False
38	        while not chosen:
39	            try:
40	                choice = raw_input(prompt).strip()[0].lower()
41	            except (EOFError, KeyboardInterrupt):
42	                choice = 'q'
43	            print '\nYou picked: [%s]' % choice 
44              if choice not in 'neq':
45                  print 'invalid option, try again'
46              else:
47	                chosen = True
49　                done = True
50  newuser()
51  olduser()
52
53  if __name__ == '__main__':
54	showmenu()

they provide a login name and a password. Once an “account” has been set up, an existing user can return as long as the user gives the login and correct password. New users cannot create an entry with an existing login name.
他们提供登录名和密码。帐号建立后，已存在用户可用登录名和正确的密码重返系统。新用户不能用别人的登录名建立帐号。

Line-by-Line Explanation
逐行解释

Lines 1–3
After  the  Unix-startup  line,  we  initialize  the  program  with  an  empty  user database. Because we are not storing the data anywhere, a new user database is created every time this program is executed.
在Unix初始行后,我们用一个空用户数据库初始化程序。 因为我们没有把数据存储在任何地方，每次程序执行时都会新建一个用户数据库。

Lines 5–15
The newuser() function is the code that serves new users. It checks to see if a name  has  already  been  taken,  and  once  a  new  name  is  verified,  the  user  is prompted for his or her password (no encryption exists in our simple program), and his or her password is stored in the dictionary with his or her user name as the key.
newuser() 函数用来建立新用户。它检查名字是否已经存在，如果证实是一个新名字，将要求用户输入他或她的密码 (我们这个简单的程序没有加密)，用户的密码被存储在字典里，以他们的名字做字典中的键。

Lines 17–24
The olduser() function handles returning users. If a user returns with the correct login and password, a welcome message is issued. Otherwise, the user is notified of an invalid login and returned to the menu. We do not want an infinite loop here to prompt for the correct password because the user may have inadvertently entered the incorrect menu option.
olduser()函数处理返回的用户。如果用户用正确的用户名和密码登录，打出欢迎信息。否则通知用户是无效登录并返回菜单。我们不会采用一个无限循环来提示用户输入正确的密码，因为用户可能会无意进入错误的菜单选项。

Lines 26–51
The  real  controller  of  this  script  is  the  showmenu() function.  The  user  is presented  with  a  friendly  menu.  The  prompt  string  is  given  using  triple quotes because it takes place over multiple lines and is easier to manage on multiple lines than on a single line with embedded '\n' symbols. Once the menu is displayed, it waits for valid input from the user and chooses which mode of operation to follow based on the menu choice. The  try-except statements  we  describe  here  are  the  same  as  for  the   stack.py and queue.py examples from the last chapter (see Section 6.14.1).
真正控制这个脚本的是showmenu()函数，它显示给用户一个友好界面。提示信息被包括在三引号里("""), 这样做是因为提示信息跨多行，而且比单行包含'\n'符号的字符串更容易处理。菜单显示后，它等待用户的有效输入，然后根据菜单选项选择操作方式。try-expect 语句和上章 stack.py queue.py例子里的一样(见 小节 6.14.1).

Lines 53–54
This is the familiar code that will only call showmenu() to start the application if the script was involved directly (not imported). Here is a sample execution of our script:
如果这个脚本被直接执行(不是通过import方式)，这行代码会调用showmenu()函数运行程序。这是我们的脚本运行结果：

$ userpw.py

(N)ew User Login
(E)xisting User Login
(Q)uit

Enter choice: n

You picked: [n]
login desired: king arthur passwd: grail

(N)ew User Login
(E)xisting User Login
(Q)uit

Enter choice: e

You picked: [e]
login: sir knight


passwd: flesh wound login incorrect

(N)ew User Login
(E)xisting User Login
(Q)uit

Enter choice: e

You picked: [e] login: king arthur passwd: grail
welcome back king arthur

(N)ew User Login
(E)xisting User Login
(Q)uit

Enter choice: ^D You picked: [q]




7.6 Set Types
集合类型

In mathematics, a set is any collection of distinct items, and its members are often referred to as set elements. Python captures this essence in its set type objects. A set object is an unordered collection of hashable values. Yes,  set  members  would  make  great  dictionary  keys.  Mathematical  sets translate to Python set objects quite effectively and testing for set membership and operations such as union and intersection work in Python as expected.
数学上， 把set称做由不同的元素组成的集合，集合(set)的成员通常被称做集合元素(set elements)。Python把这个概念引入到它的集合类型对象里。集合对象是一组无序排列的可哈希的值。是的，集合成员可以做字典中的键。数学集合转为Python的集合对象很有效，集合关系测试和union、intersection等操作符在Python 里也同样如我们所预想地那样工作。

　Like other container types, sets support membership testing via in and not in operators, cardinality using the len()BIF, and iteration over the set membership using for loops. However, since sets are unordered, you do not index into or slice them,  and there are no keys used to access a value.
  和其他容器类型一样，集合支持用 in 和 not in 操作符检查成员, 由 len() 内建函数得到集合的基数(大小),  用for 循环迭代集合的成员。但是因为集合本身是无序的，你不可以为集合创建索引或执行切片(slice)操作，也没有键(keys)可用来获取集合中元素的值。
  
　There are two different types of sets available, mutable (set) and immutable (frozenset). As you can imagine, you are allowed to add and remove elements from the mutable form but not the immutable. Note that mutable sets are not hashable and thus cannot be used as either a dictionary key or as an element of another set. The reverse is true for frozen sets, i.e., they have a hash value and can be used as a dictionary key or a member of a set.
  集合(sets)有两种不同的类型，可变集合(set) 和 不可变集合(frozenset)。如你所想，对可变集合(set)，你可以添加和删除元素，对 不可变集合(frozenset)则不允许这样做。请注意，可变集合(set)不是可哈希的，因此既不能用做字典的键也不能做其他集合中的元素。不可变集合(frozenset)则正好相反，即，他们有哈希值，能被用做字典的键或是作为集合中的一个成员。

  
　Sets became available in Python 2.3 via the sets module and accessed via the ImmutableSet and Set classes.  However, it was decided that having them as built-in types was a better idea, so these classes were then ported to C along with some improvements and integrated into Python 2.4. You can read more about those improvements as well as set types in general in PEP 218 at http://python.org/peps/pep-0218.html.
集合(Sets)最早出现在Python2.3版本中，通过集合(sets)模块来创建，并通过ImmutableSet类和Set类进行访问。而后来，大家都认为把它们作为内建的数据类型是个更好的主意，因此这些类被用C重写改进后包含进Python2.4。关于集合类型和这些类改进的更多内容，可阅读此文获得详情：PEP 218，链接地址： http://python.org/peps/pep-0218.html.

  Although sets are now an official Python type, they have often been seen in many Python applications (as user-defined classes), a wheel that has been reinvented many times over, similar to complex numbers (which eventually became  a  Python  type  way  back  in  1.4).  Until  current  versions  of  Python, most  users  have  tried  to  shoehorn  set  functionality  into  standard  Python types like lists and dictionaries as proxies to a real set type (even if they were not the perfect data structure for their applications). Now users have more options, including a “real” set type.
虽然现在集合类型已经是Python的基本数据类型了，但它经常会以用户自定义类的形式出现在各种Python程序中，就像复数一样(复数从Python1.4版本起成为python的一个数据类型)，这样重复的劳动已数不胜数了。在现在的Python版本之前，(即使集合类型对许多人的程序来说并不是最理想的数据结构，)许多人仍然试图给列表和字典这样的Python标准类型添加集合功能，这样可以把它们作为真正集合类型的代理来使用。因此现在的使用者有包括“真正”集合类型在内的多种选择。

　Before we go into detail regarding Python set objects, we have to mentally translate the mathematical symbols to Python (see Table 7.3) so that we are clear on terminology and functionality.
在我们详细讲述Python的集合对象之前，我们必须理解Python中的一些数学符号 (见表7.3)， 这样对术语和功能有一个清晰的了解。


Table 7.3  Set Operation and Relation Symbols
表 7.3 集合操作符和关系符号


Mathematical Symbol
数学符号

Python Symbol	
Python符号

Description
说明

?	in	Is a member of
	in  是...的成员

?	not in	Is not a member of
	not in  不是...的成员

?	==	Is equal to
	==  等于

?	!=	Is not equal to
	!= 	不等于

?	<	Is a (strict) subset of
	<	是...的(严格)子集

?	<=	Is a subset of (includes improper subsets)
	<=	是...的子集(包括非严格子集)
	
?	>	Is a (strict) superset of
	>	是...的(严格)超集

?	>=	Is a superset of (includes improper supersets)
	>=	是...的超集(包括非严格超集)
	
?	&	Intersection
	&	交集

?	|	Union
    |	合集

– or \	-	Difference or relative complement
– 或 \	-	差补或相对补集

?	^	Symmetric difference
	^	对称差分

Chun_ch07.fm  Page 275  Wednesday, August 23, 2006  4:52 PM


7.6	Set Types	275
7.6 集合类型

How to Create and Assign Set Types
如何创建集合类型和给集合赋值

There is no special syntax for sets like there is for lists ( [ ] ) and dictionaries ( { } ) for example. Lists and dictionaries can also be created with their corresponding factory functions list() and dict(), and that is also the only way sets can be created, using their factory functions set() and frozenset():
集合与列表( [ ] )和字典( { } ) 不同，没有特别的语法格式。列表和字典可以分别用他们自己的工厂方法 list() 和 dict() 创建，这也是集合被创建的唯一方法 - 用集合的工厂方法 set() 和 frozenset():

>>> s = set('cheeseshop')
>>> s
set(['c', 'e', 'h', 'o', 'p', 's'])
>>> t = frozenset('bookshop')
>>> t
frozenset(['b', 'h', 'k', 'o', 'p', 's'])
>>> type(s)
<type 'set'>
>>> type(t)
<type 'frozenset'>
>>> len(s)
6
>>> len(s) == len(t) 
True
>>> s == t
False

How to Access Values in Sets
如何访问集合中的值

You are either going to iterate through set members or check if an item is a member (or not) of a set:
你可以遍历查看集合成员或检查某项元素是否是一个集合中的成员:

>>> 'k' in s
False
>>> 'k' in t
True
>>> 'c' not in t
True

>>> for i in s:
...	  print i
... 
c
e 
h 
o 
p 
s

How to Update Sets
如何更新集合

You can add and remove members to and from a set using various built-in methods and operators:
用各种集合内建的方法和操作符添加和删除集合的成员:

>>> s.add('z')
>>> s
set(['c', 'e', 'h', 'o', 'p', 's', 'z'])
>>> s.update('pypi')
>>> s
set(['c', 'e', 'i', 'h', 'o', 'p', 's', 'y', 'z'])
>>> s.remove('z')
>>> s
set(['c', 'e', 'i', 'h', 'o', 'p', 's', 'y'])
>>> s -= set('pypi')
>>> s
set(['c', 'e', 'h', 'o', 's'])

As mentioned before, only mutable sets can be updated. Any attempt at such operations on immutable sets is met with an exception:
我们之前提到过，只有可变集合能被修改。试图修改不可变集合会引发异常。

>>> t.add('z')
Traceback (most recent call last): 
  File "<stdin>", line 1, in ?
AttributeError: 'frozenset' object has no attribute 'add'

How to Remove Set Members and Sets
如何删除集合中的成员和集合

We saw how to remove set members above. As far as removing sets themselves, like any Python object, you can let them go out of scope or explicitly remove them from the current namespace with del. If the reference count goes to zero, then it is tagged for garbage collection.
前面我们看到如何删除集合成员。如果如何删除集合本身，可以像删除任何Python对象一样，令集合超出它的作用范围，或调用del将他们直接清除出当前的名字空间。如果它的引用计数为零，也会被标记以便被垃圾回收。

>>> del s
>>>


7.7  Set Type Operators
集合类型操作符

7.7.1 Standard Type Operators (all set types)
标准类型操作符（所有的集合类型）

Membership (in, not in)
成员关系   (in, not in)
As  for  sequences,  Python’s  in  and  not  in  operators  are  used  to  determine whether an element is (or is not) a member of a set.
就序列而言，Python中的in和not in操作符决定某个元素是否是一个集合中的成员。
>>> s = set('cheeseshop')
>>> t = frozenset('bookshop')

>>> 'k' in s
False
>>> 'k' in t
True
>>> 'c' not in t
True

Set Equality/Inequality
集合等价/不等价

Equality  (or  inequality)  may  be  checked  between  the  same  or  different  set types. Two sets are equal if and only if every member of each set is a member of the other. 
等价/不等价被用于在相同或不同的集合之间做比较。两个集合相等是指，对每个集合而言，当且仅当其中一个集合中的每个成员同时也是另一个集合中的成员。
You can also say that each set must be a(n improper) subset of the other, e.g., both expressions s <= t and s >= t are true, or (s <= t and s>= t) is True. Equality (or inequality) is independent of set type or ordering of members when the sets were created—it is all based on the set membership.
你也可以说每个集合必须是另一个集合的一个子集， 即，s <= t 和 s >= t 的值均为真(True), 或(s <= t and s>= t) 的值为真(True)。集合等价/不等价与集合的类型或集合成员的顺序无关，只与集合的元素有关。

>>> s == t
False
>>> s != t
True
>>> u = frozenset(s)
>>> s == u
True
>>> set('posh') == set('shop') 
True

Subset Of/Superset Of
子集/超集

Sets  use  the  Python  comparison  operators  to  check  whether  sets  are subsets or supersets of other sets. The “less than” symbols (  <, <= ) are used  for  subsets  while  the  “greater  than”  symbols  (>,  >= )  are  used  for supersets.
Sets用Python的比较操作符检查某集合是否是其他集合的超集或子集。“小于”符号(  <, <= )用来判断子集，“大于”符号(  >, >= )用来判断超集。

　Less-than  and  greater-than  imply  strictness,  meaning  that  the  two  sets being compared cannot be equal to each other. The equal sign allows for less strict improper subsets and supersets.
  “小于” 和 “大于”意味着两个集合在比较时不能相等。等于号允许非严格定义的子集和超集。
  
　Sets  support  both  proper  (  < )  and  improper  (  <= )  subsets  as  well  as proper ( > ) and improper ( >= ) supersets. A set is “less than” another set if and only if the first set is a proper subset of the second set (is a subset but not equal), and a set is “greater than” another set if and only if the first set is a proper superset of the second set (is a superset but not equal).
  Sets 支持严格(  < )子集和非严格  (  <= ) 子集, 也支持严格(  > )超集和非严格  (  >= ) 超集。只有当第一个集合是第二个集合的严格子集时，我们才称第一个集合“小于”第二个集合，同理，只有当第一个集合是第二个集合的严格超集时，我们才称第一个集合“大于”第二个集合。

>>> set('shop') < set('cheeseshop') True
>>> set('bookshop') >= set('shop') True

7.7.2 Set Type Operators (All Set Types)
集合类型操作符（所有的集合类型）

Union ( | )
The union operation is practically equivalent to the OR (or inclusive disjunction) of sets. The union of two sets is another set where each element is a member of at least one of the sets, i.e., a member of one set or the other. The union symbol has a method equivalent, union().
联合( | )
联合(union)操作和集合的OR(又称可兼析取(inclusive disjunction))其实是等价的，两个集合的联合是一个新集合，该集合中的每个元素都至少是其中一个集合的成员，即，属于两个集合其中之一的成员。联合符号有一个等价的方法，union().

>>> s | t
set(['c', 'b', 'e', 'h', 'k', 'o', 'p', 's'])

Intersection ( & )
You can think of the intersection operation as the AND (or conjunction) of sets. The intersection of two sets is another set where each element must be a member of at both sets, i.e., a member of one set and the other. The intersection symbol has a method equivalent, intersection().
交集( & )
你可以把交集操作比做集合的AND(或合取)操作。两个集合的交集是一个新集合，该集合中的每个元素同时是两个集合中的成员，即，属于两个集合的成员。交集符号有一个等价的方法，intersection().

>>> s & t
set(['h', 's', 'o', 'p']

Difference/Relative Complement ( – )
差补/相对补集( – )
The  difference,  or  relative  complement,  between  two  sets  is  another  set where each element is in one set but not the other. The difference symbol has a method equivalent, difference().
两个集合(s和t)的差补或相对补集是指一个集合C，该集合中的元素，只属于集合s，而不属于集合t。差符号有一个等价的方法，difference().
>>> s - t 
set(['c', 'e'])

Symmetric Difference ( ^ )
对称差分( ^ )
Similar  to  the  other  Boolean  set  operations,  symmetric  difference  is  the XOR (or exclusive disjunction) of sets. The symmetric difference between two sets is another set where each element is a member of one set but not the  other.  The  symmetric  difference  symbol  has  a  method  equivalent, symmetric_difference().
和其他的布尔集合操作相似，对称差分是集合的XOR(又称”异或“ (exclusive disjunction)). 两个集合(s和t)的对称差分是指另外一个集合C,该集合中的元素，只能是属于集合s或者集合t的成员，不能同时属于两个集合。对称差分有一个等价的方法，symmetric_difference().

>>> s ^ t
set(['k', 'b', 'e', 'c'])

Mixed Set Type Operations
混合集合类型操作

In the above examples, s is a set while t is a frozenset. Note that each of the resulting sets from using the set operators above result in sets. However note that the resulting type is different when the operands are reversed:
上面的示例中，左边的s是可变集合，而右边的t是一个不可变集合. 注意上面使用集合操作运算符所产生的仍然是可变集合,但是如果左右操作数的顺序反过来，结果就不一样了:

>>> t | s
frozenset(['c', 'b', 'e', 'h', 'k', 'o', 'p', 's'])
>>> t ^ s
frozenset(['c', 'b', 'e', 'k'])
>>> t - s frozenset(['k', 'b'])
　If both types are sets or frozensets, then the type of the result is the same type as each of the operands, but if operations are performed on mixed types(set and frozenset, and vice versa), the type of the resulting set is the same type as the left operand, which we can verify in the above. And no, the plus sign is not an operator for the set types:
如果左右两个操作数的类型相同，既都是可变集合或不可变集合, 则所产生的结果类型是相同的，但如果左右两个操作数的类型不相同(左操作数是set，右操作数是frozenset，或相反情况)，则所产生的结果类型与左操作数的类型相同，上例中可以证明这一点。还要注意，加号不是集合类型的运算符:

>>> v = s + t
Traceback (most recent call last): File "<stdin>", line 1, in ?
TypeError: unsupported operand type(s) for +: 'set' and
'set'
>>> v = s | t
>>> v
set(['c', 'b', 'e', 'h', 'k', 'o', 'p', 's'])
>>> len(v)
8
>>> s < v
True

7.7.3 Set Type Operators (Mutable Sets Only)
集合类型操作符（仅适用于可变集合）

(Union) Update ( |= )
The update operation adds (possibly multiple) members from another set to the existing set. The method equivalent is update().
这个更新方法从已存在的集合中添加(可能多个)成员，此方法和update()等价.

>>> s = set('cheeseshop')
>>> u = frozenset(s)
>>> s |= set('pypi')
>>> s
set(['c', 'e', 'i', 'h', 'o', 'p', 's', 'y'])


Retention/Intersection Update ( &= )
The retention (or intersection update) operation keeps only the existing set members that are also elements of the other set. The method equivalent is intersection_update().
保留(或交集更新)操作保留与其他集合的共有成员。此方法和intersection_update()等价.

>>> s = set(u)
>>> s &= set('shop')
>>> s
set(['h', 's', 'o', 'p'])


Difference Update ( –= )
The difference update operation returns a set whose elements are members of the original set after removing elements that are (also) members of the other set. The method equivalent is difference_update().
对集合s和t进行差更新操作s-=t，差更新操作会返回一个集合，该集合中的成员是集合s去除掉集合t中元素后剩余的元素。此方法和difference_update()等价.

>>> s = set(u)
>>> s -= set('shop')
>>> s
set(['c', 'e'])


Symmetric Difference Update ( ^= )
The symmetric difference update operation returns a set whose members are either elements of the original or other set but not both. The method equivalent is symmetric_difference_update().
对集合s和t进行对称差分更新操作(s^=t),对称差分更新操作会返回一个集合，该集合中的成员仅是原集合s或仅是另一集合t中的成员。此方法和symmetric_difference_update()等价.

>>> s = set(u)
>>> t = frozenset('bookshop')
>>> s ^= t
>>> s
set(['c', 'b', 'e', 'k'])


7.8  Built-in Functions
内建函数

7.8.1 Standard Type Functions
标准类型函数

len()
The len() BIF for sets returns cardinality (or the number of elements) of the set passed in as the argument.
把集合作为参数传递给内建函数len()，返回集合的基数(或元素的个数)。

>>> s = set(u)
>>> s
set(['p', 'c', 'e', 'h', 's', 'o'])
>>> len(s)
6


7.8.2 Set Type Factory Functions
集合类型工厂函数

set() and frozenset()

The  set() and  frozenset() factory  functions  generate  mutable  and immutable sets, respectively. If no argument is provided, then an empty set is created. If one is provided, it must be an iterable, i.e., a sequence, an iterator, or an object that supports iteration such as a file or a dictionary.
set()和frozenset()工厂函数分别用来生成可变和不可变的集合。如果不提供任何参数，默认会生成空集合。如果提供一个参数，则该参数必须是可迭代的，即，一个序列，或迭代器，或支持迭代的一个对象，例如：一个文件或一个字典。

>>> set()
set([])
>>> set([])
set([])
>>> set(())
set([])
>>> set('shop')
set(['h', 's', 'o', 'p'])
>>>
>>> frozenset(['foo', 'bar'])
frozenset(['foo', 'bar'])
>>>
>>> f = open('numbers', 'w')
>>> for i in range(5):
...	f.write('%d\n' % i)
...
>>> f.close()
>>> f = open('numbers', 'r')
>>> set(f)
set(['0\n', '3\n', '1\n', '4\n', '2\n'])
>>> f.close()



7.9  Set Type Built-in Methods
集合类型内建方法

7.9.1 Methods (All Set Types)
方法（所有的集合方法）

We have seen the operator equivalents to most of the built-in methods, summarized in Table 7.4.
我们已看到很多和内建方法等价的操作符，表 7.4 做了小结：
　The one method without an operator equivalent is copy(). Like the dictionary method of the same name, it is faster to create a copy of the object using copy() than  it  is  using  a  factory  function  like  set(),  frozenset(),  or dict().
内建方法copy() 没有等价的操作符。和同名的字典方法一样，copy()方法比用像 set(),  frozenset(), 或dict()这样的工厂方法复制对象的副本要快。



Table 7.4  	Set Type Methods
表7.4	 	集合类型方法

Method Name	Operation
方法名称	操作

s.issubset(t)	Returns True if every member of s is in t, False otherwise
s.issubset(t)	如果s是t的子集，则返回True,否则返回False

s.issuperset(t)	Returns True if every member of t is in s, False otherwise
s.issuperset(t) 如果t是s的超集，则返回True,否则返回False

s.union(t)	Returns a new set with the members of s or t 
s.union(t)	返回一个新集合，该集合是s和t的并集

s.intersection(t)	Returns a new set with members of s and t 
s.intersection(t)	返回一个新集合，该集合是s和t的交集

s.difference(t)	Returns a new set with members of s but not t 
s.difference(t)	返回一个新集合，该集合是s的成员，但不是t的成员

s.symmetric_difference(t)  	Returns a new set with members of s or t but not both
s.symmetric_difference(t)	返回一个新集合，该集合是s或t的成员，但不是s和t共有的成员

s.copy()	Returns a new set that is a (shallow) copy of s
s.copy()	返回一个新集合，它是集合s的浅复制

7.9.2 Methods (Mutable Sets Only)
方法（仅适用于可变集合）

Table 7.5 summarizes all of the built-in methods that only apply to mutable sets, and similar to the methods above, we have already seen most of their operator equivalents.
表 7.5 总结了所有可变集合的内建方法，和上面的方法相似，我们已经看过许多和它们等价的操作符。
 
　The new methods here are add(), remove(), discard(), pop(), and clear().  For  the  methods  that  take  an  object,  the  argument  must  be hashable.
  新的方法有 add(), remove(), discard(), pop(), clear().  这些接受对象的方法，参数必须是可哈希的。


7.9.3 Using Operators versus Built-in Methods
操作符和内建方法比较

As you can see, there are many built-in methods that have near-equivalents when using operators. By “near-equivalent,” we mean that there is one major difference: when using the operators, both operands must be sets while for the methods, objects can be iterables too. Why was it implemented this way? The official Python documentation states that “[this] precludes error-prone constructions like set('abc') [and] 'cbs' in favor of the more readable set('abc').intersection('cbs').”
像你看到的， 很多内建的方法几乎和操作符等价。我们说"几乎等价"，意思是它们间是有一个重要区别： 当用操作符时，操作符两边的操作数必须是集合。 在使用内建方法时，对象也可以是迭代类型的。为什么要用这种方式来实现呢？ Python的文档里写明： 采用易懂的 set('abc').intersection('cbs') 可以避免用  set('abc') [and] 'cbs' 这样容易出错的构建方法。




Table 7.5  Mutable Set Type Methods
表 7.5 可变集合类型的方法

Method Name		Operation
方法名			操作

s.update(t)		Updates s with elements added from t; in other words, s now has members of either s or t
s.update(t)		用t中的元素修改s, 即，s现在包含s或t的成员

s.intersection_update(t)	Updates s with members of both s and t
s.intersection_update(t)	s中的成员是共同属于s和t的元素。

s.difference_update(t)		Updates s with members of s without elements of t
s.difference_update(t)		s中的成员是属于s但不包含在t中的元素

s.symmetric_difference_update(t)    Updates s with members of s or t but not both
s.symmetric_difference_update(t) s中的成员更新为那些包含在s或t中，但不是s和t共有的元素 

s.add(obj)	Adds object obj to set s
s.add(obj)	在集合s中添加对象obj

s.remove(obj)	Removes object obj from set s; KeyError raised if obj is not an element of s (obj not in s)
s.remove(obj)	从集合s中删除对象obj；如果obj不是集合s中的元素(obj not in s)，将引发KeyError错误

s.discard(obj)	Removes object obj if obj is an element of s (obj in s)
s.discard(obj)	如果obj是集合s中的元素，从集合s中删除对象obj；

s.pop()		Removes and returns an arbitrary object of s
s.pop()		删除集合s中的任意一个对象，并返回它

s.clear()	Removes all elements from s
s.clear()	删除集合s中的所有元素

7.10  	Operator, Function/Method
7.10 	操作符、函数/方法

Summary Table for Set Types
集合类型总结表

In  Table  7.6,  we  summarize  all  of  the  set  type  operators,  functions,  and methods.
表 7.6 中，我们总结了所有的集合类型的操作符、函数和方法

7.11  Related Modules
相关模块

The sets module became available in 2.3 and may be useful if you wish to  subclass  the  Set or  ImmutableSet classes.  Although  set  types  were integrated into Python 2.4, there are currently no plans to deprecate the module.
集合(set)模块从 2.3 版本引进，可继承Set 或 ImmuteablSet来生成子类。虽然从Python2.4起使用集合类型，但是集合模块不会弃用。 

Table 7.6  Set Type Operators, Functions, and Methods
表7.6 集合类型操作符、函数和方法

Function/Method	Name
函数/方法名

Operator Equivalent  
等价运算符 

Description
说明

All Set Types 
所有集合类型

len(s)	Set cardinality: number of elements in s 
len(s)	集合基数: 集合s中元素的个数

set([obj])	Mutable set factory function; if obj given, it must be iterable, new set elements taken from obj; if not, creates an empty set
set([obj])	可变集合工厂函数; obj必须是支持迭代的，由obj中的元素创建集合，否则创建一个空集合

frozenset([obj])	Immutable set factory function; operates the same as set() except returns immutable set
frozenset([obj])	不可变集合工厂函数; 执行方式和set()方法相同，但它返回的是不可变集合

obj in s	Membership test: is obj an element of s?
obj in s	成员测试：obj 是s中的一个元素吗?

obj not in s  	Non-membership test: is obj not an element of s?
obj not in s	非成员测试：obj 不是s中的一个元素吗?

s == t	Equality test: do s and t have exactly the same elements?
s == t	等价测试: 测试s和t是否具有相同的元素?

s != t	Inequality test: opposite of ==
s != t	不等价测试: 与==相反

s < t	(Strict) subset test; s != t and all elements of s are members of t
s < t	(严格意义上)子集测试; s != t 而且s中所有的元素都是t的成员

s.issubset(t)	s <= t	Subset test (allows improper subsets): all elements of s are members of t
s.issubset(t)	s <= t	子集测试(允许不严格意义上的子集): s中所有的元素都是t的成员

s > t	(Strict) superset test: s != t and all elements of t are members of s
s > t	(严格意义上)超集测试: s != t 而且t中所有的元素都是s的成员

s.issuperset(t) s >= t	Superset test (allows improper supersets): all elements of t are members of s
s.issuperset(t) s >= t	超集测试(允许不严格意义上的超集): t中所有的元素都是s的成员

s.union(t)	s | t	Union operation: elements in s or t
s.union(t)	s | t	合并操作：s或t中的元素

s.intersec- tion(t)  s & t	  Intersection operation: elements in s and t
s.intersec- tion(t)  s & t	  交集操作：s和t中的元素

s.difference(t) s - t	Difference operation: elements in s that are not elements of t
s.difference(t) s - t	差分操作: s中的元素，而不是t中的元素

s.symmetric_difference(t)    s ^ t	    Symmetric difference operation: elements of either s or t but not both
s.symmetric_difference(t)	 s ^ t		对称差分操作：s或t中的元素，但不是s和t共有的元素

s.copy()	Copy operation: return (shallow) copy of s
s.copy()	复制操作:返回s的(浅复制)副本

Table 7.6  Set Type Operators, Functions, and Methods (continued)
集合类型，函数和方法(继续)

Function/Method 函数/方法
Name 名字
Operator 操作符
Equivalent   Description
等价描述

Mutable Sets Only
仅用于可变集合
s.update(t)	s |= t	(Union) update operation: members of t added to s
s.update(t)	s |= t  (Union) 修改操作: 将t中的成员添加s

s.intersection_update(t)
s &= t	Intersection update operation: s only contains members of the original s and t
s.intersection_update(t)
s &= t	交集修改操作: s中仅包括s和t中共有的成员

s.difference_update(t)
s -= t	Difference update operation: s only contains original members who are not in t
s.difference_update(t)
s -= t	差修改操作: s中包括仅属于s但不属于t的成员

s.symmetric_ difference_ update(t)
s ^= t	Symmetric difference update operation: s only contains members of s or t but not both
s.symmetric_ difference_ update(t)
s ^= t	对称差分修改操作: s中包括仅属于s或仅属于t的成员

s.add(obj)	Add operation: add obj to s 
s.add(obj)	加操作: 将obj添加到s

s.remove(obj)	Remove operation: remove obj from s; KeyError raised if obj not in s
s.remove(obj)	删除操作: 将obj从s中删除；如果s中不存在obj,将引发KeyError

s.discard(obj)	Discard operation: friendlier version of remove() — remove obj from s if obj in s
s.discard(obj)	丢弃操作: remove() 的友好版本 - 如果s中存在obj, 从s中删除它

s.pop()	Pop operation: remove and return an arbitrary element of s
s.pop() Pop操作: 移除并返回s中的任意一个元素

s.clear()	Clear operation: remove all elements of s
s.clear() 	清除操作: 移除s中的所有元素

Some general online references for sets which you may find useful include:
以下是一些你可能认为有用的在线参考文章：

http://en.wikipedia.org/wiki/Set http://www.geocities.com/basicmathsets/set.html http://www.math.uah.edu/stat/foundations/Sets.xhtml


7.12  Exercises
练习

7–1.   Dictionary Methods. What dictionary method would we use to combine two dictionaries together?
7–1.   字典方法。哪个字典方法可以用来把两个字典合并到一起？

7–2.   Dictionary Keys. We know that dictionary values can be arbitrary Python objects, but what about the keys? Try using different types of objects as the key other than numbers or strings. What worked for you and what didn’t? As for the failures, why do you think they didn’t succeed?
7–2.   字典的键。我们知道字典的值可以是任意的Python对象，那字典的键又如何呢？请试着将除数字和字符串以外的其他不同类型的对象作为字典的键，看一看，哪些类型可以，哪些不行？对那些不能作字典的键的对象类型，你认为是什么原因呢？

7–3.   Dictionary and List Methods.
(a) Create a dictionary and display its keys alphabetically.
(b) Now display both the keys and values sorted in alphabetical order by the key.
(c) Same as part (b), but sorted in alphabetical order by the value. (Note: This has no practical purpose in dictionaries or hash tables in general because most access and ordering
[if any] is based on the keys. This is merely an exercise.)
7–3.   字典和列表的方法。
(a) 创建一个字典，并把这个字典中的键按照字母顺序显示出来。
(b) 现在根据已按照字母顺序排序好的键，显示出这个字典中的键和值。
(c)同(b),但这次是根据已按照字母顺序排序好的字典的值，显示出这个字典中的键和值。(注意：对字典和哈希表来说，这样做一般没有什么实际意义，因为大多数访问和排序(如果需要)都是基于字典的键，这里只把它作为一个练习。)

7–4.   Creating Dictionaries. Given a pair of identically sized lists, say,
[1, 2, 3,...], and ['abc', 'def', 'ghi',...], process all that list data into a single dictionary that looks like: {1:'abc', 2: 'def', 3: 'ghi',...}.
7-4.   建立字典。给定两个长度相同的列表，比如说，列表[1, 2, 3,...]和['abc', 'def', 'ghi',...],用这两个列表里的所有数据组成一个字典，像这样：{1:'abc', 2: 'def', 3: 'ghi',...}

7–5.   userpw2.py. The following problems deal with the program in Example 7.1, a manager of a database of name-password key-value pairs.
7–5. userpw2.py. 下面的问题和例题7.1中管理名字-密码的键值对数据的程序有关。

(a) Update the script so that a timestamp (see the time module) is also kept with the password indicating date and time of last login. This interface should prompt for login and password and indicate a successful or failed login as before, but if successful, it should update the last login timestamp. If the login occurs within four hours of the last login, tell the user, “You already logged in at: <last_ login_timestamp>.”
(a)修改那个脚本，使它能记录用户上次的登录日期和时间(用time模块)，并与用户密码一起保存起来。程序的界面有要求用户输入用户名和密码的提示。无论户名是否成功登录，都应有提示，在户名成功登录后，应更新相应用户的上次登录时间戳。如果本次登录与上次登录在时间上相差不超过4个小时，则通知该用户： “You already logged in at: <last_ login_timestamp>.”

(b) Add an “administration” menu to include the following two menu options: (1) remove a user and (2) display a list of all users in the system and their passwords
(b) 添加一个“管理”菜单，其中有以下两项:(1)删除一个用户 (2)显示系统中所有用户的名字和他们的密码的清单。

(c) The passwords are currently not encrypted. Add password- encryption if so desired (see the crypt, rotor, or other cryptographic modules).
(c) 口令目前没有加密。请添加一段对口令加密的代码(请参考crypt, rotor, 或其它加密模块)

(d) *Add a GUI interface, i.e., Tkinter, on top of this application.
(d) 为程序添加图形界面，例如，用Tkinter写。

(e) Allow usernames to be case-insensitive.
(e) 要求用户名不区分大小写。

(f) Restrict usernames by not allowing symbols or whitespace.
(f) 加强对用户名的限制，不允许符号和空白符。

(g) Merge the “new user” and “old user” options together. If a new user tries to log in with a nonexistent username, prompt if they are new and if so, do the proper setup. Otherwise, they are an existing user so log in as normal.
(g)合并“新用户”和“老用户”两个选项。如果一个新用户试图用一个不存在的用户名登录，询问该用户是否是新用户，如果回答是肯定的，就创建该帐户。否则，按照老用户的方式登录。


7–6.   Lists and Dictionaries. Create a crude stock portfolio data-base system. There should be at least four data columns: stock ticker symbol, number of shares, purchase price, and current price—you can add more if you wish, such as percentage gain(loss), 52-week high/low, beta, etc.
7-6.  列表和字典。创建一个简单的股票证券投资数据系统。其中应至少包含四项数据：股市行情显示器符号，所持有的股票，购买价格及当前价位 - 你可以随意添加其他数据项，比如收益率，52周最高指数、最低指数，等等。

   Have the user input values for each column to create a single row. Each row should be created as list. Another all-encompassing list will hold all these rows. Once the data is entered, prompt the user for one column to use as the sort metric. Extract the data values of that column into a dictionary as keys, with their corresponding values being the row that contains that key. Be mindful that the sort metric must have non-coincidental keys or else you will lose a row because dictionaries are not allowed to have more than one value with the same key.
   用户每次输入各列的数据构成一个输出行。每行数据构成一个列表。还有一个总列表，包括了所有行的数据。数据输入完毕后，提示用户选择一列数据项进行排序。把该数据项抽取出来作为字典的键，字典的值就是该键对应行的值的列表。提醒读者：被选择用来排序的数据项必须是非重复的键，否则就会丢失数据，因为字典不允许一个键有多个值。
   
You may also choose to have additional calculated output, such as percentage gain/loss, current portfolio values, etc.
你还可以选择其他计算输出，比如，盈亏比率，目前证券资产价值等。

7–7.   Inverting Dictionaries. Take a dictionary as input and return one as output, but the values are now the keys and vice versa.
7-7.   颠倒字典中的键和值。用一个字典做输入，输出另一个字典，用前者的键做值，前者的值做键。

7–8.   Human Resources. Create a simple name and employee number dictionary application. Have the user enter a list of names and employee numbers. Your interface should allow a sorted output(sorted by name) that displays employee names followed by their employee numbers. Extra credit: Come up with an additional feature that allows for output to be sorted by employee numbers.
7-8.   人力资源。创建一个简单的雇员姓名和编号的程序。让用户输入一组雇员姓名和编号。你的程序可以提供按照姓名排序输出的功能，雇员姓名显示在前面，后面是对应的雇员编号。附加题：添加一项功能，按照雇员编号的顺序输出数据。

7–9.   Translations.
7-9.   翻译

(a) Create a character translator (that works similar to the Unix tr command). This function, which we will call tr(), takes three strings as arguments: source, destination, and base strings, and has the following declaration:

def tr(srcstr, dststr, string)

srcstr contains the set of characters you want “translated,” dststr contains the set of characters to translate to, and string is the string to perform the translation on. For example, if srcstr == 'abc', dststr == 'mno', and string == 'abcdef', then tr() would output 'mnodef'. Note that len(srcstr) == len(dststr).
For this exercise, you can use the chr() and ord() BIFs, but they are not necessary to arrive at a solution.
(b) Add a new flag argument to this function to perform case-insensitive translations.
(c) Update your solution so that it can process character deletions. Any extra characters in srcstr that are beyond those that could be mapped to characters in dststr should be filtered. In other words, these characters are mapped to no characters in dststr, and are thus filtered from the modified string that is returned. For example, if srcstr == 'abcdef', dststr == 'mno', and string == 'abcdefghi', then tr() would output 'mnoghi'. Note now that len(srcstr) >= len(dststr).

(a) 编写一个字符翻译程序(功能类似于Unix中的tr命令)。我们将这个函数叫做tr()，它有三个字符串做参数: 源字符串、目的字符串、基本字符串，语法定义如下：

def tr(srcstr, dststr, string)

srcstr的内容是你打算“翻译”的字符集合，dsrstr是翻译后得到的字符集合，而string是你打算进行翻译操作的字符串。举例来说，如果srcstr == 'abc', dststr == 'mno', string == 'abcdef', 那么tr()的输出将是'mnodef'. 注意这里len(srcstr) == len(dststr).

在这个练习里，你可以使用内建函数chr() 和 ord(), 但它们并不一定是解决这个问题所必不可少的函数。
(b) 在这个函数里增加一个标志符参数，来处理不区分大小写的翻译问题。
(c)修改你的程序，使它能够处理删除字符的操作。字符串srcstr中不能够映射到字符串dststr中字符的多余字符都将被过滤掉。换句话说，这些字符没有映射到dststr字符串中的任何字符，因此就从函数返回的字符里被过滤掉了。举例来说：如果  srcstr == 'abcdef', dststr == 'mno', string == 'abcdefghi', 那么tr()将输出'mnoghi'. 注意这里len(srcstr) >= len(dststr).

7–10.   Encryption. Using your solution to the previous problem, and create a “rot13” translator. “rot13” is an old and fairly simplistic encryption routine whereby each letter of the alphabet is rotated 13 characters. Letters in the first half of the alphabet will be rotated to the equivalent letter in the second half and vice versa, retaining case. For example, a goes to n and X goes to K. Obviously, numbers and symbols are immune from translation.
(b) Add an application on top of your solution to prompt the user for strings to encrypt (and decrypt on reapplication of the algorithm), as in the following examples:
7–10.   加密。
(a) 用上一个练习的思路编写一个"rot13"翻译器。"rot13"是一个古老而又简单的加密方法，它把字母表中的每个字母用其后的第13个字母来代替。字母表中前半部分字母将被映射到后半部分，而后半部分字母将被映射到前半部分，大小写保持不变。举例来说，'a'将被替换为'n','X'将被替换为'K'; 数字和符号不进行翻译。
(b)
在你的解决方案的基础上加一个应用程序，让它提示用户输入准备加密的字符串(这个算法同时也可以对加密后的字符串进行解密)，如下所示:

% rot13.py
Enter string to rot13: This is a short sentence. Your string to en/decrypt was: [This is a short sentence.].
The rot13 string is: [Guvf vf n fubeg fragrapr.].
%
% rot13.py
Enter string to rot13: Guvf vf n fubeg fragrapr. Your string to en/decrypt was: [Guvf vf n fubeg fragrapr.].
The rot13 string is: [This is a short sentence.].

7–11.   Definitions. What constitutes valid dictionary keys? Give examples of valid and invalid dictionary keys.
7–11.   定义。什么组成字典中合法的键? 举例说明字典中合法的键和非法的键。

7–12.   Definitions. 
(a) What is a set in the mathematical sense?
(b) What is a set type as it relates to Python?
7-12.   定义。
(a)在数学上，什么是集合?
(b)在Python中，关于集合类型的定义是什么？

7–13.   Random Numbers. The next problems use a customization of Exercise 5–17: use randint() or randrange() in the random module to generate a set of numbers: generate between 1 to 10 random numbers numbered randomly between 0 and 9(inclusive). These values constitute a set A (A can be mutable or otherwise). Create another random set B in a similar manner. Display A | B and A & B each time sets A and B are generated.
7–13.   随机数。修改练习5-17的代码：使用random模块中的randint()或randrange()方法生成一个随机数集合：从0到9(包括9)中随机选择，生成1到10个随机数。这些数字组成集合A(A可以是可变集合，也可以不是)。同理，按此方法生成集合B。每次新生成集合A和B后，显示结果 A | B 和 A & B

7–14.   User Validation. Alter the previous problem where instead of displaying A | B and A & B, ask the user to input solutions to A | B and A & B, and let the user know if his or her solution was right or wrong. If it is not correct, give the user the ability to correct and revalidate his or her answers. Display the correct results if three incorrect answers are submitted. 
Extra credit: Use your knowledge of sets to generate potential subsets and ask the user whether they are indeed subsets (or not), and provide corrections and answers as necessary as in the main part of this problem.
7–14.   用户验证。修改前面的练习，要求用户输入A | B 和A & B的结果，并告诉用户他(或她)的答案是否正确，而不是将A | B 和A & B 的结果直接显示出来。如果用户回答错误，允许他(或她)修改解决方案，然后重新验证用户输入的答案。如果用户三次提交的答案均不正确，程序将显示正确结果。
附加题：运用你关于集合的知识，创建某个集合的潜在子集，并询问用户此潜在子集是否真是该集合的子集，要求和主程序一样有显示更正和答案的功能。

7–15.   Set Calculator. This exercise is inspired by Exercise 12.2 in the free online Java textbook located at http://math.hws.edu/ javanotes. Create an application that allows users to input a pair of sets, A and B, and allow users to give an operation symbol, i.e., in, not in, &, |, ^, <, <=, >, >=, ==, !=, etc. (For sets, you define the input syntax—they do not have to be enclosed in brackets as the Java example.) Parse the entire input string and execute the operation on the input sets as requested by the user. Your solution should require fewer lines of Python than the one in Java.
7–15.   编写计算器。 这个练习取材于http://math.hws.edu/ 在线免费Java教材中的练习12.2。编写一个程序允许用户选择两个集合:A和B, 及运算操作符。例如，in, not in, &, |, ^, <, <=, >, >=, ==, !=, 等. (你自己定义集合的输入语法，它们并不一定要像Java示例中那样用方括号括住。)解析输入的字符串，按照用户选择的运算进行操作。你写的程序代码应该比Java版本的该程序更简洁。