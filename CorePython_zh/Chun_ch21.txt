Database
Programming
数据库编程


Chapter Topics
本章主题

        Introduction
        Databases and Python RDBMSs, ORMs, and Python
        Database Application Programmer’s Interface (DB-API)
        Relational Databases (RDBMSs)
        Object-Relational Mappers (ORMs)
        Related Modules
        Exercises

　21

in  this  chapter,  we  discuss  how  to  communicate  with  databases  from
Python. Earlier, we discussed simplistic persistent storage, but in many
   cases, a full-fledged relational database management system (RDBMS) is required for your application.
   本章的主题是如何通过Python访问数据库。前面我们已经了解了简单持久存储，但是在更多场合下，我们的应用程序需要的是一个功能齐全的关系型数据库。



21.1  Introduction
介绍
21.1.1 Persistent Storage
持久存储

In any application, there is a need for persistent storage. Generally, there are three basic storage mechanisms: files, a relational database system (RDBMS),
or some sort of hybrid, i.e., an API (application programmer interface) that
“sits  on  top  of ”  one  of  those  existing  systems,  an  object  relational  mapper
(ORM), file manager, spreadsheet, configuration file, etc.
在任何的应用程序中，都需要持久存储。一般说来，有三种基本的存储机制：文件、关系型数据库或其它的一些变种，例如现有系统的API，ORM、文件管理器、电子表格、配置文件等等。
　In an earlier chapter, we discussed persistent storage using both plain file access  as  well  as  a  Python  and  DBM  overlay  on  top  of  files,  i.e.,  *dbm, dbhash/bsddb files,  shelve (combination  of  pickle and  DBM),  and using their dictionary-like object interface. This chapter will focus on using RDBMSs for the times when files or writing your own system does not suf- fice for larger projects.
　在前面的章节中，我们研究了通过基于常规文件的 Python 和 DBM 接口来实现持久存储, 比如 *dbm, dbhas/bsddb 文件, shelve(pickle和DBM的结合). 这些接口都提供了类似字典的对象接口。本章的主题是如何在中大型项目中使用关系型数据库.(对这些项目而言, 那些接口力不从心)

21.1.2 Basic Database Operations and SQL
基本的数据库操作和SQL语言

Before we dig into databases and how to use them with Python, we want to present  a  quick  introduction  (or  review  if  you  have  some  experience)  to some  elementary  database  concepts  and  the  Structured  Query  Language(SQL).
在深入主题之前，下面先简单介绍一下基本的数据库概念和结构化查询语言（SQL）。如果你有足够的经验, 可以跳过, 也可以通过阅读正文来复习一下. 

Underlying Storage

Databases usually have a fundamental persistent storage using the file sys- tem,  i.e.,  normal  operating  system  files,  special  operating  system  files,  and even raw disk partitions.
底层存储
数据库的底层存储通常使用文件系统, 它可以是普通操作系统文件、专用操作系统文件,甚至有可能是磁盘分区。

User Interface
用户界面
Most  database  systems  provide  a  command-line  tool  with  which  to  issue SQL  commands  or  queries.  There  are  also  some  GUI  tools  that  use  the command-line  clients  or  the  database  client  library,  giving  users  a  much nicer interface.
大部分的数据库系统会提供一个命令行工具来执行SQL命令和查询，当然也有一些使用图形界面的漂漂亮亮的客户端程序来干同样的事。

Databases
数据库
An RDBMS can usually manage multiple databases, e.g., sales, marketing, customer support, etc., all on the same server (if the RDBMS is server-based; simpler systems are usually not). In the examples we will look at in this chapter, MySQL is an example of a server-based RDBMS because there is a server process  running  continuously  waiting  for  commands  while  neither  SQLite nor Gadfly have running servers.
关系型数据库管理系统通常通常都支持多个数据库，例如销售库、市场库、客户支持库等等. 如果你使用的关系数据库管理系统是基于服务器的，这些数据库就都在同一台服务器上 (一些简单的关系型数据库没有服务器, 如sqlite).  本章的例子中, MySQL是一种基于服务器的关系数据库管理系统(只要服务器在运行, 它就一直在等待运行指令)，SQLite 和Gadfly 则是另一种轻量型的基于文件的关系数据库(它们没有服务器)。

Components
组件
The table is the storage abstraction for databases. Each row of data will have fields that correspond to database columns. The set of table definitions of col- umns and data types per table all put together define the database schema. Databases are created and dropped. The same is true for tables. Adding new rows to a database is called inserting, changing existing rows in a table is called  updating,  and  removing  existing  rows  in  a  table  is  called  deleting. These actions are usually referred to as database  commands or operations. Requesting rows from a database with optional criteria is called querying. When you query a database, you can fetch all of the results (rows) at once, or just iterate slowly over each resulting row. Some databases use the concept of a cursor for issuing SQL commands, queries, and grabbing results, either all at once or one row at a time.
你可以将数据库存储想像为一个表格, 每行数据都有一个或多个字段对应着数据库中的列. 每个表每个列及其数据类型的集合构成数据库结构的定义. 数据库能够被创建, 也可以被删除. 表也一样. 往数据库里增加一条记录称为 插入(inserting) 一条记录, 修改库中一条已有的记录则称为 更新(updating), 删除表中已经有的数据行称为删除(deleting). 这些操作通常作为数据库操作命令来提交. 从一个数据库中请求符合条件的数据称为查询(querying). 当你对一个数据库进行查询时, 你可以一步取回所有符合条件的数据, 也可以循环逐条取出每一行. 有些数据库使用游标的概念来表示 SQL 命令, 查询, 取回结果集等等.


SQL

Database  commands  and  queries  are  given  to  a  database  by  SQL.  Not  all databases  use  SQL,  but  the  majority  of  relational  databases  do.  Here  are some examples of SQL commands. Most databases are configured to be case- insensitive, especially database commands. The accepted style is to use CAPS for database keywords. Most command-line programs require a trailing semi- colon ( ; ) to terminate a SQL statement.
数据库命令和查询操作需要通过SQL语句来执行. 不是所有的数据库都使用SQL, 但所有主流的关系型数据库都使用SQL. 下面是一些SQL命令的例子. 绝大多数数据库被配置为大小写不敏感, 除了数据库操作命令以外. 被广为接受的书写SQL的基本风格是关键字大写. 绝大多数命令行程序要求用一个分号来结束一条SQL语句. 

Creating a Database
创建数据库

CREATE DATABASE test;
GRANT ALL ON test.* to user(s);
　The first line creates a database named “test,” and assuming that you are a database administrator, the second line can be used to grant permissions to specific users (or all of them) so that they can perform the database opera- tions below.
　第一行创建一个名为“test”的数据库，第二行将该数据库的权限赋给具体的用户（或者全部用户），以便它们可以执行下面的数据库操作。

Using a Database
选择要使用的数据库
USE test;
　If you logged into a database system without choosing which database you want to use, this simple statement allows you to specify one with which to perform database operations.
　如果在登录数据库时没有指定要使用那个数据库，这条简单的语句就可以指定你打算访问的数据库.
　

Dropping a Database
删除数据库
DROP DATABASE test;
　This simple statement removes all the tables and data from the database and deletes it from the system.
　这条短短的语句具有极大的威力. 它用来删除数据库(包括数据库中所有的表及表中的数据).  在输入完这条语句按下回车之前, 好好想想你是否真的打算这么做. 

Creating a Table
创建表
CREATE TABLE users (login VARCHAR(8), uid INT, prid INT);
This statement creates a new table with a string column login and a pair
of integer fields uid and prid.
这个语句用于创建表  users，它有一个类型为字符串的列login和两个类型为整数的字段uid和prid。

Dropping a Table
删除表
DROP TABLE users;
This simple statement drops a database table along with all its data.
这个简单的语句删除数据库中的一个表和它的所有数据。

Inserting a Row
插入行
INSERT INTO users VALUES('leanna', 311, 1);

   You can insert a new row in a database with the INSERT statement. Spec- ify the table and the values that go into each field. For our example, the string
'leanna' goes  into  the  login field,  and  311 and  1 to  uid and  prid, respectively.
INSERT语句用来向数据库中添加新的数据行. 语句中必须指定要插入的表及该表中各个字段的值。上例中, 表名是 users, 字符串'leanna' 对应着 login字段，311 和 1 分别对应着uid 和 prid。

Updating a Row
更新行
UPDATE users SET prid=4 WHERE prid=2; 
UPDATE users SET prid=1 WHERE uid=311;

　To change existing table rows, you use the UPDATE statement. Use SET for the columns that are changing and provide any criteria for determining which rows should change. In the first example, all users with a “project ID”
or prid of 2 will be moved to project #4. In the second example, we take one user (with a UID of 311) and move them to project #1.
UPDATE语句用来改变数据库中的已有记录. 使用 SET 关键字来指定你要修改的字段及新值, 你可以指定条件来筛选出需要更新的记录.在第一个例子中, 所有 prid 字段值为 2 的记录, 其 prid 字段的值都变更为 4. 在第二个例子里, uid 字段值为 311 的用户, 其 prid 字段的新值被置为 1. 

Deleting a Row
删除行

DELETE FROM users WHERE prid=%d; 
DELETE FROM users;
　To delete a table row, use the DELETE FROM command, give the table you want to delete rows from, and any optional criteria. Without it, as in the sec- ond example, all rows will be deleted.
DELETE FROM 命令用来删除数据. 必须指定你要删除的数据所在表名, 如果未提供(可选的)筛选条件, 就象第二个例子一样, 表中所有的数据都会被删除.

　Now that you are up to speed on basic database concepts, it should make following the rest of the chapter and its examples much easier. If you need additional help, there are plenty of database books out in the market that you can check out.
现在你已经了解数据库的基本概念, 有了这些基础, 本章余下的部分学起来会更加容易. 如果需要进一步了解数据库知识, 市面是有数不清的数据库书籍可以选择. 

21.1.3 Databases and Python
数据库 和 Python

We are going to cover the Python database API and look at how to access relational databases from Python, either directly through a database interface,
or via an ORM, and how you can accomplish the same task but without necessarily having to give explicitly commands in SQL.
下面我们要详细了解 Python 数据库API. Python能够直接通过数据库接口, 也可以通过 ORM (不需要自己书写SQL) 来访问关系数据库. 
 
　Topics such as database principles, concurrency, schema, atomicity, integrity, recovery, proper complex left JOINs, triggers, query optimization, transactions, stored procedures, etc., are all outside the scope of this text, and we will  not  be  discussing  these  in  this  chapter  other  than  direct  use  from  a Python application. There are plenty of resources you can refer to for general information. Rather, we will present how to store and retrieve data to/from RDBMSs  while  playing  within  a  Python  framework.  You  can  then  decide which is best for your current project or application and be able to study sam- ple code that can get you started instantly. The goal is to get you up to speed as quickly as possible if you need to integrate your Python application with
some sort of database system.
类似数据库原理, 并发能力, 视图, 原子性, 数据完整性, 数据可恢复性, 还有左连接, 触发器, 查询优化, 事务支持, 及存储过程等等, 这些东西, (市面上)有数不清的资源可供参考. 本章不讨论这些主题, 我们将从一个 python 应用程序开始, 了解在 python 框架下如何将数据保存到数据库, 如果将数据从数据库中取出来. 之后你就可以决定哪种方式适用于你手头的项目. 通过学习示例代码, 你可以立马动手把某种数据库整合到你的python应用程序当中. 

　We are also breaking out of our mode of covering only the “batteries included” features of the Python standard library. While our original goal was to play only in that arena, it has become clear that being able to work with databases is really a core component of everyday application development in the Python world.
　在python世界里, 无需怀疑, 与数据库协同工作已经是几乎所有应用程序的核心部分. 在本章中, 我们将不仅仅使用"万能"的Python标准库. 尽管我们需要从标准库开始. 

　As a software engineer, you can probably only make it so far in your career without having to learn something about databases: how to use one (command- line and/or GUI interfaces), how to pull data out of one using the Structured Query Language (SQL), perhaps how to add or update information in a data- base, etc. If Python is your programming tool, then a lot of the hard work has already been done for you as you add database access to your Python universe. We first describe what the Python “DB-API” is, then give examples of database interfaces that conform to this standard.
作为一个软件工程师, 在你的职业生涯中, 你可能永远不需要学习数据库知识: 如何使用命令行工具, 如何使用SQL? 如何添加和更新数据? 等等等等.  如果 python 是你的编程工具, 为你的 python应用添加数据库支持易如反掌. 下面我们先来介绍一下 Python DB-API, 然后给出使用这个标准的例子. 
　We will give some examples using popular open source relational database management systems (RDBMSs). However, we will not include discussions of open source vs. commercial products, etc. Adapting to those other RDBMS sys- tems should be fairly straightforward. A special mention will be given to Aaron Watters’s Gadfly database, a simple RDBMS written completely in Python.

我们的例子会使用开源的数据库系统. 不过我们不会去讨论开源产品好还是商业产品更好. 要适应其它的数据库也相当容易, 需要特别提到的是 Aaron Watter 的 Gadfly 数据库, 一个完全由 Python 代码写成的数据库系统. 

　The way to access a database from Python is via an adapter. An adapter is basically a Python module that allows you to interface to a relational data- base’s client library, usually in C. It is recommended that all Python adapters conform to the Python DB-SIG’s Application Programmer Interface (API). This is the first major topic of this chapter.
从python中访问数据库需要接口程序. 接口程序是一个 python 模块, 它提供数据库客户端库(通常是C语言写成的)的接口供你访问. 需要提到一点, 所有 Python 接口程序都一定程度上遵守 Python DB-API 规范. 这也是本章的第一个主要主题.

　Figure  21.1  illustrates  the  layers  involved  in  writing  a  Python  database application, with and without an ORM. As you can see, the DB-API is your interface to the C libraries of the database client.
图21.1 演绎了 Python 数据库应用程序的结构(包括使用和不使用 ORM). 你可以看到 DB-API 是数据库客户端 C 库的接口.

Application
(embedded SQL)

Python application
(embedded SQL)


Python DB adapter
Python application
(little or no SQL)

   Python ORM Python DB adapter
   
RDBMS client library
RDBMS client library
RDBMS client library



Relational database (RDBMS)
关系数据库

Figure 21–1    Multitiered communication between application and database. 
图 21-1 数据库和应用程序之间的多层通讯
The first box is generally a C/C++ program while DB-API compliant adapters let you program applications in Python. ORMs can simplify an application by handling all of the database- specific details.
第一个盒子一般是 C/C++ 程序, 你的程序通过 DB-API 兼容接口程序访问数据库.
ORM 通过程序处理数据库细节来简化数据库开发.

21.2  Python Database Application
Programmer’s Interface (DB-API)
Python数据库应用程序
程序员接口(DB-API)

Where can one find the interfaces necessary to talk to a database? Simple. Just go to the database topics section at the main Python Web site. There you will find links to the full and current DB-API (version 2.0), existing database modules, documentation, the special interest group, etc. Since its inception, the DB-API has been moved into PEP 249. (This PEP obsoletes the old DB- API 1.0 specification which is PEP 248.) What is the DB-API?
去哪儿找一个合适的接口访问数据库? 很简单, 去 python.org 找到数据库主题那一节, 你会发现所有支持 DB-API 2.0的各种数据库模块, 文档, SIG等等. 从那时起, DB-API被移到 PEP 249中(这个PEP废弃了老的 DB-API 1.0 , 也就是PEP248标准). 那么, 什么是 DB-API ?


　The API is a specification that states a set of required objects and database access mechanisms to provide consistent access across the various database adapters  and  underlying  database  systems.  Like  most  community-based efforts, the API was driven by strong need.
DB-API是一个规范. 它定义了一系列必须的对象和数据库存取方式, 以便为各种各样的底层数据库系统和多种多样的数据库接口程序提供一致的访问接口. 象绝大多数社区成果一样, 这个API的产生来自于强烈的需求.

　In the “old days,” we had a scenario of many databases and many people implementing  their  own  database  adapters.  It  was  a  wheel  that  was  being reinvented over and over again. These databases and adapters were implemented  at  different  times  by  different  people  without  any  consistency  of functionality.  Unfortunately,  this  meant  that  application  code  using  such interfaces also had to be customized to which database module they chose to use, and any changes to that interface also meant updates were needed in the application code.
在"旧社会", 不同的人为各种各样的数据库实现了各种各样的数据库接口程序. 同一个轮子被不同的人一遍又一遍的重复发明. 这些接口由不同的人在不同的时间实现, 功能接口各不兼容. 这意味着使用这些接口的程序必须自定义他们选择的接口模块. 当这个接口模块变化时, 应用程序的代码也必须随之更新. 

　A  special  interest  group  (SIG)  for  Python  database  connectivity  was formed, and eventually, an API was born . . . the DB-API version 1.0. The API provides  for  a  consistent  interface  to  a  variety  of  relational  databases,  and porting  code  between  different  databases  is  much  simpler,  usually  only requiring tweaking several lines of code. You will see an example of this later on in this chapter.
一个处理 Python 数据库事务的特殊事物小组（SIG，special  interest  group） 因此诞生, 最后. DB-API 1.0 问世. DB-API 为不同的数据库提供了一致的访问接口, 在不同的数据库之间移植代码成为一件轻松的事情(一般来说, 只修要修改几行代码). 接下来你会看到这样的例子. 

21.2.1 Module Attributes
模块属性

The  DB-API  specification  mandates  that  the  features  and  attributes  listed below must be supplied. A DB-API-compliant module must define the glo- bal attributes as shown in Table 21.1.
DB-API规范里的以下特性和属性必须提供. 一个 DB-API 兼容的模块必须定义下表 Table 21.1 中定义的所有全局属性.

Data Attributes
数据属性

apilevel
This string (not float) indicates the highest version of the DB-API the mod- ule is compliant with, i.e., “1.0”, “2.0”, etc. If absent, “1.0” should be assumed
as the default value.
apilevel 这个字符串(不是浮点数)表示这个 DB-API模块所兼容的DB-API最高版本号. 如果 "1.0", "2.0", 如果未定义, 则默认是 "1.0";

Table 21.1  DB-API Module Attributes
表 21.1 DB-API模块属性
Attribute       Description
属性名          描述
apilevel        Version of DB-API module is compliant with 
apilevel        DB-API 模块兼容的 DB-API版本号

threadsafety    Level of thread safety of this module 
                线程安全级别
paramstyle      SQL statement parameter style of this module 
                该模块支持的 SQL语句参数风格
connect()       Connect() function
                连接函数
(Various exceptions)    (See Table 21.4)
异常(参见表21.4)
threadsafety
This an integer with these possible values:
threadsafety 这是一个整数, 取值范围如下
?
0:
Not threadsafe, so threads should not share the module at all
不支持线程安全, 多个线程不能共享此模块
?
1:
Minimally threadsafe: threads can share the module but not connections
初级线程安全支持: 线程可以共享模块, 但不能共享连接

?
2:
Moderately threadsafe: threads can share the module and connections but not cursors
中级线程安全支持 线程可以共享模块和连接, 但不能共享游标
?
3:
Fully threadsafe: threads can share the module, connections, and cursors
完全线程安全支持 线程可以共享模块, 连接及游标.


If a resource is shared, a synchronization primitive such as a spin lock or
semaphore  is  required  for  atomic-locking  purposes.  Disk  files  and  global variables are not reliable for this purpose and may interfere with standard mutex operation. See the threading module or the chapter on multithreaded programming (Chapter 16) on how to use a lock.

如果一个资源被共享, 就必需使用自旋锁或者是信号量这样的同步原语对其进行原子目标锁定。 对这个目标来说,  磁盘文件和全局变量都不可靠, 并且有可能妨碍 . 
mutex(互斥量)的操作. 参阅 threading 模块或第16章(多线程编程)来了解如何使用锁. 

paramstyle

The API supports a variety of ways to indicate how parameters should be inte- grated into an SQL statement that is eventually sent to the server for execution. This argument is just a string that specifies the form of string substitution you will use when building rows for a query or command (see Table 21.2).
DB-API支持多种方式的SQL参数风格. 这个参数是一个字符串, 表明SQL语句中字符串替代的方式. (参阅表21.2)

Function Attribute(s)
函数属性

connect() Function  access  to  the  database  is  made  available  through Connection objects. A compliant module has to implement a connect() function, which creates and returns a Connection object. Table 21.3 shows the arguments to connect().
connect 方法生成一个connect 对象, 我们通过这个对象来访问数据库. 符合标准的模块都会实现 connect 方法. 表21.3列出了 connect 函数的参数.  

Table 21.2  paramstyle Database Parameter Styles
表21.2 数据库参数风格
Parameter
Style   Description     Example
风络    描述            示例
numeric Numeric positional style        WHERE name=:1
数字    数字位置风格
named   Named style     WHERE name=:name
命名    命名参数风格

pyformat        Python dictionary printf() format conversion WHERE name=%(name)s
pyformat        python 字典格式转换        

qmark   Question mark style     WHERE name=?
问号    问号风格

format  ANSI C printf() format conversion WHERE name=%s
format  标准 ANSI C 格式转换



You can pass in database connection information as a string with multiple
parameters (DSN) or individual parameters passed as positional arguments
(if you know the exact order), or more likely, keyworded arguments. Here is an example of using connect() from PEP 249:

connect(dsn='myhost:MYDB',user='guido',password='234$')
数据库连接参数可以以一个 DSN 字符串的形式提供, 也可以以多个位置相关参数的形式提供(如果你明确知道参数的顺序的话), 也可以以关键字参数的形式提供. 下面是一个来自 PEP 249的使用 connect() 的例子:

　The  use  of  DSN  versus  individual  parameters  is  based  primarily  on  the system  you  are  connecting  to.  For  example,  if  you  are  using  an  API  like ODBC or JDBC, you would likely be using a DSN, whereas if you are work- ing directly with a database, then you are more likely to issue separate login parameters. Another reason for this is that most database adapters have not implemented  support  for  DSN.  Below  are  some  examples  of  non-DSN
　
使用 DSN字符串还是独立参数? 这要看你连接的是哪种数据库. 举例来说, 如果你使用类似 ODBC 或 JDBC 的 API, 你就应该使用 DSN 字符串. 如果你直接访问数据库, 你就会更倾向于使用独立参数. 另一个使用独立参数的原因是, 很多数据库接口程序还不支持 DSN 参数. 下面是一个非 DSN 的例子.

Table 21.3  connect() Function Attributes
表 21.3 connect()   函数 属性
Parameter       Description
参数            描述
user            Username 
password        Password 
host            Hostname
database        Database name

dsn             Data source name



connect() calls. Note that not all adapters have implemented the specification exactly, e.g., MySQLdb uses db instead of database.
connect()调用. 注意不是所有的接口程序都是严格按照规范实现的. MySQLdb 就使用了 db 参数而不是规范推荐的 database 参数来表示要访问的数据库.

?       MySQLdb.connect(host='dbserv', db='inv', user='smith')
?       PgSQL.connect(database='sales')
?       psycopg.connect(database='template1', user='pgsql')
?       gadfly.dbapi20.connect('csrDB', '/usr/local/database')
?       sqlite3.connect('marketing/test')

Exceptions
异常
Exceptions that should also be included in the compliant module as globals are shown in Table 21.4.
兼容标准的模块也应该提供这些异常类. 见表 21.4
21.2.2 Connection Objects
连接对象

Connections are how your application gets to talk to the database. They represent the fundamental communication mechanism by which commands are sent to the server and results returned. Once a connection has been estab- lished (or a pool of connections), you create cursors to send requests to and receive replies from the database.
要与数据库进行通信, 必须先和数据库建立连接. 连接对象处理命令如何送往服务器, 以及如何从服务器接收数据等基础功能. 连接成功(或一个连接池)后你就能够向数据库服务器发送请求, 得到响应.

Table 21.4  DB-API Exception Classes
表21.4 DB-API 异常类
Exception       Description
异常            描述
Warning             Root warning exception class
警告                警告异常基类
Error               Root error exception class 
错误                错误异常基类
InterfaceError      Database interface (not database) error 
接口错误            数据库接口错误
DatabaseError       Database error
数据库错误          数据库错误
DataError           Problems with the processed data 
数据错误            处理数据时出错
OperationalError    Error during database operation execution 
操作错误            数据库执行命令时出错
IntegrityError      Database relational integrity error 
完整性错误          数据完整性错误
InternalError       Error that occurs within the database 
内部错误            数据库内部出错
ProgrammingError    SQL command failed
程序错误            SQL 执行失败 
NotSupportedError   Unsupported operation occurred
不支持错误          试图执行数据库不支持的特性


Methods
方法

Connection objects are not required to have any data attributes but should define the methods shown in Table 21.5.
连接对象没有必须定义的数据属性, 但是它至少应该定义表21.5中的这些方法.
　When close() is used, the same connection cannot be used again with- out running into an exception.
一旦执行了 close() 方法, 再试图使用连接对象的方法将会导致异常. 
　The  commit() method  is  irrelevant  if  the  database  does  not  support transactions or if it has an auto-commit feature that has been enabled. You can implement separate methods to turn auto-commit off or on if you wish. Since this method is required as part of the API, databases that do not have the concept of transactions should just implement “pass” for this method.
对不支持事务的数据库或者虽然支持事务, 但设置了自动提交(auto-commit)的数据库系统来说, commit()方法什么也不做. 如果你确实需要, 可以实现一个自定义方法来关闭自动提交行为. 由于 DB-API 要求必须实现此方法, 对那些没有事务概念的数据库来说, 这个方法只需要有一条 pass 语句就可以了. 
　Like  commit(),  rollback() only  makes  sense  if  transactions  are  supported in the database. After execution, rollback() should leave the data- base in the same state as it was when the transaction began. According to PEP  249,  “Closing  a  connection  without  committing  the  changes  first  will cause an implicit rollback to be performed.”
类似 commit(), rollback() 方法仅对支持事务的数据库有意义. 执行完rollback(), 数据库将恢复到提交事务前的状态. 根据 PEP249, 在提交commit()之前关闭数据库连接将会自动调用rollback()方法. 

　If the RDBMS does not support cursors, cursor() should still return an object that faithfully emulates or imitates a real cursor object. These are just the minimum requirements. Each individual adapter developer can always add special attributes specifically for their interface or database.
对不支持游标的数据库来说, cursor()方法仍然会返回一个尽量模仿游标对象的对象. 这些是最低要求. 特定数据库接口程序的开发者可以任意为他们的接口程序添加额外的属性, 只要他们愿意.

　It is also recommended but not required for adapter writers to make all database  module  exceptions  (see  above)  available  via  a  connection.  If  not, then  it  is  assumed  that  Connection objects  will  throw  the  corresponding module-level  exception.  Once  you  have  completed  using  your  connection and  cursors  closed,  you  should  commit() any  operations  and  close() your connection.
DB-API规范建议但不强制接口程序的开发者为所有数据库接口模块编写异常类. 如果没有提供异常类, 则假定该连接对象会引发一致的模块级异常. 一旦你完成了数据库连接, 并且关闭了游标对象, 你应该执行 commit() 提交你的操作, 然后关闭这个连接. 

Table 21.5  Connection Object Methods
表 21.5  连接对象方法
Method Name     Description

close()         Close database connection 
close()         关闭数据库连接
commit()        Commit currenttransaction 
commit()        提交当前事务
rollback()      Cancel current transaction
rollback()      取消当前事务
cursor()        Create (and return) a cursor or cursor-like object using this connection
cursor()        使用这个连接创建并返回一个游标或类游标的对象

errorhandler(cxn, cur, errcls, errval) 错误处理


21.2.3 Cursor Objects
游标对象

Once  you  have  a  connection,  you  can  start  talking  to  the  database.  As  we mentioned above in the introductory section, a cursor lets a user issue data- base commands and retrieve rows resulting from queries. A Python DB-API cursor object functions as a cursor for you, even if cursors are not supported
in the database. In this case, the database adapter creator must implement CURSOR objects so that they act like cursors. This keeps your Python code consistent when you switch between database systems that have or do not have cursor support.
当你建立连接之后, 就可以与数据库进行交互. 我们在前面那一小节提交, 一个游标允许用户执行数据库命令和得到查询结果. 一个 Python DB-API 游标对象总是扮演游标的角色, 无论数据库是否真正支持游标. 从这一点讲, 数据库接口程序必须实现游标对象. 只有这样, 才能保证无论使用何种后端数据库你的代码都不需要做任何改变.

　Once you have created a cursor, you can execute a query or command (or multiple queries and commands) and retrieve one or more rows from the results set. Table 21.6 shows data attributes and methods that cursor objects have.
创建游标对象之后, 你就可以执行查询或其它命令(或者多个查询和多个命令), 也可以从结果集中取出一条或多条记录. 表 21.6 列举了游标对象拥有的属性和方法. 

Table 21.6  Cursor Object Attributes
表 21.6 游标对象的属性
Object Attribute        Description
对象属性                描述
arraysize       Number of rows to fetch at a time with fetch- many(); defaults to 1
arraysize       使用fechmany()方法一次取出多少条记录, 默认值为 1
connection      Connection that created this cursor (optional)
connectionn     创建此游标对象的连接(可选)

description     Returns cursor activity (7-item tuples): (name, type_code, display_size, internal_ size, precision, scale, null_ok); only name and type_code are required
描述            返回游标活动状态(一个包含七个元素的元组): (name, type_code, display_size, internal_ size, precision, scale, null_ok); 只有 name 和 type_code 是必须提供的. 

lastrowid       Row ID of last modified row (optional; if row IDs not supported, default to None)
lastrowid       返回最后更新行的 id (可选), 如果数据库不支持行 id, 默认返回 None)
rowcount        Number of rows that the last execute*() produced or affected
rowcount        最后一次 execute() 操作返回或影响的行数. 

callproc(func[,args]) Call a stored procedure
callproc(func[,args]) 调用一个存储过程

close() Close cursor
close() 关闭游标对象


execute(op[,args])
execute(op[,args]) 执行一个数据库查询或命令
executemany(op,args)  Execute a database query or command

Like execute() and map() combined; prepare
and execute a database query or command over given
arguments
类似 execute() 和 map() 的结合, 为给定的每一个参数准备并执行一个数据库查询/命令
Table 21.6  Cursor Object Attributes (continued)
表 21.6 游标对象属性(续)
Object Attribute        Description
对象属性                描述

fetchone()      Fetch next row of query result
fetchone()      得到结果集的下一行

fetchmany([size=cursor.arraysize]) Fetch next size rows of query result
fetchmany([size=cursor.arraysize]) 得到结果集的下几行 (几 = size)

fetchall()      Fetch all (remaining) rows of a query result
fetchall()      返回结果集中剩下的所有行

__iter__()      Create iterator object from this cursor (optional; also see next())
__iter__()      创建一个迭代对象 (可选; 参阅 next())

messages        List of messages (set of tuples) received from the database for cursor execution (optional)
messages        游标执行后数据库返回的信息列表 (元组集合) (可选)

next()  Used by iterator to fetch next row of query result(optional; like fetchone(), also see __iter__())
next()  使用迭代对象得到结果集的下一行(可选; 类似 fetchone(), 参阅 __iter__())

nextset()       Move to next results set (if supported)
nextset()       移到下一个结果集 (如果支持的话)

rownumber       Index of cursor (by row, 0-based) in current result set(optional)
rownumber       当前结果集中游标的索引 (以行为单位, 从0开始) (可选)


setinput- sizes(sizes) Set maximum input size allowed (required but imple- mentation optional)
setinput- sizes(sizes) 设置输入最大值 (必须有, 但具体实现是可选的)

setoutput- size(size[,col]) Set maximum buffer size for large column fetches(required but implementation optional)
setoutput- size(size[,col]) 设置大列的缓冲区大写(必须有, 但具体实现是可选的)


The most critical attributes of cursor objects are the execute*() and the
fetch*() methods . . . all the service requests to the database are performed
by these. The arraysize data attribute is useful in setting a default size for
fetchmany(). Of course, closing the cursor is a good thing, and if your data-
base supports stored procedures, then you will be using callproc().
游标对象最重要的属性是 execute*() 和 fetch*() 方法. 所有对数据库服务器的请求都由它们来完成.对fetchmany()方法来说, 设置一个合理的arraysize 属性会很有用. 当然, 在不需要时关掉游标对象也是个好主意. 如果你的数据库支持存储过程, 你就可以使用callproc() 方法.  


21.2.4 Type Objects and Constructors
类型对象和构造器

Oftentimes, the interface between two different systems are the most fragile. This is seen when converting Python objects to C types and vice versa. Similarly, there is also a fine line between Python objects and native database objects. As a programmer writing to Python’s DB-API, the parameters you send to a database
are given as strings, but the database may need to convert it to a variety of differ- ent, supported data types that are correct for any particular query.
通常两个不同系统的接口要求的参数类型是不一致的,譬如python调用c函数时Python对象和C类型之间就需要数据格式的转换, 反之亦然. 类似的, 在Python对象和原生数据库对象之间也是如此. 对于 Python DB-API 的开发者来说, 你传递给数据库的参数是字符串形式的, 但数据库会根据需要将它转换为多种不同的形式. 以确保每次查询能被正确执行. 

　For  example,  should  the  Python  string  be  converted  to  a  VARCHAR,  a TEXT,  a  BLOB,  or  a  raw  BINARY  object,  or  perhaps  a  DATE  or  TIME object if that is what the string is supposed to be? Care must be taken to pro- vide  database  input  in  the  expected  format,  so  because  of  this  another requirement  of  the  DB-API  is  to  create  constructors  that  build  special objects  that  can  easily  be  converted  to  the  appropriate  database  objects. Table 21.7 describes classes that can be used for this purpose. SQL NULL values are mapped to and from Python’s NULL object, None.
举例来说, 一个 Python 字符串可能被转换为一个 VARCHAR, 或一个TEXT, 或一个BLOB, 或一个原生 BINARY 对象, 或一个DATE或TIME对象. 一个字符串到底会被转换成什么类型? 必须小心的尽可能以数据库期望的数据类型来提供输入, 因此另一个DB-API的需求是创建一个构造器以生成特殊的对象, 以便能够方便的将Python对象转换为合适的数据库对象. 表21.7描述了可以用于此目的的类. SQL 的 NULL 值被映射为 Pyhton的 NULL 对象, 也就是 None. 


Table 21.7  Type Objects and Constructors
表21.7 类型对象和构造器
Type Object     Description
类型对象        描述
Date(yr,mo,dy)  Object for a date value
Date(yr,mo,dy)  日期值对象

Time(hr,min,sec)        Object for a time value
Time(hr,min,sec)        时间值对象


Timestamp(yr,mo,dy,hr, min,sec) Object for a timestamp value
Timestamp(yr,mo,dy,hr, min,sec) 时间戳对象

DateFromTicks(ticks) Date object given number of seconds since the epoch
DateFromTicks(ticks) 通过自1970-01-01 00:00:01 utc以来的ticks秒数得到日期

TimeFromTicks(ticks) Time object given number of seconds since the epoch
TimeFromTicks(ticks) 通过自1970-01-01 00:00:01 utc以来的ticks秒数得到时间值对象

TimestampFromTicks(ticks) Timestamp object given number of seconds since the epoch
TimestampFromTicks(ticks) 通过自1970-01-01 00:00:01 utc以来的ticks秒数得到时间戳对象

Binary(string)  Object for a binary (long) string value
Binary(string)  对应二进制长字符串值的对象

STRING  Object describing string-based columns, e.g., VARCHAR
STRING  描述字符串列的对象, 比如 VARCHAR

BINARY  Object describing (long) binary columns, i.e., RAW, BLOB
BINARY  描述二进制长列的对象 比如 RAW, BLOB

NUMBER  Object describing numeric columns 
NUMBER  描述数字列的对象
DATETIME      Object describing date/time columns 
DATETIME      描述日期时间列的对象
ROWID       Object describing “row ID” columns
ROWID       描述 “row ID” 列的对象

Changes to API Between Versions
DB-API版本变更

Several important changes were made when the DB-API was revised from version 1.0 (1996) to 2.0 (1999):
有几个重要的变更发生在 DB-API 从1.0(1996)升级到2.0(1999)时:
?       Required dbi module removed from API
从API中移除了原来必须的 dbi 模块
?       Type objects were updated
更新了类型对象
?       New attributes added to provide better database bindings
增加了新的属性以提供更易用的数据库绑定
?       callproc() semantics and return value of execute() redefined
变更了 callproc() 的语义及重定义了 execute() 的返回值
?       Conversion to class-based exceptions
基于异常的错误处理

　Since version 2.0 was published, some of the additional optional DB-API extensions that you read about above were added in 2002. There have been no other significant changes to the API since it was published. Continuing discussions of the API occur on the DB-SIG mailing list. Among the topics brought up over the last 5 years include the possibilities for the next ver- sion  of  the  DB-API,  tentatively  named  DB-API  3.0.  These  include  the following:
自从 DB-API 2.0 发布以来, 曾经在2002年加入了一些可选的 DB- API扩展, 但一直没有什么重大的变更. 在DB-SIG邮件列表中一直在讨论DB-API的未来版本 -- 暂时命名为 DB-API 3.0. 它将包括以下特性:  

?       Better return value for nextset() when there is a new result set
当有一个新的结果集时nextset()会有一个更合适的返回值
?       Switch from float to Decimal
float 变更为 Decimal
?       Improved flexibility and support for parameter styles
支持更灵活的参数风格
?       Prepared statements or statement caching
预备语句或语句缓存
?       Refine the transaction model
优化事务模型
?       State the role of API with respect to portability
确定 DB-API 可移值性的角色
?       Add unit testing
增加单元测试
　If you have strong feelings about the API, feel free to participate and join in the discussion. Here are some references you may find handy.
如果你对这些API特别感兴趣, 欢迎积极参与. 下面有一些手边的资源.

?       http://python.org/topics/database
?       http://www.linuxjournal.com/article/2605
?       http://wiki.python.org/moin/DbApi3


21.2.5 Relational Databases
关系数据库

So,  you  are  now  ready  to  go.  A  burning  question  must  be,  “Interfaces  to which database systems are available to me in Python?” That inquiry is simi- lar  to,  “Which  platforms  is  Python  available  for?”  The  answer  is,  “Pretty much all of them.” Following is a list that is comprehensive but not exhaustive:
现在我们准备开始, 一个问题摆在面前, 在Pyhton 里我可以使用哪种数据库接口? 换言之, Python支持哪些平台? 答案是几乎所有的平台. 下面是一个不怎么完整的数据库支持列表:

Commercial RDBMSs
商业关系数据库管理系统

?       Informix
?       Sybase
?       Oracle
?       MS SQL Server
?       DB/2
?       SAP
?       Interbase
?       Ingres

Open Source RDBMSs
开源关系数据库管理系统
?       MySQL
?       PostgreSQL
?       SQLite
?       Gadfly

Database APIs
数据库APIs
?       JDBC
?       ODBC

To find a current list of what databases are supported, check out:
要知道 Python 支持哪些数据库, 请参阅下面网址:

http://python.org/topics/database/modules.html


21.2.6 Databases and Python: Adapters
数据库和Python：接口程序

For each of the databases supported, there exists one or more adapters that let you connect to the target database system from Python. Some databases, such as Sybase, SAP, Oracle, and SQLServer, have more than one adapter available. The best thing to do is to find out which ones fit your needs best. Your questions for each candidate may include: how good its performance is, how  useful  is  its  documentation  and/or  Web  site,  whether  it  has  an  active community or not, what the overall quality and stability of the driver is, etc. You have to keep in mind that most adapters provide just the basic necessities
to get you connected to the database.  It is the extras that you may be looking for. Keep in mind that you are responsible for higher-level code like thread- ing and thread management as well as management of database connection pools, etc.
对每一种支持的数据库, 都有一个或多个Python接口程序允许你连接到目标数据库系统. 某些数据库, 比如 Sybase, SAP, Oracle和SQLServer, 都有两个或更多个接口程序可供选择. 你要做的就是挑选一个最能满足你需求的接口程序. 你挑选接口程序的标准可以是: 性能如何? 文档或WEB站点的质量如何? 是否有一个活跃的用户或开发社区? 接口程序的质量和稳定性如何? 等等等等. 记住绝大多数接口程序只提供基本的连接功能, 你可能需要一些额外的特性. 高级应用代码如线程和线程管理以及数据库连接池的管理等等, 需要你自己来完成. 

If you are squeamish and want less hands-on—for example, if you wish to do
as little SQL or database administration as much as possible—then you may wish to consider object-relational mappers, covered later on in this chapter.
Let us now look at some examples of how to use an adapter module to talk
to a relational database. The real secret is in setting up the connection. Once you have this and use the DB-API objects, attributes, and object methods, your core code should be pretty much the same regardless of which adapter and RDBMS you use.
如果你不想处理这些, 比方你不喜欢自己写SQL, 也不想参与数据库管理的细节--那么本章后面讲到的 ORM应该可以满足你的要求. 现在来看一些使用接口程序访问数据库的例子, 关键之处在于设置数据库连接.在建立连接之后, 不管后端是何种数据库, 对 DB-API 对象的属性和方法进行操作都是一样的.

21.2.7 Examples of Using Database Adapters
使用数据库接口程序举例

First, let us look at a some sample code, from creating a database to creating
a table and using it. We present examples using MySQL, PostgreSQL, and
SQLite.
首先, 我们来看一下例子代码, 创建数据库, 创建表, 使用表. 我们分别提供了使用 MySQL, PostgreSQL, SQLite 的例子.
 
MySQL

We will use MySQL as the example here, along with the only MySQL Python adapter: MySQLdb, aka MySQL-python. In the various bits of code, we will also show you (deliberately) examples of error situations so that you have an idea of what to expect, and what you may wish to create handlers for.
这里我们以 MySQL 数据库为例, 使用唯一的 MySQL 接口程序: MySQLdb, 这个接口程序又名 MySQL-python. 在这部分代码里, 我们故意在例子里埋下一个错误
　We first log in as an administrator to create a database and grant permis- sions, then log back in as a normal client.
首先我们以管理员身份登录, 创建一个数据库, 并赋予相应权限, 之后我们再以普通用户身份登录数据库. 以便你能了解你希望得到什么, 这样你会想到为它创建一个事件处理程序.

>>> import MySQLdb
>>> cxn = MySQLdb.connect(user='root')
>>> cxn.query('DROP DATABASE test') Traceback (most recent call last):
File "<stdin>", line 1, in ?
_mysql_exceptions.OperationalError: (1008, "Can't drop database 'test'; database doesn't exist")
>>> cxn.query('CREATE DATABASE test')
>>> cxn.query("GRANT ALL ON test.* to ''@'localhost'")
>>> cxn.commit()
>>> cxn.close()

　In the code above, we did not use a cursor. Some adapters have Connec- tion objects, which can execute SQL queries with the query() method, but not all. We recommend you either not use it or check your adapter to make sure it is available.
The commit() was optional for us as auto-commit is turned on by default
in MySQL. We then connect back to the new database as a regular user, cre-
ate a table, and perform the usual queries and commands using SQL to get our  job  done  via  Python.  This  time  we  use  cursors  and  their  execute() method.
在上面的代码中， 我们没有使用cursor对象。某些（但不是所有的）接口程序拥有连接对象， 这些连接对象拥有query()方法， 可以执行SQL查询。我们建议你不要使用这个方法， 或者事先检查该方法在当前接口程序当中是否可用。之后我们以普通用户身份再次连接这个新数据， 创建表， 然后通过Python执行SQL查询和命令, 来完成我们的工作。这次我们使用游标对象(cursors)和它们的execute()方法, 下一个交互集演示了创建表。


The next set of interactions shows us creating a table. An attempt to create
it again (without first dropping it) results in an error.
下面的代码演示了如何创建一个表. 在删除一个表之前如果试图重建这个表将产生错误.

>>> cxn = MySQLdb.connect(db='test')
>>> cur = cxn.cursor()
>>> cur.execute('CREATE TABLE users(login VARCHAR(8), uid INT)')
0L

Now we will insert a few rows into the database and query them out.
现在我们来插入几行数据到数据库, 然后再将它们取出来.

>>> cur.execute("INSERT INTO users VALUES('john', 7000)")
1L
>>> cur.execute("INSERT INTO users VALUES('jane', 7001)")
1L
>>> cur.execute("INSERT INTO users VALUES('bob', 7200)")
1L
>>> cur.execute("SELECT * FROM users WHERE login LIKE 'j%'")
2L
>>> for data in cur.fetchall():
...     print '%s\t%s' % data
...
john    7000
jane    7001

The last bit features updating the table, either updating or deleting rows.
最后一个特性是更新表, 包括更新或删除数据.

>>> cur.execute("UPDATE users SET uid=7100 WHERE uid=7001")
1L
>>> cur.execute("SELECT * FROM users")
3L
>>> for data in cur.fetchall():
...     print '%s\t%s' % data
...
john    7000 jane       7100 bob        7200
>>> cur.execute('DELETE FROM users WHERE login="bob"')
1L
>>> cur.execute('DROP TABLE users')
0L
>>> cur.close()
>>> cxn.commit()
>>> cxn.close()

　MySQL is one of the most popular open source databases in the world, and it is no surprise that a Python adapter is available for it. Keep in mind that  no  database  modules  are  available  in  the  Python  standard  library—all
adapters are third-party packages that have to be downloaded and installed separately from Python. Please see the References section toward the end of the chapter to find out how to download it.
Mysql 是最流行的开源数据库之一. 毫无疑问会有一个针对 MySQL的 Python接口程序. 不过Python标准库中并没有集成这个接口程序, 这是一个第三方包, 你需要单独下载并安装它. 在本章的末尾的索引页, 你可以找到如何下载它. 


PostgreSQL

Another popular open source database is PostgreSQL. Unlike MySQL, there are no less than three current Python adapters available for Postgres: psy- copg, PyPgSQL, and PyGreSQL. A fourth, PoPy, is now defunct, having contributed its project to combine with that of PyGreSQL back in 2003. Each of the three remaining adapters has its own characteristics, strengths, and weaknesses,  so  it  would  be  a  good  idea  to  practice  due  diligence  to  determine which is right for you.
另一个著名的开源数据库是 PostgreSQL. 与 MySQL不同, 有至少 3 个 Python 接口程序可以访问 PosgreSQL: psycopg, PyPgSQL 和 PyGreSQL. 第四个, PoPy, 现在已经被废弃(2003年, 它贡献出自己的代码, 与PygreSQL整合在一起). 这三个接口程序各有长处, 各有缺点, 根据实践结果选择使用哪个接口是个好主意.  

　The good news is that the interfaces are similar enough that you can create an application that, say, measures the performance between all three (if that
is a metric that is important to you). Here we show you the setup code to get
a Connection object for each:

多亏他们都支持 DB-API, 所以他们的接口基本一致, 你只需要写一个应用程序, 然后分别测试这三个接口的性能(如果性能对你的程序很重要的化). 下面我给出这三个接口的连接代码:
psycopg

>>> import psycopg
>>> cxn = psycopg.connect(user='pgsql')

PyPgSQL

>>> from pyPgSQL import PgSQL
>>> cxn = PgSQL.connect(user='pgsql')

PyGreSQL

>>> import pgdb
>>> cxn = pgdb.connect(user='pgsql')

Now comes some generic code that will work for all three adapters.
好, 下面的代码就能够在所有接口程序下工作了.

>>> cur = cxn.cursor()
>>> cur.execute('SELECT * FROM pg_database')
>>> rows = cur.fetchall()
>>> for i in rows:
...     print i
>>> cur.close()
>>> cxn.commit()
>>> cxn.close()

Finally, you can see how their outputs are slightly different from one another.
最后, 你会发现他们的输出有一点点轻微的不同.

PyPgSQL

sales template1 template0

psycopg

('sales', 1, 0, 0, 1, 17140, '140626', '3221366099',
'', None, None)
('template1', 1, 0, 1, 1, 17140, '462', '462', '', None,
'{pgsql=C*T*/pgsql}')
('template0', 1, 0, 1, 0, 17140, '462', '462', '', None,
'{pgsql=C*T*/pgsql}')

PyGreSQL

['sales', 1, 0, False, True, 17140L, '140626',
'3221366099', '', None, None]
['template1', 1, 0, True, True, 17140L, '462', '462',
'', None, '{pgsql=C*T*/pgsql}']
['template0', 1, 0, True, False, 17140L, '462',
'462', '', None, '{pgsql=C*T*/pgsql}']

SQLite

For extremely simple applications, using files for persistent storage usually suffices,  but  the  most  complex  and  data-driven  applications  demand  a  full relational database. SQLite targets the intermediate systems and indeed is a hybrid of the two. It is extremely lightweight and fast, plus it is serverless and requires little or no administration.
对非常简单的应用来说, 使用文件进行持久存储通常就足够了. 但对于绝大多数数据驱动的应用程序必须使用全功能的关系数据库. SQLite 介于二者之间, 它定位于中小规模的应用.它是相当轻量级的全功能关系型数据库, 速度很快, 几乎不用配置, 并且不需要服务器. 


　SQLite has seen a rapid growth in popularity, and it is available on many platforms.  With  the  introduction  of  the  pysqlite database  adapter  in Python 2.5 as the sqlite3 module, this marks the first time that the Python standard library has featured a database adapter in any release.
SQLite 正在快速的流行. 并且在各个平台上都能用.  在 python2.5集成了前面介绍的 pysqlite 数据库接口程序, 作为 python2.5的 sqlite3 模块. 这是 Python 标准库第一次将一个数据库接口程序纳入标准库, 也许这标志着一个新的开始.

　It was bundled with Python not because it was favored over other databases and adapters, but because it is simple, uses files (or memory) as its backend store like the DBM modules do, does not require a server, and does not have licensing issues. It is simply an alternative to other similar persistent storage solutions included with Python but which happens to have a SQL interface. Having a module like this in the standard library allows users to develop rapidly in Python using SQLite, then migrate to a more powerful RDBMS such  as  MySQL,  PostgreSQL,  Oracle,  or  SQL  Server  for  production  pur- poses if this is their intention. Otherwise, it makes a great solution to stay with for those who do not need all that horsepower.
它被打包到 Python 当中并不是因为他比其它的数据库接口程序更优秀, 而是因为他足够简单, 使用文件(或内存)作为它的后端存储, 就象 DBM 模块做的那样, 不需要服务器, 而且也不存在授权问题. 它是Python中其它的持久存储解决方案的一个替代品, 一个拥有 SQL 访问界面的优秀替代品. 在标准库中有这么一个模块, 就能方便用户使用Python 和 SQLite 进行软件开发, 等到软件产品正式上市发布时, 只要需要, 就能够很容易的将产品使用的数据库后端变更为一个全功能的, 更强大的类似 MySQL, PostgreSQL, Oracle 或 SQL Server 那样的数据库. 当然, 对那些不需要那么大马力的应用程序来说, SQLite 已经足够使用. :)

　Although the database adapter is now provided in the standard library, you still have to download the actual database software yourself. However, once you have installed it, all you need to do is start up Python (and import the adapter) to gain immediate access:
尽管标准库已经提供了数据库接口程序, 你仍然需要自己下载真正的数据库软件.(作者好像此处犯糊涂了. sqlite 是不需要额外下载东西的, 只要有接口程序就可以工作). 一旦你安装好之后, 你只需要打开 Python 解释器, 下面是一个例子:

>>> import sqlite3
>>> cxn = sqlite3.connect('sqlite_test/test')
>>> cur = cxn.cursor()
>>> cur.execute('CREATE TABLE users(login VARCHAR(8), uid
INTEGER)')
>>> cur.execute('INSERT INTO users VALUES("john", 100)')
>>> cur.execute('INSERT INTO users VALUES("jane", 110)')
>>> cur.execute('SELECT * FROM users')
>>> for eachUser in cur.fetchall():
...     print eachUser
...
(u'john', 100)
(u'jane', 110)
>>> cur.execute('DROP TABLE users')
<sqlite3.Cursor object at 0x3d4320>
>>> cur.close()
>>> cxn.commit()
>>> cxn.close()

　Okay, enough of the small examples. Next, we look at an application simi- lar to our earlier example with MySQL, but which does a few more things:
OK, 这个小例子已经足够了. 接下来, 我们来看一个小程序, 它类似前面使用 MySQL 的例子,不过更简单一些. 

?       Creates a database (if necessary)
?       Creates a table
?       Inserts rows into the table
?       Updates rows in the table
?       Deletes rows from the table
?       Drops the table

　For this example, we will use two other open source databases. SQLite has become quite popular of late. It is very small, lightweight, and extremely fast for all the most common database functions. Another database involved in this example is Gadfly, a mostly SQL-compliant RDBMS written entirely in Python.  (Some  of  the  key  data  structures  have  a  C  module  available,  but Gadfly can run without it [slower, of course].)
对这个例子来说中, 我们仍然使用两个其它的开源数据库. SQLite 现如今已经相当流行. 它体积小, 而且足够快, 是一个几乎拥有全部功能的相当轻量级的数据库. 这个例子中用到的另一个数据库是 Gadfly, 一个基本兼容 SQL 的纯 Python 写成的关系数据库. (某些关键的数据库结构有一个C模块, 不过 Gadfly 没有它也一样可以运行[当然, 会慢不少, 嘿嘿]).

　Some notes before we get to the code. Both SQLite and Gadfly require the  user  to  give  the  location  to  store  database  files  (while  MySQL  has  a default area and does not require this information from the use). The most
current incarnation of Gadfly is not yet fully DB-API 2.0 compliant, and as a result, is missing some functionality, most notably the cursor attribute rowcount
in our example.
在进入代码之前, 有几个提醒. SQLite和Gadfly 需要用户指定保存数据库文件的位置(Mysql有一个默认区域保存数据, 在使用Mysql数据库时无需指定这个). 另外, Gadfly 目前的版本还不兼容 DB-API 2.0, 也就是说, 它缺失一些功能, 尤其是缺少我们例子中用到的 cursor 属性 rowcount.

Database Adapter Example Application
数据库接口程序应用程序举例

In the example below, we want to demonstrate how to use Python to access a database. In fact, for variety, we added support for three different database systems: Gadfly, SQLite, and MySQL. We are going to create a database (if one does not already exist), then run through various database operations such
as creating and dropping tables, and inserting, updating, and deleting rows. Example 21.1 will be duplicated for the upcoming section on ORMs as well.

在下面这个例子里, 我们演示了 Python 如何访问数据库. 事实上, 我们的程序支持三种不同的数据库系统: Gadfly, SQLite 和 MySQL. 我们将要创建一个数据库(如果它不存在的话). 然后进行多种数据库操作, 比如创建表, 删除表, 插入数据, 更新数据, 删除数据等等.
在下一小节中的 ORM 中我们将重复例子21.1 的这些功能.

Line-by-Line Explanation
逐行解释

Lines 1–18
The first part of this script imports the necessary modules, creates some glo- bal “constants” (the column size for display and the set of databases we are supporting), and features the setup() function, which prompts the user to select the RDBMS to use for any particular execution of this script.
　The  most  notable  constant  here  is  DB_EXC,  which  stands  for  DataBase EXCeption. This variable will eventually be assigned the database exception module for the specific database system that the users chooses to use to run this application with. In other words, if users choose MySQL, DB_EXC will be _mysql_exceptions, etc. If we developed this application in more of an object-oriented fashion, this would simply be an instance attribute, i.e.,
self.db_exc_module or something like that.
第1-18行
脚本的第一部分导入必须的模块, 创建一些"全局常量"(列的显示大小及我们的程序支持的数据库).  其中 setup() 函数, 提供一个简单界面让用户选择使用哪种数据库.
值得留意的是 DB_EXC 常量, 它代表数据库异常.  他最终的值由用户最终选择使用的数据库决定. 也就是说, 如果用户选择 MySQL, DB_EXC 将是 _mysql_exceptions, 以此类推... 如果我们用流行的面向对象的方式来开发这个应用, 它将会以一个实例属性的方式表示, 比如 self.db_exc_module 或者什么别的名字. 

Lines 20–75
The  guts  of  consistent  database  access  happens  here  in  the  connect() function. At the beginning of each section, we attempt to load the requested database modules. If a suitable one is not found, None is returned to indicate that the database system is not supported.
第20-75行
表现数据库存取一致性本质的connect()函数在这一段. 在每一小节的开头, 我们尝试载入需要的数据库模块. 如果找不到合适的模块, None 值被返回, 表示这个数据库系统暂不支持.

　Once a connection is made, then all other code is database and adapter independent and should work across all connections. (The only exception in our script is insert().) In all three subsections of this set of code, you will notice that a valid connection should be passed back as cxn.
在数据库连接建立以后, 其余的代码对数据库和接口程序来说都是透明的(不区分哪种数据库, 哪种接口程序, 代码都可以工作). 有一个唯一的例外, 就是脚本的 insert()函数.  在所有三个小节的这段代码里, 数据库连接成功后会返回一个连接对象 cxn.

If SQLite is chosen (lines 24–36), we attempt to load a database adapter.
We first try to load the standard library’s sqlite3 module (Python 2.5+). If that fails, we look for te third-party pysqlite2 package. This is to support 2.4.x and older systems with the pysqlite adapter installed. 

如果选中了 SQLite(24行-36行), 我们尝试载入一个数据库接口程序. 我们首先尝试载入标准库模块 sqlite3(Python2.5及更高版本支持), 如果载入失败, 就会去寻找第三方 pysqlite2 包. 这个包支持 Python 2.4.x 或更老些的系统.

If a suitable adapter is found, we then check to ensure that the directory exists because the data-base  is  file  based.  (You  may  also  choose  to  create  an  in-memory  database.) When  the  connect() call  is  made  to  SQLite,  it  will  either  use  one  that already exists or make a new one using that path if it does not.
如果成功导入合适的接口程序, 由于SQLite是基于文件的数据库系统,同我们需要确认一下数据库文件所在的目录是否存在.(当然, 你也可以选择在内存里创建一个数据库). 当调用 connect() 函数时, 如果这个数据库文件已经存在, SQLite 会使用这个数据库, 如果文件不存, 它就会创建一个新文件.

Example 21.1   Database Adapter Example (ushuffle_db.py)
例子21.1 数据库接口程序示例

This script performs some basic operations using a variety of databases (MySQL, SQLite, Gadfly) and a corresponding Python database adapter.
这段脚本使用同样的接口对多种数据库执行了一些数据库基本操作. 
1       #!/usr/bin/env python
2
3       import os
4       from random import randrange as rrange
5
6       COLSIZ = 10
7       RDBMSs = {'s': 'sqlite', 'm': 'mysql', 'g': 'gadfly'}
8       DB_EXC = None
9


12    Choose a database system:
13
14    (M)ySQL
15    (G)adfly
16    (S)QLite
17
18    Enter choice: ''').strip().lower()[0]]
19
20    def connect(db, dbName):
21      global DB_EXC
22      dbDir = '%s_%s' % (db, dbName)
23
24      if db == 'sqlite':
25      try:
26      import sqlite3
27      except ImportError, e:
28      try:
29      from pysqlite2 import dbapi2 as sqlite3
30      except ImportError, e:
31      return None
32
33      DB_EXC = sqlite3
34      if not os.path.isdir(dbDir):
35      os.mkdir(dbDir)
36      cxn = sqlite.connect(os.path.join(dbDir, dbName))
37
38      elif db == 'mysql':
39      try:


42      except ImportError, e:
43      return None
44
45      try:
46      cxn = MySQLdb.connect(db=dbName)
47      except _mysql_exceptions.OperationalError, e:



Example 21.1   Database Adapter Example (ushuffle_db.py)
例子21.1 数据库接口程序示例
(continued)
(继续...)
48      cxn = MySQLdb.connect(user='root')
49      try:
50      cxn.query('DROP DATABASE %s' % dbName)
51      except DB_EXC.OperationalError, e:
52      pass
53      cxn.query('CREATE DATABASE %s' % dbName)
54      cxn.query("GRANT ALL ON %s.* to ''@'localhost'" % dbName)
55      cxn.commit()
56      cxn.close()
57      cxn = MySQLdb.connect(db=dbName)
58
59      elif db == 'gadfly':
60      try:
61      from gadfly import gadfly
62      DB_EXC = gadfly
63      except ImportError, e:
64      return None
65
66      try:
67      cxn = gadfly(dbName, dbDir)
68      except IOError, e:
69      cxn = gadfly()
70      if not os.path.isdir(dbDir):
71      os.mkdir(dbDir)
72      cxn.startup(dbName, dbDir)
73      else:
74      return None
75      return cxn
76


79      cur.execute('''
80      CREATE TABLE users (
81      login VARCHAR(8),
82      uid INTEGER,
83      prid INTEGER)
84      ''')
85      except DB_EXC.OperationalError, e:
86      drop(cur)
87      create(cur)
88
89    drop = lambda cur: cur.execute('DROP TABLE users')
90
91    NAMES = (
92      ('aaron', 8312), ('angela', 7603), ('dave', 7306),
93      ('davina',7902), ('elliot', 7911), ('ernie', 7410),
94      ('jess', 7912), ('jim', 7512), ('larry', 7311),
95      ('leslie', 7808), ('melissa', 8602), ('pat', 7711),
96      ('serena', 7003), ('stan', 7607), ('faye', 6812),
97      ('amy', 7209),
98    )
99
100  def randName():
101     pick = list(NAMES)
102     while len(pick) > 0:
103     yield pick.pop(rrange(len(pick)))
104
105  def insert(cur, db):
106     if db == 'sqlite':
107     cur.executemany("INSERT INTO users VALUES(?, ?, ?)",
108     [(who, uid, rrange(1,5)) for who, uid in randName()])
109     elif db == 'gadfly':
110     for who, uid in randName():
111     cur.execute("INSERT INTO users VALUES(?, ?, ?)",
112     (who, uid, rrange(1,5)))
113     elif db == 'mysql':
114     cur.executemany("INSERT INTO users VALUES(%s, %s, %s)",
115     [(who, uid, rrange(1,5)) for who, uid in randName()])
116
117  getRC = lambda cur: cur.rowcount if hasattr(cur,
'rowcount') else -1
118
119  def update(cur):
120     fr = rrange(1,5)
121     to = rrange(1,5)
122     cur.execute(
123     "UPDATE users SET prid=%d WHERE prid=%d" % (to, fr))
124     return fr, to, getRC(cur)
125
126  def delete(cur):
127     rm = rrange(1,5)
128     cur.execute('DELETE FROM users WHERE prid=%d' % rm)
129     return rm, getRC(cur)
130
131  def dbDump(cur):
132     cur.execute('SELECT * FROM users')
133     print '\n%s%s%s' % ('LOGIN'.ljust(COLSIZ),


136     print '%s%s%s' % tuple([str(s).title().ljust(COLSIZ) \
137     for s in data])
138
139  def main():
140     db = setup()
141     print '*** Connecting to %r database' % db
142     cxn = connect(db, 'test')
143     if not cxn:
144     print 'ERROR: %r not supported, exiting' % db
145     return
146     cur = cxn.cursor()
147
148     print '\n*** Creating users table'

149     create(cur)
150
151     print '\n*** Inserting names into table'
152     insert(cur, db)
153     dbDump(cur)
154
155     print '\n*** Randomly moving folks',
156     fr, to, num = update(cur)
157     print 'from one group (%d) to another (%d)' % (fr, to)
158     print '\t(%d users moved)' % num
159     dbDump(cur)
160
161     print '\n*** Randomly choosing group',
162     rm, num = delete(cur)
163     print '(%d) to delete' % rm
164     print '\t(%d users removed)' % num
165     dbDump(cur)
166
167     print '\n*** Dropping users table'
168     drop(cur)
169     cur.close()
170     cxn.commit()
171     cxn.close()
172
173 if __name__ == '__main__':
174     main()
Example 21.1  Database Adapter Example (ushuffle_db.py)
例子21.1 数据库接口程序示例




　MySQL (lines 38–57) uses a default area for its database files and does not require this to come from the user. Our code attempts to connect to the spec- ified database. If an error occurs, it could mean either that the database does not exist or that it does exist but we do not have permission to see it. Since this is just a test application, we elect to drop the database altogether (ignor- ing any error if the database does not exist), and re-create it, granting all per- missions after that.
MySQL(38-57行)的数据文件会存保在默认的数据存储区域, 所以不需要用户指定存储位置. 我们的代码尝试连接指定的数据库. 如果发生错误, 有可能是数据库不存在或者虽然数据库存在但我们没有权限访问它. 由于这仅仅是一个测试应用程序, 我们选择完全先删掉这个数据库(忽略掉如果数据库不存在可能引发的错误), 然后重建该库, 然后给访问它的用户赋予权限. 

　The last database supported by our application is Gadfly (lines 59–75). (At the time of writing, this database is mostly but not fully DB-API–compliant, and you will see this in this application.) It uses a startup mechanism similar
to  that  of  SQLite:  it  starts  up  with  the  directory  where  the  database  files should be. If it is there, fine, but if not, you have to take a roundabout way to start up a new database. (Why this is, we are not sure. We believe that the startup() functionality  should  be  merged  into  that  of  the  constructor gadfly.gadfly().)
我们的应用程序支持的最后一个数据库是 Gadfly(第59-75行). 在本书写作的时候, 这个数据库已经几乎但还没有完全兼容 DB-API, 你也会在这个程序里看到这一点.) 它使用类似SQLite的启动机制: 它的启动目录是数据文件所在的目录. 如果数据文件在那儿, OK, 如果那儿没有数据文件, 你必须重新启动一个新的数据库.(为什么非要这样, 我们也不十分清楚. 我们认为 startup() 函数应该被合并到构造器函数 gadfly.gadfly()当中去).

Lines 77–89
The create() function creates a new users table in our database. If there is an error, that is almost always because the table already exists. If this is the case, drop the table and re-create it by recursively calling this function again. This code is dangerous in that if the recreation of the table still fails, you will have infinite recursion until your application runs out of memory. You will fix this problem in one of the exercises at the end of the chapter.
The table is dropped from the database with the one-liner drop().
第77-89行, create() 函数在数据库中创建一个新的 users 表, 如果中间产生问题, 几乎肯定是因为这个表已经存在. 如果正是这个原因的话, 删掉这个表, 然后递归调用create()函数来重新创建它. 这个代码有一个缺陷, 就是当重建表仍然失败的话, 你将陷入死循环, 直至内存耗尽.在本章最后有一道习题就是这个问题, 你可以试着修复这个潜在的bug. 


Lines 91–103
This is probably the most interesting part of the code outside of database activity. It consists of a constant set of names and user IDs followed by the generator  randName() whose  code  can  be  found  in  Chapter  11  (Func- tions)  in  Section  11.10.  The  NAMES constant  is  a  tuple  that  must  be  con- verted  to  a  list  for  use  with  randName() because  we  alter  it  in  the generator,   randomly   removing   one   name   at   a   time   until   the   list   is exhausted. Well, if NAMES was a list, we would only use it once. Instead, we make it a tuple and copy it to a list to be destroyed each time the generator
is used.
91-103行
这可能是除了数据库操作之外最有趣的代码部分了. 它由一组固定用户名及ID值的集合及一个生成器函数 randName() 构成. 这个函数的代码也可以在第11章的11.10小节找到. NAMES 常量是一个元组, 因为我们在randName()这个生成器里需要改变它的值, 所以我们必须在 randName()里先将它转换为一个列表. 我们一次随机的移除一个名字, 直到列表为空为止. 如果 NAMES 本身是一个列表, 我们只能使用它一次(它就被消耗光了). 我们将它设计成为一个元组, 这样我们就可以多次从这个元组生成一个列表供生成器使用. 

Lines 105–115
The insert() function is the only other place where database-dependent code lives, and the reason is that each database is slightly different in one way or another. For example, both the adapters for SQLite and MySQL are DB-API–compliant,  so  both  of  their  cursor  objects  have  an  execute- many() function, whereas Gadfly does not, so rows have to be inserted one
at a time.
105-115行
由于各种数据库之间有一些细微差别, insert()函数里的代码是依赖具体数据库的. 举例来说, SQLite 和 MySQL的接口程序都是 DB-API 兼容的, 所以它们的游标对象都拥有 executemany()方法, 可是是 Gadfly 没有这个方法, 因此它只能一次插入一行. 

　Another quirk is that both SQLite and Gadfly use the  qmark parameter style while MySQL uses format. Because of this, the format strings are dif- ferent. If you look carefully, however, you will see that the arguments them- selves are created in a very similar fashion.
另一个不同之处在于 SQLite 和 Gadfly 的参数风格是 qmark, 而MySQL的参数风格是 format.
由于这些原因, 格式字符串必须不同. 如果你比较细心的话, 你会看到他们的参数创建过程非常相似.

　What the code does is this: for each name-userID pair, it assigns that indi- idual to a project group (given by its project ID or prid). The project ID is chosen randomly out of four different groups (randrange(1,5)).
这段代码的功能是: 对每个 name-userID 数据对, 随机分配一个项目小组id(,然后存入数据库). 

Line 117
This single line represents a conditional expression (read as: Python ternary operator) that returns the rowcount of the last operation (in terms of rows altered), or if the cursor object does not support this attribute (meaning it is not DB-API–compliant), it returns –1.
Conditional expressions were added in Python 2.5, so if you are using 2.4.x
or older, you will need to convert it back to the “old-style” way of doing it:
第117行
这独立的一行是有一个条件表达式(读作, Python 3目操作符), 它返回最后一步操作所影响的行数, 如果游标对象不支持这个属性(也就是说这个接口程序不兼容 DB-API)的话, 它返回 -1.
python 2.5 中新增了条件表达式, 如果你使用的是python 2.4.x 或更老版本, 你可能需要将它转换为老风格的方式, 如下:

getRC = lambda cur: (hasattr(cur, 'rowcount') \
and [cur.rowcount] or [-1])[0]

　If you are confused by this line of code, don’t worry about it. Check the FAQ to see why this is, and get a taste of why conditional expressions were finally added to Python in 2.5. If you are able to figure it out, then you have developed a solid understanding of Python objects and their Boolean values.
如果你对这行代码看不太明白, 不用着急. 看看 FAQ 就能知道为什么最终 Python 2.5 中加入了条件表达式. 如果你能弄明白, 你就彻底搞明白了 python对象以及他们的布尔值.

Lines 119–129
The  update() and  delete() functions  randomly  choose  folks  from  one group.  If  the  operation  is  update,  move  them  from  their  current  group  to another (also randomly chosen); if it is delete, remove them altogether.
第119-129行
update() 和 delete() 函数随机从一个组里选择了几条记录, 如果是 update 操作, 就将他们从当前小组移到另一个小组(也是随机选择的). 如果是 delete 操作, 则删除它们. 

Lines 131–137
The dbDump() function pulls all rows from the database, formats them for printing, and displays them to the user. The print statement to display each user is the most obfuscated, so let us take it apart.
第131-137行
dbDump()函数从数据库中读取所有数据, 并将数据进行格式化, 然后显示给用户看. print 语句显示每个用户不够清晰, 所以我们将它分开显示.

　First, you should see that the data were extracted after the SELECT by the  fetchall() method.  So  as  we  iterate  each  user,  take  the  three  col- umns (login, uid, prid), convert them to strings (if they are not already), titlecase it, and format the complete string to be COLSIZ columns left-justi- fied  (right-hand  space  padding).  Since  the  code  to  generate  these  three strings is a list (via the list comprehension), we need to convert it to a tuple for the format operator ( % ).
首先, 通过 fetchall() 方法读取数据, 然后迭代遍历每个用户, 将三列数据(login, uid, prid)转换为字符串(如果它们还不是的话), 并将姓和名的首字母大写, 再格式化整个字符为左对齐的COLSIZ列.(右边留白) . 由代码生成的字符串是一个列表(通过列表解析， list comprehension), 我们需要将它们转换成一个元组以支持 % 运算符. 
Lines 139–174
The director of this movie is  main(). It makes the individual functions to each function described above that defines how this script works (assuming that it does not exit due to either not finding a database adapter or not being able to obtain a connection [lines 143–145]). The bulk of it should be fairly self-explanatory given the proximity of the print statements. The last bits of main() close  the  cursor,  and  commit  and  close  the  connection.  The  final lines of the script are the usual to start the script.
第139-174行
本部影片的导演 main() 出场. 它将上面定义的这些函数组织起来, 让他们尽情发挥. (假定它们没有因为找不到数据库接口程序或者不能得到有效连接对象而中途退出[第143-145行]). 它的大部分代码都是能够自我解释的 print 语句. 最后 main() 关闭游标对象, 提交操作, 然后关闭数据库连接. 脚本的最后几行代码用来启动脚本的执行. 

21.3 Object-Relational Managers (ORMs)
对象-关系管理器(ORMs)

As seen in the previous section, a variety of different database systems are available today, and most of them have Python interfaces to allow you to harness their power. The only drawback to those systems is the need to know SQL. If you are a programmer who feels more comfortable with manipulat- ing Python objects instead of SQL queries, yet still want to use a relational database as your data backend, then you are a great candidate to be a user of ORMs.
通过前一节我们知道, 如今有很多种数据库系统, 他们中的绝大多数都有Python接口, 以方便你驾驭他们的能量. 这些系统唯一的缺点是需要你懂得SQL. 如果你是一个喜欢折腾 Python 对象却讨厌 SQL 查询的家伙, 又想使用关系型数据库做为你的数据存储的后端, 你就完全具备成为一个 ORM 用户的天资. 

21.3.1 Think Objects, Not SQL
考虑对象，而不是SQL

Creators  of  these  systems  have  abstracted  away  much  of  the  pure  SQL layer  and  implemented  objects  in  Python  that  you  can  manipulate  to accomplish the same tasks without having to generate the required lines of SQL. Some systems allow for more flexibility if you do have to slip in a few lines  of  SQL,  but  for  the  most  part,  you  can  avoid  almost  all  the  general SQL required.
这些系统的创建者将绝大多数纯 SQL层功能抽象为Python对象, 这样你就无需编写SQL也能够完成同样的任务. 如果你在某些情况下实在需要SQL, 有些系统也允许你拥有这种灵活性. 但绝大多数情况下, 你应该尽量避免进行直接的SQL查询.

　Database tables are magically converted to Python classes with columns and features as attributes and methods responsible for database operations. Setting up your application to an ORM is somewhat similar to that of a stan- dard database adapter. Because of the amount of work that ORMs perform on your behalf, some things are actually more complex or require more lines of code than using an adapter directly. Hopefully, the gains you achieve in productivity make up for a little bit of extra work.
数据库的表被转换为 Python类, 它具有列属性和操作数据库的方法. 让你的应用程序支持 ORM 非常类似使用那些标准的数据库接口程序. 由于大部分工作由 ORM 代为处理, 相比直接使用接口程序来说, 一些事情可能实际需要更多的代码. 另人欣慰的是, 一点点额外的付出会回报你更高的生产率. 

21.3.2 Python and ORMs
Python 和 ORM


The most well-known Python ORMs today are SQLAlchemy and SQLObject. We will give you examples of SQLAlchemy and SQLObject because the sys- tems are somewhat disparate due to different philosophies, but once you fig- ure these out, moving on to other ORMs is much simpler.
如今最知名的 Python ORM模块是 SQLAlchemy 和 SQLObject. 由于二者有着不同的设计哲学, 我们会分别给出 SQLAlchemy 和 SQLObject 的例子. 只要你能搞清楚这两种ORM的使用, 转到其它的 ORM 将是相当简单的事.

　Some other Python ORMs include PyDO/PyDO2, PDO, Dejavu, PDO, Durus,  QLime,  and  ForgetSQL.  Larger  Web-based  systems  can  also  have their own ORM component, i.e., WebWare MiddleKit and Django’s Data- base API. Note that “well-known” does not mean “best for your application.” Although  these  others  were  not  included  in  our  discussion,  that  does  not mean that they would not be right for your application.
其它的 Python ORM 包括 PyDO/PyDO2, PDO, Dejavu, Durus, QLime和 ForgetSQL. 一些大型的Web开发工具/框架也可以有自己的 ORM 组件, 如 WebWare MiddleKit 和 Django 的数据库 API.需要指出的是, 知名的 ORM 并不意味着就是最适合你的应用程序的ORM. 那些其它的 ORM 虽然没有纳入我们的讨论范围, 但一样有可能是适合你的应用程序的选择.

21.3.3 Employee Role Database Example
雇员数据库举例

We will port our user shuffle application ushuffle_db.py to both SQLAl- chemy and SQLObject below. MySQL will be the backend database server for both. You will note that we implement these as classes because there is more of an object “feel” to using ORMs as opposed to using raw SQL in a database adapter. Both examples import the set of  NAMES and the random name chooser from ushuffle_db.py. This is to avoid copying-and-pasting the same code everywhere as code reuse is a good thing.
现在我们将 shuffle 应用程序 ushuffle_db.py 改造为使用 SQLAlchemy 和 SQLObject 实现. 数据库后端仍然是 MySQL. 相对于直接使用原始 SQL来讲, 我们使用 ORM 时用类代替了函数, 这样会更有对象的感觉. 两个例子都使用了 ushuffle_db.py 中的 NAMES 集合和 随机名字选择函数.  这是为了避免将同样的代码到处 复制-粘贴, 代码能够被有效重用是件好事情. 

SQLAlchemy

We start with SQLAlchemy because its interface is somewhat closer to SQL than SQLObject’s interface. SQLAlchemy abstracts really well to the object world but does give you more flexibility in issuing SQL if you have to. You will find both of these ORMs (Examples 21.2 and 21.3) very similar in terms of setup  and  access,  as  well  as  being  of  similar  size,  and  both  shorter  than ushuffle_db.py (including  the  sharing  of  the  names  list  and  generator used to randomly iterate through that list).

与SQLObject相比, SQLAlchemy的接口在某种程度上更接近 SQL, 所以我们先从 SQLAlchemy 开始.SQLAlchemy 的抽象层确实相当完美, 而且在你必须使用SQL完成某些功能时, 它提供了足够的灵活性. 你会发现这两个ORM模块在设置及存取数据时使用的术语非常相似, 代码长度也很接近, 都比ushuffle_db.py 少. (包括共享的 names 列表和随机名字生成器). 

Line-by-Line Explanation
逐行解释

Lines 1–10
As  expected,  we  begin  with  module  imports  and  constants.  We  follow  the suggested  style  guideline  of  importing  Python  Standard  Library  modules first, followed by third-party or external modules, and finally, local modules
to our application. The constants should be fairly self-explanatory.
第1-10行
和前面一样, 第一件事是导入相关的模块和常量. 我们倡导首先导入Python标准库模块, 然后再导入第三方或扩展模块, 最后导入本地模块这种风格. 这些常量都是自解释的, 所以无需废话. 

Lines 12–31
The  constructor  for  our  class,  like   ushuffle_db.connect(),  does everything  it  can  to  make  sure  that  there  is  a  database  available  and returns a connection to it (lines 18–31). This is the only place you will see real SQL, as such activity is typically an operational task, not application- oriented.
第12-31行是类的构造器, 类似 ushuffle_db.connect(). 它确保数据库可用并返回一个有效连接(第18-31行). 这也是唯一能看到原始 SQL的地方. 这是一种典型的操作任务, 不是面向应用的任务.

Lines 33–44
The try-except clause (lines 33–40) is used to reload an existing table or make a new one if it does not exist yet. Finally, we attach the relevant objects
to our instance.
第33-44行
这个 try-except 子句(第33-40行)用来重新载入一个已有的表, 或者在表不存在的情况下创建一个新表. 最终我们得到一个合适的对象实例.

Example 21.2  SQLAlchemy ORM Example (ushuffle_sa.py)
例子21.2 SQLAlchemy ORM 例子

This “user shuffle” application features SQLAlchemy paired up with the MySQL
database as its backend.
这个 user shuffle 程序的主角是 SQLAlchemy前端 和 MySQL 数据库后端
1       #!/usr/bin/env python
2
3       import os
4       from random import randrange as rrange
5       from sqlalchemy import *
6       from ushuffle_db import NAMES, randName
7
8       FIELDS = ('login', 'uid', 'prid')



12    class MySQLAlchemy(object):
13      def __init__(self, db, dbName):
14      import MySQLdb
15      import _mysql_exceptions
16      MySQLdb = pool.manage(MySQLdb)
17      url = 'mysql://db=%s' % DBNAME
18      eng = create_engine(url)
19      try:
20      cxn = eng.connection()
21      except _mysql_exceptions.OperationalError, e:


24      eng1.execute('DROP DATABASE %s' % DBNAME)
25      except _mysql_exceptions.OperationalError, e:
26      pass
27      eng1.execute('CREATE DATABASE %s' % DBNAME)
28      eng1.execute(
29      "GRANT ALL ON %s.* TO ''@'localhost'" % DBNAME)
30      eng1.commit()
31      cxn = eng.connection()
32
33      try:
34      users = Table('users', eng, autoload=True)
35      except exceptions.SQLError, e:
36      users = Table('users', eng,
37      Column('login', String(8)),
38      Column('uid', Integer),
39      Column('prid', Integer),
40      redefine=True)



44      self.users = users
45
46      def create(self):
47      users = self.users

48      try:
49      users.drop()
50      except exceptions.SQLError, e:
51      pass
52      users.create()
53
54      def insert(self):
55      d = [dict(zip(FIELDS,
56      [who, uid, rrange(1,5)])) for who,uid in randName()]
57      return self.users.insert().execute(*d).rowcount
58
59      def update(self):
60      users = self.users
61      fr = rrange(1,5)
62      to = rrange(1,5)
63      return fr, to, \
64      users.update(users.c.prid==fr).execute(prid=to).rowcount
65
66      def delete(self):
67      users = self.users
68      rm = rrange(1,5)
69      return rm, \
70      users.delete(users.c.prid==rm).execute().rowcount
71
72      def dbDump(self):
73      res = self.users.select().execute()
74      print '\n%s%s%s' % ('LOGIN'.ljust(COLSIZ),
75      'USERID'.ljust(COLSIZ), 'PROJ#'.ljust(COLSIZ))
76      for data in res.fetchall():
77      print '%s%s%s' % tuple([str(s).title().ljust
(COLSIZ) for s in data])
78
79      def __getattr__(self, attr):
80      return getattr(self.users, attr)
81
82      def finish(self):
83      self.cxn.commit()
84      self.eng.commit()
85
86    def main():
87      print '*** Connecting to %r database' % DBNAME
88      orm = MySQLAlchemy('mysql', DBNAME)
89
90      print '\n*** Creating users table'
91      orm.create()
92
93      print '\n*** Inserting names into table'
94      orm.insert()
95      orm.dbDump()
96
97      print '\n*** Randomly moving folks',
98      fr, to, num = orm.update()
99      print 'from one group (%d) to another (%d)' % (fr, to)
100     print '\t(%d users moved)' % num
101     orm.dbDump()
102
103     print '\n*** Randomly choosing group',
104     rm, num = orm.delete()
105     print '(%d) to delete' % rm
106     print '\t(%d users removed)' % num
107     orm.dbDump()
108
109     print '\n*** Dropping users table'
110     orm.drop()
111     orm.finish()
112
113  if __name__ == '__main__':
114     main()
Example 21.2  SQLAlchemy ORM Example (ushuffle_sa.py)
例子21.2 SQLAlchemy ORM 示例(ushuffle_sa.py)

Lines 46–70
These next four methods represent the core database functionality of table creation  (lines  46–52),  insertion  (lines  54–57),  update  (lines  59–64),  and deletion (lines 66–70). We should also have a method for dropping the table:
第46-70行
这四个方法处理数据库核心功能: 创建表(46-52行), 插入数据(54-57行), 更新数据(59-64行), 删除数据(66-70行). 我们也有一个方法用来删除表. 

def drop(self):
self.users.drop()
or
drop = lambda self: self.users.drop()

However, we made a decision to give another demonstration of delegation
(as introduced in Chapter 13, Object-Oriented Programming). Delegation is where missing functionality (method call) is passed to another object in our instance which has it. See the explanation of lines 79–80.
不过, 我们还是决定提供另一种委托处理方式(曾在第13章, 面向对象编程中介绍). 委托处理就是指一个方法调用不存在时, 转交给另一个拥有此方法的对象去处理. 参见第79-80行的解释.

Lines 72–77
The responsibility of displaying proper output to the screen belongs to the dbDump() method. It extracts the rows from the database and pretty-prints the  data  just  like  its  equivalent  in  ushuffle_db.py.  In  fact,  they  are nearly identical.
第72-77行
输出内容由dbDump()方法完成. 它从数据库中得到数据, 就象 ushuffle_db.py 中那样对数据进行美化, 事实上, 这部分代码几乎完全相同.

Lines 79–80
We  deliberately  avoided  creating  a  drop() method  for  the  table  since  it would  just  call  the  table’s  drop  method  anyway.  Also,  there  is  no  added 
functionality, so why create yet another function to have to maintain? The
__getattr__() special method is called whenever an attribute lookup fails.
If our object calls orm.drop() and finds no such method, getattr (orm,
'drop') is  invoked.  When  that  happens,  __getattr__() is  called  and
delegates the attribute name to self.users. The interpreter will find that
self.users  has  a  drop attribute  and  pass  that  method  call  to  it:  self.
users.drop()!
应该尽量避免为一个表创建一个 drop() 方法, 因为这总是会调用 table 自身的 drop() 方法. 同样, 既然没有新增功能, 那我们有什么必要要创建另一个函数?无论属性查找是否成功特殊方法 __getattr__() 总是会被调用. 如果调用 orm.drop() 却发现这个对象并没有 drop() 方法, getattr(orm, 'drop')就会被调用. 发生这种情况时,__getattr__() 被调用, 之后将这个属性名委托给 self.users. 解释器会发现 self.users 有一个 drop 属性并执行.

Example 21.3  SQLObject ORM Example (ushuffle_so.py)

This “user shuffle” application features SQLObject paired up with the MySQL database as its backend.
这个 user shuffle 应用程序的主角前端是 SQLObject, 后端是MySQL数据库.

1       #!/usr/bin/env python
2
3       import os
4       from random import randrange as rrange
5       from sqlobject import *
6       from ushuffle_db import NAMES, randName
7
8       DBNAME = 'test'
9       COLSIZ = 10
10    FIELDS = ('login', 'uid', 'prid')
11
12    class MySQLObject(object):
13      def __init__(self, db, dbName):
14      import MySQLdb
15      import _mysql_exceptions
16      url = 'mysql://localhost/%s' % DBNAME
17
18      while True:
19      cxn = connectionForURI(url)



23      class Users(SQLObject):
24      class sqlmeta:
25      fromDatabase = True
26      login = StringCol(length=8)
27      uid = IntCol()
28      prid = IntCol()
29      break
30      except _mysql_exceptions.ProgrammingError, e:
31      class Users(SQLObject):
32      login = StringCol(length=8)
33      uid = IntCol()
34      prid = IntCol()
35      break


connectionForURI('mysql://root@localhost')
38      cxn1.query("CREATE DATABASE %s" % DBNAME)
39      cxn1.query("GRANT ALL ON %s.* TO ''@'
localhost'" % DBNAME)
40      cxn1.close()
41      self.users = Users
42      self.cxn = cxn
43
44      def create(self):
45      Users = self.users



Example 21.3  SQLObject ORM Example (ushuffle_so.py)
(continued)

46      Users.dropTable(True)
47      Users.createTable()
48
49      def insert(self):
50      for who, uid in randName():
51      self.users(**dict(zip(FIELDS,
52      [who, uid, rrange(1,5)])))
53
54      def update(self):
55      fr = rrange(1,5)
56      to = rrange(1,5)
57      users = self.users.selectBy(prid=fr)
58      for i, user in enumerate(users):
59      user.prid = to
60      return fr, to, i+1
61
62      def delete(self):
63      rm = rrange(1,5)
64      users = self.users.selectBy(prid=rm)
65      for i, user in enumerate(users):
66      user.destroySelf()
67      return rm, i+1
68
69      def dbDump(self):
70      print '\n%s%s%s' % ('LOGIN'.ljust(COLSIZ),
71      'USERID'.ljust(COLSIZ), 'PROJ#'.ljust(COLSIZ))
72      for usr in self.users.select():
73      print '%s%s%s' % (tuple([str(getattr(usr,
74      field)).title().ljust(COLSIZ) \
75      for field in FIELDS]))
76
77      drop = lambda self: self.users.dropTable()
78      finish = lambda self: self.cxn.close()
79
80   def main():
81      print '*** Connecting to %r database' % DBNAME
82      orm = MySQLObject('mysql', DBNAME)
83
84      print '\n*** Creating users table'
85      orm.create()
86
87      print '\n*** Inserting names into table'
88      orm.insert()
89      orm.dbDump()
90
91      print '\n*** Randomly moving folks',
92      fr, to, num = orm.update()
93      print 'from one group (%d) to another (%d)' % (fr, to)
Example 21.3  SQLObject ORM Example (ushuffle_so.py)
(continued)

94      print '\t(%d users moved)' % num
95      orm.dbDump()
96
97      print '\n*** Randomly choosing group',
98      rm, num = orm.delete()
99      print '(%d) to delete' % rm
100     print '\t(%d users removed)' % num
101     orm.dbDump()
102
103     print '\n*** Dropping users table'
104     orm.drop()
105     orm.finish()
106
107 if __name__ == '__main__':
108     main()





Lines 82–84
The last method is finish(), which commits the transaction.
最后一个方法是 finish, 它来提交整个事务.

Lines 86–114
The  main() function  drives  our  application.  It  creates  a  MySQLAlchemy
object and uses that for all database operations. The script is the same as
for  our  original  application,  ushuffle_db.py.  You  will  notice  that  the
database parameter db is optional and does not serve any purpose here
in  ushuffle_sa.py or  the  upcoming  SQLobject  version  ushuffle_
so.py. This is a placeholder for you to add support for other RDBMSs
in these applications (see Exercises at the end of the chapter).
第86-114行
main() 函数是整个应用程序的入口, 它创建了一个 MySQLAlchemy 对象并通过它完成所有的数据库操作. 这段脚本和 ushuffle_db.py 功能一样. 你会注意到数据库参数 db 是可选的,而且在 ushuffle_sa.py 和即将碰到 的ushuffle_so.py 中, 它不起任何作用. 它只是一个占位符以方便你对这个应用程序添加其它的数据库支持.(参见本章后面的习题)

Upon running this script, you may get output that looks like this:
运行这段脚本, 你会看到类似下面的输出:
$ ushuffle_sa.py
*** Connecting to 'test' database
连接 test 数据库
*** Creating users table
创建 users 表
*** Inserting names into table
向users 表插入姓名数据
LOGIN
USERID
PROJ#
Serena
7003
4
Faye
6812
4
Leslie
7808
3
Ernie
7410
1
Dave
7306
2
Melissa
8602
1
Amy
7209
3
Angela
7603
4
Jess
7912
2
Larry
7311
1
Jim
7512
2
Davina
7902
3
Stan
7607
4
Pat
7711
2
Aaron
8312
2
Elliot
7911
3


*** Randomly moving folks from one group (1) to another (3)
随机将几个人从一个组移动到另一个组
(3 users moved)


LOGIN
USERID
PROJ#
Serena
7003
4
Faye
6812
4
Leslie
7808
3
Ernie
7410
3
Dave
7306
2
Melissa
8602
3
Amy
7209
3
Angela
7603
4
Jess
7912
2
Larry
7311
3
Jim
7512
2
Davina
7902
3
Stan
7607
4
Pat
7711
2
Aaron
8312
2
Elliot
7911
3

*** Randomly choosing group (2) to delete
随机选中一个组删除
(5 users removed)
(5 个用户被删除)

LOGIN
USERID
PROJ#
Serena
7003
4
Faye
6812
4
Leslie
7808
3
Ernie
7410
3
Melissa
8602
3
Amy
7209
3
Angela
7603
4
Larry
7311
3
Davina
7902
3
Stan
7607
4
Elliot
7911
3

*** Dropping users table
$

Line-by-Line Explanation
逐行解释

Lines 1–10
This modules imports and constant declarations are practically identical to those of ushuffle_sa.py except that we are using SQLObject instead of SQLAlchemy.
第1-10行
除了我们使用的是 SQLObject 而不是 SQLAlchemy 以外, 导入模块和常量声明几乎与 ushuffle_sa.py 相同. 

Lines 12–42
The constructor for our class does everything it can to make sure that there is
a database available and returns a connection to it, just like our SQLAlchemy example. Similarly, this is the only place you will see real SQL. Our application, as coded here, will result in an infinite loop if for some reason a Users table cannot be created in SQLObject.
12-42行
类似我们的SQLAlchemy 例子, 类的构造器做大量工作以确保有一个数据库可用, 然后返回一个连接. 同样的, 这也是你能在程序里看到SQL语句的唯一位置. 我们这个程序, 如果因为某种原因造成SQLObject无法成功创建用户表, 就会陷入无限循环当中. 

　We are trying to be clever in handling errors by fixing the problem and retrying  the  table  (re)create.  Since  SQLobject  uses  metaclasses,  we  know that special magic is happening under the covers, so we have to define two different classes—one for if the table already exists and another if it does not. The code works something like this:
我们尝试能够聪明的处理错误, 解决掉这个重建表的问题. 因为 SQLObject 使用元类, 我们知道类的创建幕后发生特殊事件, 所以我们不得不定义两个不同的类, 一个用于表已经存在的情况, 一个用于表不存的情况. 代码工作原理如下:

1.   Try and establish a connection to an existing table; if it works, we are done (lines 23–29)
1. 尝试建立一个连接到一个已经存在的表. 如果正常工作, OK. (第23-29行)
2.   Otherwise, create the class from scratch for the table; if so, we are done (lines 31–36)
2.如果第一步不成功, 则从零开始为这个表创建一个类, 如果成功, OK. (第31-36行)
3.   Otherwise, we have a database issue, so try and make a new database (lines 37–40)
3. 如果第二步仍不成功, 我们的数据库可能遇到麻烦, 那就重新创建一个新的数据库(第37-40行)
4.   Loop back up and try all this again
4. 重新开始新的循环.

　Hopefully it (eventually) succeeds in one of the first two places. When the loop is terminated, we attach the relevant objects to our instance as we did in ushuffle_sa.py.
希望程序最终能在第一步或第二步成功完成. 当循环结束时, 类似ushuffle_sa.py, 我们得到合适的对象实例. 

Lines 44–67, 77–78
The database operations happen in these lines. We have table create (lines 44–47)
and drop (line 77), insert (lines 49–52), update (lines 54–60), and delete
(lines  62–67).  The  finish() method  on  line  78  is  to  close  the  connec- tion. We could not use delegation for table drop like we did for the SQLA- lchemy  example  because  the  would-be  delegated  method  for  it  is  called dropTable() not drop().
第44-67行, 77-78行
这些行处理数据库操作. 我们在 44-47行创建了表, 并在77行删掉了表. 在49-52行插入数据, 在54-60行更新数据, 在62-67行删除了数据. 78行调用了finish()方法来关闭数据库连接. 我们不能象SQLAlchemy 那样使用删表代理, 因为SQLObject的删表代理名为 dropTable()而不是drop().

Lines 69–75
This  is  the  same  and  expected  dbDump() method,  which  pulls  the  rows from the database and displays things nicely to the screen.
第69-75行
使用dbDump()方法, 我们从数据库中得到数据, 并将它显示在屏幕上. 

Lines 80–108
This   is   the   main() function   again.   It   works   just   like   the   one   in ushuffle_sa.py.  Also,  the  db argument  to  the  constructor  is  a  place- holder for you to add support for other RDBMSs in these applications (see Exercises at the end of the chapter).
第80-108行
又到了 main() 函数. 它工作的方式非常类似 ushuffle_sa.py . 同样的, 构造器的 db 参数仅仅是一个占位符, 用以支持其它的数据库系统(参阅本章最后的习题)

Here is what your output may look like if you run this script:
当你运行这段脚本时, 你的输出可能类似这样:
$ ushuffle_so.py

*** Connecting to 'test' database
连接 test 数据库

*** Creating users table
创建 users 表
*** Inserting names into table
向表里插入姓名数据
LOGIN
USERID
PROJ#
Jess
7912
1
Amy
7209
4
Melissa
8602
2
Dave
7306
4
Angela
7603
4
Serena
7003
2
Aaron
8312
1
Leslie
7808
1
Stan
7607
3
Pat
7711
3
Jim
7512
4
Larry
7311
3
Ernie
7410
2

Faye
6812
4
Davina
7902
1
Elliot
7911
4

*** Randomly moving folks from one group (2) to another (3)
随机将三个人从一个组移动到另一个组
(3 users moved)

LOGIN
USERID
PROJ#
Jess
7912
1
Amy
7209
4
Melissa
8602
3
Dave
7306
4
Angela
7603
4
Serena
7003
3
Aaron
8312
1
Leslie
7808
1
Stan
7607
3
Pat
7711
3
Jim
7512
4
Larry
7311
3
Ernie
7410
3
Faye
6812
4
Davina
7902
1
Elliot
7911
4

*** Randomly choosing group (3) to delete
(6 users removed)

LOGIN
USERID
PROJ#
Jess
7912
1
Amy
7209
4
Dave
7306
4
Angela
7603
4
Aaron
8312
1
Leslie
7808
1
Jim
7512
4
Faye
6812
4
Davina
7902
1
Elliot
7911
4

*** Dropping users table
$

21.3.4 Summary
     总结
We hope that we have provided you with a good introduction to using rela- tional databases with Python. When your application’s needs go beyond those offered by plain files, or specialized files like DBM, pickled, etc., you have many options. There are a good number of RDBMSs out there, not to mention
one  completely  implemented  in  Python,  freeing  one  from  having  to  install, maintain, or administer a real database system. Below, you will find information on many of the Python adapters plus database and ORM systems out there. We also suggest checking out the DB-SIG pages as well as the Web pages and mail- ing lists of all systems of interest. Like all other areas of software development, Python makes things easy to learn and simple to experiment with.

关于如何在python中使用关系型数据库, 希望我们前面介绍的东西对你有用. 当你应用程序的需求超出纯文本或类似DBM等特殊文件的能力时, 有多种数据库可以选择, 别忘了还有一个完全由Python实现的真正的免安装维护和管理的真实数据库系统. 你能在下面找到多种Python数据库接口程序和 ORM系统. 我们也建议你研究一下互联网上的 DB-SIG 的网页和邮件列表. 类似其它的软件开发领域, 只不过 Python 更简单易学, 用户体验更好.

21.4 Related Modules
相关模块

Table 21.8 lists most of the common databases out there along with working Python modules and packages that serve as adapters to those database systems. Note that not all adapters are DB-API–compliant.
表 21.8 列出了常见的Python数据库接口程序, 注意不是所有的接口程序都是 DB-API 兼容的.

Table 21.8      Database-Related Modules and Websites
表 21.8 数据库相关模块及其站点

Name    Online Reference or Description
名字    网站   参考或描述
Databases
数据库
Gadfly  http://gadfly.sf.net

MySQL   http://mysql.com or http://mysql.org


MySQLdb a.k.a. MySQL-
python
http://sf.net/projects/mysql-python

PostgreSQL      http://postgresql.org

psycopg http://initd.org/projects/psycopg1 psycopg2     http://initd.org/software/initd/psycopg/ PyPgSQL        http://pypgsql.sf.net
PyGreSQL        http://pygresql.org

PoPy    Deprecated; merged into PyGreSQL project
PoPy    已废弃, 与 PyGreSQL 项目合并

SQLite  http://sqlite.org

pysqlite        http://initd.org/projects/pysqlite

sqlite3a        pysqlite integrated into Python Standard Library; use this one unless you want to download the latest patch
sqlite3a        pysqlite 已经整合到Python标准库; 除非你要下载最新的补丁, 否则建议使用标准库

APSW    http://rogerbinns.com/apsw.html

Table 21.8      Database-Related Modules and Websites (continued)
表 21.8 数据库相关模块及其站点(续)

Name    Online Reference or Description
名字    网站   参考或描述
Databases
数据库
MaxDB (SAP)     http://mysql.com/products/maxdb

sdb     http://dev.mysql.com/downloads/maxdb/7.6.00.html#Python

sapdb   http://sapdb.org/sapdbPython.html

Firebird (InterBase)    http://firebird.sf.net

KInterbasDB     http://kinterbasdb.sf.net

SQL Server      http://microsoft.com/sql

pymssql http://pymssql.sf.net (requires FreeTDS [http://freetds.org])

adodbapi        http://adodbapi.sf.net

Sybase  http://sybase.com

sybase  http://object-craft.com.au/projects/sybase

Oracle  http://oracle.com

cx_Oracle       http://starship.python.net/crew/atuining/cx_Oracle

DCOracle2       http://zope.org/Members/matt/dco2
                             (older, for Oracle8 only)

Ingres  http://ingres.com

Ingres DBI      http://ingres.com/products/Prod_Download_Python_DBI.html

ingmod  http://www.informatik.uni-rostock.de/~hme/software/

ORMs

SQLObject       http://sqlobject.org

SQLAlchemy      http://sqlalchemy.org

PyDO/PyDO2      http://skunkweb.sf.net/pydo.html

a.      pysqlite added to Python 2.5 as sqlite3 module.
pysqlite 已经添加到python2.5中, 作为它的 sqlite3 模块
21.5  Exercises
练习

21–1.   Database API. What is the Python DB-API? Is it a good thing? Why (or why not)?
什么是 Python DB-API? 它是一个好东西么? 为什么是?(或为什么不是?)
21–2.   Database API. Describe the differences between the data- base module parameter styles (see the paramstyle module attribute).
描述一下数据库模块参数风格之间的不同在哪儿?
21–3.   Cursor Objects. What are the differences between the cursor
execute*() methods?
        游标对象的 execute*() 系列方法有何区别?
21–4.   Cursor Objects. What are the differences between the cursor
fetch*() methods?
        游标对象的 fetch*() 系列方法有何区别?
21–5.   Database Adapters. Research your RDBMS and its Python
module. Is it DB-API compliant? What additional features are available for that module that are extras not required by the API?
        研究一下你使用的数据库及相应的 python 模块. 它是否与 DB-API兼容? 该模块是否提供了 DB-API必须功能之外的更多特性?
21–6.   Type Objects. Study using Type objects for your database and DB-API adapter and write a small script that uses at least one of those objects.
        针对你使用的数据库和 DB-API接口程序, 学习使用 Type 对象写一段小的脚本, 至少要用到其中的一个对象. 
21–7.   Refactoring. In the create() function of Example 21.1
(ushuffle_db.py), a table that already exists is dropped
and re-created by recursively calling create() again. This
is dangerous in case the re-creation of the table fails (again)
because you will then have infinite recursion. Fix this problem
by creating a more practical solution that does not involve copy- ing the create query (cur.execute()) again in the exception handler. Extra Credit: Try to recreate the table a maximum of three times before returning failure back to the caller.
重构 例子21.1(ushuffle_db.py)中的 create() 函数, 一个 table 会先被删除, 然后递归调用 create() 函数重建这个 table. 如果在重建这个 table 时失败, 就会陷入无限循环之中. 通过在异常处理中不再调用 create 命令(cur.execute())修复这个问题, 搞一个更实用的解决方案出来. 附加题： 实现如果创建 table 失败, 在返回失败之前最多重试三次. 

21–8.   Database and HTML. Take any existing database table, and use the knowledge you developed from Chapter 20 and out- put the contents of a database table into an HTML table.
数据库和html 利用现有数据库的一个表和你在第20章学到的开发知识, 读出数据库表的内容, 将它放到一个 html table 中去. 
21–9.   Web Programming and Databases. Take our “user shuffle” exam- ple (ushuffle_db.py), and create a Web interface for it.
数据库网站开发 给我们的user shuffle例子写一个网页界面.
21–10.  GUI Programming and Databases. Take our “user shuffle”
example (ushuffle_db.py), and throw a GUI for it.
数据库界面编程 给我们的 user shuffle 例子写一个图形界面.
21–11.  Stock Portfolio Class. Update the stock database example
from Chapter 13 to use a relational database.
股票投资组合类 修改第十三章股票数据的例子, 将它改造为使用某一种关系数据库保存数据.
21–12.  Switching ORMs to a Different RDBMS. Take either the SQLAlchemy (ushuffle_sa.py) or SQLObject (ushuf- fle_so.py) application and swap out MySQL as the back- end RDBMS for another one of your choice.
切换 ORM 后端为其它的数据库. 将 SQLAlchemy(ushuffle_sa.py) 或 SQLObject(ushuffle_so.py) 应用程序后端数据库由 MySQL 切换为另一种数据库系统.

