Internet Client
Programming
网络客户端编程

:- digital (digital:digitalwit@gmail.com)已认领
||'''status'''|| 草稿  || digital || 完成度 ~0%||

Chapter Topics
本章主题
	Introduction
	Transferring Files
	File Transfer Protocol (FTP)
	Network News, Usenet, and Newsgroups
	Network News Transfer Protocol (NNTP)
	Electronic Mail
	Simple Mail Transfer Protocol (SMTP)
	Post Office Protocol version 3 (POP3)
	Related Modules
引言
文件传输
文件传输协议(FTP)
网络新闻、Usenet, 和新闻组
网络新闻传输协议(NNTP)
电子邮件
简单邮件传输协议(SMTP)
邮局协议3(POP3)
相关模块
						
17
	
in an earlier chapter, we took a look at low-level networking communication
protocols using sockets. This type of networking is at the heart of most of the
client/server protocols which exist on the Internet today. These protocols
include those for transferring files (FTP, SCP, etc.), reading Usenet
newsgroups (NNTP), sending e-mail (SMTP), and downloading e-mail from a server
(POP3, IMAP), etc. These protocols work in a way much like the client/server
examples in the earlier chapter on socket programming. The only thing that is
different is that now we have taken lower-level protocols like TCP/IP and
created newer, more specific protocols on top of it to implement the
higher-level services we just described.
在之前的章节中，我们已经大致了解了那些使用套接字的低级别的网络通讯协议。这种网络
互连是当今互联网中大部分客户端／服务器协议的核心。这些网络协议包括文件传输(FTP, 
SCP等)，阅读Usenet新闻组(NNTP)，e-mail发送(SMTP)，从服务器上下载e-mail(POP3, 
IMAP)等等。这些协议的工作方式与之前在套接字编程中介绍的客户端／服务器的例子很像。
唯一的不同在于，我们已经使用过TCP/IP等低级别的协议，并基于此创建了新的，更具体的
协议来实现我们刚刚描述的服务。


17.1 What Are Internet Clients?
17.1 什么是因特网客户端？

Before we take a look at these protocols, we first must ask, “What is an
Internet client?” To answer this question, we simplify the Internet to a place
where data are exchanged, and this interchange is made up of someone offering a
service and a user of such services. You will hear the term “producer-consumer”
in some circles (although this phrase is generally reserved for conversations
on operating systems). Servers are the producers, providing the services, and
clients consume the offered services. For any one particular service, there is
usually only one server (process, host, etc.) and more than one consumer. We
previously examined the client/server model, and although we do not need to
create Internet clients with the low-level socket operations seen earlier, the
model is an accurate match.
在着手研究这些协议之前，我们要先问一个问题：“因特网客户端到底是什么”？要回答这个
问题，我们把因特网简化成一个数据交换中心，数据交换的参与者是一个服务提供者和
一个服务的使用者。有的人把它称为“生产者－消费者”（虽然这个词一般只用在讲解操作
系统相关信息时）。服务器就是生产者，它提供服务，一般只有一个服务器（进程或主机
等），和多个消费者，就像我们之前看的客户端／服务器模型那样。虽然现在我们不再使用
底级别的套接字来创建因特网客户端，但模型是完全相同的。

Here, we will look specifically at three of these Internet protocols—FTP, NNTP,
and POP3—and write clients for each. What you should take away afterward are
being able to recognize how similar the APIs of all of these protocols
are—this is done by design, as keeping interfaces consistent is a worthy
cause—and most importantly, the ability to create real clients of these and
other Internet protocols. And even though we are only highlighting these three
specific protocols, at the end of this chapter, you should feel confident
enough to write clients for just about any Internet protocol.
这里，我们将详细了解三个因特网协议——FTP, NNTP和POP3，并写出它们的客户端程序。通过
这些程序，你将会发现这些协议的API是多么的相似——由于保持接口的一致性有很大的好处，
所以，这些相似性在设计之初就考虑到了——更重要的是，你还能学会如何写出这些协议与
其它协议实用的客户端程序来。虽然我们只着重说了这三个协议。在看完这些协议后，你就能
有足够的信心和能力写出任何因特网协议的客户端程序了。


17.2  Transferring Files
17.2 文件传输

17.2.1 File Transfer Internet Protocols
17.2.1 文件传输因特网协议

One of the most popular Internet activities is file exchange. It happens all
the time. There have been many protocols to transfer files over the Internet,
with some of the most popular including the File Transfer Protocol (FTP), the
Unix-to-Unix Copy Protocol (UUCP), and of course, the Web’s Hypertext Transfer
Protocol (HTTP). We should also include the remote (Unix) file copy command rcp
(and now its more secure and flexible cousins scp and rsync).
因特网中最流行的事情就是文件的交换。文件交换无处不在。有很多协议可以供因特网上
传输文件使用。最流行的有文件传输协议(FTP)，Unix-to-Unix复制协议(UUCP)，以及网页
的超文本传输协议(HTTP)。另外，还有（Unix下的）远程文件复制指令rcp（以及更安全，
更灵活的scp和rsync）。

HTTP, FTP, and scp/rsync are still quite popular today. HTTP is primarily used
for Web-based file download and accessing Web services. It generally doesn’t
require clients to have a login and/or password on the server host to obtain
documents or service. The majority of all HTTP file transfer requests are for
Web page retrieval (file downloads).
迄今为止，HTTP，FTP和scp/rsync还是非常流行的。HTTP主要用于网页文件的下载和访问
Web服务上。它一般不要求用户输入登录的用户名密码就可以访问服务器上的文件和服务。
HTTP文件传输请求主要是用于获取网页（文件下载）。

On the other hand, scp and rsync require a user login on the server host.
Clients must be authenticated before file transfers can occur, and files can be
sent (upload) or retrieved (download). Finally, we have FTP. Like scp/rsync,
FTP can be used for file upload or download; and like scp/ rsync, it employs
the Unix multi-user concepts of usernames and passwords: FTP clients must use
the login/password of existing users. However, FTP also allows anonymous
logins. Let us now take a closer look at FTP.
相对的，scp和rsync要求用户登录到服务器，否则不能上传或下载文件。至于FTP，跟
scp/rsync一样，可以上传或下载文件，还采用了Unix的多用户的概念，用户一定要输入有
效的用户名和密码才能使用。不过，FTP也允许匿名登录。接下来，我们先仔细看看FTP。

17.2.2 File Transfer Protocol (FTP)
17.2.2 文件传输协议（FTP）

The File Transfer Protocol was developed by the late Jon Postel and Joyce
Reynolds in the Internet Request for Comment (RFC) 959 document and published
in October 1985. It is primarily used to download publicly accessible files in
an anonymous fashion. It can also be used by users to transfer files between
two machines, especially in cases where you’re using a Unix system as for file
storage or archiving and a desktop or laptop PC for work. Before the Web became
popular, FTP was one of the primary methods of transferring files on the
Internet, and one of the only ways to download software and/or source code. 
文件传输协议由已故的Jon Postel和Joyce Reynolds开发，记录在RFC(Request for Comment)
959号文档中，于1985年10月发布。它主要用于匿名下载公共文件。也可以用于在两台电脑
之间传输文件，尤其是在使用Unix系统做为文件存储系统，使用其它机器来工作的情况。
早在网络流行之前，FTP就是在因特网上文件传输，软件和源代码下载的主要手段之一。

As described previously, one must have a login/password for accessing the
remote host running the FTP server. The exception is anonymous logins, which
are designed for guest downloads. These permit clients who do not have accounts
to download files. The server’s administrator must set up an FTP server with
anonymous logins in order for these to occur. In these cases, the “login” of an
unregistered user is called “anonymous,” and the password is generally the
e-mail address of the client. This is akin to a public login and access to
directories that were designed for general consumption as opposed to logging in
and transferring files as a particular user. The list of available commands via
the FTP protocol is also generally more restrictive than that for real users.
FTP要求输入用户名和密码才能访问远程的FTP服务器，但它也允许没有帐号的用户以匿名
用户登录。不过，管理员要先设置FTP服务器允许匿名用户登录。这时，匿名用户的用户名
是“anonymous”，密码一般是用户的e-mail地址。与特定的用户拥有特定的帐户不同，这有点
像是把FTP公开出来让大家访问。匿名用户通过FTP协议可以使用的命令与一般的用户相比来
说，限制更多。

The protocol is diagrammed below in Figure 17–1 and works as follows:
图17-1展示了这个协议，其工作流程如下：

1.  Client contacts the FTP server on the remote host
2.  Client logs in with username and password (or “anonymous” and e-mail address)
3.  Client performs various file transfers or information requests
4.  Client completes the transaction by logging out of the remote host and FTP server

1.  客户端连接远程的FTP服务器
2.  客户端输入用户名和密码（或“anonymous”和e-mail地址）
3.  客户端做各种文件传输和信息查询操作
4.  客户端登出远程FTP服务器，结束通讯

Of course, this is generally how it works. Sometimes there are circumstances
whereby the entire transaction is terminated before it’s completed. These
include being disconnected from the network if one of the two hosts crash or
because of some other network connectivity issue. For inactive clients, FTP
connections will generally time out after 15 minutes (900 seconds) of
inactivity. 
当然，这只是很泛的一个流程。有时，由于网络两边电脑的崩溃或是网络的问题，
会导致整个事务在完成之前被中断。一般，在客户端超过15分钟（900秒）不活动之后，连
接就会被关闭。

Under the covers, it is good to know that FTP uses only TCP (see earlier
chapter on network programming)—it does not use UDP in any way. Also, FTP may
be seen as a more “unusual” example of client/server programming because both
the clients and the servers use a pair of sockets for communication: one is the
control or command port (port 21), and the other is the data port (sometimes
port 20).
在底层上，FTP只使用TCP（见前面网络编程相关章节）——它不使用UDP。而且，FTP是客户端／
服务器编程中很“与众不同”的例子。客户端和服务器都使用两个套接字来通讯：一个是控制和
命令端口（21号端口），另一个是数据端口（有时是20号端口）。

ctrl/cmd
M (> 1023)
21



FTP server
(Active) (Passive)



FTP
client






data	Internet







M + 1	20 or
N (> 1023)


Figure 17–1    FTP Clients and Servers on the Internet. The client and server
communicate using the FTP protocol on the command or control port while data is
transferred using the data port.
图17-1 因特网上的FTP客户端和服务器。客户端和服务器使用指令和控制端口发送FTP协议，而
数据通过数据端口传输。

We say “sometimes” because there are two FTP modes, Active and Passive, and
the server’s data port is only 20 for Active mode. After the server sets up 20
as its data port, it “actively” initiates the connection to the client’s data
port. For Passive mode, the server is only responsible for letting the client
know where its random data port is, and the client must initiate the data
connection. As you can see in this mode, the FTP server is taking a more
“passive” role in setting up the data connection. Finally, there is now support
for a new Extended Passive Mode to support version 6 Internet Protocol (IPv6)
addresses—see RFC 2428.
我们说“有时”是因为FTP有两种模式：主动和被动。只有在主动模式服务器才使用数据端口。
在服务器把20号端口设置为数据端口后，它“主动”连接客户端的数据端口。而被动模式中，
服务器只是告诉客户端它的随机端口的号码，客户端必须主动建立数据连接。在这种模式下，你会看到，
FTP服务器在建立数据连接时是“被动”的。最后，现在已经有了一种扩展被动模式来支持第
6版本的因特网协议（IPv6）地址——见 RFC 2428。


Python has support for most Internet protocols, including FTP. Other sup-
ported client libraries can be found at
http://docs.python.org/lib/internet.html. Now let’s take a look at just how
easy it is to create an Internet client with Python.
Python已经支持了包括FTP在内的大多数据因特网协议。支持各个协议的客户端模块可以在
http://docs.python.org/lib/internet.html找到。现在看看用Python创建一个因特网
客户端程序有多简单。

17.2.3  Python and FTP
17.2.3 Python和FTP

So how do we write an FTP client using Python? What we just described in the
previous section covers it pretty much. The only additional work required is to
import the appropriate Python module and make the appropriate calls in Python.
So let us review the protocol briefly:
那么，我们怎么用Python写FTP客户端程序呢？其实，我们之前已经提到过一些了。现在还要
再加上相应的Python模块导入和调用的操作。现在再来回顾一下流程：

1.   Connect to server
2.   Log in
3.   Make service request(s) (and hopefully get reply[ies])
4.   Quit

1.   连接到服务器
2.   登录
3.   发出服务请求 （有可能有返回信息）
4.   退出

When using Python’s FTP support, all you do is import the ftplib module and
instantiate the ftplib.FTP class. All FTP activity will be accomplished using
your object, i.e., logging in, transferring files, and logging out. Here is
some Python pseudocode:
在使用Python的FTP支持时，你所需要做的就是导入ftplib模块，并实例化一个ftplib.FTP
类对象。所有的FTP操作（如登录，传输文件和登出等）都要使用这个对象来完成。下面是
一段Python的伪代码：

from ftplib import FTP
f = FTP('ftp.python.org')
f.login('anonymous', 'guess@who.org')
:
f.quit()

Soon we will look at a real example, but for now, let us familiarize ourselves
with methods from the ftplib.FTP class, which you will likely use in your code.
在看真实的例子之前，我们要先熟悉一下ftplib.FTP类的方法，这些方法将在代码中用到。

17.2.4  ftplib.FTP Class Methods
17.2.4 ftplib.FTP类方法

We outline the most popular methods in Table 17.1. The list is not
comprehensive— see the source code for the class itself for all methods—but the
ones presented here are those that make up the “API” for FTP client programming
in Python.
在表17.1中列出了最常用的方法，这个表并不全面——想查看所有的方法，请参阅模块源代码
——但这里列出的方法组成了我们在Python中FTP客户端编程的“API”。

In other words, you don’t really need to use the others as they are either
utility or administrative functions or are used by the API methods later.
也就是说，你不一定要使用其它的方法，因为它们或者是辅助函数，或者是管理函数，或者
是被API调用的。


Table 17.1 Methods for FTP Objects
表17.1 FTP对象的方法

Method	Description
方法    描述


login(user='anonymous', passwd='', acct='')
Log in to FTP server; all arguments are optional
login(user='anonymous', passwd='', acct='')
登录到FTP服务器，所有的参数都是可选的

pwd()	Current working directory
pwd()	得到当前工作目录

cwd(path)	Change current working directory to path
cwd(path)	把当前工作目录设置为path

dir([path[,...[,cb]])	Displays directory listing of path; optional callback cb passed to retrlines()
dir([path[,...[,cb]])	显示path目录里的内容，可选的参数cb是一个回调函数，它会被传给retrlines()方法

nlst([path[,...])	Like dir() but returns a list of filenames instead of displaying
nlst([path[,...])	与dir()类似，但返回一个文件名的列表，而不是显示这些文件名

retrlines(cmd [, cb])	Download text file given FTP cmd, e.g., “RETR filename”; optional callback 
                        cb for processing each line of file
retrlines(cmd [, cb])	给定FTP命令（如“RETR filename”），用于下载文本文件。可选的回调函数cb用于处理文件的每一行


retrbinary(cmd, cb[,    Similar to retrlines() except for binary file;
bs=8192[, ra]])         callback cb for processing each block (size bs
                        defaults to 8K) downloaded required
retrbinary(cmd, cb[,    与retrlines()类似，只是这个指令处理二进制文件。回调函数cb用于处理每一块
bs=8192[, ra]])         （块大小默认为8K）下载的数据。
                        
storlines(cmd, f)	Upload text file given FTP cmd, e.g., “STOR filename”; open file object f required
storlines(cmd, f)	给定FTP命令（如“STOR filename”），以上传文本文件。要给定一个文件对象f

storbinary(cmd, f[,     Similar to storlines() but for binary file;
bs=8192])               open file object f required, upload blocksize bs
                        defaults to 8K
storbinary(cmd, f[,     与storlines()类似，只是这个指令处理二进制文件。要给定一个文件对象f，上传块大小bs默认为8K
bs=8192])               
                        

rename(old, new)	Rename remote file from old to new
rename(old, new)	把远程文件old改名为new

delete(path)	Delete remote file located at  path 
delete(path)	删除位于path的远程文件

mkd(directory)	Create remote directory 
mkd(directory)	创建远程目录

rmd(directory)	Remove remote directory
rmd(directory)	删除远程目录

quit()	Close connection and quit
quit()	关闭连接并退出


The methods you will most likely use in a normal FTP transaction include
login(), cwd(), dir(), pwd(), stor*(), retr*(), and quit(). There are more FTP
object methods not listed in the table which you may find useful. Please see
the Python documentation for detailed information on FTP objects:
在一般的FTP通讯中，要使用到的指令有login(), cwd(), dir(), pwd(), stor*(), retr*()
和quit()。有一些没有列出的FTP对象方法也是很有用的。请参阅Python的文档以得到更多
关于FTP对象的信息：

http://python.org/docs/current/lib/ftp-objects.html

17.2.5  Interactive FTP Example
17.2.5 交互式FTP示例

An example of using FTP with Python is so simple to use that you do not even
have to write a script. You can just do it all from the interactive interpreter
and see the action and output in real time. This is a sample session we did
years ago when there was still an FTP server running at python.org:
在Python中使用FTP非常的简单，你甚至可以不用写脚本，直接在交互式解释器中
实时地看到交互与输出。下面这个例子是在几年前，python.org还支持ftp服务的时候做
的：

>>> from ftplib import FTP
>>> f = FTP('ftp.python.org')
>>> f.login('anonymous', '-help@python.org')
'230 Guest login ok, access restrictions apply.'
>>> f.dir()
total 38
drwxrwxr-x

10 1075

4127

512 May 17

2000 .

drwxrwxr-x
10 1075
4127
512 May 17
2000 ..

drwxr-xr-x
3 root
wheel
512 May 19
1998 bin

drwxr-sr-x
3 root
1400
512 Jun	9
1997 dev

drwxr-xr-x
3 root
wheel
512 May 19
1998 etc

lrwxrwxrwx
1 root
bin
7 Jun 29
1999 lib ->
usr/lib

-r--r--r--
1 guido
4127
52 Mar 24
2000 motd
drwxrwsr-x
8 1122
4127
512 May 17
2000 pub
drwxr-xr-x
5 root
wheel
512 May 19
1998 usr
>>> f.retrlines('RETR motd')
Sun Microsystems Inc.	SunOS 5.6	Generic August 1997
'226 Transfer complete.
>>> f.quit()
'221 Goodbye.'

17.2.6 Client Program FTP Example
17.2.6 客户端FTP程序举例

We mentioned previously that an example script is not even necessary since you
can run one interactively and not get lost in any code. We will try anyway. For
example, let us say you wanted a piece of code that goes to download the latest
copy of Bugzilla from the Mozilla Web site. Example 17.1 is what we came up
with. We are attempting an application here, but even so, you can probably run
this one interactively, too. Our application uses the FTP library to download
the file and built it with some error-checking.
之前我们说过，你可以不写脚本，在交互环境中使用FTP。不过，下面我们还是要写一段
脚本，假设你要从Mozilla的网站下载最新的Bugzilla的代码。例17.1就是用来完成这个
工作的。我们在试着写一个应用程序，不过，你也可以交互式地运行这段代码。我们的程
序使用FTP库来下载文件，也做了一些错误检测。

It is not automated, however; it is up to you to run it whenever you want to
perform the download, or if you are on a Unix-based system, you can set up a
“cron” job to automate it for you. Another issue is that it will break if
either the file or directory names change.
不过，程序并不完全自动。你要自己决定什么时候要去下载。如果你在使用类Unix系统，
你可以设定一个“cron”任务来自动下载。另一个问题是，如果文件的文件名或目录名改了的
话，程序就不能正常工作了。

Example 17.1 FTP Download Example (getLatestFTP.py)
例17.1 FTP下载示例 (getLatestFTP.py)

This program is used to download the latest version of a file from a Web site.
You can tweak it to download your favorite application.
这个程序用于下载网站中最新版本的文件。你可以修改这个程序让它下载你喜欢的程序。

1	#!/usr/bin/env python
11   def main():
12	try:
13	f = ftplib.FTP(HOST)
14	except (socket.error, socket.gaierror), e:
15	print 'ERROR: cannot reach "%s"' % HOST
16	return
17	print '*** Connected to host "%s"' % HOST
18
19	try:
20	f.login()
21	except ftplib.error_perm:
22	print 'ERROR: cannot login anonymously’
23	f.quit()
24	return
25	print '*** Logged in as "anonymous"'
26
27	try:
28	f.cwd(DIRN)
29	except ftplib.error_perm:
30	print 'ERROR: cannot CD to "%s"' % DIRN
31	f.quit()
32	return
33	print '*** Changed to "%s" folder' % DIRN
34
35	try:
36	f.retrbinary('RETR %s' % FILE,
37	open(FILE, 'wb').write)
38	except ftplib.error_perm:
39	print 'ERROR: cannot read file "%s"' % FILE
40	os.unlink(FILE)
41	else:
42	print '*** Downloaded "%s" to CWD' % FILE
43	f.quit()
44	return
45
46   if __name__ == '__main__':
47	main()


If no errors occur when we run our script, we get the following output:
如果运行脚本时没有出错，则会得到如下输出：

$ getLatestFTP.py
*** Connected to host "ftp.mozilla.org"
*** Logged in as "anonymous"
*** Changed to "pub/mozilla.org/webtools" folder
*** Downloaded "bugzilla-LATEST.tar.gz" to CWD
$

Line-by-Line Explanation
逐行解释

Lines 1–9
1-9行
The initial lines of code import the necessary modules (mainly to grab
exception objects) and set a few constants.
代码前几行导入要用的模块和设置一些常量

Lines 11–44
11-44行
The main() function consists of various steps of operation: create an FTP
object and attempt to connect to the FTPs server (lines 12–17) and (return and)
quit on any failure. We attempt to login as “anonymous” and bail if it fails
(lines 19–25). The next step is to change to the distribution directory (lines
27–33), and finally, we try to download the file (lines 35–44).
main()函数分为以下几步：创建一个FTP对象，尝试连接到FTP服务器（12-17行）然后返回。
在有任何错误发生的时候退出。我们尝试用“anonymous”登录，如果不行就结束（19-25行）。
下一步就是转到发布目录（27-33行），最后，下载文件（35-44行）。

On lines 35–36, we pass a callback to retrbinary() that should be executed for
every block of binary data downloaded. This is the write() method of a file
object we create to write out the local version of the file. We are depending
on the Python interpreter to adequately close our file after the transfer is
done and not to lose any of our data. Although more convenient, your author
tries to not use this style as much as possible because the programmer should
be responsible for freeing resources directly allocated rather than depending
on other code. In this case, we should save the open file object to a variable,
say loc, and then pass loc.write in the call to ftp.retrbinary().
在35-36行，我们传了一个回调函数给retrbinary()，它在每接收到一块二进制数据的
时候都会被调用。这个函数就是我们创建的本地文件对应文件对象的write方法。在传输结束
的时候，Python解释器会自动关闭这个文件对象，而不会丢失数据。虽然这样方便，但最好
还是不要这样做，做为一个程序员，要尽量做到在资源不再被使用的时候就直接释放，而不是
依赖其它代码来做释放操作。在这里，我们应该把文件对象保存到一个变量中，如变量loc，
然后把loc.write传给ftp.retrbinary()方法。

Also in this block of code, if for some reason we are not able to save the
file, we remove the empty file if it is there to avoid cluttering up the file
system (line 40). Finally, to avoid another pair of lines that close the FTP
connection and return, we use a try-except-else clause (lines 35–42).
在代码中，如果由于某些原因我们无法保存这个文件，那要把存在的空文件给删掉，以防
搞乱文件系统（40行）。最后，我们使用了try-except-else子句（35-42行），而不是
写两遍关闭FTP连接然后返回的代码。

Lines 46–47
46-47行
This is the usual idiom for running a standalone script.
这是运行独立脚本的惯用方法。

17.2.7 Miscellaneous FTP
17.2.7 FTP的其它方面

Python supports both Active and Passive modes. Note, however, that in Python
2.0 and before, Passive mode was off by default; in Python 2.1 and later, it is
on by default.
Python同时支持主动和被动模式。注意，在Python2.0及以前版本中，被动模式支持默认是关闭的，
在Python2.1及以后版本中，默认是打开的。

Here is a list of typical FTP clients:
以下是一些典型的FTP客户端类型：
?	Command-line client program: This is where you execute FTP transfers by
running an FTP client program such as /bin/ftp, or NcFTP, which allows users
to interactively participate in an FTP transaction via the command line.
?	命令行客户端程序：你可以使用一些FTP文件传输工具如/bin/ftp或NcFTP，它们允许
用户在命令行交互式的参与到FTP通讯中来。

?	GUI client program: Similar to a command-line client program except it
is a GUI application like WsFTP and Fetch.
?	GUI客户端程序：与命令行客户端程序相似，只是它是一个GUI程序。如WsFTP和Fetch等。

?	Web browser: In addition to using HTTP, most Web browsers (also
referred to as a client) can also speak FTP. The first directive in a URL/URI
is the protocol, i.e., “http://blahblah.” This tells the browser to use HTTP as
a means of transferring data from the given Web site. By changing the protocol,
one can make a request using FTP, as in “ftp://blahblah.” It looks pretty much
exactly the same as an URL, which uses HTTP. (Of course, the “blahblah” can
expand to the expected “host/path?attributes” after the protocol directive
“ftp://”. Because of the login requirement, users can add their logins and
passwords (in clear text) into their URL, i.e.,
?	网页浏览器：在使用HTTP之外，大多数网页浏览器（也是一个客户端）可以进行FTP
通讯。URL/URI的第一部分就用来表示所使用的协议，如“http://blahblah.”这就告诉浏览器
要使用HTTP做为与给定网站进行通讯的协议。修改协议部分，就可以发使用FTP的请求，如“
ftp://blahblah.”，这跟使用HTTP的网页的URL很像。（当然，“ftp://”后面的“blahblah”
可以展开为“host/path?attributes”）。如果要登录，用户可以把登录信息（以明文方式）
放在URL里，如：
“ftp://user:passwd@host/path?attr1=val1&attr2=val2. . .”.

?	Custom application: A program you write that uses FTP to transfer
files. It generally does not allow the user to interact with the server as the
application was created for specific purposes.
?	定制程序：你自己写的用于FTP文件传输的程序。由于程序用于特殊目的，一般这种
程序都不允许用户与服务器接触。

All four types of clients can be creating using Python. We used ftplib above to
create our custom application, but you can just as well create an interactive
command-line application. On top of that, you can even bring a GUI toolkit such
as Tk, wxWidgets, GTK+, Qt, MFC, and even Swing into the mix (by importing
their respective Python [or Jython] interface modules) and build a full GUI
application on top of your command-line client code. Finally, you can use
Python’s urllib module to parse and perform FTP transfers using FTP URLs. At
its heart, urllib imports and uses ftplib making urllib another client of
ftplib.
这四种客户端类型都可以用Python来写。上面，我们用ftplib来创建了一个自己的定制程序，
你也可以自己做一个命令行的应用程序。在命令行的基础上，你可以使用一些界面工具包，
如Tk，wxWidgets，GTK+，Qt，MFC，甚至Swing（要导入相应的Python[或Jython]的接口模块）
来创建一个完整的GUI程序。最后，你可以使用Python的urllib模块来解析FTP的URL并进行FTP
传输。在urllib的内部也导入并使用了ftplib，urllib也是ftplib的客户端。

FTP is not only useful for downloading client applications to build and/or use,
but it can also be helpful in your everyday job if it involves moving files
between systems. For example, let us say you are an engineer or a system
administrator needing to transfer files. It is an obvious choice to use the scp
or rsync commands when crossing the Internet boundary or pushing files to an
externally visible server. However, there is a penalty when moving extremely
large logs or database files between internal machines on a secure network in
that manner: security, encryption, compression/decompression, etc. If what you
want to do is just build a simple FTP application that moves files for you
quickly during the after-hours, using Python is a great way to do it!
FTP不仅可以用在下载应用程序上，还可以用在系统之间文件的转移上。比如，如果你是一个
工程师或是系统管理员，你需要传输文件。在跨网络的时候，很明显可以使用scp或rsync命令，
或者把文件放到一个外部能访问的服务器上。不过，在一个安全网络的内部机器之间移动
大量的日志或数据库文件，这种方法的开销就太大了，要注意安全性，加密，压缩，解压缩等。
如果你想要做的只是写一个FTP程序来帮助你在下班后自动移动文件，那用Python是一个非常
好的主意。

You can read more about FTP in the FTP Protocol Definition/Specification (RFC
959) at ftp://ftp.isi.edu/in-notes/rfc959.txt as well as on the http://www.
networksorcery.com/enp/protocol/ftp.htm Web page. Other related RFCs include
2228, 2389, 2428, 2577, 2640, and 4217. To find out more about Python’s FTP
support, you can start here:
从FTP协议定义／规范（RFC 959）中，你可以得到更多关于FTP的信息：
ftp://ftp.isi.edu/in-notes/rfc959.txt以及网页
http://www.networksorcery.com/enp/protocol/ftp.htm。其它相关的RFC有2228，2389，
2428，2577，2640和4217。想了解更多Python对FTP的支持，可以从这里开始：
http://python.org/docs/current/lib/module-ftplib.html.


17.3 Network News
17.3 网络新闻

17.3.1 Usenet and Newsgroups
17.3.1 Usenet与新闻组

The Usenet News System is a global archival “bulletin board.” There are
newsgroups for just about any topic, from poems to politics, linguistics to
computer languages, software to hardware, planting to cooking, finding or
announcing employment opportunities, music and magic, breaking up or finding
love. Newsgroups can be general and worldwide or targeted toward a specific
geographic region.
Usenet新闻系统是一个全球存档的“电子公告板”。各种主题的新闻组一应俱全，从诗歌
到政治，从自然语言学到计算机语言，软件到硬件，种植到烹饪，招工，应聘，音乐，
魔术，分手，求爱等。新闻组可以是面向全球泛泛而谈，也可以是只面向某个地理区域。

The entire system is a large global network of computers that participate in
sharing Usenet postings. Once a user uploads a message to his or her local
Usenet computer, it will then be propagated to other adjoining Usenet com-
puters, and then to the neighbors of those systems, until it’s gone around the
world and everyone has received the posting. Postings will live on Usenet for a
finite period of time, either dictated by a Usenet system administrator or the
posting itself via an expiration date/time.
整个系统是一个由大量计算机组成的一个庞大的全球网络,计算机之间共享Usenet上的帖子.如果某一个用户发了一个帖子到本地的Usenet计算机上,这个帖子会被传播到其它相连的计算机上，并再由这些计算机传到与它们相连的计算机上,直到这个帖子传播到了全世界，每个人都收到这个帖子为止.





Each system has a list of newsgroups that it “subscribes” to and only accepts
postings of interest—not all newsgroups may be archived on a server. Usenet
news service is dependent on which provider you use. Many are open to the
public while others only allow access to specific users, such as paying
subscribers, or students of a particular university, etc. A login and password
are optional, configurable by the Usenet system administrator. The ability to
post or download-only is another parameter configurable by the administrator.
每个系统都有一个它已经“订阅”的新闻组的列表，它只接收它感兴趣的新闻组里的帖子——
而不是服务器上所有新闻组的帖子。Usenet新闻组服务内容取决于服务提供者，很多都是
可供公众访问的，也有一些只允许特定的用户使用，例如付费用户，特定大学的学生等。
如果Usenet系统管理员设置了的话，有可能会要求输入用户名和密码。管理员也可以设置
是否只允许上传或只允许下载。

17.3.2 Network News Transfer Protocol (NNTP)
17.3.2 网络新闻传输协议(NNTP)

The method by which users can download newsgroup postings or “articles” or
perhaps post new articles is called the Network News Transfer Protocol (NNTP).
It was authored by Brian Kantor (UC San Diego) and Phil Lapsley (UC Berkeley)
in RFC 977, published in February 1986. The protocol has since then been
updated in RFC 2980, published in October 2000.
供用户在新闻组中下载或发表帖子的方法叫网络新闻传输协议（NNTP）。它由
Brain Kantor（加利福尼亚大学圣地亚哥分校）和Phil Lapsley（加利福尼亚大学伯克利分校）
创建并记录在RFC 977中，于1986年2月公布。其后的更新记录在RFC 2980，于2000年10月公布。

As another example of client/server architecture, NNTP operates in a fashion
similar to FTP; however, it is much simpler. Rather than having a whole set of
different port numbers for logging in, data, and control, NNTP uses only one
standard port for communication, 119. You give the server a request, and it
responds appropriately, as shown in Figure 17–2.
作为客户端／服务器架构的另一个例子，NNTP与FTP的操作方式很像，而且简单得多。FTP
需要不同的端口来做登录，数据传输和控制，而NNTP只使用一个标准端口119来做通讯。
你给服务器一个请求，它做相应的反馈，见图17-2。

Usenet on the Internet
在因特网上使用Usenet








NNTP
clients
(newsreaders)
NNTP
servers


NNTP
(update)




Figure 17–2    NNTP Clients and Servers on the Internet. Clients
mostly read news but may also post. Articles are then distributed as servers update each other.
图17-2 因特网上的NNTP客户端和服务器。客户端主要阅读新闻，有时也发帖子。文章会在服务器之间做同步。



17.3.3 Python and NNTP
17.3.3 Python和NNTP

Based on your experience with Python and FTP above, you can probably guess that
there is an nntplib and an nntplib.NNTP class that you need to instantiate, and
you would be right. As with FTP, all we need to do is to import that Python
module and make the appropriate calls in Python. So let us review the protocol
briefly:
由于之前已经有了Python和FTP的经验，你也许可以猜到，一定有一个库nntplib和一个类
nntplib.NNTP，你要实例化这个类。你猜对了。用FTP一样，我们所要做的就是导入那个Python
模块，然后调用相应的方法。我们先大致看一下这个协议：

1.  Connect to server
2.  Log in (if applicable)
3.  Make service request(s)
4.  Quit

1.  连接到服务器
2.  登录（如果需要的话）
3.  发送请求
4.  退出

Look somewhat familiar? It should, because it’s practically a carbon copy of
the FTP protocol. The only change is that the login step is optional, depending
on how an NNTP server is configured.
是不是有点熟悉？是的，这几乎就是完全复制了FTP协议。唯一的不同就是根据NNTP服务器的
配置不一样，登录这一步是可选的。

Here is some Python pseudocode to get started:
下面是一段Python的伪代码：

from nntplib import NNTP
n = NNTP('your.nntp.server')
r,c,f,l,g = n.group('comp.lang.python')
... n.quit()


Typically, once you log in, you will choose a newsgroup of interest and call
the group() method. It returns the server reply, a count of the number of
articles, the ID of the first and last articles, and superfluously, the group
name again. Once you have this information, you will then perform some sort of
action such as scroll through and browse articles, download entire postings
(headers and body of article), or perhaps post an article.
一般来说，在你登录完成后，你要调用group()方法来选择一个感兴趣的新闻组。方法返回
服务器的返回信息，文章的数量，第一个和最后一个文章的ID，以及组的名字。在有了这些
信息后，你会做一些其它的操作，如从头到尾看文章，下载整个帖子（文章的标题和内容），
或者发表一篇文章等。

Before we take a look at a real example, let’s introduce some of the more
popular methods of the nntplib.NNTP class.
在看真实的例子之前，我们要先介绍一下nntplib.NNTP类的一些常用的方法。

17.3.4 nntplib.NNTP Class Methods
17.3.4 nntplib.NNTP类方法

As in the previous section outlining the ftplib.FTP class methods, we will not
show you all methods of nntplib.NNTP, just the ones you need in order to create
an NNTP client application.
跟前一节列出ftplib.FTP类的方法时一样，我们不会列出nntplib.NNTP的所有方法，只列出你
创建NNTP客户端程序时可能用得着的方法。


Table 17.2  Methods for NNTP Objects
表17.2 NNTP对象的方法


Method	Description
方法    描述

group(name)	Select newsgroup name and return a tuple (rsp, ct, fst, lst,
                group): server response, number of articles, first and last 
                article numbers and group name, all of which are strings 
                (name == group)
group(name)	选择一个组的名字，返回一个元组(rsp,ct,fst,lst,group): 服务器的返回信息，
                文章的数量，第一个和最后一个文章的号码以及组名，所有数据都是字符串。
                （返回的group与我们传进去的name应该是相同的）
                
xhdr(hdr, artrg,        Returns list of hdr headers for article range artrg
[ofile])                (“first-last” format) or outputs data to file ofile
xhdr(hdr, artrg,        返回文章范围artrg('头-尾'的格式)内文章hdr头的列表，或输出到文件ofile中
[ofile])                

body(id[,       Get article body given its id, which is either a message ID 
ofile])         (enclosed in <...> or an article number (as a string); returns tuple 
                (rsp, anum, mid, data): server response, article number (as a string),
                message ID (enclosed in <...>), and list of article lines or outputs
                data to file ofile
body(id[,       给定文章的id，id可以是消息的ID（放在尖括号里），或一个文章号（是一个字符串），返回
ofile])         一个元组(rsp, anum, mid, data): 服务器的返回信息，文章号（是一个字符串），消息的ID
                （放在尖括号里），和文章所有行的列表或把数据输出到文件ofile中。

head(id)	Similar to body(). . . same tuple returned except lines only contain 
                article headers
head(id)	与body()相似，只是返回的元组中那个行的列表中只包含了文章的标题。
                
article(id)	Also similar to body(). . . same tuple returned except lines contain 
                both headers and article body
article(id)	也跟body()一样，只是返回的元组中那个行的列表中包含了文章的标题和内容。

stat(id)	Set article “pointer” to id (message ID or article number as above); 
                returns tuple similar to body (rsp, anum, mid) but contains no data 
                from article
stat(id)	让文章的“指针”指向id（同上，是一个消息的ID或是文章的号码）。返回一个跟body一样
                的元组(rsp, anum, mid)，但不包含文章的数据。
                
next()	Used with stat(), moves article pointer to “next” article and returns similar tuple
next()	用法和stat()类似，把文章指针移到下一篇文章，返回与stat()相似的元组

last()	Also used with stat(), moves article pointer to “last” article and returns similar tuple
last()	用法和stat()类似，把文章指针移到最后一篇文章，返回与stat()相似的元组

post(ufile)	Upload data from ufile file object (using ufile.readline()) and post to current newsgroup
post(ufile)	上传ufile文件对象里的内容（使用ufile.readline()），并在当前新闻组发表。

quit()	Close connection and quit
quit()	关闭连接，然后退出


As with the FTP objects table in the previous segment, there are more NNTP
object methods not described here. To avoid clutter, we list only the ones we
think you would most likely use. For the rest, we again refer you to the Python
Library Reference.
跟上一节的FTP对象表一样，还有一些NNTP对象的方法没有提及。为了避免混乱，我们只
列出了你可能用得到的。其余的，我们再次建议你参考Python手册。


17.3.5 Interactive NNTP Example
17.3.5 交互式NNTP举例

Here is an interactive example of how to use Python’s NNTP library. It should
look similar to the interactive FTP example. (The e-mail addresses have been
changed for privacy reasons.)
接下来，是一个如何使用Python中NNTP库的交互式的例子。它看上去跟交互式的FTP的例子
差不多。（出于保密的原因，e-mail地址都做了修改）。

When connecting to a group, you get a 5-tuple back from the group() method as
described in Table 17.2.
在调用表17.2中所列的group()方法连接到一个组的时候，你会得到一个长度为5的元组。

>>> from nntplib import NNTP
>>> n = NNTP('your.nntp.server')
>>> rsp, ct, fst, lst, grp = n.group('comp.lang.python')
>>> rsp, anum, mid, data = n.article('110457')
>>> for eachLine in data:
...	print eachLine
From: "Alex Martelli" <alex@...> Subject: Re: Rounding Question
Date: Wed, 21 Feb 2001 17:05:36 +0100
"Remco Gerlich" <remco@...> wrote:
> Jacob Kaplan-Moss <jacob@...> wrote in comp.lang.python:
>> So I've got a number between 40 and 130 that I want to round up to
>> the nearest 10. That is:
>>
>>	40 --> 40, 41 --> 50, ..., 49 --> 50, 50 --> 50, 51 --> 60
>> Rounding like this is the same as adding 5 to the number and then
> rounding down. Rounding down is substracting the remainder if you were
> to divide by 10, for which we use the % operator in Python.

This will work if you use +9 in each case rather than +5 (note that he doesn't
really want rounding -- he wants 41 to 'round' to 50, for ex).

Alex
>>> n.quit()
'205 closing connection - goodbye!'
>>>

17.3.6 Client Program NNTP Example
17.3.6 客户端程序NNTP举例

For our NNTP client example, we are going to try to be more adventurous. It
will be similar to the FTP client example in that we are going to download the
latest of something—this time it will be the latest article available in the
Python language newsgroup, comp.lang.python.
在NNTP客户端例子中，我们来点更复杂的。在之前的FTP客户端例子中，我们是下载最新的文件，
这一次，我们要下载Python语言新闻组com.lang.python里的最后一篇文章。

Once we have it, we will display (up to) the first 20 lines in the article, and
on top of that, (up to) the first 20 meaningful lines of the article. By that,
we mean lines of real data, not quoted text (which begin with “>” or “|”) or
even quoted text introductions like “In article <. . .>, soAndSo@some.domain
wrote:”.
下载完成后，我们会显示文章的前20行，而且是前20行有意义的内容。有意义的内容是指那些
不是被引用的文本（引用以“>”或“|”开头），也不是像这样的文本“In article <. . .>, 
soAndSo@some.domain wrote:”。

Finally, we are going to do blank lines intelligently. We will display one
blank line when we see one in the article, but if there are more than one
consecutive blank, we only show the first blank line of the set. Only lines
with real data are counted toward the “first 20 lines,” so it is possible to
display a maximum of 39 lines of output, 20 real lines of data interleaved with
19 blank ones.
最后，我们要智能的处理空行。在文章中出现了一行空行，那我们就显示一行空行，但如果有
多行连续的空行，那只显示一行空行。只有有数据的行才算在“前20行”之中。所以，最多可能
显示39行输出，20行实际数据间隔了19行空行。

If no errors occur when we run our script, we may see something like this:
如果脚本的运行正常的话，我们可能会看到这样的输出：

$ getLatestNNTP.py
*** Connected to host "your.nntp.server"
*** Found newsgroup "comp.lang.python"
*** Found last article (#471526):

From: "Gerard Flanagan" <grflanagan@...>
Subject: Re: Generate a sequence of random numbers that sum up to 1? Date: Sat Apr 22 10:48:20 CEST 2006
*** First (<= 20) meaningful lines:
def partition(N=5):
vals = sorted( random.random() for _ in range(2*N) )
vals = [0] + vals + [1]
for j in range(2*N+1):
yield vals[j:j+2]
deltas = [ x[1]-x[0] for x in partition() ]
print deltas
print sum(deltas)
[0.10271966686994982, 0.13826576491042208, 0.064146913555132801,
0.11906452454467387, 0.10501198456091299, 0.011732423830768779,
0.11785369256442912, 0.065927165520102249, 0.098351305878176198,
0.077786747076205365, 0.099139810689226726]
1.0
$

Example 17.2  NNTP Download Example (getFirstNNTP.py)
例17.2 NNTP下载示例 （getFirstNNTP.py）

This downloads and displays the first “meaningful” (up to 20) lines of the most
recently available article in comp.lang.python, the Python newsgroup.
这个脚本下载并显示Python新闻组comp.lang.python最后一篇文章的前20个“有意义的”行。

1	#!/usr/bin/env python









11   def main():
12
13	try:
14	n = nntplib.NNTP(HOST)
15	#, user=USER, password=PASS)
16	except socket.gaierror, e:
17	print 'ERROR: cannot reach host "%s"' % HOST
18	print '	("%s")' % eval(str(e))[1]
19	return
20	except nntplib.NNTPPermanentError, e:
21	print 'ERROR: access denied on "%s"' % HOST
22	print '	("%s")' % str(e)
23	return
24	print '*** Connected to host "%s"' % HOST
25
26	try:
27	rsp, ct, fst, lst, grp = n.group(GRNM)
28	except nntplib.NNTPTemporaryError, e:
29	print 'ERROR: cannot load group "%s"' % GRNM
30	print '	("%s")' % str(e)
31	print '	Server may require authentication'
32	print '	Uncomment/edit login line above'
33	n.quit()
34	return
35	except nntplib.NNTPTemporaryError, e:
36	print 'ERROR: group "%s" unavailable' % GRNM
37	print '	("%s")' % str(e)
38	n.quit()
39	return
40	print '*** Found newsgroup "%s"' % GRNM

42	rng = '%s-%s' % (lst, lst)
43	rsp, frm = n.xhdr('from', rng)
44	rsp, sub = n.xhdr('subject', rng)
45	rsp, dat = n.xhdr('date', rng)

46	print
47
'''*** Found last article (#%s):

(continued)

Example 17.2  NNTP Download Example
(getFirstNNTP.py) (continued)

48	From: %s
49	Subject: %s
50	Date: %s
51   '''% (lst, frm[0][1], sub[0][1], dat[0][1])
52
53	rsp, anum, mid, data = n.body(lst)
54	displayFirst20(data)
55	n.quit()
56
57   def displayFirst20(data):
58	print '*** First (<= 20) meaningful lines:\n'
59	count = 0
60	lines = (line.rstrip() for line in data)
61	lastBlank = True
62	for line in lines:
63	if line:
64	lower = line.lower()
65	if (lower.startswith('>') and not \
66	lower.startswith('>>>')) or \
67	lower.startswith('|') or \
68	lower.startswith('in article') or \


71	continue
72	if not lastBlank or (lastBlank and line):
73	print '	%s' % line
74	if line:
75	count += 1
76	lastBlank = False
77	else:
78	lastBlank = True
79	if count == 20:
80	break
81
82   if __name__ == '__main__':
83	main()


This output is given the original newsgroup posting, which looks like this:
这个输出显示了新闻组帖子的原始内容，如下：

From: "Gerard Flanagan" <grflanagan@...>
Subject: Re: Generate a sequence of random numbers that sum up to 1? Date: Sat Apr 22 10:48:20 CEST 2006
Groups: comp.lang.python

Gerard Flanagan wrote:
> Anthony Liu wrote:
> > I am at my wit's end.

> > I want to generate a certain number of random numbers.
> >  This is easy, I can repeatedly do uniform(0, 1) for
> > example.

> > But, I want the random numbers just generated sum up
> > to 1 .

> > I am not sure how to do this.  Any idea?  Thanks.

> --------------------------------------------------------------
> import random

> def partition(start=0,stop=1,eps=5):
>	d = stop - start
>	vals = [ start + d * random.random() for _ in range(2*eps) ]
>	vals = [start] + vals + [stop]
>	vals.sort()
>	return vals

> P = partition()

> intervals = [ P[i:i+2] for i in range(len(P)-1) ]

> deltas = [ x[1] - x[0] for x in intervals ]

> print deltas

> print sum(deltas)
> ---------------------------------------------------------------

def partition(N=5):
vals = sorted( random.random() for _ in range(2*N) )
vals = [0] + vals + [1]
for j in range(2*N+1):
yield vals[j:j+2]

deltas = [ x[1]-x[0] for x in partition() ]

print deltas

print sum(deltas)

[0.10271966686994982, 0.13826576491042208, 0.064146913555132801,
0.11906452454467387, 0.10501198456091299, 0.011732423830768779,
0.11785369256442912, 0.065927165520102249, 0.098351305878176198,
0.077786747076205365, 0.099139810689226726]
1.0


Of course, the output will always be different since articles are always being
posted. No two executions will result in the same output unless your news
server has not been updated with another article since you last ran the script.
当然，由于新文章不断的出现，输出经常会不一样。只要你的服务器里一有文章更新，
输出就会不一样了。

Line-by-Line Explanation
逐行解释

Lines 1–9
1-9行
This application starts with a few import statements and some constants, much
like the FTP client example.
程序开始是一些导入语句和常量定义，跟FTP客户端差不多。

Lines 11–40
11-40行
In the first section, we attempt to connect to the NNTP host server and bail if
it tails (lines 13–24). Line 15 is commented out deliberately in case your
server requires authentication (with login and password)—if so, uncomment this
line and edit it in with line 14. This is followed by trying to load up the
specific newsgroup. Again, it will quit if that newsgroup does not exist, is
not archived by this server, or if authentication is required (lines 26–40).
在第一部分，我们尝试连接到NNTP服务器，如果失败就退出（13-24行）。第15行故意注释
掉了，如果需要输入用户名和密码进行认证的话，可以打开这一行，并修改第14行。后面是
尝试读取指定的新闻组。同样，如果新闻组不存在，服务器没有保存这个新闻组，或是需要
认证的话，退出（26-40行）。

Lines 42–55
42-55行
In the next part we get some headers to display (lines 42–51). The ones that
have the most meaning are the author, subject, and date. This data is retrieved
and displayed to the user. Each call to the xhdr() method requires us to give
the range of articles to extract the headers from. We are only interested in a
single message, so the range is “X-X” where X is the last message number.
下面这一部分，我们读一些头信息，并显示出来（42-51行）。最有用处的头信息包括作者，
主题和日期。这些数据会被读取并显示给用户。在每一次调用xhdr()方法时，都要给定想要提取
信息头的文章的范围。我们只想取一条信息，所以范围就是“X-X”，其中，X是最后一条信息
的号码。

xhdr() returns a 2-tuple consisting of a server response (rsp) and a list of
the headers in the range we specify. Since we are only requesting this
information for one message (the last one), we just take the first element of
the list (hdr[0]). That data item is a 2-tuple consisting of the article number
and the data string. Since we already know the article number (because we give
it in our range request), we are only interested in the second item, the data
string (hdr[0][1]).
xhdr()方法返回一个长度为2的元组，包含了服务器的返回信息（rsp）和我们指定范围的
信息头的列表。由于我们只指定了一个消息（最后一个），我们只取列表的第一个元素
（hdr[0]）。数据元素是一个长度为2的元组，包含文章号和数据字符串。由于我们已经
知道了文章号（我们在请求中给出了），我们只关心第二个元素，数据字符串（hdr[0][1]）。

The last part is to download the body of the article itself (lines 53–55). It
consists of a call to the body() method, a display the first 20 or fewer
meaningful lines (as defined at the beginning of this section), a logout of the
server, and complete execution.
最后一部分是下载文章的内容（53-55行）。先调用body()方法，然后显示前20个有意义的
行，最后登出服务器，完成执行。

Lines 57–80
57-80行
The core piece of processing is done by the displayFirst20() function (lines
57–80). It takes the set of lines making up the article body and does some
preprocessing like setting our counter to 0, creating a generator expression
that lazily iterates through our (possibly large) set of lines making up the
body, and “pretends” that we have just seen and displayed a blank line (more on
this later; lines 59–61). When we strip the line of data, we only remove the
trailing whitespace (rstrip()) because leading spaces may be intended lines of
Python code.
主要的处理任务由displayFirst20()函数完成（57-80行）。它接受文章的所有行做为参数，
并做一些预处理，如把计数器清0，创建一个生成器表达式对文章内容的所有行做一些
处理，然后“假装”我们刚碰到并显示了一行空行（59-61行，稍后细说）。由于前导空格
可能是Python代码的一部分，所以在我们去掉字符串中的空格的时候，只删除字符串右边
的空格（rstrip()）。

One criterion we have is that we should not show any quoted text or quoted text
introductions. That is what the big if statement is for on lines 65–71 (also
include line 64). We do this checking if the line is not blank (line 63).  We
lowercase the line so that our comparisons are case-insensitive (line 64).
我们要做的是，我们不要显示引用的文本和引用文本指示行。这就是65-71行（也包含64行）
的那个大if语句所要做的事。如果这一行不是空行的时候，才做这个检查（63行）。检查
的时候，会把字符串转成小写，这样就能做到比较的时候大小写无关（64行）。

If a line begins with “>” or “|,” it means it is usually a quote. We make an
exception for lines that start with “>>>” since it may be an interactive
interpreter line, although this does introduce a flaw that a triply-old message
(one quoted three times for the fourth responder) is displayed. (One of the
exercises at the end of the chapter is to remove this flaw.) Lines that begin
with “in article . . .”, and/or end with “writes:” or “wrote:”, both with
trailing colons ( : ), are also quoted text introductions. We skip all these
with the continue statement.
如果一行以“>”或“|”开头，说明这一般是一个引用。不过，我们认为“>>>”是一个例外，因为
这有可能是交互命令行的提示，虽然这样可能有问题，因为它也可能是一段被引用了三次的
消息（1段文本到第4个回复的帖子时被引用了3次）却被显示了。

Now to address the blank lines. We want our application to be smart. It should
show blank lines as seen in the article, but it should be smart about it. If
there is more than one blank line consecutively, only show the first one so the
user does not see unnecessarily excessive lines, scrolling useful information
off the screen. We should also not count any blank lines in our set of 20
meaningful lines. All of these requirements are taken care of in lines 72–78.
现在来处理空行。我们想让程序聪明一些，它应该能显示文章中的空行，但对空行的处理要
做到智能。如果有多个连续的空行，则只显示第一个，这样用户不用看那么多行信息，导致有
用的信息却在屏幕之外。我们也不能把空行计算到20行有意义的行之中。所有这些要求都在
72-78行内实现。

The if statement on line 72 says to only display the line if the last line was
not blank, or if the last line was blank but now we have a non-blank line. In
other words, if we fall through and we print the current line, it is because it
is either a line with data or a blank line as long as the previous line was not
blank. Now the other tricky part: if we have a non-blank line, count it and set
the lastBlank flag to False since this line was not empty (lines 74–76).
Otherwise, we have just seen a blank line so set the flag to True.
72行的if语句表示只有在上一行不为空，或者上一行为空但当前行不为空的时候才显示。
也就是说，如果显示了当前行的话，就说明要么当前行不为空，要么当前行为空但上一行
不为空。这是另一个比较有技巧的地方：如果我们碰到了一个非空行，计数器加1，并设置
lastBlank标志为False，以表示这一行非空（74-76行）。否则，表示我们碰到了空行，把标
志设为True。

Now back to the business on line 61 . . . we set the lastBlank flag to True
because if the first real (non-introductory or quoted) line of the body is a
blank, we do not want to display it . . . we want to show the first real data
line!
现在回到第61行，我们设lastBlank标志为True，是因为，如果内容的第一行实际数据
（不是前导数据或是引用数据）是一个空行，我们不会显示它。因为我们想要看第一行
实际数据！

Finally, if we have seen 20 non-blank lines, then we quit and discard the
remaining lines (lines 79–80). Otherwise we would have exhausted all the lines
and the for loop terminates normally.
最后，如果我们已经显示了20行非空行，则退出，放弃其余的行（79-80行）。否则，我们
应该已经遍历了所有行，循环也正常结束了。

17.3.7 Miscellaneous NNTP
17.3.7 NNTP的其它方面

You can read more about NNTP in the NNTP Protocol Definition/ Specification
(RFC 977) at ftp://ftp.isi.edu/in-notes/rfc977.txt as well as on the
http://www.networksorcery.com/enp/protocol/nntp.htm Web page. Other related
RFCs include 1036 and 2980. To find out more about Python’s NNTP support, you
can start here: http://python.org/docs/current/lib/module-nntplib.html.
从NNTP协议定义／规范（RFC 977）中，你可以得到更多关于NNTP的信息：
ftp://ftp.isi.edu/in-notes/rfc977.txt以及网页
http://www.networksorcery.com/enp/protocol/nntp.htm。其它相关的RFC有1036，2980。
想了解更多Python对NNTP的支持，可以从这里开始：
http://python.org/docs/current/lib/module-nntplib.html.


17.4 Electronic Mail
17.4 电子邮件

Electronic mail is both archaic and modern at the same time. For those of us
who have been using the Internet since the early days, e-mail seems so “old,”
especially compared to newer and more immediate communication mechanisms such
as Web-based online chat, instant messaging (IM), and digital telephony, i.e.,
Voice Over Internet Protocol (VOIP), applications. The next section gives a
high-level overview of how e-mail works. If you are already familiar with this
and just want to move on to developing e-mail-related clients in Python, skip
to the succeeding sections.
电子邮件既古老又现代。对于我们这些从很早就开始用因特网的人来说，e-mail看上去是
如此的“古老”，尤其是相对于基于网页的在线聊天，即时聊天（IM），和数字电话即
VOIP（Voice Over Internet Protocol）等更新更快的通讯方式来说更是如此。下一节中，
我们将从宏观上介绍一下e-mail是如何工作的。如果你已经对此相当了解，只想看如何用Python
做e-mail相关的开发，你可以跳到后续章节。

Before we take a look at the e-mail infrastructure, have you ever asked
yourself what is the exact definition of an e-mail message? Well, according to
RFC 2822, “[a] message consists of header fields (collectively called ‘the
header of the message’) followed, optionally, by a body.” When we think of
e-mail as users, we immediately think of its contents, whether it be a real
message or an unsolicited commercial advertisement (aka spam). However, the RFC
states that the body itself is optional and that only the headers are required.
Imagine that!
在看e-mail的底层的结构之前，你有没有问过自己，e-mail的确切定义到底是什么？根据
RFC 2822,“消息由头域（合起来叫消息头）以及后面可选的消息体组成”。对于一般用户来
说，一说起e-mail就会让我们想到它的内容，不管它是一封真的邮件还是一封不请自来的商
业广告（即spam，垃圾邮件），都应该有内容。不过，RFC规定，邮件体是可选的，只有邮
件头是必要的。这一点要特别注意。

17.4.1 E-mail System Components and Protocols
17.4.1 E-mail系统组件和协议

Despite what you may think, electronic mail (e-mail) actually existed before
the modern Internet came around. It actually started as a simple message
exchange between mainframe users . . . note that there wasn’t even any
networking involved as they all used the same computer. Then when networking
became a reality, it was possible for users on different hosts to exchange
messages. This, of course, was a complicated concept as people used different
computers, which used different networking protocols. It was not until the
early 1980s that message exchange settled on a single de facto standard for
moving e-mail around the Internet.
不管你是怎么样想的，电子邮件(e-mail)实际上在现代的因特网出现之前就已经出现了。
它一开始用于mainframe的用户之间简单的交换信息。注意，由于他们都在使用同一台
电脑，所以，这里甚至都没有涉及到网络。后来，当网络成为现实的时候，用户就可以在
不同的主机之间交换信息。当然，由于用户使用着不同的电脑，电脑之间使用着不同的协议，
信息交换成了一个很复杂的概念。直到20世纪80年代，因特网上用e-mail进行信息交换才
有了一个事实上的统一的标准。

Before we get into the details, let’s first ask ourselves, how does e-mail
work? How does a message get from sender to recipient across the vastness of
all the computers accessible on the Internet? To put it simply, there are the
originating computer (the sender’s message departs from here) and the
destination computer (recipient’s mail server). The optimal solution is if the
sending machine knows exactly how to reach the receiving host because then it
can make a direct connection to deliver the message. However, this is usually
not the case.
在深入细节之前，我们先问问自己，e-mail是怎么工作的？一条消息是如何从发件人那
通过浩瀚的因特网，到达收件人的？简单点来说，有一台发送电脑（发件人的消息从这
里发送出去），和一台目的电脑（收件人的信件服务器）。最好的解决方案是发送电脑
知道如何连接到接收电脑，这样一来，它就可以直接把消息发送过去。不过，实际上一
般并不这么顺利。

The sending computer queries to find another intermediate host who can pass the
message along its way to the final recipient host. Then that host searches for
the next host who is another step closer to the destination. So in between the
originating and final destination hosts are any number of machines called
“hops.” If you look carefully at the full e-mail headers of any message you
receive, you will see a “passport” stamped with all the places your message
bounced to before it finally reached you.
发送电脑要查询到某一台中间主机，这台中间主机能到达最后的收件主机。然后这台中间
主机要找一台离目的主机更近一些的主机。所以，在发送主机和目的主机之间，可能会有
多台叫做“跳板”的主机。如果你仔细看看你收到的e-mail的邮件头，你会看到一个
“passport”标记，其中记录了邮件寄给你这一路上都到过了哪些地方。

To get a clearer picture, let’s take a look at the components of the e-mail
system. The foremost component is the message transport agent (MTA). This is a
server process running on a mail exchange host which is responsible for the
routing, queuing, and sending of e-mail. These represent all the hosts that an
e-mail message bounces from beginning at the source host all the way to the
final destination host and all hops in between. Thus they are “agents” of
“message transport.”
为了让描述清楚一些，让我们先看看e-mail系统的各个组件。最主要的组件是消息传输代理
（MTA）。这是一个在邮件交换主机上运行的一个服务器程序，它负责邮件的路由，
队列和发送工作。它们就是邮件从源主机到目的主机所要经过的跳板。所以也被称为是
“信息传输”的“代理”。

In order for all this to work, MTAs need to know two things: 1) how to find out
the next MTA to forward a message to, and 2) how to talk to another MTA. The
first is solved by using a domain name service (DNS) lookup to find the MX
(Mail eXchange) of the destination domain. This is not necessarily the final
recipient, but rather, the next recipient who can eventually get the message to
its final destination. Next, how do MTAs forward messages to other MTAs?
要让所有这些工作起来，MTA要知道两件事情：1) 如何找到消息应该去的下一台MTA 2) 如何
与另一台MTA通讯。第一件事由域名服务（DNS）来查找目的域名的MX（邮件交换Mail 
eXchange）来完成。这对于最后的收件人是不必要的，但对其它的跳板来说，则是必要的。
对于第二件事，MTA怎么把消息转给其它的MTA呢？

17.4.2 Sending E-mail
17.4.2 发送E-mail

In order to send e-mail, your mail client must connect to an MTA, and the only
language they understand is a communication protocol. The way MTAs communicate
with one another is by using a message transport system (MTS). This protocol
must be “known” by a pair of MTAs before they can communicate. As we described
at the beginning of this section, such communication was dicey and
unpredictable in the early days as there were so many different types of
computer systems, each running different networking software. With the added
complexity that computers were using both networked transmission as well as
dial-up modem, delivery times were unpredictable. In fact, this author has
had a message not show up until almost nine months after the message was
originally sent! How is that for Internet speed? Out of this complexity rose
the Simple Mail Transfer Protocol (SMTP) in 1982, one of the foundations of
modern e-mail.
要能发送e-mail，你的邮件客户端一定要连接到一个MTA，它们靠某种协议进行通讯。
MTA之间通讯所使用的协议叫消息传输系统（MTS）。只有两个MTA都使用这个协议时，才能进行通讯。
在本节开始时就说过，由于以前存在很多不同的计算机系统，每个系统都使用不同的网络
软件，这种通讯很危险，具有不可预知性。更复杂的是，有的电脑使用互连的网络，而有
的电脑使用调制解调器拨号，消息的发送时间也是不可预知的。事实上，笔者曾经有一封
邮件在发送9个月后才收到！互连网的速度怎么会这么慢？出于对这些复杂度的考虑，现代
e-mail的基础之一，简单邮件传输协议（SMTP）于1982年出现了。 


SMTP

SMTP was authored by the late Jonathan Postel (ISI) in RFC 821, published in
August 1982. The protocol has since been updated in RFC 2821, published in
April 2001. Some well-known MTAs that have implemented SMTP include:
SMTP由已故的Jonathan Postel（加利福尼亚大学信息学院）创建，记录在RFC 821中，于
1982年8月公布。其后的修改记录在RFC 2821中，于2001年4月公布。一些已经实现了SMTP
的著名MTA包括：

Open Source MTAs
开源MTA
?	Sendmail
?	Postfix
?	Exim
?	qmail (freely distributed but not Open Source)
?	qmail (免费发布，但不开源)

Commercial MTAs
商业MTA
?	Microsoft Exchange
?	Lotus Notes Domino Mail Server

Note that while they have all implemented the minimum SMTP protocol
requirements as specified in RFC 2821, most of them, especially the com-
mercial MTAs, have added even more features to their servers, which goes above
and beyond the protocol definition.
注意，虽然它们都实现了RFC 2821中定义的最小化SMTP协议，它们中的大多数，尤其是一些
商业MTA，都在服务器中加入了协议定义之外的特有的功能。

SMTP is the MTS that is used by most of the MTAs on the Internet for message
exchange. It is the protocol used by MTAs to transfer e-mail from (MTA) host to
(MTA) host. When you send e-mail, you must connect to an outgoing SMTP server
where your mail application acts as an SMTP client. Your SMTP server,
therefore, is the first hop for your message.
SMTP是在因特网上MTA之间用于消息交换的最常用的MTS。它被MTA用来把e-mail从一台主机
传送到另一台主机。在你发e-mail的时候，你必须要连接到一个外部的SMTP服务器，这时，
你的邮件程序是一个SMTP客户端。你的SMTP服务器也因此成为了你的消息的第一个跳板。

17.4.3 Python and SMTP
17.4.3 Python和SMTP

Yes, there is an smtplib and an smtplib.SMTP class to instantiate. Review this
familiar story:
是的，也存在一个smtplib模块和一个smtplib.SMTP类要实例化。再来看看这个已经熟悉的
过程吧：

1.   Connect to server
2.   Log in (if applicable)
3.   Make service request(s)
4.   Quit

1.   连接到服务器
2.   登录（如果需要的话）
3.   发出服务请求
4.   退出

As with NNTP, the login step is optional and only required if the server has
SMTP authentication (SMTP-AUTH) enabled. SMTP-AUTH is defined in RFC 2554. And
also like NNTP, speaking SMTP only requires communicating with one port on
the server; this time, it’s port 25.
像NNTP一样，登录是可选的，只有在服务器打开了SMTP认证（SMTP-AUTH）时才要登录。
SMTP-AUTH在RFC 2554中定义。还是跟NNTP一样，SMTP通讯时，只要一个端口25。

Here is some Python pseudocode to get started:
下面是一些Python的伪代码：
from smtplib import SMTP
n = SMTP('smtp.yourdomain.com')
... n.quit()

Before we take a look at a real example, let’s introduce some of the more
popular methods of the smtplib.SMTP class.
在看真实的例子之前，我们要先介绍一下smtplib.SMTP类的一些常用的方法。

17.4.4 smtplib.SMTP Class Methods
17.4.4 smtplib.SMTP类方法

As in the previous section outlining the smtplib.SMTP class methods, we won’t
show you all methods, just the ones you need in order to create an SMTP client
application. For most e-mail sending applications, only two are required:
sendmail() and quit().
跟之前一样，我们会列出smtplib.SMTP类的方法，但不会列出所有的方法，只列出你创建
SMTP客户端程序所需要的方法。对大多数e-mail发送程序来说，只有两个方法是必须的：
sendmail()和quit()。

All arguments to sendmail() should conform to RFC 2822, i.e., e-mail addresses
must be properly formatted, and the message body should have appropriate
leading headers and contain lines that must be delimited by carriage-return and
NEWLINE \r\n pairs.
sendmail()的所有参数都要遵循RFC 2822，即e-mail地址必须要有正确的格式，消息体要有
正确的前导头，前导头后面是两个回车和换行（\r\n）对。

Note that an actual message body is not required. According to RFC 2822, “[the]
only required header fields are the origination date field and the originator
address field(s),” i.e., “Date:” and “From:”: (MAIL FROM, RCPT TO, DATA).
注意，实际的消息体不是必要的。根据RFC 2822,“唯一要求的头信息只有发送日期和发送
地址”，即“Date:”和“From:”：(MAIL FROM, RCPT TO, DATA)

There are a few more methods not described here, but they are not normally
required to send an e-mail message. Please see the Python documentation for
information on all the SMTP object methods.
还有一些方法没有被提到，不过，一般来说，它们不是发送e-mail所必须的。请参考Python
文档以获取SMTP对象的所有方法的信息。


Table 17.3 Methods for SMTP Objects
表17.3 SMTP对象的方法


Method	Description
方法    描述


sendmail                Send msg from from to to (list or tuple) and
(from, to, msg[,        optional ESMTP mail (mopts) and recipient
mopts, ropts])          (ropts) options
sendmail                把msg从from发送给to（列表或元组）。ESMTP设置（mopts）和收件人设置（ropts）为可选。
(from, to, msg[,        
mopts, ropts])          

quit()	                Close connection and quit
quit()	                关闭连接，然后退出


login(user, passwd)a    Log in to SMTP server with user name and passwd
login(user, passwd)a    使用user用户和passwd密码登录到SMTP服务器

a.	SMTP-AUTH only.
a.	只在有SMTP-AUTH时使用。


17.4.5 Interactive SMTP Example
17.4.5 交互式SMTP示例

Once again, we present an interactive example:
同样地，我们先给一个交互式的例子：

>>> from smtplib import SMTP as smtp
>>> s = smtp('smtp.python.is.cool')
>>> s.set_debuglevel(1)
>>> s.sendmail('wesley@python.is.cool', ('wesley@python.is.cool',
'chun@python.is.cool'), ''' From: wesley@python.is.cool\r\nTo: wesley@python.is.cool, chun@python.is.cool\r\nSubject: test msg\r\n\r\nxxx\r\n.''')
send: 'ehlo myMac.local\r\n'
reply: '250-python.is.cool\r\n'
reply: '250-7BIT\r\n'
reply: '250-8BITMIME\r\n'
reply: '250-AUTH CRAM-MD5 LOGIN PLAIN\r\n'
reply: '250-DSN\r\n' reply: '250-EXPN\r\n' reply: '250-HELP\r\n' reply: '250-NOOP\r\n'
reply: '250-PIPELINING\r\n' reply: '250-SIZE 15728640\r\n' reply: '250-STARTTLS\r\n'
reply: '250-VERS V05.00c++\r\n'
reply: '250 XMVP 2\r\n'
reply: retcode (250); Msg: python.is.cool
7BIT
8BITMIME
AUTH CRAM-MD5 LOGIN PLAIN DSN
EXPN HELP NOOP
PIPELINING SIZE 15728640
STARTTLS
VERS V05.00c++ XMVP 2
send: 'mail FROM:<wesley@python.is.cool> size=108\r\n'
reply: '250 ok\r\n'
reply: retcode (250); Msg: ok
send: 'rcpt TO:<wesley@python.is.cool>\r\n'
reply: '250 ok\r\n'
reply: retcode (250); Msg: ok send: 'data\r\n'
reply: '354 ok\r\n'
reply: retcode (354); Msg: ok data: (354, 'ok')


send: 'From: wesley@python.is.cool\r\nTo: wesley@python.is.cool\r\nSubject: test msg\r\n\r\nxxx\r\n..\r\n.\r\n'
reply: '250 ok ; id=2005122623583701300or7hhe\r\n'
reply: retcode (250); Msg: ok ; id=2005122623583701300or7hhe data: (250, 'ok ; id=2005122623583701300or7hhe')
{}
>>> s.quit()
send: 'quit\r\n'
reply: '221 python.is.cool\r\n'
reply: retcode (221); Msg: python.is.cool

17.4.6  Miscellaneous SMTP
17.4.6  SMTP的其它方面

You can read more about SMTP in the SMTP Protocol Definition/Specification (RFC
2821) at ftp://ftp.isi.edu/in-notes/rfc2821.txt as well as on the http://
www.networksorcery.com/enp/protocol/smtp.htm Web page. To find out more about
Python’s SMTP support, you can start here: http://python.org/docs/
current/lib/module-smtplib.html
从SMTP协议定义／规范（RFC 2821）中，你可以得到更多关于SMTP的信息：
ftp://ftp.isi.edu/in-notes/rfc2821.txt以及网页
http://www.networksorcery.com/enp/protocol/smtp.htm。
想了解更多Python对SMTP的支持，可以从这里开始：
http://python.org/docs/current/lib/module-smtplib.html.

One of the more important aspects of e-mail which we have not discussed yet is
how to properly format Internet addresses as well as e-mail messages
themselves. This information is detailed in the Internet Message Format RFC,
2822, and can be downloaded at ftp://ftp.isi.edu/in-notes/rfc2822.txt.
我们还没有讨论的e-mail的一个很重要的方面是怎么正确的设定因特网地址的格式和e-mail
消息。这些信息详细记录在因特网信息格式RFC 2822中。可以在
ftp://ftp.isi.edu/in-notes/rfc2822.txt下载。

17.4.6 Receiving E-mail
17.4.6 接收E-mail

Back in the day, communicating by e-mail on the Internet was relegated to uni-
versity students, researchers, and employees of private industry and commercial
corporations. Desktop computers were predominantly still Unix-based worksta-
tions. Home users just dialed-up on PCs and really didn’t use e-mail. When the
Internet began to explode in the mid-1990s, e-mail came home to everyone.
在以前，在因特网上用e-mail通讯的只有大学学生，研究人员和工商企业的雇员。桌面电脑
还都是类Unix操作系统。家庭用户只是拨号到PC上，并不真的使用e-mail。在20世纪90年代
中期因特网大爆炸的时候，e-mail进入了千家万户。

Because it was not feasible for home users to have workstations in their dens
running SMTP, a new type of system had to be devised to leave e-mail on an
incoming mail host while periodically downloading mail for offline reading.
Such a system consists of both a new application and a new protocol to
communicate with the mail server.
对于家族用户来说，在家里放一个工作站来运行SMTP是不现实的。必须要设计一种新的系统，
能够周期性地把信件下载到本地计算机，以供离线时使用。这样的系统就要有一套新的协议
和新的应用程序来与邮件服务器通讯。

The application, which runs on a home computer, is called a mail user agent
(MUA). An MUA will download mail from a server, perhaps automatically deleting
it in the process (or not, leaving the mail on the server to be deleted
manually by the user). However, an MUA must also be able to send mail .  . . in
other words, it should also be able to speak SMTP to communicate directly to an
MTA when sending mail. We have already seen this type of client, in the
previous section when we looked at SMTP. How about downloading mail then?
在家用电脑中运行的应用程序叫邮件用户代理（MUA）。MUA从服务器上下载邮件，在这个过程中可能会
自动删除它们（也可能不删除，留在服务器上，让用户手动删除）。不过，MUA也
必须要能发送邮件。也就是说，在发送邮件的时候，它要能直接与MTA用SMTP进行通讯。在
前面讲SMTP的章节中，我们已经看过这种客户端了。那下载邮件的呢？


17.4.7 POP and IMAP
17.4.7 POP和IMAP

The first protocol developed for downloading was the Post Office Protocol. As
stated in the original RFC document, RFC 918 published in October 1984, “The
intent of the Post Office Protocol (POP) is to allow a user’s workstation to
access mail from a mailbox server. It is expected that mail will be posted from
the workstation to the mailbox server via the Simple Mail Transfer Protocol
(SMTP).” The most recent version of POP is version 3, otherwise known as POP3.
POP3, defined in RFC 1939, is still widely used today, and is the basis of our
example client below.
用于下载邮件的第一个协议叫邮局协议，记录在RFC 918中，于1984年10月公布。“邮局协议
（POP）的目的是让用户的工作站可以访问邮箱服务器里的邮件。邮件要能从工作站通过
简单邮件传输协议（SMTP）发送到邮件服务器”。POP协议的最新版本是第3版，也叫POP3。
POP3在RFC 1939中定义，至今为止仍在被广泛地使用，也是我们下面的客户端例子的主要内容。

Another protocol came a few years after POP, known as the Interactive Mail
Access Protocol, or IMAP. The first version was experimental, and it was not
until version 2 that its RFC was published, RFC 1064 in July 1988. The current
version of IMAP in use today is IMAP4rev1, and it, too, is widely used. In
fact, Microsoft Exchange, one of the predominant mail servers in the world
today, uses IMAP as its download mechanism. The IMAP4rev1 protocol definition
is spelled out in RFC 3501, published in March 2003. The intent of IMAP is to
provide a more complete solution to the problem; however, it is more complex
than POP. Further discussion of IMAP is beyond the scope of the remainder of
this chapter. We refer the interested reader to the aforementioned RFC
documents. The diagram in Figure 17–3 illustrates this complex system we know
simply as e-mail.
在POP之后几年，出现了另一个协议，叫交互式邮件访问协议（IMAP）。第一个版本是实验
性的，直到第2版时，其RFC 1064才在1988年被公布。现在被使用的IMAP版本是IMAP4rev1，
它也被广泛地使用。事实上，当今世界上占有邮件服务器大多数市场的Microsoft Exchange
就使用IMAP作为其下载机制。IMAP4rev1协议定义在RFC 3501，于2003年3月公布。IMAP的
目的是要提供一个更全面的解决方案。不过，它比POP更为复杂。对IMAP的进一步讨论超出
了本章剩余部分的范围。我们建议感兴趣的用户参考上述RFC文档。图17-3展示的复杂系统
就是我们所认为的简单的e-mail。


Mail
Internet



SPAM & virus

POP3/IMAP4
(receive)

client

Sender
(or recipient)

MUA


MTA
filtering device
Mail
server

MTA
Mail
client

MUA


Recipient
(or sender)


SMTP (send)



Figure 17–3    E-Mail Senders and Recipients on the Internet. Clients download and
send mail via their MUAs, which talk to their corresponding MTAs. E-Mail “hops” from
MTA to MTA until it reaches the correct destination.
图17-3 因特网上的E-Mail发件人和收件人。客户端通过他们的MUA和相应的MTA进行通讯，来下载和
发送邮件。E-Mail从一个MTA“跳”到另一个MTA，直到到达目的地为止。


17.4.8 Python and POP3
17.4.8 Python和POP3
No surprises here: import poplib and instantiate the poplib.POP3 class;
the standard conversation is as expected:
毫不奇怪，我们要做的是：导入poplib，实例化poplib.POP3类。
标准的做法如下：


1.   Connect to server
2.   Log in
3.   Make service request(s)
4.   Quit

1.   连接到服务器
2.   登录
3.   发出服务请求
4.   退出

And the expected Python pseudocode:
Python的伪代码如下：

from poplib import POP3
p = POP3('pop.python.is.cool')
p.user(...)
p.pass_(...)
... p.quit()

Before we take a look at a real example, let’s take a look at an interactive
example as well as introduce the basic methods of the poplib.POP3 class.
在看真实的例子之前，我们要先看一个交互式的例子以及介绍一下poplib.POP3类的一些
基本的方法。

17.4.9 Interactive POP3 Example
17.4.9 交互式POP3举例

Here is an interactive example of using Python’s poplib:
下面是使用Python poplib模块的交互式的例子：

>>> from poplib import POP3
>>> p = POP3('pop.python.is.cool')
>>> p.user('techNstuff4U')
'+OK'
>>> p.pass_('notMyPasswd') Traceback (most recent call last):
File "<stdin>", line 1, in ?
   File "/usr/local/lib/python2.4/poplib.py", line 202, in pass_
return self._shortcmd('PASS %s' % pswd)
　File "/usr/local/lib/python2.4/poplib.py", line 165, in _shortcmd
return self._getresp()
　File "/usr/local/lib/python2.4/poplib.py", line 141, in _getresp
raise error_proto(resp)
poplib.error_proto: -ERR directory status: BAD PASSWORD
>>> p.user('techNstuff4U')
'+OK'
>>> p.pass_('youllNeverGuess')
'+OK ready'
 (102, 2023455)
>>> rsp, msg, siz = p.retr(102)
>>> rsp, siz
('+OK', 480)
>>> for eachLine in msg:
...	print eachLine
...
Date: Mon, 26 Dec 2005 23:58:38 +0000 (GMT) Received: from c-42-32-25-43.smtp.python.is.cool
by python.is.cool (scmrch31) with ESMTP
id <2005122623583701300or7hhe>; Mon, 26 Dec 2005
23:58:37 +0000
From: wesley@python.is.cool To: wesley@python.is.cool Subject: test msg

xxx
.
>>> p.quit()
'+OK python.is.cool'

17.4.10 poplib.POP3 Class Methods
17.4.10 poplib.POP3类方法

The POP3 class has numerous methods to help you download and manage your inbox
offline. The most widely used ones are included in Table 17.4.
POP3类有无数的方法来帮助你下载和离线管理你的邮箱。最常用的列在表17.4中。


Table 17.4  Methods for POP3 Objects
表17.4 POP3对象的常用方法


Method	Description
方法    描述

user(login)	Sends the login name to the server; awaits reply indicating the server is waiting for user’s password
user(login)	发送用户名login到服务器，并等候服务器的正在等待用户密码的返回信息

pass_(passwd)	Sends passwd (after user logs in with user()); an exception occurs on login/passwd failure
pass_(passwd)	发送密码passwd（在使用user()登录之后使用）。如果登录失败，引发一个异常

stat()	Returns mailbox status, a 2-tuple (msg_ct, mbox_siz): the total message count and total message size, aka octets
stat()	返回邮件的状态，一个长度为2的元组（msg_ct, mbox_siz）：消息的数量和消息的总大小也即字节数

list([msgnum])	Superset of stat(). . . returns entire message list from server
                as a 3-tuple (rsp, msg_list, rsp_siz): server response, message list, 
                response message size; if msgnum given, return data for that message only
list([msgnum])	stat()的扩展，从服务器返回长度为3的元组的消息列表（rsp, msg_list, rsp_siz）：
                服务器的返回信息，消息的列表，返回信息的大小。如果给了msgnum的话，只返回指定消息的数据。

retr(msgnum)	Retrieves message msgnum from server and sets
                its 'seen' flag; returns a 3-tuple (rsp,
                msglines, msgsiz): server response, all lines
                of message msgnum, and message size in bytes/
                octets
retr(msgnum)	从服务器中得到消息msgnum，并设置其“已读”标志。返回一个长度为3的元组（rsp, msglines, msgsiz）：
                服务器的返回信息，消息msgnum的所有行，消息的字节数

dele(msgnum)	Tag message number msgnum for deletion; most servers process deletes upon quit()
dele(msgnum)	把消息msgnum标记为删除，大多数服务器在调用quit()后执行删除操作。

quit()	Logs out, commits changes (e.g., process “seen,”
“delete” flags, etc.), unlocks mailbox, terminates
connection, and quits
quit()  登出，保存修改（如，执行“已读”和“删除”标记等），解锁邮箱，结束连接，然后退出




When logging in, the user() method not only sends the login name to the server,
but it also awaits the reply indicating the server is waiting for user’s
password. If pass_() fails due to authentication issues, the exception raised
is poplib.error_proto. If it is successful, it gets back a positive reply,
e.g., ‘+OK ready’, and the mailbox on the server is locked until quit() is
called.
在登录时,user()方法不仅向服务器发送了用户名，也要等待服务器正在等待用户
密码的返回信息。如果pass_()方法认证失败，会引发一个poplib.error_proto的异常。
如果成功，会得到一个以'+'号开头的返回信息，如“+OK ready”，然后服务器上的该
邮箱就被锁定了，直到调用了quit()方法为止。

For the list() method, the msg_list is of the form [‘msgnum msgsiz’,…] where
msgnum and msgsiz are the message number and message sizes, respectively, of
each message.
调用list()方法时，msg_list的格式为：[‘msgnum msgsiz’,…]，其中，msgnum和msgsiz分别是
每个消息的编号和消息的大小。

There are a few other methods not listed here. For the full details, check out
the documentation for poplib in the Python Library Reference.
还有一些方法未被列出，想要了解更多信息，请参考Python手册里poplib的文档。


17.4.12 Client Program SMTP and POP3 Example
17.4.12 客户端程序SMTP和POP3举例

The example below shows how to use both SMTP and POP3 to create a client that
both receives and downloads e-mail as well as one that uploads and sends
e-mail. What we are going to do is send an e-mail message to ourselves (or some
test account) via SMTP, wait for a bit—we arbitrarily chose ten seconds— and
then use POP3 to download our message and assert that the messages are
identical. Our operation will be a success if the program completes silently,
meaning that there should be no output or any errors.
下面的例子演示了如何使用SMTP和POP3来创建一个既能接收和下载e-mail也能上传和发送
e-mail的客户端。我们将要先用SMTP发一封e-mail给自己（或其它测试帐户），等待一段
时间——我们随便选了一个时间，10秒钟——然后使用POP3下载这封e-mail，下载下来的内容
跟发送的内容应该是完全一样的。如果程序悄无声息地结束，没有输出也没有异常，那就
说明我们的操作都成功了。

Example 17.3  SMTP and POP3 Example (myMail.py)
例17.3 SMTP和POP3示例 (myMail.py)

This script sends a test e-mail message to the destination address (via the
outgoing/SMTP mail server) and retrieves it immediately from the (incoming
mail/ POP) server. You must change the server names and e-mail addresses to
make it work properly.
这个脚本（通过SMTP邮件服务器）发送一封测试e-mail到目的地址，并马上（通过POP）
把e-mail从服务器上收回来。要让程序能正常工作，你需要修改服务器的名字和e-mail的地址。

1	#!/usr/bin/env python
2
3	from smtplib import SMTP
4	from poplib import POP3
5	from time import sleep
6



10   origHdrs = ['From: wesley@python.is.cool',
11	'To: wesley@python.is.cool',
12	'Subject: test msg']
13   origBody = ['xxx', 'yyy', 'zzz']
14   origMsg = '\r\n\r\n'.join(['\r\n'.join(origHdrs),
'\r\n'.join(origBody)])
15
16   sendSvr = SMTP(SMTPSVR)
17   errs = sendSvr.sendmail('wesley@python.is.cool',
18	('wesley@python.is.cool',), origMsg)
19   sendSvr.quit()
20   assert len(errs) == 0, errs
21   sleep(10)	# wait for mail to be delivered
22
23   recvSvr = POP3(POP3SVR)
24   recvSvr.user('wesley')
25   recvSvr.pass_('youllNeverGuess')
26   rsp, msg, siz = recvSvr.retr(recvSvr.stat()[0])
27   # strip headers and compare to orig msg
28   sep = msg.index('')
29   recvBody = msg[sep+1:]
30   assert origBody == recvBody # assert identical


Line-by-Line Explanation
逐行解释

Lines 1–8
1-8行
This application starts with a few import statements and some constants, much
like the other examples in this chapter. The constants here are the outgoing
(SMTP) and incoming (POP3) mail servers.
跟本章前面的例子一样，程序一开始是一些导入语句和常量的定义。常量分别是发送邮件
和接收邮件的服务器。

Lines 10–14
10-14行
These lines represent the preparation of the message contents. We have some
mail headers followed by three lines for the message body. The From and To
headers represent the message sender and recipient(s). Line 14 puts everything
together into a sendable message of headers followed by a message body, all
delimited by the RFC 2822-required line delimiters with a blank line separating
the two sections.
这几行是消息内容的准备工作。这里，我们放了三行消息头然后是消息体。From和To两个头
分别表示消息的发件人和收件人。14行把消息头和消息体放在一起组成一个可以发送的消息，
按RFC 2822的要求，这两部分用空行隔开。


Lines 16–21
16-21行
We connect to the outgoing (SMTP) server and send our message.  There is
another pair of From and To addresses here. These are the “real” e-mail
addresses, or the envelope sender and recipient(s). The recipient field should
be an iterable. If a string is passed in, it will be transformed into a list of
one element. For unsolicited spam e-mail, there is usually a discrepancy
between the message headers and the envelope headers.
我们连接到发送（SMTP）服务器来发送我们的消息。这里还有一对From和To的地址，这些
地址是“真实”的e-mail地址，或者说是信封格式(envlelope)的地址。收件人参数应该是一个可
迭代的对象，如果传的是一个字符串，就会被转成一个只有一个元素的列表。不请自来的
垃圾邮件中，消息头和信封头总是不一致的。

The third argument to sendmail() is the e-mail message itself. Once it has
returned, we log out of the SMTP server and check that no errors have occurred.
Then we give the servers some time to send and receive the message.
sendmail()的第三个参数是e-mail信息本身。这个函数返回之后，我们就登出SMTP服务器，
并判断是否有错误发生过。我们要等待一段时间，等待服务器完成消息的发送与接收。


Lines 23–30
23-30行
The final part of our application downloads the just-sent message and asserts
that both it and the received messages are identical. A connection is made to
the POP3 server with a username and password. After successful login, a stat()
call is made to get a list of available messages. The first message is chosen
([0]), and retr() is told to download it.
程序的最后一部分是下载刚刚发送的消息，并断言发送的和接收的消息是完全一样的。先
给出用户名和密码，连接到POP3服务器，在登录成功后，调用stat()方法得到有效的消息
的列表。我们先选第一条消息([0])，然后调用retr()下载这个消息。

We look for the blank line separating the headers and message, discard the
headers, and compare the original message body with the incoming message body.
If they are identical, nothing is displayed and the program ends successfully.
Otherwise, an assertion is made.
我们用空行来分隔头和信息，去掉头部分，比较原始信息体和收到的信息体。如果它们
相同，什么都不显示，程序正常退出，否则，会出现一个断言失败的错误。

Due to the numerous errors, we left out all the error-checking for this script
so that it is easy on the eyes. One of the exercises at the end of the chapter
is to add the error-checking.
由于错误的类型太多，我们在这个脚本里不做错误检查，这样的好处是你可以直接看到出现
了什么错误。在本章末尾有一个习题就是做错误检查的。

Now you have a very good idea of how sending and receiving e-mail works in
today’s environment. If you wish to continue exploring this realm of pro-
gramming expertise, see the next section for other e-mail-related Python
modules, which will prove valuable in application development.
现在，你对如何发送和接收e-mail有了一个很全面的了解。如果你想深入了解这一方面的
编程，请参阅下一章里介绍的e-mail相关的模块，它们在程序开发方面有相当大的帮助。

17.5 Related Modules
17.5 相关模块

One of Python’s greatest assets is the strength of its networking support in
the standard library, particularly those oriented toward Internet protocols and
client development. Listed below are related modules, first focusing on
electronic mail followed by Internet protocols in general.
Python最好的一个方面就是它在标准库中提供了相当的全面的网络支持。尤其在因特网协议
和客户端开发方面的支持更为全面。下面列出了一些相关模块，首先是电子邮件相关的，
随后是一般用途的因特网协议相关的。

17.5.1 E-mail

Python features numerous e-mail modules and packages to help you with building
an application. Some of them are listed in Table 17.5.
Python自带了很多e-mail模块和包可以帮助你创建应用程序。表17.5中列出了一部分。


Table 17.5  E-Mail-Related Modules
表17.5 E-Mail相关模块


Module/Package	Description
模块/包         描述

email	Package for processing e-mail (also supports MIME)
email	e-mail处理的包 （也支持MIME）

rfc822	RFC2822 mail header parsers
rfc822	RFC2822邮件头解析器

smtpd	SMTP server
smtpd	SMTP服务器

base64	Base 16, 32, and 64 data encodings (RFC 3548) 
base64	Base 16，32，和64数据编码(RFC 3548) 

mhlib	Classes for handling MH folders and messages 
mhlib	处理MH文件夹和信息的类

mailbox	Classes to support parsing mailbox file formats 
mailbox	支持mailbox文件格式解析的类

mailcap	Support for handling “mailcap” files
mailcap	“mailcap” 文件的处理模块

mimetools	(deprecated) MIME message parsing tools (use email above)
mimetools	（不建议使用）MIME信息解析工具（使用上面的email）

mimetypes	Converts between filenames/URLs and associated MIME types
mimetypes	在文件名或URL到相关的MIME类型之间转换的模块

MimeWriter	(deprecated) MIME message processing (use email above)
MimeWriter	（不建议使用）MIME信息处理模块（使用上面的email）

mimify	(deprecated) Tools to MIME-process messages with (use email above)
mimify	（不建议使用）信息的MIME处理工具（使用上面的email）

binascii	Binary and ASCII conversion
binascii	二进制和ASCII转换

binhex	Binhex4 encoding and decoding support
binhex	Binhex4编码和解码支持


17.5.2 Other Internet Protocols
17.5.2 其他网络协议


Table 17.6  Internet Protocol-Related Modules
表17.6 因特网协议相关的模块


Module	Description
模块    描述

ftplib	FTP protocol client
ftplib	FTP协议客户端


gopherlib	Gopher protocol client
gopherlib	Gopher协议客户端

httplib	HTTP and HTTPS protocol client
httplib	HTTP和HTTPS协议客户端

imaplib	IMAP4 protocol client 
imaplib	IMAP4协议客户端

nntplib	NNTP protocol client 
nntplib	NNTP协议客户端

poplib	POP3 protocol client 
poplib	POP3协议客户端

smtplib	SMTP protocol client 
smtplib	SMTP协议客户端

telnetlib	Telnet client class
telnetlib	Telnet协议客户端类

17.6 Exercises
17.6 练习

FTP

17–1.  Simple FTP Client. Given the FTP examples from this chapter, write a
small FTP client program that goes to your favorite Web sites and downloads the
latest versions of the applications you use. This may be a script that you
run every few months to make sure you’re using the “latest and greatest.” You
should probably keep some sort of table with FTP location, login, and
password for your convenience.
17-1. 简单FTP客户端。参考本章的FTP例子，写一个小的FTP客户端程序，能够去你喜欢的网站
下载你使用的软件的最新版本。这个脚本应该每几个月就运行一次，以确保你在用的软件是
“最新和最好的”。你应该把FTP地址，登录信息放在一个表里，省得每次都要修改。

17–2.  Simple FTP Client and Pattern-Matching. Use your solution to the
previous exercise as a starting point for creating another simple FTP client
that either pushes or pulls a set of files from a remote host using patterns.
For example, if you want to move a set of Python or PDF files from one host to
another, allow users to enter “*.py” or “doc*.pdf” and only transfer those
files whose names match.
17-2.  简单FTP客户端和模式匹配。在上一个练习的基础上创建一个新的FTP客户端程序。
它可以上传和下载指定模式的文件。比方说，如果想把一些Python的文件和PDF文件从
一台电脑传到另一台电脑上，那用户可以输入“*.py”或“doc*.pdf”，程序会只传这些文件
名匹配的文件。

17–3.  Smart FTP Command-Line Client. Create a command-line FTP application
similar to the vanilla Unix /bin/ftp program, however, make it a “better FTP
client,” meaning it should have additional useful features. You can take a look
at the ncFTP application as motivation. It can be found at http://ncftp.com.
For example, it has the following features: history, bookmarks (saving FTP
locations with log in and password), download progress, etc. You may have to
implement readline functionality for history and curses for screen control.
17-3.  智能FTP命令行客户端程序。创建一个跟Unix下/bin/ftp类似的命令行下的FTP程序，
不过，这个FTP客户端要更好一些，能提供更有用的功能。你可以看看http://ncftp.com的
ncFTP做为样板。它有以下功能：历史记录，书签（可以保存FTP地址和登录信息），下载
进度显示等。你可以使用readline来记录历史命令，用curses来控制屏幕。

17–4.  FTP and Multithreading. Create an FTP client that uses Python threads to
download files. You can either upgrade your existing Smart FTP client as in the
previous problem, or just write a more simple client to download files. This
can be either a command-line program where you enter multiple files as
arguments to the program, or a GUI where you let the user select 1+ file(s) to
transfer. Extra credit: Allow patterns, i.e., *.exe. Use individual threads to
download each file.
17-4.  FTP和多线程。创建一个能使用Python的线程库下载文件的FTP客户端程序。你可以通
过修改上一个练习的程序或者重写一个简单的客户端来下载文件。你可以在命令行参数里指
定要下载的文件，也可以做一个GUI，在界面中让用户选择要下载的文件。附加题：要能
支持模式，如*.exe。要使用不同的线程来下载每个文件。

17–5.  FTP and GUI. Take your smart FTP client developed above and add a GUI
layer on top of it to form a complete FTP application. You may choose from any
of the modern Python GUI toolkits.
17-5.  FTP和GUI。在你上面写的FTP客户端程序中加入GUI，让你的程序成为一个完整的FTP应用
程序。你可以使用Python的任何GUI工具包。

17–6.  Subclassing. Derive ftplib.FTP and make a new class FTP2 where you do
not need to give “STOR filename” and “RETR filename” commands with all four (4)
retr*() and stor*() methods . . . you only need to pass in the filename. You
may choose to either override the existing methods or create new ones with a
‘2’ suffix, i.e., retrlines2().
17-6.  子类化。从ftplib.FTP派生出一个类FTP2，在这个类中，你不用像之前那4个
retr*()和stor*()方法中那样要给定“STOR filename” 或“RETR filename”这样的命令。只要
传文件名就好了。你可以重写已有的方法也可以在方法后加一个2，如retrlines2()。

The file Tools/scripts/ftpmirror.py in the Python source distribution is a
script that can mirror FTP sites, or portions thereof, using the ftplib module.
It can be used as an extended example that applies to this module. The next
five problems feature creating solutions that revolve around code like
ftpmirror.py. You may use code in ftpmirror.py or implement your own solution
with its code as your motivation.
Python发布包中有一个Tools/scripts/ftpmirror.py脚本，它使用ftplib模块，可以对整
个FTP站点或FTP站点的一部分做镜像。它可以做为ftplib模块应用的扩展例子来使用。解答
下面5个问题时，可以参考这个脚本。你可以直接使用ftpmirror.py里的代码，也可以以这个
脚本为样板，自己重新写一个。

17–7.  Recursion. The ftpmirror.py script copies a remote directory
recursively. Create a simpler FTP client in the spirit of ftpmirror.py but one
that does not recurse by default. Create an “-r” option that tells the
application to recursively copy subdirectories to the local filesystem.
17-7.  递归。ftpmirror.py脚本递归的复制一个远程的目录。写一个与ftpmirror.py相似的
脚本，它的默认行为是不递归的。只有在传入了“-r”参数的时候，才递归的把文件复制到本地
目录。

17–8.  Pattern-Matching. The ftpmirror.py script has an “-s” option that lets
users skip files that match the given pattern, i.e., “.exe.” Create your own
simpler FTP client or update your solution to the previous exercise so that it
lets the user supply a pattern and only copy those files matching that pattern.
Use your solution to an earlier problem above as a starting point.
17-8.  模式匹配。ftpmirror.py脚本支持“-s”参数让用户指定能匹配模式的文件不
下载，如“*.exe”。重新写一个简单的FTP客户端程序或修改之前的程序，实现让用户指定通
配符，程序只下载能匹配模式的文件。可以在你之前练习的答案基础上实现。

17–9.  Recursion and Pattern-Matching. Create an FTP client that integrates
both of the previous exercises.
17-9.  递归和模式匹配。写一个FTP客户端程序，把上面两个练习的脚本集成在一起。

17–10.  Recursion and ZIP files. This problem is similar to the first recursion
exercise above—instead of copying the remote files to the local filesystem,
either update your existing FTP client or create a new one to download remote
files and compress them into a ZIP (or TGZ or BZ2) file. This “-z” option
allows your users to back up an FTP site in an automated manner.
17-10.  递归和ZIP文件。这个练习与上面的第一个递归练习有些相似，只是不再直接把文件
下载到本地文件系统，而是文件下载后压缩到一个ZIP（或TGZ，或BZ2）文件中。同样，你可以
在之前脚本的基础上改，也可以重写一个。使用“-z”参数让用户可以自动地备份一个FTP站点。

17–11.  Kitchen Sink. Implement a single, final, all-encompassing FTP
application that has all the solutions to the exercises above, i.e., “-r”,
“-s”, and “-z” options.
17-11.  集成。实现一个最终的，全功能的FTP应用程序，包含上面几个练习的所有功能。
即，支持“-r”“-s”和“-z”参数。

NNTP

17–12.  Introduction to NNTP. Change Example 17.2 (getLatestNNTP.py) so that
instead of the most recent article, it displays the first available article
meaningfully.
17-12.  NNTP介绍。修改例17.2(getLatestNNTP.py)，让它显示第一封（而不是最后一封）
有效文章的有意义的内容。

17–13.  Improving Code. Fix the flaw in getLatestNNTP.py where triple-quoted
lines show up in the output. This is because we want to display Python
interactive interpreter lines but not triple-quoted text. Solve this problem by
checking whether the stuff that comes after the “>>>” is real Python code. If
so, display it as a line of data; if not, do not display this quoted text.
Extra credit: Use your solution to solve another minor problem: leading
whitespace is not stripped from the body because it may represent indented
Python code. If it really is code, display it; otherwise, it is text so
lstrip() that before displaying.
17-13.  代码改进。修正getLatestNNTP.py的会输出3次引用问题，这是因为我们想输出Python
交互解释的内容，而不是被3次引用的文本。用检查“>>>”后的代码是否为合法Python代码的方式
来解决这个问题。如果合法，那就显示这一行数据，如果不合法，认为是引用文本，不显示。
附加题：你的解决方案再解决这样一个小问题：我们没有去掉前导的空格，因为它可能是
Python代码的缩进。如果真的是代码的缩进，就显示它，否则，认为它是一般的文本，先对
字符串用lstrip()方法处理后再显示。

17–14.  Finding Articles. Create an NNTP client application that lets the user
log in and choose a newsgroup of interest. Once that has been accomplished,
prompt the user for keywords to search article Subject lines for. Bring up the
list of articles that match the requirement and display them to the user. The
user should then be allowed to choose an article to read from that list—display
them and provide simple navigation like pagination, etc. If no search field
is entered, bring up all current articles.
17-14.  查找文章。写一个NNTP客户端程序，让用户能选择并登录感兴趣的新闻组。在登录成功
后，提示用户输入一些关键字，使用这些关键字来查找文章的标题。把符合要求的文章列出来
显示给用户。用户可以在列表中选择某一篇文章进行阅读，这时要能显示选定文章的内容。程序
还要有简单的导航功能，如分页等。如果没有给出搜索关键字，则显示所有的文章。

17–15.  Searching Bodies. Upgrade your solution to the previous problem by
searching both Subject lines and article bodies. Allow for AND or OR searching
of keywords. Also allow for AND or OR searching of Subject lines and article
bodies, i.e., keyword(s) must be in Subject lines only, article bodies only,
either, or both.
17-15.  搜索内容。修改上一题你的脚本，让脚本同时搜索主题和文章内容。允许关键字的
“与”（AND）和“或”（OR）的操作。也要允许指定在标题和文章内容的“与”（AND）和“或”（OR）
即，关键字要只在标题里出现，只在内容里出现或两者里面都要出现。

17–16.  Threaded Newsreader. This doesn’t mean write a multithreaded
newsreader—it means organize related postings into “article threads.” In other
words, group related articles together, independent of when the individual
articles were posted. All the articles belonging to individual threads should
be listed chronologically though. Allow the user to:
17-16.  线索化的新闻阅读工具。把不同的回帖组织到一个“文章线索”中。也就是说，把
相关的文章放在一起，与文章什么时候发的没有关系。同一个线索中的文章按时间顺序排列。
用户可以：

(a) select individual articles (bodies) to view, then have the option to go
back to the list view or to previous or next article either sequentially or
related to the current thread.
(a) 选择某一篇文章进行阅读，然后可以选择回到文章列表，顺序阅读当前线索的
前一篇文章或是后一篇文章。

(b) allow replies to threads, option to copy and quote previous article,
reply to the entire newsgroup via another post. Extra credit: Allow personal
reply to individual via e-mail.
(b) 允许回复线索，可以选择复制并引用之前文章，用跟贴的方式回复到整个新闻组。附加题：
也允许私下用e-mail进行回复。

(c) permanently delete threads—no future related articles should show up in the
article list. For this, you will have to temporarily keep a persistent list of
deleted threads so that they don’t show up again. You can assume a thread is
dead if no one posts an article with the same Subject line after several
months.
(c) 永久地删除线索，即后续的相关文章不会在文章列表中显示。要实现这个功能，你应该把
要删除的文章的列表暂时记录下来。一个线索在几个月之后还没有人回复的话，你可以认为这
个线索已经死了。

17–17.  GUI Newsreader. Similar to an FTP exercise above, choose a Python GUI
toolkit to implement a complete standalone GUI newsreader application.
17-17.  GUI新闻阅读工具。跟上面的FTP练习差不多，选择一个GUI工具包来实现一个完整的，
独立的GUI新闻阅读工具。

17–18.  Refactoring. Like ftpmirror.py for FTP, there is a demo script for
NNTP: Demo/scripts/newslist.py. Run it.  This script was written a long time
ago and can use a facelift. For this exercise, you are to refactor this program
using features of the latest versions of Python as well as your developing
skills in Python to perform the same task but run and complete in less time.
This can include using list comprehensions or generator expressions, using
smarter string concatenation, not calling unnecessary functions, etc.
17-18.  重构。跟FTP的ftpmirror.py一样。NNTP也有一个示例脚本：Demo/scripts/newslist.py。
运行它。这个脚本在很久之前就写好了，你可以做一些翻新工作。做为练习，你要用Python
新版本的一些特性和你的Python开发技巧来重构这个脚本。让这个脚本运行得更快。
你可以使用列表解析和生成器表达式，用更智能的字符串连接而不是调用不必要的函数等。

17–19.  Caching. Another problem with newslist.py is that, according to its
author, “I should really keep a list of ignored empty groups and re-check them
for articles on every run, but I haven’t got around to it yet.” Make this
improvement a reality. You may use the default version as-is or your newly
improved one from the previous exercise.
17-19.  缓冲。如其作者所说，newslist.py的另一个问题是，“我应该把要忽略的空的新闻
组的列表保存下来，在每次运行的时候检查一下是否有新的文章，但我真的抽不出时间”。
你来实现这个功能。你可以直接修改它，也可以修改你之前的脚本。


E-MAIL

17–20.  Identifiers. The POP3 method pass_() is used to send the password to
the server after giving it the login name using login(). Can you give any
reasons why you believe this method was named with a trailing underscore, i.e.,
“pass_()”, instead of just plain old “pass()”?
17-20.  标识符。POP3的pass_()方法用于在调用login()方法传了用户名之后，传递密码。
你能不能说出，为什么这个方法命名时要在后面加一个下划线，即“pass_()”，而不是
“pass()”？

17–21.  IMAP. Now that you are familiar with how POP works, your experience
will help you with an IMAP client. Study the IMAP protocol RFC document, and
use the Python imaplib module to help you.
17-21.  IMAP。现在，你已经熟悉了POP是怎么工作的。这方面的经验对你写一个IMAP客户端
程序也是有帮助的。研究一下IMAP协议的RFC文档，使用Python的imaplib模块来实现一个IMAP
客户端程序。

The next set of exercises deal with the myMail.py application found in this
chapter (Example 17.3).
下面的练习题跟本章（例17.3）中的myMail.py程序有关。

17–22.  E-mail Headers. In myMail.py, the last few lines compared the
originally sent body with the body in the received e-mail. Create similar code
to assert the original headers. Hint: Ignore newly added headers.
17-22.  e-mail头。在myMail.py的最后几行，比较了发送的信息体与接收到的e-mail的
信息体。写一段相似的代码，比较信息头。注意，要忽略新加入的头。

17–23.  Error Checking. Add SMTP and POP3 error-checking.
17–23.  错误检查。加入SMTP和POP3的错误检查。

17–24.  SMTP and IMAP. Take our simple myMail.py, and added support for IMAP.
Extra credit: Support both mail download protocols, letting the user choose
which to use.
17-24.  SMTP和IMAP。在简单的myMail.py中，加入IMAP的支持。附加题：支持两种邮件
下载协议，让用户选择要使用哪一种协议。

17–25.  E-mail Composition. Further develop your solution to the previous
problem by giving the users of your application the ability to compose and send
e-mail.
17-25.  撰写e-mail。再次扩展你之前的程序，允许用户撰写和发送e-mail。

17–26.  E-mail Application. Further develop your e-mail application, turning it
into something more useful by adding in mailbox management. Your application
should be able to read in the current set of e-mail messages in a user’s imbeds
and display their Subject lines. Users should be able to select messages to
view. Extra credit: Add support to view attachments via external
applications.
17-26.  e-mail应用程序。再次扩展你的e-mail应用程序，在其中加入更有用的邮箱管理
功能。你的程序要能读出当前所有e-mail的信息，并显示其主题。用户可以选择想要看的
邮件。附加题：要能支持用外部程序查看附件。

17–27.  GUI. Add a GUI layer on top of your solution to the previous problem to
make it practically a full e-mail application.
17-27.  GUI. 给你的脚本加入GUI的功能，让它成为一个实用的完整的e-mail应用程序。

17–28.  Elements of SPAM. Unsolicited junk e-mail, or spam, is a very real and
significant problem today. There are many good solutions out there, validating
this market. We do not want you to (necessarily) reinvent the wheel but we
would like you to get a taste of some of the elements of spam.
17-28.  垃圾邮件的特点。不请自来的垃圾邮件（spam）是当今的一大问题。所幸，针对
这个问题有不少好的解决方案。我们不用你来重新发明轮子，我们想让你了解一些垃圾邮件
的特点。

(a) “mbox” format. Before we can get started, we should convert any e-mail
messages you want to work on to a common format, such as the “mbox” format.
(There are others that you can use if you prefer. Once you have several (or
all) work messages in mbox format, merge them all into a single file.
(a) “mbox”格式。在开始之前，我们要把你想处理的e-mail信息转为一个公共的格
式。比如"mbox"格式。（如果你愿意，你也可以使用别的格式。）如果你已经有了一些mbox格式的消息，把它们合并到一个文件中。

(b) Headers. Most of the clues of spam lie in the e-mail headers. (You may wish
to use the email package or parse them manually yourself.) Write code that
answers questions such as:
– What e-mail client appears to have originated this message? (Check out the
  X-Mailer header.)
– Is the message ID (Message-ID header) format valid?
– Are there domain name mismatches between the From, Received, and perhaps
Return-Path headers? What about domain name and IP address mismatches? Is there
an X-Authentication-Warning header? If so, what does it report?
(b) 头。很多e-mail的头上就看出有垃圾邮件的线索。（你可以用email包或自己解析头）。
写一段代码来回答以下问题：
- 发送这个消息的e-mail客户端软件是什么？（检查X-Mailer头）
- 报文ID（Message-ID头）的格式是否合法？
- From, Received和Return-Path头的域名是否不匹配？域名和IP地址是否不匹配？有没有
X-Authentication-Warning头？如果有的话，内容是什么？

(c) Information Servers. Based on an IP address or domain, servers such as
WHOIS, SenderBase.org, etc., may be able to help you identify the location
where a piece of bulk e-mail originated. Find one or more of these services and
build code to the find the country of origin, and optionally the city, network
owner name, contact info, etc.
(c) 信息服务器。一些服务器如WHOIS, SenderBase.org等可以根据IP地址或域名帮助你
找到e-mail来自何方。找到一些这样的服务，写一些代码来得到来源地的国别，城市，网络
所有者的名字，联系方法等。

(d) Keywords. Certain words keep popping up in spam. You have no doubt seen
them before, and in all of their variations, including using a number
resembling a letter, capitalizing random letters, etc. Build a list of
frequent words that you have seen definitely tied to spam, and quarantine such
messages as possible spam. Extra credit: Develop an algorithm or add keyword
variations to spot such trickery in messages.
(d) 关键字。垃圾邮件中，有一些字经常出现。你之前一定见过，它们是单个的字母，开头
大写的随机字母等。把你常见的一些大量在垃圾邮件中出现的词汇放在一个列表中。把出现
了这些词汇的邮件做为疑似垃圾邮件隔离。附加题：设计一种算法或加入一些关键字的变形
来找出这些邮件。

(e) Phishing. These spam messages attempt to disguise themselves as valid
e-mail from major banking institutions or well-known Internet Web sites. They
contain links that lure readers to Web sites in an attempt to harvest private
and extremely sensitive information such as login names, passwords, and credit
card numbers. These fakers do a pretty good job of giving their fraudulent mes-
sages an accurate look-and-feel. However, they cannot hide the fact that the
actual link that they direct users to does not belong to the company they are
masquerading as. Many of them are obvious giveaways, i.e., horriblelooking
domain names, raw IP addresses, and even IP addresses in 32-bit integer format
rather than in octets. Develop code that can determine whether e-mail that
looks like official communication is real or bogus.
(e) 钓鱼。这些垃圾邮件总是想把他们伪装成来自大银行或某个知名的网站的合法的e-mail。
里面包含某种链接，引诱用户输入自己私密的或是敏感的信息，如登录用户名，密码和信
用卡的卡号等。这些骗子往往做得足以以假乱真。不过，他们还是免不了要让用户登录到
与他们声称的并不相符的网站。这里，就可能会透露出很多信息，如，看上去很乱七八糟的域名，
只用了IP地址，或是32位整数形式而不是字节形式的IP地址等。写一段代码来判断一封看上
去像正式交流的e-mail是真的还是假的。

MISCELLANEOUS
其它

A list of various Internet protocols, including the three highlighted in this
chapter, can be found at http://www.networksorcery.com/enp/topic/ipsuite.htm#
Application%20layer%20protocols. A list of specific Internet protocols
supported by Python (currently), can be found at http://docs.python.org/lib/
internet.html

可以在http://www.networksorcery.com/enp/topic/ipsuite.htm#Application%20layer%20protocols
找到包含本章中所列的那些协议在内的各种因特网协议的列表。Python（当前）所支持的
因特网协议列表可以在http://docs.python.org/lib/internet.html找到。


17–29.  Developing Alternate Internet Clients. Now that you have seen four
examples of how Python can help you develop Internet clients, choose another
protocol with client support in a Python standard library module and write a
client application for it.
17-29.  开发其它因特网客户端程序。现在，你已经看到了4个Python开发因特网客户端程序的
例子。选一种Python标准库中支持的其它协议，开发一个对应的客户端程序。

17–30. *Developing New Internet Clients. Much more difficult: find an uncommon
or upcoming protocol without Python support and implement it. Be serious enough
that you will consider writing and submitting a PEP to have your module
included in the standard library distribution of a future Python release.
17-30. *开发一种新的因特网客户端程序。这个难度比较大：找到一个不常用的，或是还未
成型的Python尚未支持的协议，实现它。如果做得好的话，你可以考虑提交一个PEP，把你
的实现加入到以后版本Python的标准库中发布。

