Multithreaded
Programming
多线程编程

Chapter Topics
本章主题
	Introduction/Motivation
	Threads and Processes
	Threads and Python
	thread Module
	threading Module
	ProducerCConsumer Problem and the Queue Module
	Related Modules
引言/动机
线程和进程
线程和Python
thread模块
threading模块
生产者-消费者问题和Queue模块
相关模块
18
in this section, we will explore the different ways you can achieve more
parallelism in your code by using the multithreaded (MT) programming features
found in Python. We will begin by differentiating between processes and threads
in the first few of sections of this chapter. We will then introduce the notion
of multithreaded programming. (Those of you already familiar with MT
programming can skip directly to Section 18.3.5.) The final sections of this
chapter present some examples of how to use the threading and Queue modules to
accomplish MT programming with Python.
本节中，我们将探索在Python中，用多线程编程技术实现代码并行性的几种不同的
方法。在前面几节中，我们将介绍进程与线程的区别。然后介绍多线程编程的概念。
（已经熟悉多线程编程的读者可以直接跳到第18.3.5节）。本章的最后几节将演示在
Python中如何使用threading和Queue模块来实现多线程编程。


18.1 Introduction/Motivation
18.1 引言/动机

Before the advent of multithreaded (MT) programming, running of computer
programs consisted of a single sequence of steps that were executed in
synchronous order by the host’s central processing unit (CPU). This style of
execution was the norm whether the task itself required the sequential order-
ing of steps or if the entire program was actually an aggregation of multiple
subtasks. What if these subtasks were independent, having no causal rela-
tionship (meaning that results of subtasks do not affect other subtask out-
comes)? Is it not logical, then, to want to run these independent tasks all at
the same time? Such parallel processing could significantly improve the per-
formance of the overall task. This is what MT programming is all about.
在多线程（MT）编程出现之前，电脑程序的运行由一个执行序列组成，执行序列按顺序
在主机的中央处理器（CPU）中运行。无论是任务本身要求顺序执行还是整个程序是由
多个子任务组成，程序都是按这种方式执行的。即使子任务相互独立，互相无关（即，
一个子任务的结果不影响其它子任务的结果）时也是这样。这样是不是有点不合逻辑？
会不会想要并行运行这些相互独立的子任务呢？这样的并行处理可以大幅度地提升
整个任务的效率。这就是多线程编程的目的。

MT programming is ideal for programming tasks that are asynchronous in nature,
require multiple concurrent activities, and where the processing of each
activity may be nondeterministic, i.e., random and unpredictable. Such
programming tasks can be organized or partitioned into multiple streams of
execution where each has a specific task to accomplish. Depending on the
application, these subtasks may calculate intermediate results that could be
merged into a final piece of output.
多线程编程对于某些任务来说，是最理想的。这些任务具有以下特点：它们本质上就是异
步的，需要有多个并发事务，各个事务的运行顺序可以是不确定的，随机的，不可预测的。
这样的编程任务可以被分成多个执行流，每个流都有一个要完成的目标。根据应用的不同，
这些子任务可能都要计算出一个中间结果，用于合并得到最后的结果。

While CPU-bound tasks may be fairly straightforward to divide into subtasks
and executed sequentially or in a multithreaded manner, the task of managing a
single-threaded process with multiple external sources of input is not as
trivial. To achieve such a programming task without multithreading, a
sequential program must use one or more timers and implement a multiplexing
scheme.
运算密集型的任务一般都比较容易分隔成多个子任务，可以顺序执行或以多线程的方式执行。
单线程处理多个外部输入源的的任务就不是那么容易了。这种编程任务如果不用多线程的方
式处理，则一定要使用一个或多个计时器来实现。

A sequential program will need to sample each I/O (input/output) terminal
channel to check for user input; however, it is important that the program does
not block when reading the I/O terminal channel because the arrival of user
input is nondeterministic, and blocking would prevent processing of other I/O
channels. The sequential program must use non-blocked I/O or blocked I/O with a
timer (so that blocking is only temporary).
一个顺序执行的程序要从每个I/O(输入/输出)终端信道检查用户的输入时，程序无论如何也
不能在读取I/O终端信道的时候阻塞。因为用户输入的到达是不确定的，阻塞会导致其它I/O
信息的数据不能被处理。顺序执行的程序必须使用非阻塞I/O，或是带有计时器的阻塞I/O（
这样才能保证阻塞只是暂时的）。

Because the sequential program is a single thread of execution, it must juggle
the multiple tasks that it needs to perform, making sure that it does not spend
too much time on any one task, and it must ensure that user response time is
appropriately distributed. The use of a sequential program for this type of
task often results in a complicated flow of control that is difficult to
understand and maintain.
由于顺序执行的程序只有一个线程在运行。它要保证它要做的多任务，不会有某个任务占用
太多的时间，而且要合理地分配用户的响应时间。执行多任务的顺序执行的程序一般程序控
制流程都很复杂，难以理解。

Using an MT program with a shared data structure such as a Queue (a
multithreaded queue data structure discussed later in this chapter), this pro-
gramming task can be organized with a few threads that have specific functions
to perform:
使用多线程编程和一个共享的数据结构如Queue（本章后面会介绍的一种多线程队列数据结构），
这种程序任务可以用几个功能单一的线程来组织：

? UserRequestThread: Responsible for reading client input, perhaps from an I/O
channel. A number of threads would be created by the program, one for each
current client, with requests being entered into the queue.

? UserRequestThread: 负责读取客户的输入，可能是一个I/O信道。程序可能创建多个线程，
每个客户一个，请求会被放入队列中。

? RequestProcessor: A thread that is responsible for retrieving requests from
the queue and processing them, providing output for yet a third thread.

? RequestProcessor: 一个负责从队列中获取并处理请求的线程，它为下面那种线程提供输出。

? ReplyThread: Responsible for taking output destined for the user and either
sending it back, if in a networked application, or writing data to the local
file system or database.
? ReplyThread: 负责把给用户的输出取出来，如果是网络应用程序就把结果发送出去，否则就
保存到本地文件系统或数据库中。


Organizing this programming task with multiple threads reduces the complexity
of the program and enables an implementation that is clean, efficient, and well
organized. The logic in each thread is typically less complex because it has a
specific job to do. For example, the UserRequestThread simply reads input from
a user and places the data into a queue for further processing by another
thread, etc. Each thread has its own job to do; you merely have to design each
type of thread to do one thing and do it well. Use of threads for specific
tasks is not unlike Henry Ford’s assembly line model for manufacturing
automobiles.
把这种编程任务用多线程来组织可以降低程序的复杂度，并使得干净，有效和具有良好组织
地程序结构实现变得可能。每个线程的逻辑都不会很复杂，因为它要做的事情很清楚。例如，
UserRequestThread只是从用户或某个数据源读取数据，放到一个队列中，等待其它线程
进一步的处理，等等，每个线程都有自己明确的任务。你只要设计好每个线程要做什么，
并把要做的事做好就可以了。对某些任务使用线程跟亨利福特制造汽车时使用的装配线模型
有些相似。


18.2  Threads and Processes
18.2 线程和进程
18.2.1 What Are Processes?
18.2.1 什么是进程？

Computer programs are merely executables, binary (or otherwise), which reside
on disk. They do not take on a life of their own until loaded into memory and
invoked by the operating system. A process (sometimes called a heavyweight
process) is a program in execution. Each process has its own address space,
memory, a data stack, and other auxiliary data to keep track of execution. The
operating system manages the execution of all processes on the system, dividing
the time fairly between all processes. Processes can also fork or spawn new
processes to perform other tasks, but each new process has its own memory, data
stack, etc., and cannot generally share information unless interprocess
communication (IPC) is employed.
计算机程序只不过是磁盘中可执行的，二进制（或其它类型）的数据。它们只有在被读取
到内存中，被操作系统调用的时候才开始它们的生命期。进程（有时被称为重量级进程）是
程序的一次执行。每个进程都有自己的地址空间，内存，数据栈以及其它记录其运行轨迹的
辅助数据。操作系统管理在其上运行的所有进程，并为这些进程公平地分配时间。进程也可
以通过fork和spawn操作来完成其它的任务。不过各个进程有自己的内存空间，数据栈等，
所以只能使用进程间通讯（IPC），而不能直接共享信息。

18.2.2 What Are Threads?
18.2.2 什么是线程？

Threads (sometimes called lightweight processes) are similar to processes
except that they all execute within the same process, and thus all share the
same context. They can be thought of as “mini-processes” running in parallel
within a main process or “main thread.”
线程（有时被称为轻量级进程）跟进程有些相似，不同的是，所有的线程运行在同一个进程
中，共享相同的运行环境。它们可以想像成是在主进程或“主线程”中并行运行的“迷你进程”。

A thread has a beginning, an execution sequence, and a conclusion. It has an
instruction pointer that keeps track of where within its context it is
currently running. It can be preempted (interrupted) and temporarily put on
hold (also known as sleeping) while other threads are running―this is called
yielding. Multiple threads within a process share the same data space with the
main thread and can therefore share information or communicate with one another
more easily than if they were separate processes. Threads are generally
executed in a concurrent fashion, and it is this parallelism and data sharing
that enable the coordination of multiple tasks. Naturally, it is impossible to
run truly in a concurrent manner in a single CPU system, so threads are
scheduled in such a way that they run for a little bit, then yield to other
threads (going to the proverbial “back of the line” to await more CPU time
again). Throughout the execution of the entire process, each thread performs
its own, separate tasks, and communicates the results with other threads as
necessary.
线程有开始，顺序执行和结束三部分。它有一个自己的指令指针，记录自己运行到什么地方。
线程的运行可能被抢占（中断），或暂时的被挂起（也叫睡眠），让其它的线程运行，这叫
做让步。一个进程中的各个线程之间共享同一片数据空间，所以线程之间可以比进程之间更方便地共享数据以及相互通讯。线程一般都是并发执行的，正是由于这种并行和
数据共享的机制使得多个任务的合作变为可能。实际上，在单CPU的系统中，真正的并发是不
可能的，每个线程会被安排成每次只运行一小会，然后就把CPU让出来，让其它的线程去
运行。在进程的整个运行过程中，每个线程都只做自己的事，在需要的时候跟其它的线程共享
运行的结果。

Of course, such sharing is not without its dangers. If two or more threads
access the same piece of data, inconsistent results may arise because of the
ordering of data access. This is commonly known as a race condition. Fortu-
nately, most thread libraries come with some sort of synchronization primitives
that allow the thread manager to control execution and access.
当然，这样的共享并不是完全没有危险的。如果多个线程共同访问同一片数据，则由于数据
访问的顺序不一样，有可能导致数据结果的不一致的问题。这叫做竞态条件(race condition)。
幸运的是，大多数线程库都带有一系列的同步原语，来控制线程的执行和数据的访问。


Another caveat is that threads may not be given equal and fair execution time.
This is because some functions block until they have completed. If not written
specifically to take threads into account, this skews the amount of CPU time in
favor of such greedy functions.
另一个要注意的地方是，由于有的函数会在完成之前阻塞住，在没有特别为多线程做修改的情
况下，这种“贪婪”的函数会让CPU的时间分配有所倾斜。导致各个线程分配到的运行时间可能
不尽相同，不尽公平。


18.3  Python,Threads, and the Global Interpreter Lock
18.3 Python、线程和全局解释器锁

18.3.1 Global Interpreter Lock (GIL)
18.3.1 全局解释器锁(GIL)

Execution of Python code is controlled by the Python Virtual Machine (aka the
interpreter main loop). Python was designed in such a way that only one thread
of control may be executing in this main loop, similar to how multiple
processes in a system share a single CPU. Many programs may be in memory, but
only one is live on the CPU at any given moment. Likewise, although multiple
threads may be “running” within the Python interpreter, only one thread is
being executed by the interpreter at any given time.
Python代码的执行由Python虚拟机(也叫解释器主循环)来控制。Python在设计之初就考虑
到要在主循环中，同时只有一个线程在执行，就像单CPU的系统中运行多个进程那样，
内存中可以存放多个程序，但任意时刻，只有一个程序在CPU中运行。同样地，虽然Python
解释器中可以“运行”多个线程，但在任意时刻，只有一个线程在解释器中运行。

Access to the Python Virtual Machine is controlled by the global interpreter
lock (GIL). This lock is what ensures that exactly one thread is running. The
Python Virtual Machine executes in the following manner in an MT environment:
对Python虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同一时刻只有一个
线程在运行。在多线程环境中，Python虚拟机按以下方式执行：

1.   Set the GIL
2.   Switch in a thread to run
3.   Execute either . . .
a.  For a specified number of bytecode instructions, or
b. If the thread voluntarily yields control (can be accomplished time.sleep(0))
4.   Put the thread back to sleep (switch out thread)
5.   Unlock the GIL, and . . .
6.   Do it all over again (lather, rinse, repeat)

1.   设置GIL
2.   切换到一个线程去运行
3.   运行：
  a. 指定数量的字节码指令，或者
  b. 线程主动让出控制（可以调用time.sleep(0)）
4.   把线程设置为睡眠状态
5.   解锁GIL
6.   再次重复以上所有步骤


When a call is made to external code, i.e., any C/C++ extension built-in
function, the GIL will be locked until it has completed (since there are no
Python bytecodes to count as the interval). Extension programmers do have the
ability to unlock the GIL, however, so you being the Python developer shouldn’t
have to worry about your Python code locking up in those situations.
在调用外部代码（如C/C++扩展函数）的时候，GIL将会被锁定，直到这个函数结束为止（由
于在这期间没有Python的字节码被运行，所以不会做线程切换）。编写扩展的程序员可以主
动解锁GIL。不过，Python的开发人员则不用担心在这些情况下你的Python代码会被锁住。

As an example, for any Python I/O-oriented routines (which invoke built-in
operating system C code), the GIL is released before the I/O call is made,
allowing other threads to run while the I/O is being performed. Code that
doesn’t have much I/O will tend to keep the processor (and GIL) for the full
interval a thread is allowed before it yields. In other words, I/O-bound Python
programs stand a much better chance of being able to take advantage of a
multithreaded environment than CPU-bound code.
例如，对所有面向I/O的(会调用内建的操作系统C代码的)程序来说，GIL会在这个I/O调用
之前被释放，以允许其它的线程在这个线程等待I/O的时候运行。如果某线程并未使用很多I/O操作，它会在自己的时间片内一直占用处理器（和GIL）。也就是说，I/O密集型的Python
程序比计算密集型的程序更能充分利用多线程环境的好处。

Those of you interested in the source code, the interpreter main loop, and the
GIL can take a look at the Python/ceval.c file.
对源代码，解释器主循环和GIL感兴趣的人，可以看看Python/ceval.c文件。



18.3.2 Exiting Threads
18.3.2 退出线程

When a thread completes execution of the function it was created for, it exits.
Threads may also quit by calling an exit function such as thread.exit(), or
any of the standard ways of exiting a Python process, i.e., sys.exit() or
raising the SystemExit exception. You cannot, however, go and “kill” a thread.
当一个线程结束计算，它就退出了。线程可以调用thread.exit()之类的退出函数，也可以
使用Python退出进程的标准方法，如sys.exit()或抛出一个SystemExit异常等。不过，你不
可以直接“杀掉”("kill")一个线程。

We will discuss in detail the two Python modules related to threads in the next
section, but of the two, the thread module is the one we do not recommend.
There are many reasons for this, but an obvious one is that when the main
thread exits, all other threads die without cleanup. The other module,
threading, ensures that the whole process stays alive until all “important”
child threads have exited. (We will clarify what “important” means soon. Look
for the daemon threads Core Tip sidebar.)
在下面一节中，我们将要讨论两个跟线程有关的模块。这两个模块中，我们不建议使用
thread模块。这样做有很多原因，很明显的一个原因是，当主线程退出的时候，所有其它
线程没有被清除就退出了。但另一个模块threading就能确保所有“重要的”子线程都退出
后，进程才会结束。（我们等一会会详细说明什么叫“重要的”，请参阅守护线程的核心提
示）。

Main threads should always be good managers, though, and perform the task of
knowing what needs to be executed by individual threads, what data or arguments
each of the spawned threads requires, when they complete execution, and what
results they provide. In so doing, those main threads can collate the
individual results into a final, meaningful conclusion.
主线程应该是一个好的管理者，它要了解每个线程都要做些什么事，线程都需要什么数据和
什么参数，以及在线程结束的时候，它们都提供了什么结果。这样，主线程就可以把各个线
程的结果组合成一个有意义的最后结果。


18.3.2 Accessing Threads from Python
18.3.2 在Python中使用线程

Python supports multithreaded programming, depending on the operating system
that it is running on. It is supported on most Unix-based platforms, i.e.,
Linux, Solaris, MacOS X, *BSD, as well as Win32 systems. Python uses
POSIX-compliant threads, or “pthreads,” as they are commonly known.
在Win32和Linux, Solaris, MacOS, *BSD等大多数类Unix系统上运行时，Python支持
多线程编程。Python使用POSIX兼容的线程，即pthreads。

By default, threads are enabled when building Python from source (since Python
2.0) or the Win32 installed binary. To tell whether threads are available for
your interpreter, simply attempt to import the thread module from the
interactive interpreter. No errors occur when threads are available:
默认情况下，从源代码编译的(2.0及以上版本的)Python以及Win32的安装包里，线程支持
是打开的。想要从解释器里判断线程是否可用，只要简单的在交互式解释器里尝试导入
thread模块就行了，只要没出现错误就表示线程可用。

>>> import thread
>>>
If your Python interpreter was not compiled with threads enabled, the module
import fails:
如果你的Python解释器在编译时，没有打开线程支持，导入模块会失败：

>>> import thread
Traceback (innermost last): File "<stdin>", line 1, in ?
ImportError: No module named thread

In such cases, you may have to recompile your Python interpreter to get access
to threads. This usually involves invoking the configure script with the
“--with-thread” option. Check the README file for your distribution to obtain
specific instructions on how to compile Python with threads for your system.
这种情况下，你就要重新编译你的Python解释器才能使用线程。你可以在运行配置脚本的
时候，加上“--with-thread”参数。参考你的发布版的README文件，以获取如何编译支持
线程的Python的相关信息。


18.3.4  Life Without Threads
18.3.4 没有线程支持的情况

For our first set of examples, we are going to use the time.sleep() function to
show how threads work. time.sleep() takes a floating point argument and
“sleeps” for the given number of seconds, meaning that execution is temporarily
halted for the amount of time specified.
第一个例子中，我们会使用time.sleep()函数来演示线程是怎样工作的。time.sleep()需要
一个浮点型的参数，来指定“睡眠”的时间（单位秒）。这就意味着，程序的运行会被挂起
指定的时间。

Let us create two “time loops,” one that sleeps for 4 seconds and one that
sleeps for 2 seconds, loop0() and loop1(), respectively. (We use the names
“loop0” and “loop1” as a hint that we will eventually have a sequence of
loops.) If we were to execute loop0() and loop1() sequentially in a one-
process or single-threaded program, as onethr.py does in Example 18.1, the
total execution time would be at least 6 seconds. There may or may not be a
1-second gap between the starting of loop0() and loop1(), and other execution
overhead which may cause the overall time to be bumped to 7 seconds.
我们要创建两个“计时循环”。一个睡眠4秒种，一个睡眠2秒种，分别是loop0()和loop1()。
（我们命名为“loop0”和“loop1”表示我们将有一个循环的序列）。如果我们像例18.1的
onethr.py中那样，在一个进程或一个线程中，顺序地执行loop0()和loop1()，那运行的
总时间为6秒。在启动loop0()，loop1()，和其它的代码时，也要花去一些时间，所以，
我们看到的总时间也有可能会是7秒钟。

Example 18.1 Loops Executed by a Single Thread (onethr.py)
例18.1 单线程中运行的循环 (onethr.py)

Executes two loops consecutively in a single-threaded program. One loop must
complete before the other can begin.The total elapsed time is the sum of times
taken by each loop.
在单线程中顺序执行两个循环。一定要一个循环结束后，另一个才能开始。总时间是各个
循环运行时间之和。

1	#!/usr/bin/env python
2
3	from time import sleep, ctime
4
5	def loop0():
6	print 'start loop 0 at:', ctime()
7	sleep(4)
8	print 'loop 0 done at:', ctime()
9
10   def loop1():
11	print 'start loop 1 at:', ctime()
12	sleep(2)
13	print 'loop 1 done at:', ctime()
14
15   def main():
16	print 'starting at:', ctime()
17	loop0()
18	loop1()
19	print 'all DONE at:', ctime()
20
21   if __name__ == '__main__':
22	main()



We can verify this by executing onethr.py, which gives the following
output:
我们可以通过运行onethr.py来验证这一点，下面是运行的输出：


$ onethr.py
starting at: Sun Aug 13 05:03:34 2006

start loop 0 at: Sun Aug 13 05:03:34 2006 
loop 0 done at: Sun Aug 13 05:03:38 2006 
start loop 1 at: Sun Aug 13 05:03:38 2006 
loop 1 done at: Sun Aug 13 05:03:40 2006 
all DONE at: Sun Aug 13 05:03:40 2006

Now, pretend that rather than sleeping, loop0() and loop1() were separate
functions that performed individual and independent computations, all working
to arrive at a common solution. Wouldn’t it be useful to have them run in
parallel to cut down on the overall running time? That is the premise behind MT
that we now introduce to you.
假定loop0()和loop1()里做的不是睡眠，而是各自独立的，不相关的运算，各自的运算结果
到最后将会汇总成一个最终的结果。这时，如果能让这些计算并行执行的话，那不是可以
减少总的运行时间吗？这就是我们现在要介绍的多线程编程的前提条件。

18.3.5 Python Threading Modules
18.3.5 Python的threading模块

Python provides several modules to support MT programming, including the
thread, threading, and Queue modules. The thread and threading modules allow
the programmer to create and manage threads. The thread module provides basic
thread and locking support, while threading provides higher-level, fully
featured thread management. The Queue module allows the user to create a queue
data structure that can be shared across multiple threads. We will take a look
at these modules individually and present examples and intermediate-sized
applications.
Python提供了几个用于多线程编程的模块，包括thread, threading和Queue等。thread和
threading模块允许程序员创建和管理线程。thread模块提供了基本的线程和锁的支持，
而threading提供了更高级别，功能更强的线程管理的功能。Queue模块允许用户创建一个
可以用于多个线程之间共享数据的队列数据结构。我们将分别介绍这几个模块，并给出一
些例子和中等大小的应用。


CORE TIP: Avoid use of thread module
核心提示：避免使用thread模块

We recommend avoiding the thread module for many reasons.The first is that the
high-level threading module is more contemporary, not to mention the fact that
thread support in the threading module is much improved and the use of
attributes of the thread module may conflict with using the threading module.
Another reason is that the lower-level thread module has few synchronization
primitives (actually only one) while threading has many.
出于以下几点考虑，我们不建议您使用thread模块。首先，更高级别的threading模块更
为先进，对线程的支持更为完善，而且使用thread模块里的属性有可能会与threading出
现冲突。其次，低级别的thread模块的同步原语很少（实际上只有一个），而threading
模块则有很多。

However, in the interest of learning Python and threading in general, we do
present some code that uses the thread module.These pieces of code should be
used for learning purposes only and will give you a much better insight as to
why you would want to avoid using the thread module. These examples also show
how our applications and thread programming improve as we migrate to using more
appropriate tools such as those available in the threading and Queue modules.
不过，出于对学习Python和线程的兴趣，我们将给出一点使用thread模块的例子。这些代
码只用于学习目的，让你对为什么应该避免使用thread模块有更深的认识，以及让你了
解在把代码改为使用threading和Queue模块时，我们能获得多大的便利。

Another reason to avoid using thread is because there is no control of when
your process exits.When the main thread finishes, all threads will also die,
without warning or proper cleanup. As mentioned earlier, at least threading
allows the important child threads to finish first before exiting.
另一个不要使用thread原因是，对于你的进程什么时候应该结束完全没有控制，当主线程
结束时，所有的线程都会被强制结束掉，没有警告也不会有正常的清除工作。我们之前说
过，至少threading模块能确保重要的子线程退出后进程才退出。

Use of the thread module is recommended only for experts desiring lower-level
thread access.Those of you new to threads should look at the code samples to
see how we can overlay threads onto our time loop application and to gain a
better understanding as to how these first examples evolve to the main code
samples of this chapter.Your first multithreaded application should utilize
threading and perhaps other high-level thread modules, if applicable.
只建议那些有经验的专家在想访问线程的底层结构的时候，才使用thread模块。而使用
线程的新手们则应该看看我们是如何把线程应用到我们的第一个程序，从而增加代码的
可读性，以及第一段例子如何进化到我们本章的主要的代码的。如果可以的话，你的第
一个多线程程序应该尽可能地使用threading等高级别的线程模块。

18.4 thread Module
18.4 thread模块

Let’s take a look at what the thread module has to offer. In addition to being
able to spawn threads, the thread module also provides a basic syn-
chronization data structure called a lock object (aka primitive lock, simple
lock, mutual exclusion lock, mutex, binary semaphore). As we mentioned earlier,
such synchronization primitives go hand in hand with thread management.
我们先看看thread模块都提供了些什么。除了产生线程外，thread模块也提供了基本的
同步数据结构锁对象(lock object，也叫原语锁，简单锁，互斥锁，互斥量，二值信号量)。
如之前所说，同步原语与线程的管理是密不可分的。

Listed in Table 18.1 are the more commonly used thread functions and LockType
lock object methods.
表18.1中所列的是常用的线程函数以及LockType类型的锁对象的方法。

The key function of the thread module is start_new_thread(). Its syntax is
exactly that of the apply() built-in function, taking a function along with
arguments and optional keyword arguments. The difference is that instead of the
main thread executing the function, a new thread is spawned to invoke the
function.
start_new_thread()函数是thread模块的一个关键函数，它的语法与内建的apply()函数
完全一样，其参数为：函数，函数的参数以及可选的关键字参数。不同的是，函数不是
在主线程里运行，而是产生一个新的线程来运行这个函数。

Let’s take our onethr.py example and integrate threading into it. By slightly
changing the call to the loop*() functions, we now present mtsleep1.py in
Example 18.2.
现在，把线程加入到我们的onethr.py例子中。稍微改变一下loop*()函数的调用方法，我
们得到了例18.2的mtsleep1.py。



Table 18.1 thread Module and Lock Objects
表18.1 thread模块和锁对象

Function/Method	Description
函数            描述



thread Module Functions
thread模块函数

start_new_thread(function, args, kwargs=None)


Spawns a new thread and execute function with the given args and optional
kwargs
产生一个新的线程，在新线程中用指定的参数和可选的kwargs来调用这个函数。

allocate_lock()	Allocates LockType lock object
allocate_lock()	分配一个LockType类型的锁对象

exit()	Instructs a thread to exit
exit()	让线程退出


LockType Lock Object Methods
LockType类型锁对象方法

acquire(wait=None)	Attempts to acquire lock object
acquire(wait=None)	尝试获取锁对象

locked()	Returns True if lock acquired, False otherwise
locked()	如果获取了锁对象返回True，否则返回False

release()	Releases lock
release()	释放锁

Example 18.2  Using the thread Module (mtsleep1.py)
例18.2 使用thread模块 (mtsleep1.py)

The same loops from onethr.py are executed, but this time using the simple
multithreaded mechanism provided by the thread module.The two loops are
executed concurrently (with the shorter one finishing first, obviously), and
the total elapsed time is only as long as the slowest thread rather than the
total time for each separately.
这儿执行的是和onethr.py中一样的循环，不同的是，这一次我们使用的是thread模块提供的简单的
多线程的机制。两个循环并发地被执行（显然，短的那个先结束）。总的运行时间为最
慢的那个线程的运行时间，而不是所有的线程的运行时间之和。

1	#!/usr/bin/env python
2
3	import thread
4	from time import sleep, ctime
5
6	def loop0():
7	print 'start loop 0 at:', ctime()
8	sleep(4)
9	print 'loop 0 done at:', ctime()
10
11   def loop1():
12	print 'start loop 1 at:', ctime()
13	sleep(2)
14	print 'loop 1 done at:', ctime()
15
16   def main():
17	print 'starting at:', ctime()





23   if __name__ == '__main__':
24	main()


start_new_thread() requires the first two arguments, so that is the reason for
passing in an empty tuple even if the executing function requires no arguments.
start_new_thread()要求一定要有前两个参数。所以，就算我们想要运行的函数不要参数，
我们也要传一个空的元组。

Upon execution of this program, our output changes drastically. Rather than
taking a full 6 or 7 seconds, our script now runs in 4, the length of time of
our longest loop, plus any overhead.
这个程序的输出与之前的输出大不相同，之前是运行了6，7秒，而现在则是4秒，是最长的
循环的运行时间与其它的代码的时间总和。

$ mtsleep1.py
starting at: Sun Aug 13 05:04:50 2006
start loop 0 at: Sun Aug 13 05:04:50 2006 
start loop 1 at: Sun Aug 13 05:04:50 2006 
loop 1 done at: Sun Aug 13 05:04:52 2006 
loop 0 done at: Sun Aug 13 05:04:54 2006 
all DONE at: Sun Aug 13 05:04:56 2006

The pieces of code that sleep for 4 and 2 seconds now occur concurrently,
contributing to the lower overall runtime. You can even see how loop 1 fin-
ishes before loop 0. The only other major change to our application is the
addition of the “sleep(6)” call. Why is this necessary? The reason is that if
we did not stop the main thread from continuing, it would proceed to the next
statement, displaying “all done” and exit, killing both threads running
loop0() and loop1().
睡眠4秒和2秒的代码现在是并发执行的。这样，就使得总的运行时间被缩短了。你可以看到，
loop1甚至在loop0前面就结束了。程序的一大不同之处就是多了一个“sleep(6)”的函数调用。
为什么要加上这一句呢？因为，如果我们没有让主线程停下来，那主线程就会运行下一条语
句，显示“all done”，然后就关闭运行着loop0()和loop1()的两个线程，退出了。

We did not have any code that told the main thread to wait for the child
threads to complete before continuing. This is what we mean by threads
requiring some sort of synchronization. In our case, we used another sleep()
call as our synchronization mechanism. We used a value of 6 seconds because
we know that both threads (which take 4 and 2 seconds, as you know) should have
completed by the time the main thread has counted to 6.
我们没有写让主线程停下来等所有子线程结束之后再继续运行的代码。这就是我们之前说
线程需要同步的原因。在这里，我们使用了sleep()函数做为我们的同步机制。我们使用6秒
是因为我们已经知道，两个线程（你知道，一个要4秒，一个要2秒）在主线程等待6秒后应该
已经结束了。

You are probably thinking that there should be a better way of managing threads
than creating that extra delay of 6 seconds in the main thread. Because of this
delay, the overall runtime is no better than in our single- threaded version.
Using sleep() for thread synchronization as we did is not reliable. What if our
loops had independent and varying execution times? We may be exiting the main
thread too early or too late. This is where locks come in.
你也许在想，应该有什么好的管理线程的方法，而不是在主线程里做一个额外的延时6秒的
操作。因为这样一来，我们的总的运行时间并不比单线程的版本来得少。而且，像这样使用
sleep()函数做线程的同步操作是不可靠的。如果我们的循环的执行时间不能事先确定的话，
那怎么办呢？这可能造成主线程过早或过晚退出。这就是锁的用武之地了。

Making yet another update to our code to include locks as well as getting rid
of separate loop functions, we get mtsleep2.py, presented in Example 18.3.
Running it, we see that the output is similar to mtsleep1.py. The only dif-
ference is that we did not have to wait the extra time for mtsleep1.py to
conclude. By using locks, we were able to exit as soon as both threads had
completed execution.
上一次修改程序，我们去掉了loop函数，现在，我们要再一次修改程序为例18.3的
mtsleep2.py，引入锁的概念。运行它，我们看到，其输出与mtsleep1.py很相似，唯一的
区别是我们不用为线程什么时候结束再做额外的等待。使用了锁，我们就可以在两个线程
都退出后，马上退出。


$ mtsleep2.py
starting at: Sun Aug 13 16:34:41 2006
start loop 0 at: Sun Aug 13 16:34:41 2006 
start loop 1 at: Sun Aug 13 16:34:41 2006 
loop 1 done at: Sun Aug 13 16:34:43 2006 
loop 0 done at: Sun Aug 13 16:34:45 2006 
all DONE at: Sun Aug 13 16:34:45 2006


So how did we accomplish our task with locks? Let us take a look at the source
code.
我们是怎么通过锁来完成任务的呢？先看一看代码吧。

Example 18.3 Using thread and Locks (mtsleep2.py)
例18.3 使用线程和锁 (mtsleep2.py)

Rather than using a call to sleep() to hold up the main thread as in
mtsleep1.py, the use of locks makes more sense.
这里，使用锁比mtsleep1.py那里在主线程中使用sleep()函数更合理。

1	#!/usr/bin/env python
2
3	import thread
4	from time import sleep, ctime
5
6	loops = [4,2]
7
8	def loop(nloop, nsec, lock):
9	print 'start loop', nloop, 'at:', ctime()
10	sleep(nsec)
11	print 'loop', nloop, 'done at:', ctime()
12	lock.release()
13
14   def main():


17	nloops = range(len(loops))
18
19	for i in nloops:
20	lock = thread.allocate_lock()
21	lock.acquire()
22	locks.append(lock)
23
24	for i in nloops:
25	thread.start_new_thread(loop,
26	(i, loops[i], locks[i]))
27
28	for i in nloops:
29	while locks[i].locked(): pass
30
31	print 'all DONE at:', ctime()
32
33   if __name__ == '__main__':
34	main()


Line-by-Line Explanation
逐行解释

Lines 1C6
1-6行
After the Unix startup line, we import the thread module and a few familiar
attributes of the time module. Rather than hardcoding separate functions to
count to 4 and 2 seconds, we will use a single loop() function and place these
constants in a list, loops.
在Unix启动信息行后面，我们导入了thread模块和time模块里我们早已熟悉的几个函数。
我们不再在函数里写死要等4秒和2秒，而是使用一个loop()函数，把这些常量放在一个
列表loops里。

Lines 8C12
8-12行
The loop() function will proxy for the now-removed loop*() functions from our
earlier examples. We had to make some cosmetic changes to loop() so that it can
now perform its duties using locks. The obvious changes are that we need to be
told which loop number we are as well as how long to sleep for. The last piece
of new information is the lock itself. Each thread will be allocated an
acquired lock. When the sleep() time has concluded, we will release the
corresponding lock, indicating to the main thread that this thread has
completed.
loop()函数替换了我们之前的那几个loop*()函数。在loop()函数里，增加了一些锁的操作。
一个很明显的改变是，我们现在要在函数中记录下循环的号码和要睡眠的时间。最后一个
不一样的地方就是那个锁了。每个线程都会被分配一个事先已经获得的锁，在sleep()的时
间到了之后就释放相应的锁以通知主线程，这个线程已经结束了。

Lines 14C34
14-34行
The bulk of the work is done here in main() using three separate for loops. We
first create a list of locks, which we obtain using the thread.al-
locate_lock() function and acquire (each lock) with the acquire() method.
Acquiring a lock has the effect of “locking the lock.” Once it is locked, we
add the lock to the lock list, locks. The next loop actually spawns the
threads, invoking the loop() function per thread, and for each thread, provides
it with the loop number, the time to sleep for, and the acquired lock for that
thread. So why didn’t we start the threads in the lock acquisition loop? There
are several reasons: (1) we wanted to synchronize the threads, so that “all the
horses started out the gate” around the same time, and (2) locks take a little
bit of time to be acquired. If your thread executes “too fast,” it is possible
that it completes before the lock has a chance to be acquired.
主要的工作在包含三个循环的main()函数中完成。我们先调用thread.allocate_lock()函
数创建一个锁的列表，并分别调用各个锁的acquire()函数获得锁。获得锁表示“把锁锁上”。
锁上后，我们就把锁放到锁列表locks中。下一个循环创建线程，每个线程都用各自的循环
号，睡眠时间和锁为参数去调用loop()函数。为什么我们不在创建锁的循环里创建线程呢？
有以下几个原因：(1) 我们想到实现线程的同步，所以要让“所有的马同时冲出栅栏”。
(2) 获取锁要花一些时间，如果你的线程退出得“太快”，可能会导致还没有获得锁，线程就
已经结束了的情况。

It is up to each thread to unlock its lock object when it has completed exe-
cution. The final loop just sits and spins (pausing the main thread) until both
locks have been released before continuing execution. Since we are checking
each lock sequentially, we may be at the mercy of all the slower loops if they
are more toward the beginning of the set of loops. In such cases, the majority
of the wait time may be for the first loop(s). When that lock is released,
remaining locks may have already been unlocked (meaning that corresponding
threads have completed execution). The result is that the main thread will fly
through those lock checks without pause. Finally, you should be well aware that
the final pair of lines will execute main() only if we are invoking this script
directly.
在线程结束的时候，线程要自己去做解锁操作。最后一个循环只是坐在那一直等（达到暂停
主线程的目的），直到两个锁都被解锁为止才继续运行。由于我们顺序检查每一个锁，所以
我们可能会要长时间地等待运行时间长且放在前面的线程，当这些线程的锁释放之后，后面
的锁可能早就释放了（表示对应的线程已经运行完了）。结果主线程只能毫不停歇地完成对
后面这些锁的检查。最后两行代码的意思你应该已经知道了，就是只有在我们直接运行这个
脚本时，才运行main()函数

As hinted in the earlier Core Note, we presented the thread module only to
introduce the reader to threaded programming. Your MT application should use
higher-level modules such as the threading module, which we will now discuss.
在核心笔记中我们就已经说过，使用thread模块只是为了给读者演示如何进行多线程编程。
你的多线程程序应该使用更高级别的模块，如threading等。现在我们就开始讨论它。

18.5 threading Module
18.5 threading模块

We will now introduce the higher-level threading module, which gives you not
only a Thread class but also a wide variety of synchronization mechanisms to
use to your heart’s content. Table 18.2 represents a list of all the objects
available in the threading module.
接下来，我们要介绍的是更高级别的threading模块，它不仅提供了Thread类，还提供了各种
非常好用的同步机制。表18.2列出了threading模块里所有的对象。

In this section, we will examine how to use the Thread class to implement
threading. Since we have already covered the basics of locking, we will not
cover the locking primitives here. The Thread() class also contains a form of
synchronization, so explicit use of locking primitives is not necessary.
在这一节中，我们会演示如何使用Thread类来实现多线程。之前已经介绍过锁的基本概念，
这里我们将不会提到锁原语。而Thread类也有某种同步机制，所以，没有必要详细介绍锁原语。




Table 18.2 threading Module Objects
表18.2 threading模块对象

threading Module Objects	Description
threading模块对象               描述

Thread	Object that represents a single thread of execution
Thread	表示一个线程的执行的对象

Lock	Primitive lock object (same lock object as in the thread module)
Lock	锁原语对象（跟thread模块里的锁对象相同）

RLock	Re-entrant lock object provides ability for a single thread to
(re)acquire an already-held lock (recursive locking)
RLock   可重入锁对象。使单线程可以再次获得已经获得了的锁（递归锁定）。


Condition	Condition variable object causes one thread to wait until a
certain “condition” has been satisfied by another thread, such as changing of
state or of some data value
Condition      条件变量对象能让一个线程停下来，等待其它线程满足了某个“条件”。如，
状态的改变或值的改变。

Event	General version of condition variables whereby any number of threads
are waiting for some event to occur and all will awaken when the event happens
Event   通用的条件变量。多个线程可以等待某个事件的发生，在事件发生后，所有的线程
都会被激活。

Semaphore	Provides a “waiting area”-like structure for threads waiting on a lock
Semaphore	为等待锁的线程提供一个类似“等候室”的结构

BoundedSemaphore	Similar to a Semaphore but ensures it never exceeds its initial value
BoundedSemaphore	与Semaphore类似，只是它不允许超过初始值

Timer	Similar to Thread except that it waits for an allotted period of time before running
Timer	与Thread相似，只是，它要等待一段时间后才开始运行。

CORE TIP: Daemon threads
核心提示：守护线程

Another reason to avoid using the thread module is that it does not support the
concept of daemon (or daemonic) threads.When the main thread exits, all child
threads will be killed regardless of whether they are doing work.The concept of
daemon threads comes into play here if you do not want this behavior.
另一个避免使用thread模块的原因是，它不支持守护线程。当主线程退出时，所有的子线程
不论它们是否还在工作，都会被强行退出。有时，我们并不期望这种行为，这时，就引入了
守护线程的概念

Support for daemon threads is available in the threading module, and here is
how they work: a daemon is typically a server that waits for client requests to
service. If there is no client work to be done, the daemon just sits around
idle. If you set the daemon flag for a thread, you are basically saying that it
is noncritical, and it is okay for the process to exit without waiting for it
to “finish.” As you have seen in Chapter 16,“Network Programming” server
threads run in an infinite loop and do not exit in normal situations.
threading模块支持守护线程，它们是这样工作的：守护线程一般是一个等待客户请求的
服务器，如果没有客户提出请求，它就在那等着。如果你设定一个线程为守护线程，就表示
你在说这个线程是不重要的，在进程退出的时候，不用等待这个线程退出。就像你在第
16章网络编程看到的，服务器线程运行在一个无限循环中，一般不会退出。

If your main thread is ready to exit and you do not care to wait for the child
threads to finish, then set their daemon flag. Think of setting this flag as
denoting a thread to be “not important.” You do this by calling each thread’s
setDaemon() method, e.g., thread.setDaemon(True), before it begins running
(thread.start().)
如果你的主线程要退出的时候，不用等待那些子线程完成，那就设定这些线程的daemon属性。
即，在线程开始（调用thread.start()）之前，调用setDaemon()函数设定线程的daemon标志
（thread.setDaemon(True)）就表示这个线程“不重要”

If you want to wait for child threads to finish, just leave them as-is, or
ensure that their daemon flags are off by explicitly calling thread.setDaemon
(False) before starting them.You can check a thread’s daemonic status with
thread.isDaemon(). A new child thread inherits its daemonic flag from its
parent.The entire Python program will stay alive until all non-daemonic threads
have exited, in other words, when no active non-daemonic threads are left).
如果你想要等待子线程完成再退出，那就什么都不用做，或者显式地调用
thread.setDaemon(False)以保证其daemon标志为False。你可以调用thread.isDaemon()函数
来判断其daemon标志的值。新的子线程会继承其父线程的daemon标志。整个Python会在所有
的非守护线程退出后才会结束,即进程中没有非守护线程存在的时候才结束。


18.5.1 Thread Class
18.5.1 Thread类

The Thread class of the threading is your primary executive object. It has a
variety of functions not available to the thread module, and are outlined in
Table 18.3.
threading的Thread类是你主要的运行对象。它有很多thread模块里没有的函数，详见表18.3。

There are a variety of ways you can create threads using the Thread class. We
cover three of them here, all quite similar. Pick the one you feel most
comfortable with, not to mention the most appropriate for your application and
future scalability (we like the final choice the best):
用Thread类，你可以用多种方法来创建线程。我们在这里介绍三种比较相像的方法。你可
以任选一种你喜欢的，或最适合你的程序以及最能满足程序可扩展性的（我们一般比较喜
欢最后一个选择）：


?	Create Thread instance, passing in function
?	Create Thread instance, passing in callable class instance
?	Subclass Thread and create subclass instance

?	创建一个Thread的实例，传给它一个函数
?	创建一个Thread的实例，传给它一个可调用的类对象
?	从Thread派生出一个子类，创建一个这个子类的实例

Table 18.3  Thread Object Methods
表18.3 Thread对象的函数

Method	Description
函数    描述

start()	Begin thread execution
start()	开始线程的执行

run()	Method defining thread functionality (usually overridden by application writer in a subclass)
run()	定义线程的功能的函数（一般会被子类重写）


join(timeout=None) Suspend until the started thread terminates; blocks unless timeout (in seconds) is given
join(timeout=None) 程序挂起，直到线程结束；如果给了timeout，则最多阻塞timeout秒

getName()	Return name of thread
getName()	返回线程的名字

setName(name)	Set name of thread
setName(name)	设置线程的名字

isAlive()	Boolean flag indicating whether thread is still running
isAlive()	布尔标志，表示这个线程是否还在运行中

isDaemon()	Return daemon flag of thread
isDaemon()	返回线程的daemon标志


setDaemon(daemonic) Set the daemon flag of thread as per the Boolean daemonic
(must be called before thread start()ed)

setDaemon(daemonic) 把线程的daemon标志设为daemonic（一定要在调用start()函数前调用）


Create Thread Instance, Passing in Function In 
创建一个Thread的实例，传给它一个函数

our first example, we will just instantiate Thread, passing in our function
(and its arguments) in a manner similar to our previous examples. This function
is what will be executed when we direct the thread to begin execution. Taking
our mtsleep2.py script and tweaking it, adding the use of Thread objects, we
have mtsleep3.py, shown in Example 18.4.
第一个例子的中，我们将初始化一个Thread对象，把函数（及其参数）像上一个例子那样传
进去。在线程开始执行的时候，这个函数会被执行。把mtsleep2.py脚本拿过来，做一些调整
加入Thread对象的使用，就成了例18.4中的mtsleep3.py。

When we run it, we see output similar to its predecessors’ output:
运行的输出跟之前很相似：

$ mtsleep3.py
starting at: Sun Aug 13 18:16:38 2006
start loop 0 at: Sun Aug 13 18:16:38 2006
start loop 1 at: Sun Aug 13 18:16:38 2006 
loop 1 done at: Sun Aug 13 18:16:40 2006 
loop 0 done at: Sun Aug 13 18:16:42 2006 
all DONE at: Sun Aug 13 18:16:42 2006

So what did change? Gone are the locks that we had to implement when using the
thread module. Instead, we create a set of Thread objects. When each Thread is
instantiated, we dutifully pass in the function (target) and arguments (args)
and receive a Thread instance in return. The biggest difference between
instantiating Thread [calling Thread()] and invoking thread.start_new_thread()
is that the new thread does not begin execution right away. This is a useful
synchronization feature, especially when you don’t want the threads to start
immediately.
那么，都做了些什么修改呢？在使用thread模块时使用的锁没有了。新加了一些Thread对象。
在实例化每个Thread对象的时候，我们把函数（target）和参数（args）传进去，得到返回
的Thread实例。实例化一个Thread（调用Thread()）与调用thread.start_new_thread()之
间最大的区别就是，新的线程不会立即开始。在你创建线程对象，但不想马上开始运行线程
的时候，这是一个很有用的同步特性。


Example 18.4  Using the threading Module (mtsleep3.py)
例18.4 使用threading模块 (mtsleep3.py)

The Thread class from the threading module has a join() method that lets the
main thread wait for thread completion.
threading模块的Thread类有一个join()函数，允许主线程等待线程的结束。


1	#!/usr/bin/env python
2
3	import threading
4	from time import sleep, ctime
5
6	loops = [4,2]
7
8	def loop(nloop, nsec):
9	print 'start loop', nloop, 'at:', ctime()
10	sleep(nsec)
11	print 'loop', nloop, 'done at:', ctime()
12
13   def main():
14	print 'starting at:', ctime()
15	threads = []
16	nloops = range(len(loops))
17
18	for i in nloops:


21	threads.append(t)
22
23	for i in nloops:	# start threads
24	threads[i].start()
25
26	for i in nloops:	# wait for all
27	threads[i].join()	# threads to finish
28
29	print 'all DONE at:', ctime()
30
31   if __name__ == '__main__':
32	main()




Once all the threads have been allocated, we let them go off to the races by
invoking each thread’s start() method, but not a moment before that. And rather
than having to manage a set of locks (allocating, acquiring, releasing,
checking lock state, etc.), we simply call the join() method for each thread.
所有的线程都创建了之后，再一起调用start()函数启动，而不是创建一个启动一个。而且，
不用再管理一堆锁（分配锁，获得锁，释放锁，检查锁的状态等），只要简单地对每个线程
调用join()函数就可以了。

join() will wait until a thread terminates, or, if provided, a timeout occurs.
Use of join() appears much cleaner than an infinite loop waiting for locks to
be released (causing these locks to sometimes be known as “spin locks”).
join()会等到线程结束，或者在给了timeout参数的时候，等到超时为止。使用join()看上
去会比使用一个等待锁释放的无限循环清楚一些(这种锁也被称为"spinlock")

One other important aspect of join() is that it does not need to be called at
all. Once threads are started, they will execute until their given function
completes, whereby they will exit. If your main thread has things to do other
than wait for threads to complete (such as other processing or waiting for new
client requests), it should by all means do so. join() is useful only when you
want to wait for thread completion.
join()的另一个比较重要的方面是它可以完全不用调用。一旦线程启动后，就会一直运行，
直到线程的函数结束，退出为止。如果你的主线程除了等线程结束外，还有其它的事情要
做（如处理或等待其它的客户请求），那就不用调用join()，只有在你要等待线程结束的
时候才要调用join()。

Create Thread Instance, Passing in Callable Class Instance 
创建一个Thread的实例，传给它一个可调用的类对象

A similar offshoot to passing in a function when creating a thread is to have a
callable class and passing in an instance for execution―this is the more OO
approach to MT programming. Such a callable class embodies an execution
environment that is much more flexible than a function or choosing from a set
of functions. You now have the power of a class object behind you, as opposed
to a single function or a list/tuple of functions.
与传一个函数很相似的另一个方法是在创建线程的时候，传一个可调用的类的实例供线程
启动的时候执行――这是多线程编程的一个更为面向对象的方法。相对于一个或几个函数来说，
由于类对象里可以使用类的强大的功能，可以保存更多的信息，这种方法更为灵活。

Adding our new class ThreadFunc to the code and making other slight
modifications to mtsleep3.py, we get mtsleep4.py, given in Example 18.5.
If we run mtsleep4.py, we get the expected output:
把ThreadFunc类加入到mtsleep3.py代码中，并做一些其它的小修改后，就得到了例18.5中
的mtsleep4.py。运行它，就会得到如下的输出：


$ mtsleep4.py
starting at: Sun Aug 13 18:49:17 2006
start loop 0 at: Sun Aug 13 18:49:17 2006 
start loop 1 at: Sun Aug 13 18:49:17 2006 
loop 1 done at: Sun Aug 13 18:49:19 2006 
loop 0 done at: Sun Aug 13 18:49:21 2006 
all DONE at: Sun Aug 13 18:49:21 2006

So what are the changes this time? The addition of the ThreadFunc class and a
minor change to instantiate the Thread object, which also instantiates
ThreadFunc, our callable class. In effect, we have a double instantiation going
on here. Let’s take a closer look at our ThreadFunc class.
那么，这次又改了些什么呢？主要是增加了ThreadFunc类和创建Thread对象时会实例化一个
可调用类ThreadFunc的类对象。也就是说，我们实例化了两个对象。下面，来仔细地看一看
ThreadFunc类吧。

We want to make this class general enough to use with functions other than our
loop() function, so we added some new infrastructure, such as having this class
hold the arguments for the function, the function itself, and also a function
name string. The constructor __init__() just sets all the values.
我们想让这个类在调用什么函数方面尽量地通用，并不局限于那个loop()函数。所以，我们
加了一些修改，如，这个类保存了函数的参数，函数本身以及函数的名字字符串。构造函数
__init__()里做了这些值的赋值工作。

When the Thread code calls our ThreadFunc object when a new thread is created,
it will invoke the __call__() special method. Because we already have our set
of arguments, we do not need to pass it to the Thread() constructor, but do
have to use apply() in our code now because we have an argument tuple. Those of
you who have Python 1.6 and higher can use the new function invocation syntax
described in Section 11.6.3 instead of using apply() on line 16:
创建新线程的时候，Thread对象会调用我们的ThreadFunc对象，这时会用到一个特殊函数
__call__()。由于我们已经有了要用的参数，所以就不用再传到Thread()的构造函数中。
由于我们有一个参数的元组，这时要在代码中使用apply()函数。如果你使用的是Python1.6
或是更高版本，你可以使用11.6.3节中所说的新的调用语法，而不用像第16行那样使用
apply()函数：

self.res = self.func(*self.args)

Example 18.5  Using Callable classes (mtsleep4.py)
例18.5 使用可调用的类 (mtsleep4.py)


In this example we pass in a callable class (instance) as opposed to just a function.
It presents more of an OO approach than mtsleep3.py.
此例中，我们传了一个可调用的类(的实例)，而不是仅传一个函数。相对mtsleep3.py中的方法来
说，这样做更具面向对象的概念。

1	#!/usr/bin/env python
2
3	import threading
4	from time import sleep, ctime
5
6	loops = [4,2]
7
8	class ThreadFunc(object):
9
10	def __init__(self, func, args, name=''):




15	def __call__(self):
16	apply(self.func, self.args)
17
18   def loop(nloop, nsec):
19	print 'start loop', nloop, 'at:', ctime()
20	sleep(nsec)
21	print 'loop', nloop, 'done at:', ctime()
22
23   def main():
24	print 'starting at:', ctime()
25	threads = []
26	nloops = range(len(loops))
27
28	for i in nloops: # create all threads
29	t = threading.Thread(


32	threads.append(t)
33
34	for i in nloops: # start all threads
35	threads[i].start()
36
37	for i in nloops: # wait for completion
38	threads[i].join()
39
40	print 'all DONE at:', ctime()
41
42   if __name__ == '__main__':
43	main()

Subclass Thread and Create Subclass Instance 
从Thread派生出一个子类，创建一个这个子类的实例

The final introductory example involves subclassing Thread(), which turns out
to be extremely similar to creating a callable class as in the previous
example. Subclassing is a bit easier to read when you are creating your threads
(lines 29C30). We will present the code for mtsleep5.py in Example 18.6 as
well as the output obtained from its execution, and leave it as an exercise for
the reader to compare mtsleep5.py to mtsleep4.py.
最后一个例子介绍如何子类化Thread类，这与上一个例子中的创建一个可调用的类非常像。
使用子类化创建线程（第29-30行）使代码看上去更清晰明了。我们将在例18.6中给出mtsleep5.py
的代码，以及代码运行的输出。比较mtsleep5.py和mtsleep4.py的任务则留给读者做为练习。

Here is the output for mtsleep5.py, again, just what we expected:
下面是mtsleep5.py的输出，同样，跟我们的期望一致：

$ mtsleep5.py
starting at: Sun Aug 13 19:14:26 2006
start loop 0 at: Sun Aug 13 19:14:26 2006 
start loop 1 at: Sun Aug 13 19:14:26 2006 
loop 1 done at: Sun Aug 13 19:14:28 2006 
loop 0 done at: Sun Aug 13 19:14:30 2006 
all DONE at: Sun Aug 13 19:14:30 2006

While the reader compares the source between the mtsleep4 and mtsleep5 modules,
we want to point out the most significant changes: (1) our MyThread subclass
constructor must first invoke the base class constructor (line 9), and (2) the
former special method __call__() must be called run() in the subclass.
在读者比较mtsleep4和mtsleep5两个模块的代码之前，我们想指出最重要的两点改变：
(1)我们的MyThread子类的构造函数一定要先调用基类的构造函数(第9行)，(2)之前的特殊
函数__call__()在子类中，名字要改为run()。

We now modify our MyThread class with some diagnostic output and store it in a
separate module called myThread (see Example 18.7) and import this class for
the upcoming examples. Rather than simply calling apply() to run our functions,
we also save the result to instance attribute self.res, and create a new method
to retrieve that value, getResult().
现在，在MyThread类中，加入一些用于调试的输出信息，把代码保存到myThread模块中(见
例18.7)，并在下面的例子中，导入这个类。除了简单地使用apply()函数来运行这些函数之外，
我们还把结果保存到实现的self.res属性中，并创建一个新的函数getResult()来得到结果。


18.5.4 Fibonacci and Factorial . . . Take Two, Plus Summation
18.5.4 斐波那契，阶乘和累加和

The mtfacfib.py script, given in Example 18.8, compares execution of the
recursive Fibonacci, factorial, and summation functions. This script runs all
three functions in a single-threaded manner, then performs the same task using
threads to illustrate one of the advantages of having a threading environment.
例18.8中的mtfacfib.py脚本比较了递归求斐波那契，阶乘和累加和函数的运行。脚本先
在单线程中运行这三个函数，然后在多线程中做同样的事，以说明多线程的好处。

Example 18.6 Subclassing Thread (mtsleep5.py)
例18.6 子类化Thread (mtsleep5.py)

Rather than instantiating the Thread class, we subclass it.This gives us more
flexibility in customizing our threading objects and simplifies the thread
creation call.
我们现在要子类化Thread类，而不是创建它的实例。这样做可以更灵活地定制我们的线程
对象，而且在创建线程的时候也更简单。

1	#!/usr/bin/env python
2
3	import threading
4	from time import sleep, ctime
5
6	loops = (4, 2)
7
8	class MyThread(threading.Thread):
9	def __init__(self, func, args, name=''):
10	threading.Thread.__init__(self)




15	def run(self):
16	apply(self.func, self.args)
17
18   def loop(nloop, nsec):
19	print 'start loop', nloop, 'at:', ctime()
20	sleep(nsec)
21	print 'loop', nloop, 'done at:', ctime()
22
23   def main():
24	print 'starting at:', ctime()
25	threads = []
26	nloops = range(len(loops))
27
28	for i in nloops:
29	t = MyThread(loop, (i, loops[i]),
30	loop.__name__)
31	threads.append(t)
32
33	for i in nloops:
34	threads[i].start()
35
36	for i in nloops:
37	threads[i].join()
38
39	print 'all DONE at:', ctime()'
40
41   if __name__ == '__main__':
42	main()

Example 18.7  MyThread Subclass of Thread (myThread.py)
例18.7 MyThread子类化Thread (myThread.py)

To generalize our subclass of Thread from mtsleep5.py, we move the subclass to
a separate module and add a getResult() method for callables that produce
return values.
为了让mtsleep5.py中，Thread的子类更为通用，我们把子类单独放在一个模块中，并加上
一个getResult()函数用以返回函数的运行结果。

1	#!/usr/bin/env python
2
3	import threading
4	from time import ctime
5
6	class MyThread(threading.Thread):
7	def __init__(self, func, args, name=''):
8	threading.Thread.__init__(self)




13	def getResult(self):
14	return self.res
15
16	def run(self):
17	print 'starting', self.name, 'at:', \
18	ctime()
19	self.res = apply(self.func, self.args)
20	print self.name, 'finished at:', \
21	ctime()


Running in single-threaded mode simply involves calling the functions one at a
time and displaying the corresponding results right after the function call.
When running in multithreaded mode, we do not display the result right away.
Because we want to keep our MyThread class as general as possible (being able
to execute callables that do and do not produce output), we wait until the end
to call the getResult() method to finally show you the return values of each
function call.
在单线程中运行只要简单地逐个调用这些函数，在函数结束后，显示对应的结果。在多线程
中，我们不马上显示结果。由于我们想让MyThread类尽可能地通用(能同时适应有输出和没
输出的函数)，我们会等到要结束时才会调用getResult()函数，并在最后显示每个函数的结
果。

Because these functions execute so quickly (well, maybe except for the
Fibonacci function), you will notice that we had to add calls to sleep() to
each function to slow things down so that we can see how threading may improve
performance, if indeed the actual work had varying execution times―you
certainly wouldn’t pad your work with calls to sleep(). Anyway, here is the
output:
由于这些函数运行得很快（斐波那契函数会慢一些），你会看到，我们得在每个函数中加上一个
sleep()函数，让函数慢下来，以便于我们能方便地看到多线程能在多大程度上加速程序的
运行。不过实际工作中，你一般不会想在程序中加上sleep()函数的。下面是程序的输出：

$ mtfacfib.py
*** SINGLE THREAD
starting fib at: Sun Jun 18 19:52:20 2006
233
fib finished at: Sun Jun 18 19:52:24 2006

Example 18.8 Fibonacci, Factorial, Summation (mtfacfib.py)
例18.8 斐波那契，阶乘和累加和 (mtfacfib.py)

In this MT application, we execute three separate recursive functions―first in
a single-threaded fashion, followed by the alternative with multiple threads.
在这个多线程程序中，我们会分别在单线程和多线程环境中，运行三个递归函数。

1	#!/usr/bin/env python
2
3	from myThread import MyThread
4	from time import ctime, sleep
5
6	def fib(x):
7	sleep(0.005)
8	if x < 2: return 1
9	return (fib(x-2) + fib(x-1))
10



14	return (x * fac(x-1))
15



19	return (x + sum(x-1))
20
21  funcs = [fib, fac, sum]
22  n = 12
23
24  def main():
25	nfuncs = range(len(funcs))
26
27	print '*** SINGLE THREAD'
28	for i in nfuncs:
29	print 'starting', funcs[i].__name__, 'at:', \
30	ctime()
31	print funcs[i](n)
32	print funcs[i].__name__, 'finished at:', \
33	ctime()
34
35	print '\n*** MULTIPLE THREADS'
36	threads = []
37	for i in nfuncs:


40	threads.append(t)
41
42	for i in nfuncs:
43	threads[i].start()
44
45	for i in nfuncs:
46	threads[i].join()
47	print threads[i].getResult()
48
49	print 'all DONE'
50
51    if __name__ == '__main__':
52	main()

starting fac at: Sun Jun 18 19:52:24 2006
479001600
fac finished at: Sun Jun 18 19:52:26 2006 
starting sum at: Sun Jun 18 19:52:26 2006
78
sum finished at: Sun Jun 18 19:52:27 2006

*** MULTIPLE THREADS

starting fib at: Sun Jun 18 19:52:27 2006 
starting fac at: Sun Jun 18 19:52:27 2006 
starting sum at: Sun Jun 18 19:52:27 2006
233
479001600
78
all DONE

18.5.5 Other Threading Module Functions
18.5.5 threading模块中的其它函数

In addition to the various synchronization and threading objects, the Threading
module also has some supporting functions, detailed in Table 18.4.
除了各种同步对象和线程对象外，threading模块还提供了一些函数。见表18.4。


Table 18.4 threading Module Functions
表18.4 threading模块的函数

Function	Description
函数            描述

activeCount()	Number of currently active Thread objects 
currentThread()	Returns the current Thread object 
enumerate()	Returns list of all currently active Threads

activeCount()	当前活动的线程对象的数量
currentThread()	返回当前线程对象
enumerate()	返回当前活动线程的列表

settrace(func)a         Sets a trace function for all threads
setprofile(func)a	Sets a profile function for all threads

settrace(func)a         为所有线程设置一个跟踪函数
setprofile(func)a	为所有线程设置一个profile函数

a.	New in Python 2.3.
a.	Python 2.3新增

18.5.5 Producer-Consumer Problem and the Queue Module
18.5.5 生产者-消费者问题和Queue模块

The final example illustrates the producer-consumer scenario where a producer
of goods or services creates goods and places it in a data structure such as a
queue. The amount of time between producing goods is non-deterministic, as is
the consumer consuming the goods produced by the producer.
最后一个例子演示了生产者和消费者的场景。生产者生产货物，然后把货物放到一个队列
之类的数据结构中，生产货物所要花费的时间无法预先确定。消费者消耗生产者生产
的货物的时间也是不确定的。

Table 18.5 Common Queue Module Attributes
表18.5 常用的Queue模块的属性

Function/Method	Description
函数            描述


Queue Module Function
Queue模块函数

queue(size)	Creates a Queue object of given size
queue(size)	创建一个大小为size的Queue对象


Queue Object Methods
Queue对象函数

qsize()	Returns queue size (approximate, since queue may be getting updated by other threads)
qsize()	返回队列的大小（由于在返回的时候，队列可能会被其它线程修改，所以这个值是近似值）

empty()	Returns True if queue empty, False otherwise
empty()	如果队列为空返回True，否则返回False

full()	Returns True if queue full, False otherwise
full()	如果队列已满返回True，否则返回False


put(item, block=0) Puts item in queue, if block given (not 0), block until room is available
put(item, block=0) 把item放到队列中，如果给了block（不为0），函数会一直阻塞到队列中有空间为止

get(block=0)	Gets item from queue, if block given (not 0), block until an item is available
get(block=0)	从队列中取一个对象，如果给了block（不为0），函数会一直阻塞到队列中有对象为止


We use the Queue module to provide an interthread communication mechanism that
allows threads to share data with each other. In particular, we create a queue
into which the producer (thread) places new goods and the consumer (thread)
consumes them. To do this, we will use the following attributes from the Queue
module (see Table 18.5).
Queue模块可以用来进行线程间通讯，让各个线程之间共享数据。现在，我们创建一个队列，
让生产者（线程）把新生产的货物放进去供消费者（线程）使用。要达到这个目的，我们要
使用到Queue模块的以下属性（见表18.5）。

Without further ado, we present the code for prodcons.py, shown in Example
18.9.
很容易地，我们就能写出例18.9的prodcons.py的代码。

Here is the output from one execution of this script:
下面是这个脚本的运行输出：

$ prodcons.py
starting writer at: Sun Jun 18 20:27:07 2006
producing object for Q... size now 1
starting reader at: Sun Jun 18 20:27:07 2006 
consumed object from Q... size now 0 
producing object for Q... size now 1
consumed object from Q... size now 0 
producing object for Q... size now 1 
producing object for Q... size now 2 
producing object for Q... size now 3 
consumed object from Q... size now 2 
consumed object from Q... size now 1
writer finished at: Sun Jun 18 20:27:17 2006
consumed object from Q... size now 0
reader finished at: Sun Jun 18 20:27:25 2006
all DONE

As you can see, the producer and consumer do not necessarily alternate in
execution. (Thank goodness for random numbers!) Seriously, though, real life is
generally random and non-deterministic.
如你所见，生产者和消费者不一定是轮流执行的（多亏有了随机数！）。实际上，真实生活
总是充满了随机性和不确定性。


Line-by-Line Explanation
逐行解释

Lines 1C6
1-6行
In this module, we will use the Queue.Queue object as well as our thread class
myThread.MyThread, which we gave in Example 18.7. We will use random.randint()
to make production and consumption somewhat varied, and also grab the usual
suspects from the time module.
在这个模块中，我们要使用Queue.Queue对象以及我们在例18.7中给出的的线程类
myThread.MyThread。我们将使用random.randint()函数来随机的进行生产和消耗。并从
time模块中导入了常用的属性。


Lines 8C16
8-16行
The writeQ() and readQ() functions each have a specific purpose, to place an
object in the queue―we are using the string 'xxx', for example―and to consume a
queued object, respectively. Notice that we are producing one object and
reading one object each time.
writeQ()和readQ()函数分别用来把对象放入队列和消耗队列中的一个对象。在这里我们使用
字符串'xxx'来表示队列中的对象。

Lines 18C26
18-26行
The writer() is going to run as a single thread whose sole purpose is to pro-
duce an item for the queue, wait for a bit, then do it again, up to the
specified number of times, chosen randomly per script execution. The reader()
will do likewise, with the exception of consuming an item, of course.
writer()函数只做一件事，就是一次往队列中放入一个对象，等待一会，然后再做同样的事，
一共做指定的次数，这个次数是由脚本运行时随机生成的。reader()函数做的事比较类似，
只是它是用来消耗对象的。

You will notice that the random number of seconds that the writer sleeps is in
general shorter than the amount of time the reader sleeps. This is to dis-
courage the reader from trying to take items from an empty queue. By giving the
writer a shorter time period of waiting, it is more likely that there will
already be an object for the reader to consume by the time their turn rolls
around again.
你会注意到，writer睡眠的时间一般会比reader睡眠的时间短。这可以减少reader尝试从空
队列中取数据的机会。writer的睡眠时间短，那reader在想要数据的时候总是能拿到数据。

Lines 28C29
28-29行
These are just setup lines to set the total number of threads that are to be
spawned and executed.
设置有多少个线程要被运行。

Example 18.9  Producer-Consumer Problem (prodcons.py)
例18.9 生产者－消费者问题 (prodcons.py)

We feature an implementation of the ProducerCConsumer problem using Queue
objects and a random number of goods produced (and consumed).The producer and
consumer are individually―and concurrently―executing threads.
这个实现中使用了Queue对象和随机地生产（和消耗）货物的方式。生产者和消费者相互
独立并且并发地运行。

1	#!/usr/bin/env python
2
3	from random import randint
4	from time import sleep
5	from Queue import Queue
6	from myThread import MyThread
7
8	def writeQ(queue):
9	print 'producing object for Q...',
10	queue.put('xxx', 1)
11	print "size now", queue.qsize()
12
13    def readQ(queue):
14	val = queue.get(1)
15	print 'consumed object from Q... size now', \
16	queue.qsize()
17
18    def writer(queue, loops):
19	for i in range(loops):
20	writeQ(queue)
21	sleep(randint(1, 3))
22
23    def reader(queue, loops):
24	for i in range(loops):
25	readQ(queue)
26	sleep(randint(2, 5))
27
28    funcs = [writer, reader]
29    nfuncs = range(len(funcs))
30
31    def main():
32	nloops = randint(2, 5)
33	q = Queue(32)
34
35	threads = []
36	for i in nfuncs:
37	t = MyThread(funcs[i], (q, nloops),
38	funcs[i].__name__)
39	threads.append(t)
40
41	for i in nfuncs:
42	threads[i].start()
43
44	for i in nfuncs:
45	threads[i].join()
46
47	print 'all DONE'
48
49    if __name__ == '__main__':
50	main()

Lines 31C47
31-47行
Finally, we have our main() function, which should look quite similar to the
main() in all of the other scripts in this chapter. We create the appropriate
threads and send them on their way, finishing up when both threads have
concluded execution.
最后，就到了main()函数，它与之前的所有脚本的main()函数都很像。先是创建所有的线程，
然后运行它们，最后，等两个线程都结束后，得到最后的运行结果。

We infer from this example that a program that has multiple tasks to perform
can be organized to use separate threads for each of the tasks. This can result
in a much cleaner program design than a single threaded program that attempts
to do all of the tasks.
从本例中，我们可以了解到，一个要完成多项任务的程序，可以考虑每个任务使用一个线程。
这样的程序在设计上相对于单线程做所有事的程序来说，更为清晰明了。

In this chapter, we illustrated how a single-threaded process may limit an
application’s performance. In particular, programs with independent, non-
deterministic, and non-causal tasks that execute sequentially can be improved
by division into separate tasks executed by individual threads. Not all
applications may benefit from multithreading due to overhead and the fact that
the Python interpreter is a single-threaded application, but now you are more
cognizant of Python’s threading capabilities and can use this tool to your
advantage when appropriate.
本章中，我们看到了单线程的程序在程序性能上的限制。尤其在有相互独立的，运行时间不
确定的多个任务的程序里，把多个任务分隔成多个线程同时运行会比顺序运行速度更快。
由于Python解释器是单线程的，所以不是所有的程序都能从多线程中得到好处。不过，你已
经对Python下的多线程有所了解，在适当的时候，可以利用它来改善程序的性能。

18.6 Related Modules
18.6 相关模块

The table below lists some of the modules you may use when programming
multithreaded applications.
下表列出了一些多线程编程中可能用得到的模块：


Table 18.6 Threading-Related Standard Library Modules
表18.6 多线程相关的标准库模块

Module	Description
模块    描述

thread	Basic, lower-level thread module
thread	基本的，底级别的线程模块

threading	Higher-level threading and synchronization objects 
Queue	Synchronized FIFO queue for multiple threads 
mutex	Mutual exclusion objects
SocketServer	TCP and UDP managers with some threading control

threading	高级别的线程和同步对象
Queue	供多线程使用的同步先进先出（FIFO）队列
mutex	互斥对象
SocketServer	具有线程控制的TCP和UDP管理器

18.7 Exercises
18.7 练习

18C1. Processes versus Threads. What are the differences between processes and
threads?
18-1. 进程与线程。线程与进程的区别是什么？

18C2. Python Threads. Which type of multithreaded application will tend to fare
better in Python, I/O-bound or CPU-bound?
18-2. Python的线程。在Python中，哪一种多线程的程序表现得更好，I/O密集型的还是计算
密集型的？

18C3. Threads. Do you think anything significant happens if you have multiple
threads on a multiple CPU system? How do you think multiple threads run on
these systems?
18-3. 线程。你认为，多CPU的系统与一般的系统有什么大的不同？多线程的程序在这种系统
上的表现会怎么样？

18C4. Threads and Files. Update your solution to Exercise 9C19, which obtains a
byte value and a file name, displaying the number of times that byte appears in
the file. Let’s suppose this is a really big file. Multiple readers in a file
is acceptable, so create multiple threads that count in different parts of
the file so that each thread is responsible for a certain part of the file.
Collate the data from each thread and provide the summed-up result. Use your
timeit() code to time both the single threaded version and your new multi-
threaded version and say something about the performance improvement.
18-4. 线程和文件。把练习9-19的答案做一些改进。我们要得到一个字节值，一个文件名
然后显示在文件中那个字节出现了多少次。假设这个文件非常的大。文件是可以有多个
读者的，那我们就可以创建多个线程，每个线程负责文件的一部分。最后，把所有的线程
的结果相加。使用timeit()对单线程和多线程分别进行计时，对性能的改进进行讨论。

18C5. Threads, Files, and Regular Expressions. You have a very large mailbox
file―if you don’t have one, put all of your e-mail messages together into a
single text file. Your job is to take the regular expressions you designed in
Chapter 15 that recognize e-mail addresses and Web site URLs, and use them to
convert all e-mail addresses and URLs in this large file into live links so
that when the new file is saved as an .html (or .htm) file, will show up in a
Web browser as live and clickable. Use threads to segregate the conversion
process across the large text file and collate the results into a single new
.html file. Test the results on your Web browser to ensure the links are indeed
working.
18-5. 线程，文件和正则表达式。你有一个非常大的mailbox文件――如果没有的话，你可以
把你所有的e-mail的原始信息放到一个文本文件中。你现在要做的是，使用你在15章写的
识别e-mail地址和网页URL的正则表达式，分析出这个大文件里的所有的e-mail地址和URL，
把这些链接写到一个.html(或.htm)文件中。在这个文件生成时，会自动显示一个浏览器，
打开这个文件，显示所有的链接。使用多线程来分隔处理大文件和把结果写到一个新的
.html文件的操作。在浏览器中测试一下你的结果，确保那些链接都能正常工作。

18C6. Threads and Networking. Your solution to the chat service application in
the previous chapter (Exercises 16C7 to 16C10) may have required you to use
heavyweight threads or processes as part of your solution. Convert that to be
multithreaded code.
18-6. 线程和网络。你在之前做的聊天服务器程序（练习16-7到16-10）也许会用到重量
级线程或者说进程，把那个代码改成多线程的。

18C7. *Threads and Web Programming. The Crawler up ahead in Example 19.1 is a
single-threaded application that downloads Web pages that would benefit from MT
programming.  Update crawl.py (you could call it mtcrawl.py) such that
independent threads are used to download pages. Be sure to use some kind of
locking mechanism to prevent conflicting access to the links queue.
18-7. *线程和Web编程。练习19.1中的爬虫，是一个单线程的网页下载程序， 但可以利用多线程提高性能。
修改crawl.py（你可以叫它mtcrawl.py），让它可以使用多个不相关的线
程来下载网页。注意要使用某种锁的机制以确保不会在访问链接队列的时候出现访问冲突。

18C8. Thread Pools. Instead of a producer thread and a consumer thread, change
the code in Example 18.9, prodcons.py, so that you have any number of consumer
threads (a thread pool) which can process or consume more than one item from
the Queue at any given moment.
18-8. 线程池。修改例18.9的代码，不再是一个生产者和一个消费者，而是可以有任意个
消费者线程（一个线程池），每个线程可以在任意时刻处理或消耗任意多个产品。

18C9. Files. Create a set of threads to count how many lines there are in a set
of (presumably large) text files. You may choose the number of threads to use.
Compare the performance against a single-threaded version of this code. Hint:
Review Chapter 9 (Files and I/O) exercises.
18-9. 文件。创建一些线程来计算一些（可能很大量的）文件中一共有多少行。你可以选择
要使用多少个线程。比较单线程与多线程的性能差异。提示：回顾一下第9章（文件和输入
输出）的练习。

18C10. Take your solution to the previous exercise and adopt it to a task of
your selection, i.e., processing a set of e-mail messages, downloading Web
pages, processing RSS or Atom feeds, enhancing message processing as part of a
chat server, solving a puzzle, etc.
18-10. 把你之前的解决方案应用到你选择的几个任务中，如，处理一些e-mail，下载一些
网页，处理一些RSS和Atom feeds，聊天时的消息处理，解一个迷题等。
