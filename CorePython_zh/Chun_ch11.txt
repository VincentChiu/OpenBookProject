Functions and Functional Programming
函数和函数式编程

Chapter Topics
章节主题
	What Are Functions?
	Calling Functions
	Creating Functions
	Passing Functions
	Formal Arguments
	Variable-Length Arguments
	Functional Programming
	Variable Scope
	Recursion
	Generators
	什么是函数
	调用函数
	创建函数
	传入函数
	形参
	变长参数
	函数式编程
	变量的作用域
	递归
	生成器

　11

We were introduced to functions in Chapter 2, and we have seen
them created and called throughout the text. In this chapter, we will look beyond the basics and give you a full treatment of all the
other features associated with functions. In addition to the expected behav- ior, functions in Python support a variety of invocation styles and argument types, including some functional programming interfaces. We 

conclude this chapter with a look at Python’s scoping and take an optional side trip into the world of recursion.

在第二章，我们引入了函数，并介绍了函数的创建和调用。这一章，我们将在前面内容的基础上，详细的讲解函数的方方面面。除了预期特性之外， Python中的函数还支持多种调用方式以及参数类型并实现了一些函数式编程接口。最后我们将以对Python变量的作用域和递归函数的讨论来结束本章的学习.

1 What Are Functions?
什么是函数？

Functions are the structured or procedural programming way of organizing the logic in your programs. Large blocks of code can be neatly segregated into manageable chunks, and space is saved by putting oft-

repeated code in functions  as  opposed  to  multiple  copies  everywhere―this  also  helps  with consistency because changing the single copy means you do not have to hunt for and make changes to multiple 

copies of duplicated code. The basics of functions  in  Python  are  not  much  different  from  those  of  other  languages with which you may be familiar. After a bit of review here in the early part of this chapter, we will 

focus on what else Python brings to the table.
函数是对程序逻辑进行结构化或过程化的一种编程方法。能将整块代码巧妙地隔离成易于管理的小块，把重复代码放到函数中而不是进行大量的拷贝--这样既能节省空间，也
有助于保持一致性，因为你只需改变单个的拷贝而无须去寻找再修改大量复制代码的拷贝。Python中函数的基础部分与你熟悉的其他的语言没有什么不同.本章开始,我们先回顾一下函数基础,然后将着重介绍python函数的其他特性.


　Functions can appear in different ways . . . here is a sampling profile of how you will see functions created, used, or otherwise referenced:
函数可以以不同的形式出现。下面简单展示了一些创建、使用，或者引用函数的方法。

declaration/definition	def foo(): print 'bar'
function object/reference   foo
function call/invocation	foo()

11. Functions versus Procedures
函数vs过程

Functions are often compared to procedures. Both are entities that can be invoked, but the traditional function or “black box,” perhaps taking some or no input  parameters,  performs  some  amount  of  processing,  

and  concludes  by sending  back  a  return  value  to  the  caller.  Some  functions  are  Boolean  in nature, returning a “yes” or “no” answer, or, more appropriately, a non-zero or zero value, respectively. Procedures 

are simply special cases, functions that do not return a value. As you will see below, Python procedures are implied func- tions because the interpreter implicitly returns a default value of None.
我们经常拿函数和过程比较。两者都是可以被调用的实体，但是传统意义上的函数或者“黑盒”，可能不带任何输入参数，经过一定的处理，最后向调用者传回返回值。其中一些函数则是布尔类型的， 返回一个“是“或者“否“的回答，更确切地说，一个非零或者零值。而过程是简单，特殊，没有返回值的函数。从后面内容你会看到，python的过程就是函数，因为解释器会隐式地返回默认值None


12. Return Values and Function Types
返回值与函数类型

Functions may return a value back to their callers and those that are more procedural in nature do not explicitly return anything at all. Languages that treat procedures as functions usually have a special type or value 
name for functions that “return nothing.” These functions default to a return type of
"void" in C, meaning no value returned. In Python, the equivalent return object type is None.

函数会向调用者返回一个值, 而实际编程中大偏函数更接近过程，不显示地返回任何东西。把过程看待成函数的语言通常对于“什么都不返回”的函数设定了特殊的类型或者值的名字。这些函数在c中默认为“void"的返回类型，意思是没有值返回。 在python中， 对应的返回对象类型是none。


　The hello() function acts as a procedure in the code below, returning no value. If the return value is saved, you will see that its value is None:
　下面hello()函数的行为就像一个过程，没有返回值。如果保存了返回值，该值为None：

>>> def hello():
...	print 'hello world'
>>>
>>> res = hello()
hello world
>>> res
>>> print res
None
>>> type(res)
<type 'None'>
Also, like most other languages, you may return only one value/object from
a function in Python. One difference is that in returning a container type, it will seem as if you can actually return more than a single object. In other
words, you cannot leave the grocery store with multiple items, but you can
throw them all in a single shopping bag, which you walk out of the store with, perfectly legal.
          另外,与其他大多数的语言一样，python里的函数可以返回一个值或者对象。只是在返回一个容器对象的时候有点不同，看起来像是能返回多个对象。好比说，你不能拿着大量零散的商品离开百货店，但是你可以将它们放在一个购物袋里，然后带着这个袋子从商店走出去，合理合法。


def foo():
return ['xyz', 1000000, -98.6]

def bar():
return 'abc', [42, 'python'], "Guido"
　The foo() function returns a list, and the bar() function returns a tuple. Because of the tuple’s syntax of not requiring the enclosing parentheses, it creates the perfect illusion of returning multiple items. If we were to 

prop- erly enclose the tuple items, the definition of bar() would look like this:
    foo()函数返回一个列表，bar()函数返回一个元组。由于元组语法上不需要一定带上圆括号， 所以让人真的以为可以返回多个对象。如果我们要恰当地给这个元组加上括号， bar()的定义看起来会是这样：

def bar():
return ('abc', [4-2j, 'python'], "Guido")
　As far as return values are concerned, tuples can be saved in a number of ways. The following three ways of saving the return values are equivalent:
   从返回值的角度来考虑， 可以通过很多方式来存储元组。接下来的3种保存返回值的方式是等价的

>>> aTuple = bar()
>>> x, y, z = bar()
>>> (a, b, c) = bar()
>>>
>>> aTuple
('abc', [(4-2j), 'python'], 'Guido')
>>> x, y, z
('abc', [(4-2j), 'python'], 'Guido')
>>> (a, b, c)
('abc', [(4-2j), 'python'], 'Guido')
　In the assignments for x, y, z, and a, b, c, each variable will receive its cor- responding  return  value  in  the  order  the  values  are  returned.  The  aTuple assignment takes the entire implied tuple returned from the 
function. Recall that a tuple can be “unpacked” into individual variables or not at all and its reference assigned directly to a single variable. (Refer back to Section 6.18.3 for a review.)
   在对x,y,z和a,b,c的赋值中，根据值返回的顺序, 每个变量会接收到与之对应的返回值。而aTuple直接获得函数隐式返回的整个元组。回想一下,元组既可以被分解成为单独的变量，也可以直接用单一变量对其进行引用。（参见6.18.3）
　In short, when no items are explicitly returned or if None is returned, then Python returns None. If the function returns exactly one object, then that is the object that Python returns and the type of that object stays 
the same.  If  the  function  returns  multiple  objects,  Python  gathers  them  all together and returns them in a tuple. Yes, we claim that Python is more flexible than languages like C where only one return value is 
allowed, but in all honesty, Python follows the same tradition. The programmer is just given  the  impression  that  he  or  she  can  return  more  than  one  object.
   简而言之，当没有显式地返回元素或者如果返回None时， python会返回一个None.那么调用者接收的就是python返回的那个对象,且对象的类型仍然相同。如果函数返回多个对象，python把他们聚集起来并以一个元组返回。是的，尽管我们声称python比诸如c那样只允许一个返回值的语言灵活的多，但是老实说，python也遵循了相同的传统。只是让程序员误以为可以返回多个对象。

Table 11.1   Return Values and Types
表11.1 返回值及其类型





Stated Number
of Objects to
Return

Type of Object That
Python Returns

0	None

1	object

>1	tuple

Table 11.1 summarizes the number of items “returned” from a function, and the object that Python actually returns.
表11.1 总结了从一个函数中返回的元素的数目，以及python实际返回的对象。

　Many languages that support functions maintain the notion that a func- tion’s type is the type of its return value. In Python, no direct type correlation can be made since Python is dynamically typed and functions 
can return val- ues of different types. Because overloading is not a feature, the programmer can use the type() built-in function as a proxy for multiple declarations with different signatures (multiple prototypes of the 
same overloaded function that differ based on its arguments).
许多静态类型的语言主张一个函数的类型就是其返回值的类型。在python中， 由于python是动态地确定类型而且函数能返回不同类型的值，所以没有进行直接的类型关联。因为重载并不是语言特性，程序员需要使用type()这个内建函数作为代理，来处理有着不同参数类型的函数的多重声明以模拟类C语言的函数重载(以参数不同选择函数的多个原型)。

11.2  Calling Functions
调用函数
1. Function Operator
函数操作符

Functions are called using the same pair of parentheses that you are used to.In fact, some consider ( ( ) ) to be a two-character operator, the function operator.  As  you  are  probably  aware,  any  input  parameters  or  arguments must be placed between these calling parentheses. Parentheses are also used as part of function declarations to define those arguments. Although we have yet to formally study classes and object-oriented programming, you will dis- cover that the function operator is also used in Python for class instantiation.
同大多数语言相同，我们用一对圆括号调用函数。实际上，有些人认为(())是一个双字符操作符。正如你可能意识到的，任何输入的参数都必须放置在括号中。作为函数声明的一部分，括号也会用来定义那些参数。虽然我们没有正式地学习类和面向对象编程，但你将会发现在python中，函数的操作符同样用于类的实例化。



2. Keyword Arguments
关键字参数

The concept of keyword arguments applies only to function invocation. The idea here is for the caller to identify the arguments by parameter name in a function call. This specification allows for arguments to be missing 

or out-of- order because the interpreter is able to use the provided keywords to match values to parameters.

关键字参数的概念仅仅针对函数的调用。这种理念是让调用者通过函数调用中的参数名字来区分参数。这样规范允许参数缺失或者不按顺序,因为解释器能通过给出的关键字来匹配参数的值。


For a simple example, imagine a function foo(), which has the following
pseudocode definition:
  举个简单的例子,比如有一个函数 foo(),伪代码如下:

def foo(x):
foo_suite # presumably does some processing with 'x'

Standard calls to foo():	foo(42)	foo('bar')	foo(y)
Keyword calls to foo():	foo(x=42)	foo(x='bar') foo(x=y)
标准调用 foo():foo(42)	foo('bar')	foo(y)
关键字调用foo():foo(x=42)	foo(x='bar') foo(x=y)
For  a  more  realistic  example,  let  us  assume  you  have  a  function  called
net_conn() and you know that it takes two parameters, say, host and port:
再举个更实际的例子, 假设你有一个函数叫做net_conn(),需要两个参数host和port:
 
   

def net_conn(host, port):
net_conn_suite
　Naturally, we can call the function, giving the proper arguments in the correct positional order in which they were declared:
　只要按照函数声明中参数定义的顺序，输入恰当的参数，自然就可以调用这个函数:
　
net_conn('kappa', 8080)
　The host parameter gets the string 'kappa' and port gets integer 8080. Keyword arguments allow out-of-order parameters, but you must provide the name of the parameter as a “keyword” to have your arguments 

match up to their corresponding argument names, as in the following:
　host参数得到字符串'kappa',port参数得到整数8080.当然也可以不按照函数声明中的参数顺序输入，但是要输入相应的参数名,如下例:
　
net_conn(port=8080, host='chino')
Keyword arguments may also be used when arguments are allowed to be
“missing.” These are related to functions that have default arguments, which we will introduce in the next section.
  当参数允许"缺失“的时候，也可以使用关键字参数.这取决于函数的默认参数, 我们将在下一小节对它进行介绍。
  


3. Default Arguments
默认参数

Default arguments are those that are declared with default values. Param- eters  that  are  not  passed  on  a  function  call  are  thus  allowed  and  are assigned the default value. We will cover default arguments more 

formally in Section 11.5.2.
默认参数就是声明了默认值的参数。因为给参数赋予了默认值，所以， 在函数调用时，不向该参数传入值也是允许的。我们将在11.5.2章对默认参数进行更全面的介绍。












4. Grouped Arguments
                         参数组


Python also allows the programmer to execute a function without explicitly specifying individual arguments in the call as long as you have grouped the arguments in either a tuple (non-keyword arguments) or a 

dictionary (key- word arguments), both of which we will explore in this chapter. Basically, you can put all the arguments in either a tuple or a dictionary (or both), and just call a function with those buckets of arguments 

and not have to explicitly put them in the function call:
Python同样允许程序员执行一个没有显式定义参数的函数，相应的方法是通过一个把元组（非关键字
参数）或字典（关键字参数）作为参数组传递给函数。我们将在本章中讨论这两种形式。基本上，你可以将所有参数放进一个元组或者字典中，仅仅用这些装有参数的容器来调用一个函数，而不必显式地将它们放在函数调用中：

func(*tuple_grp_nonkw_args, **dict_grp_kw_args)

The tuple_grp_nonkw_args are the group of non-keyword arguments as a tuple, and the  dict_grp_kw_args are a dictionary of keyword argu-ments. As we already mentioned, we will cover all of these in this chapter, but just be aware of this feature that allows you to stick arguments in tuples and/or dictionaries and be able to call functions without explicitly stating each one by itself in the function call.
其中的tuple_grp_nonkw_args是以元组形式体现的非关键字参数组, dict_grp_kw_args是装有关键字参数的字典。正如我们已经提到的，我们将在这章对这两者进行全面介绍，现在你只需知道，存在这样的特性允许你把变量放在元组和/或者字典里，并在没有显式地对参数进行逐个声明的情况下，调用函数。

　In fact, you can give formal arguments, too! These include the standard positional parameters as well as keyword argument, so the full syntax allowed in Python for making a function call is:
    实际上，你也可以给出形参！这些参数包括标准的位置参数和关键字参数，所以在python中允许的函数调用的完整语法为：

func(positional_args, keyword_args,
*tuple_grp_nonkw_args, **dict_grp_kw_args)

　All arguments in this syntax are optional―everything is dependent on the individual function call as far as which parameters to pass to the function. This syntax has effectively deprecated the apply() built-in function. 
   该语法中的所有的参数都是可选的---从参数传递到函数的过程来看，在单独的函数调用时，每个参数都是独立的。这可以有效地取代apply()内建函数。(Prior to Python 1.6, such argument objects could only be passed to apply() with the function object for invocation.)(在Python 1.6版本之前，这样的参数对象只能通过apply()函数来调用)。


Example
例子

In our math game in Example 11.1 (easyMath.py), we will use the current function calling convention to generate a two-item argument list to send to the appropriate  arithmetic  function.  (We  will  also  show  where  

apply()would have come in if it had been used.)
在子11.1里的数学游戏中，我们用函数调用转换来生成一个有两个子项的参数列表，并把这个列表发送给合的适算术函数.(我们也会指出在原来版本中哪些地方会用到apply())

　The easyMath.py application is basically an arithmetic math quiz game for  children  where  an  arithmetic  operation―addition  or  subtraction―  is randomly  chosen.  We  use  the  functional  equivalents  of  

these  operators, add() and sub(), both found in the operator module. We then generate the  list  of  arguments  (two,  since  these  are  binary  operators/  operations). Then random numbers are chosen as the 

operands. Since we do not want to support negative numbers in this more elementary edition of this appli- cation,  we  sort  our  list  of  two  numbers  in  largest-to-smallest  order,  then call the corresponding function with this argument list and the randomly chosen  arithmetic  operator  to  obtain  the  correct  solution  to  the  posed problem.
easyMath.py程序是一个儿童算术游戏，可以随机选择算术加减法。我们通过函数add(),sub()等价+-运算符，这两者都可以在operator模块中找到。接着我们生成一个参数列表（该列表只有2个参数, 因为这些是二元运算符/运算）。接着选择任意的数字作为算子。因为我们没打算在这个程序的基础版本中支持负数，所以我们将两个数字的列表按从大到小的顺序排序，然后用这个参数列表和随机选择的算术运算符去调用相对应的函数，最后获得问题的正确解答。

Example 11.1  Arithmetic Game (easyMath.py)
例子11.1 算术游戏(easyMath.py)

Randomly chooses numbers and an arithmetic function, displays the question, and verifies the results. Shows answer after three wrong tries and does not continue until the user enters the correct answer.
随机选择数字以及一个算术函数, 显示问题, 以及验证结果. 在3次错误的尝试以后给出结果，等到用户输入一个正确的答案后便会继续运行.

1	#!/usr/bin/env python
2
3	from operator import add, sub
4	from random import randint, choice
5
6	ops = {'+': add, '-': sub}
7	MAXTRIES = 2
8
9	def doprob():
10	op = choice('+-')

11	nums = [randint(1,10) for i in range(2)]





17	try:
18	if int(raw_input(pr)) == ans:

19	print 'correct'


22	print 'answer\n%s%d'%(pr, ans)
23	else:
24	print 'incorrect... try again'
25	oops += 1
26	except (KeyboardInterrupt, \
27	EOFError, ValueError):
28	print 'invalid input... try again'

29


32	doprob()
33	try:
34	opt = raw_input('Again? [y]').lower()
35	if opt and opt[0] == 'n':
36	break
37	except (KeyboardInterrupt, EOFError):
38	break
39
40   if __name__ == '__main__':
41	main()
Line-by-Line Explanation
逐行解释

Lines 1C 4
Our  code  begins  with  the  usual  Unix  startup  line  followed  by  various imports of the functions that we will be using from the operator and ran- dom modules.
我们的代码从通常的unix 启动行开始，接着从operator和random模块中，导入我们会用到的函数。


Lines 6C7
The global variables we use in this application are a set of operations and their corresponding functions, and a value indicating how many times (three: 0, 1, 2) we allow the user to enter an incorrect answer before we 

reveal the solution. The function dictionary uses the operator’s symbol to index into the dictionary, pulling out the appropriate arithmetic function.
在这个应用程序中我们用的全局变量有:一个包含了运算符和与其相关联的函数的集合(字典)， 一个决定在给出正解之前，用户有多少次机会尝试给出答案的整型变量。函数字典的键值是运算符的符号，程序通过查字典找到合适的算术函数。

Lines 9C28
The doprob() function is the core engine of the application. It randomly picks  an  operation  and  generates  the  two  operands,  sorting  them  from largest-to-smallest order in order to avoid negative numbers for 
subtraction problems. It then invokes the math function with the values, calculating the correct  solution.  The  user  is  then  prompted  with  the  equation  and  given three opportunities to enter the correct answer.
doprob()函数是应用程序的核心引擎。该函数随机选择一个操作并生成两个操作数，同时为了避免减法问题中的负数问题，将这两个算子按大到下进行排序。然后用这些值调用一个数学函数，计算出正确的解。接着用一个等式来提示用户输入并给用户三次机会来输入一个正确的答案。

　Line  10  uses  the  random.choice() function.  Its  job  is  to  take  a sequence―a string of operation symbols in our case―and randomly choose one item and return it.
    第十行用了random.choice()函数。它用于获取一个序列----我们案例中运算符号的字符串--并随机返回其中的元素。

　Line 11 uses a list comprehension to randomly choose two numbers for our exercise. This example is simple enough such that we could have just called randint() twice  to  get  our  operands,  i.e.,  nums = [randint	
(1,10), randint(1,10)], but we wanted to use a list comprehension so that you could see another example of its use as well as in case we wanted to upgrade this problem to take on more than just two numbers, similar 
to the reason why instead of cutting and pasting the same piece of code, we put it into a for loop.
    第11行用了一个列表解析来随机地给我们的练习选择两个数。这个例子非常的简单以至于我们可以仅仅用两次randint()来获得我们的操作数， 比如， nums = [randint(1,10), randint(1,10)]，但是为了让你能看看列表解析的又一个例子，我们没有这样做，而且使用列表解析更易于扩展和升级，比如获得更多的数，这与我们使用循环来代替剪切和粘贴的原因相似。

Line 12 will only work in Python 2.4 and newer because that is when the reverse flag was added to the list.sort() method (as well as the new sorted() built-in function). If you are using an earlier Python version, you need to either:
第12行只能在python2.4以及更新的版本中运行,因为list.sort()方法原本不支持倒转的标志位。如果你使用的是更早一点的python版本，你要么：

?	Add an inverse comparison function to get a reverse sort, i.e.,
lambda x, y: cmp(y, x), or
?	Call nums.sort() followed by nums.reverse()
# 	增加一个反序的比较函数来获得倒转的排序，如：
lambda x, y: cmp(y, x), 或者
# 在nums.sort()后调用nums.reverse()


Don’t be afraid of lambda if you have not seen it before.  We will cover it in  this  chapter,  but  for  now,  you  can  think  of  it  as  a  one-line  anonymous function.
如果你之前没有看见过lambda，不用害怕。我们会在这章对lambda进行详述，而现在，你可以认为它是一个单行的匿名函数。

　Line 13 is where apply() would have been used if you are using Python before 1.6. This call to the appropriate operation function would have been coded as apply(ops[op], nums) instead of ops[op](*nums).
   如果你正使用1.6以前的python，那第13行是可能会用到apply()。对合适运算函数的调用要这样写apply(ops[op],nums)，而不是ops[op](*nums)

    Lines 16C28 represent the controlling loop handling valid and invalid user input. The while loop is “infinite,” running until either the correct answer is given or the number of allowed attempts is exhausted, three in our case. It allows the program to accept erroneous input such as non-numbers, or vari- ous keyboard control characters. Once the user exceeds the maximum num- ber of tries, the answer is presented, and the user is “forced” to enter the correct value, not proceeding until that has been done.
   16-28行描述了用来处理有效和无效输入的控制循环。while循环是无限循环，直到有正确答案输入或者允许尝试的次数（我们的程序中设定为3次）被耗尽才终止运行。这允许程序接受不合法的输入,比如非数字或者各种键盘的控制字符。一旦用户超过了尝试最大的次数，程序就会给出答案并“强制“用户给出正确的答案，只有给出答案，程序才会向下进行。

Lines 30C41
   The main driver of the application is main(), called from the top level if the script is invoked directly. If imported, the importing function either manages the  execution  by  calling  doprob(),  or  calls  main() for  program 
control. main() simply calls doprob() to engage the user in the main functionality of the script and prompts the user to quit or to try another problem.
程序的主入口是main()，如果直接运行脚本，程序将自顶向下的运行。如果被作为模块导入，导入者要么调用doprob()函数来开始执行，要么调用main()来进入程序控制。main()简单地调用doprob()使用户与脚本的主要功能进行交互, 并负责提示用户退出或者尝试下一个问题。

　Since  the  values  and  operators  are  chosen  randomly,  each  execution  of easyMath.py should be different. Here is what we got today (oh, and your answers may vary as well!):
    因为数值和运算符都是随机选择的，每次运行easyMath.py的结果应该都是不一样的。这是我们今天的得到的（噢，你的答案也可能不一样!!!!):

$ easyMath.py
7 - 2 = 5 correct Again? [y]
7 * 6 = 42 correct Again? [y]
7 * 3 = 20
incorrect... try again
7 * 3 = 22
incorrect... try again
7 * 3 = 23
sorry... the answer is
7 * 3 = 21
7 * 3 = 21 correct Again? [y]
7 - 5 = 2 correct Again? [y] n


11.3  Creating Functions
创建函数
1. def Statement
def语句

Functions are created using the def statement, with a syntax like the following:
函数是用def语句来创建的，语法如下：

def function_name(arguments):
"function_documentation_string"
function_body_suite

The header line consists of the def keyword, the function name, and a set of arguments (if any). The remainder of the def clause consists of an optional but  highly  recommended  documentation  string  and  the  required  function body suite. We have seen many function declarations throughout this text, and here is another:
标题行由def关键字，函数的名字，以及参数的集合（如果有的话）组成。def子句的剩余部分包括了一个虽然可选但是强烈推荐的文档字串，和必需的函数体。在本书中我们已经看到很多函数的声明，这又是一个：

def helloSomeone(who):
'returns a salutory string customized with the input'
return "Hello " + str(who)


2. Declaration versus Definition
声明与定义比较

    Some  programming  languages  differentiate  between  function  declarations and  function  definitions.  A  function  declaration  consists  of  providing  the parser with the function name, and the names (and 
traditionally the types) of its arguments, without necessarily giving any lines of code for the function, which is usually referred to as the function definition.
    在某些编程语言里, 函数声明和函数定义区分开的。一个函数声明包括提供对函数名，参数的名字（传统上还有参数的类型），但不必给出函数的任何代码，具体的代码通常属于函数定义的范畴。
　In languages where there is a distinction, it is usually because the function definition may belong in a physically different location in the code from the function declaration. Python does not make a distinction 
between the two, as a function clause is made up of a declarative header line immediately followed by its defining suite.
   在声明和定义有区别的语言中，往往是因为函数的定义可能和其声明放在不同的文件中。python将这两者视为一体，函数的子句由声明的标题行以及随后的定义体组成的。


11.3.3  Forward References
前向引用

Like some other high-level languages, Python does not permit you to reference or call a function before it has been declared. We can try a few examples to illustrate this:
和其他高级语言类似,Python也不允许在函数未声明之前,对其进行引用或者调用.
我们下面给出几个例子来看一下:


def foo():
print 'in foo()'
bar()



If we were to call foo() here, it would fail because bar() has not been
declared yet:
   如果我们调用函数foo(),肯定会失败,因为函数bar()还没有声明:

>>> foo()
in foo()
Traceback (innermost last): File "<stdin>", line 1, in ?
File "<stdin>", line 3, in foo
NameError: bar
We will now define bar(), placing its declaration before foo()’s declaration:
我们现在定义函数bar(),在函数foo()前给出bar()的声明:

def bar():
print 'in bar()'

def foo():
print 'in foo()'
bar()
Now we can safely call foo() with no problems:
现在我们可以安全的调用foo(),而不会出现任何问题:

>>> foo() in foo() in bar()
In fact, we can even declare foo() before bar():
事实上,我们甚至可以在函数bar()前定义函数foo():

def foo():
print 'in foo()'
bar()

def bar():
print 'in bar()'
　Amazingly enough, this code still works fine with no forward referencing problems:
　太神奇了,这段代码可以非常好的运行,不会有前向引用的问题:

>>> foo() 
in foo() in bar()

　This  piece  of  code  is  fine  because  even  though  a  call  to  bar() (from foo()) appears before bar()’s definition, foo() itself is not called before bar() is declared. In other words, we declared  foo(), then bar(), and 
then called foo(), but by that time, bar() existed already, so the call suc- ceeds.
    这段代码是正确的因为即使（在foo()中）对bar()进行的调用出现在bar()的定义之前，但foo()本身不是在bar()声明之前被调用的。换句话说，我们声明foo()，然后再声明bar()，接着调用foo()，但是到那时，bar()已经存在了，所以调用成功。

　Notice that the output of foo() succeeded before the error came about. NameError is the exception that is always raised when any uninitialized iden- tifiers are accessed.
注意foo()在没有错误的情况下成功输出了'in foo()'。名字错误是当访问没有初始化的标识符时才产生的异常
　
3. Function Attributes
函数属性

    We will briefly discuss namespaces later on in this chapter, especially their relationship to variable scope. There will be a more in-depth treatment of namespaces in the next chapter; however, here we want to point out a basic feature of Python namespaces.
    在这一章中，我们稍后将对命名空间进行简短的讨论，尤其是它们与变量作用域的关系。在下一章中会有对命名空间的更深入的探讨，然而，这里我们只是想要指出python名字空间的基本特征。

　You get a free one with every Python module, class, and function. You can have a variable named x in modules foo and bar, but can use them in your current application upon importing both modules. So even 
though the same variable  name  is  used  in  both  modules,  you  are  safe  because  the  dotted attribute  notation  implies  a  separate  namespace  for  both,  i.e.,  there  is  no naming conflict in this snippet of 
code:
    你可以获得每个pyhon模块，类，和函数中任意的名字空间。你可以在模块foo和bar里都有名为x的一个变量,，但是在将这两个模块导入你的程序后，仍然可以使用这两个变量。所以，即使在两个模块中使用了相同的变量名字，这也是安全的，因为句点属性标识对于两个模块意味了不同的命名空间，比如说，在这段代码中没有名字冲突：

import foo, bar
print foo.x + bar.x

　Function attributes are another area of Python to use the dotted-attribute notation and have a namespace. (More on namespaces later on in this chapter as well as Chapter 12 on Python modules.)
    函数属性是python另外一个使用了句点属性标识并拥有名字空间的领域。(更多关于名字空间将在本章的稍后部分以及第12章关于python的模块中进行讨论）

def foo():
'foo() -- properly created doc string'

def bar():
pass

bar.__doc__ = 'Oops, forgot the doc str above'
bar.version = 0.1

　In foo() above, we create our documentation string as normal, e.g., the first unassigned string after the function declaration. When declaring bar(), we left everything out and just used the dotted-attribute notation to 
add its doc  string  as  well  as  another  attribute.  We  can  then  access  the  attributes freely.  Below  is  an  example  with  the  interactive  interpreter.  (As  you  may already be aware, using the built-in function 
help() gives more of a pretty- printing format than just using the vanilla print of the __doc__ attribute, but you can use either one you wish.)
   上面的foo()中，我们以常规地方式创建了我们的文档字串，比如， 在函数声明后第一个没有赋值的字串。当声明bar()时，我们什么都没做，仅用了句点属性标识来增加文档字串以及其他属性。我们可以接着任意地访问属性。下面是一个使用了交互解释器的例子。（你可能已经发现，用内建函数help()显示会比用__doc__属性更漂亮，但是你可以选择你喜欢的方式）

>>> help(foo)
Help on function foo in module __main__:

foo()
foo() -- properly created doc string
>>> print bar.version

0.1

>>> print foo.__doc__
foo() -- properly created doc string
>>> print bar.__doc__
Oops, forgot the doc str above

　Notice how we can define the documentation string outside of the function declaration. Yet we can still access it at runtime just like normal. One thing that you cannot do, however, is get access to the attributes in 
the function declaration.In other words, there is no such thing as a “self” inside a function declaration so that you can make an assignment like __dict__['version'] = 0.1. The rea- son for this is because the function object has not even been created yet, but afterward you have the function object and can add to its dictionary in the way we described above . . . another free namespace!
   注意我们是如何在函数声明外定义一个文档字串。然而我们仍然可以就像平常一样，在运行时刻访问它。然而你不能在函数的声明中访问属性。换句话说，在函数声明中没有'self‘这样的东西让你可以进行诸如__dict__['version'] = 0.1的赋值。这是因为函数体还没有被创建，但之后你有了函数对象，就可以按我们在上面描述的那样方法来访问它的字典。另外一个自由的名字空间！

　Function attributes were added to Python in 2.1, and you can read more about them in PEP 232.
    函数属性是在2.1中添加到python中的，你可以在PEP232中阅读到更多相关信息。

4. Inner or Nested Functions
内部/内嵌函数
    It is perfectly legitimate to create function (object)s inside other functions. That  is  the  definition  of  an  inner  or  nested  function.  Because  Python  now supports statically nested scoping (introduced in 2.1 but 
standard as of 2.2), inner functions are actually useful now. It made no sense for older versions of Python, which only supported the global and one local scope. So how does one create a nested function?
    在函数体内创建另外一个函数（对象）是完全合法的。这种函数叫做内部/内嵌函数。因为现在python支持静态地嵌套域（在2.1中引入但是到2.2时才是标准），内部函数实际上很有用的。内嵌函数对于较老的python版本没有什么意义，那些版本中只支持全局和一个局部域。那么如何去创造一个内嵌函数呢？
　The (obvious) way to create an inner function is to define a function from within an outer function’s definition (using the def keyword), as in:
    最明显的创造内部函数的方法是在外部函数的定义体内定义函数（用def关键字），如在：
def foo():
def bar():
print 'bar() called'

print 'foo() called'
bar()

foo()
bar()
　If we stick this code in a module, say inner.py, and run it, we get the fol- lowing output:
    我们将以上代码置入一个模块中，如inner.py，然后运行，我们会得到如下输出：
                               
foo() called bar() called
Traceback (most recent call last): File "inner.py", line 11, in ?
bar()
NameError: name 'bar' is not defined

　One interesting aspect of inner functions is that they are wholly contained inside the outer function’s scope (the places where you can access an object; more on scope later on in this chapter). If there are no 
outside references to bar(), it cannot be called from anywhere else except inside the outer func- tion, hence the reason for the exception you see at the end of execution in the above code snippet.
    内部函数一个有趣的方面在于整个函数体都在外部函数的作用域（即是你可以访问一个对象的区域；稍后会有更多关于作用域的介绍）之内。如果没有任何对bar()的外部引用，那么除了在函数体内，任何地方都不能对其进行调用，这就是在上述代码执行到最后你看到异常的原因

　Another way of creating a function object while inside a(nother) function is by using the lambda statement. We will cover this later on in section 11.7.1.Inner functions turn into something special called closures if the definition of  an  inner  function  contains  a  reference  to  an  object  defined  in  an  outer function. (It can even be beyond the immediately enclosing outer function too.) We will learn more about closures coming up in Section 11.8.4. In the next section, we will introduce decorators, but the example application also includes a preview of a closure.
   另外一个函数体内创建函数对象的方式是使用lambda语句。我们会在稍后的11.7.1小节进行讲述。如果内部函数的定义包含了在外部函数里定义的对象的引用（这个对象甚至可以是在外部函数之外），内部函数会变成被称为闭包（closure）的特别之物。在接下来的11.8.4小节，我们将对闭包进行更多的学习。在下一小节中，我们将介绍装饰器，但是例子程序也包含了闭包的预览。


5. *Function (and Method) Decorators
*函数（与方法）装饰器

    The main motivation behind decorators came from Python object-oriented programming (OOP). Decorators are just “overlays” on top of function calls. These overlays are just additional calls that are applied when a 
function or method is declared.
    装饰器背后的主要动机源自python面向对象编程。装饰器是在函数调用之上的修饰。这些修饰仅是当声明一个函数或者方法的时候，才会应用的额外调用。

　The syntax for decorators uses a leading “at-sign” ( @ ) followed by the dec- orator function name and optional arguments. The line following the decora- tor  declaration  is  the  function  being  decorated,  along  
with  its  optional arguments. It looks something like this:
    装饰器的语法以@开头，接着是装饰器函数的名字和可选的参数。紧跟着装饰器声明的是被修饰的函数，和装饰函数的可选参数。装饰器看起来会是这样：

@decorator(dec_opt_args)
def func2Bdecorated(func_opt_args):
:

　So how (and why) did this syntax come into being? What was the inspiration behind decorators? Well, when static and class methods were added to Python in 2.2, the idiom required to realize them was clumsy, 
confusing, and makes code less readable, i.e.,
    那么装饰器语法如何（以及为什么）产生的呢？装饰器背后的灵感是什么？唔，当静态方法和类方法在2.2时被加入到python中的时候，实现方法很笨拙：


class MyClass(object):
def staticFoo():
:
staticFoo = staticmethod(staticFoo)
:

(It  was  clearly  stated  for  that  release  that  this  was  not  the  final  syntax anyway.) Within this class declaration, we define a method named static- Foo(). Now since this is intended to become a static method, we leave out the self argument, which is required for standard class methods, as you will see in Chapter 12. The staticmethod() built-in function is then used to “convert” the function into a static method, but note how “sloppy” it looks with def staticFoo() followed by staticFoo = staticmethod (sta- ticFoo). With decorators, you can now replace that piece of code with the following:
(要澄清的是对于那个发行版本，这不是最终的语法）在这个类的声明中，我们定义了叫staticFoo()的方法。现在因为打算让它成为静态方法，我们省去它的self参数，而你会在12章中看到，self参数在标准的类方法中是必需的。接着用staticmethod()内建函数来将这个函数“转化“为静态方法，但是在def staticFoo()后跟着staticFoo = staticmethod (sta- ticFoo)显得有多么的臃肿。使用装饰器，你现在可以用如下代码替换掉上面的：

class MyClass(object):
@staticmethod
def staticFoo():
:
　Furthermore, decorators can be “stacked” like function calls, so here is a more general example with multiple decorators:
    此外，装饰器可以如函数调用一样“堆叠“起来，这里有一个更加普遍的例子，使用了多个装饰器：

@deco2
@deco1
def func(arg1, arg2, ...): pass
This is equivalent to creating a composite function:
这和创建一个组合函数是等价的。

def func(arg1, arg2, ...): pass
func = deco2(deco1(func))
　Function composition in math is defined like this: (g ? f)(x) = g(f(x)). For consistency in Python:
    函数组合用数学来定义就像这样: (g ・ f)(x) = g(f(x))。对于在python中的一致性

@g
@f
def foo():
:
. . . is the same as foo = g(f(foo)).
......与foo=g(f(foo))相同


Decorators With and Without Arguments
有参数和无参数的装饰器

Yes the syntax is slightly mind-bending at first, but once you are comfortable with it, the only twist on top of that is when you use decorators with argu- ments. Without arguments, a decorator like:
是的，装饰器语法一开始有点让你犯迷糊，但是一旦你适应了，唯一会困扰你的就是什么时候使用带参数的装饰器。没有参数的情况，一个装饰器如：

@deco
def foo(): pass

. . . is pretty straightforward:
....非常的直接

foo = deco(foo)


　Function composition without arguments (as seen above) follows. How- ever, a decorator decomaker() with arguments:
    跟着是无参函数（如上面所见）组成。然而，带参数的装饰器decomaker()

@decomaker(deco_args)
def foo(): pass
　. . . needs to itself return a decorator that takes the function as an argu- ment. In other words, decomaker() does something with deco_args and returns a function object that is a decorator that takes foo as its argument. To put it simply:
         需要自己返回以函数作为参数的装饰器。换句话说，decomaker()用deco_args做了些事并返回函数对象，而该函数对象正是以foo作为其参数的装饰器。简单的说来：

foo = decomaker(deco_args)(foo)
　Here is an example featuring multiple decorators in which one takes an argument:
   这里有一个含有多个装饰器的例子，其中的一个装饰器带有一个参数

@deco1(deco_arg)
@deco2
def func(): pass
This is equivalent to:这等价于：

func = deco1(deco_arg)(deco2(func))
　We hope that if you understand these examples here, things will become much clearer. We present a more useful yet still simple script below where the decorator does not take an argument. Example 11.8 is an intermediate script with a decorator that does take an argument.
    我们希望如果你明白这里的这些例子，那么事情就变得更加清楚了。下面我们会给出简单实用的脚本，该脚本中装饰器不带任何参数。例子11.8就是含有无参装饰器的中间脚本。

So What Are Decorators?
那么什么是装饰器？

   We know that decorators are really functions now. We also know that they take function objects. But what will they do with those functions? Generally, when you wrap a function, you eventually call it. The nice thing is that we can do that whenever it is appropriate for our wrapper. We can run some preliminary code before executing the function or some cleanup code afterward, like post- mortem analysis. It is up to the programmer.  So when you see a decorator function,  be  prepared  to  find  some  code  in  it,  and  somewhere  embedded within its definition, a call or at least some reference, to the target function. This feature essentially introduces the concept that Java developers call AOP, or aspect-oriented programming. You can place code in your decorators for con- cerns that cut across your application. For example, you can use decorators to:
现在我们知道装饰器实际就是函数。我们也知道他们接受函数对象。但它们是怎样处理那些函数的呢？一般说来，当你包装一个函数的时候，你最终会调用它。最棒的是我们能在包装的环境下在合适的时机调用它。我们在执行函数之前，可以运行些预备代码，如post-morrem分析,也可以在执行代码之后做些清理工作。所以当你看见一个装饰器函数的时候，很可能在里面找到这样一些代码，它定义了某个函数并在定义内的某处嵌入了对目标函数的调用或者至少一些引用。从本质上看，这些特征引入了java开发者称呼之为AOP（Aspect Oriented Programming，面向方面编程）的概念。你可以考虑在装饰器中置入通用功能的代码来降低程序复杂度。例如，可以用装饰器来：
?	Introduce logging
?	Insert timing logic (aka instrumentation) for monitoring performance
?	Add transactional capabilities to functions
#	引入日志
#	增加计时逻辑来检测性能
#	给函数加入事务的能力


The ability to support decorators is very important for creating enterprise applications in Python. You will see that the bullet points above correspond quite closely to our example below as well as Example 11.2.
对于用python创建企业级应用，支持装饰器的特性是非常重要的。你将会看到上面的条例与我们下面的例子有非常紧密地联系，这在例11.2中也得到了很好地体现。

Decorator Example
修饰符举例

We have an extremely simple example below, but it should get you started in really understanding how decorators work. This example “decorates” a (use- less) function by displaying the time that it was executed. It is a “timestamp decoration” similar to the timestamp server that we discuss in Chapter 16.
下面我们有个极其简单的例子，但是它应该能让你开始真正地了解装饰器是如何工作的。这个例子通过显示函数执行的时间"装饰"了一个（没有用的）函数。这是一个"时戳装饰"，与我们在16章讨论的时戳服务器非常相似。


Example 11.2   Example of Using a Function Decorator (deco.py)
例子11.2 使用函数装饰器的例子(deco.py)

This demonstration of a decorator (and closures) shows that it is merely a
“wrapper” with which to “decorate” (or overlay) a function, returning the altered function object and reassigning it to the original identifier, forever losing access to the original function object.
这个装饰器（以及闭包）示范表明装饰器仅仅是用来“装饰“（或者修饰）函数的包装，返回一个修改后的函数对象，将其重新赋值原来的标识符，并永久失去对原始函数对象的访问。

1	#!/usr/bin/env python
2

3	from time import ctime, sleep



7	print '[%s] %s() called' % (
8	ctime(), func.__name__)
9	return func()
10	return wrappedFunc
11
12   @tsfunc
13   def foo():
14	pass
15
16   foo()
17   sleep(4)
18
19   for i in range(2):
20	sleep(1)
21	foo()



Running this script, we get the following output:
运行脚本，我们得到如下输出：

[Sun Mar 19 22:50:28 2006] foo() called
[Sun Mar 19 22:50:33 2006] foo() called
[Sun Mar 19 22:50:34 2006] foo() called
Line-by-Line Explanation
逐行解释

Lines 5C10
Following the startup and module import lines, the tsfunc() function is a decorator that displays a timestamp (to standard output) of when a function is  called.  It  defines  an  inner  function  wrappedFunc(),  which  adds  the timestamp and calls the target function. The return value of the decorator is the “wrapped” function.
5-10行
在启动和模块导入代码之后， tsfunc()函数是一个显示何时调用函数的时戳的装饰器。它定义了一个内部的函数wrappedFunc()，该函数增加了时戳以及调用了目标函数。装饰器的返回值是一个“包装了“的函数。


Lines 12C21
   We define function foo() with an empty body (which does nothing) and deco- rate it with tsfunc(). We then call it once as a proof-of-concept, wait four seconds, then call it twice more, pausing one second before each invocation.
   我们用空函数体（什么都不做）来定义了foo()函数并用tsfunc()来装饰。为证明我们的设想，立刻调用它，然后等待四秒，然后再调用两次，并在每次调用前暂停一秒。

　As a result, after it has been called once, the second time it is called should be five (4 + 1) seconds after the first call, and the third time around should only be one second after that. This corresponds perfectly to the program out- put seen above.
   结果，函数立刻被调用，第一次调用后，调用函数的第二个时间点应该为5（4+1），第三次的时间应该大约为之后的1秒。这与上面看见的函数输出十分吻合。
　
　You can read more about decorators in the Python Language Reference, the “What’s New in Python 2.4” document, and the defining PEP 318.
    你可以在python langugae reference, python2.4中“What’s New in Python 2.4”的文档以及PEP 318中来阅读更多关于装饰器的内容。


3 Passing Functions
传递函数

The concept of function pointers is an advanced topic when learning a language such as C, but not Python where functions are like any other object. They can be referenced (accessed or aliased to other variables), passed as arguments to functions, be elements of container objects such as lists and dictionaries, etc. 

当学习一门如C的语言时，函数指针的概念是一个高级话题，但是对于函数就像其他对象的python来说就不是那么回事了.函数是可以被引用的（访问或者以其他变量作为其别名），也作为参数传入函数，以及作为列表和字典等等容器对象的元素


The one unique characteristic of functions which may set them apart from other objects is that they are callable, 
函数有一个独一无二的特征使它同其他对象区分开来，那就是函数是可调用的。

i.e., they can be invoked via the function opera- tor. (There are other callables in Python. For more information, see Chapter 14.) In the description above, we noted that functions can be aliases to other variables. 
举例来说，可以通过函数操作来调用他们。（在python中有其他的可调用对象。更多信息，参见14章）在以上的描述中，我们注意到可以用其他的变量来做作为函数的别名

Because all objects are passed by reference, functions are no dif- ferent. When assigning to another variable, you are assigning the reference to the same object; and if that object is a function, then all aliases to that same object are callable:
因为所有的对象都是通过引用来传递的，函数也不例外。当对一个变量赋值时，实际是将相同对象的引用赋值给这个变量。如果对象是函数的话，这个对象所有的别名都是可调用的。

>>> def foo():
...	print 'in foo()'
...
>>> bar = foo
>>> bar()
in foo()


When we assigned foo to bar, we are assigning the same function object to bar, thus we can invoke bar() in the same way we call foo(). Be sure you  understand  the  difference  between  “foo”  (reference  of  the  function object) and “foo()” (invocation of the function object).
当我们把foo赋值给bar时，bar和foo引用了同一个函数对象，所以能以和调用foo()相同的方式来调用bar()。确定你明白"foo"(函数对象的引用）和"foo()"（函数对象的调用）的区别。

Taking our reference example a bit further, we can even pass functions in as arguments to other functions for invocation:
稍微深入下我们引用的例子，我们甚至可以把函数作为参数传入其他函数来进行调用。

>>> def bar(argfunc):
...	argfunc()
...
>>> bar(foo)
in foo()
　Note  that  it  is  the  function  object  foo that  is  being  passed  to  bar(). bar() is the function that actually calls foo() (which has been aliased to the local variable argfunc in the same way that we assigned foo to bar in the previous example). Now let us examine a more realistic example, numconv.py, whose code is given in Example 11.3.
    注意到函数对象foo被传入到bar()中。bar()调用了foo()(用局部变量argfunc来作为其别名就如同在前面的例子中我们把foo赋给bar一样）。现在我们来研究下一个更加实际的例子，numconv.py，代码在例子11.3中给出

Example 11.3   Passing and Calling (Built-in) Functions
例11.3 传递和调用(内建）函数
(numConv.py)

A more realistic example of passing functions as arguments and invoking them from within the function. This script 
simply converts a sequence of numbers to the same type using the conversion function that is passed in. In particular, the test() function passes in a built-in function int(), long(), or float() to perform the conversion.
一个将函数作为参数传递，并在函数体内调用这些函数，更加实际的例子。这个脚本用传入的转换函数简单将一个序列的数转化为相同的类型。特别地，test()函数传入一个内建函数int(), long(), 或者float()来执行转换。

1	#!/usr/bin/env python
2
3	def convert(func, seq):
4	'conv. sequence of numbers to same type'
5	return [func(eachNum) for eachNum in seq]
6
7	myseq = (123, 45.67, -6.2e8, 999999999L)
8	print convert(int, myseq)
9	print convert(long, myseq)
10   print convert(float, myseq)


If we were to run this program, we would get the following output:
如果我们运行这个程序，我们将会得到如下输出：

$ numconv.py
[123, 45, -620000000, 999999999]
[123L, 45L, -620000000L, 999999999L]
[123.0, 45.67, -620000000.0, 999999999.0]
11.5  Formal Arguments


A Python function’s set of formal arguments consists of all parameters passed to the function on invocation for which there is an exact correspondence to those  of  the  argument  list  in  the  function  declaration.  These  arguments include all required arguments (passed to the function in correct 
positional order), keyword arguments (passed in or out of order, but which have key- words present to match their values to their proper positions in the argument list), and all arguments that have default values that may or may not be part
of the function call. For all of these cases, a name is created for that value in the (newly created) local namespace and it can be accessed as soon as the function begins execution.
python函数的形参集合由在调用时要传入函数的所有参数组成，这参数与函数声明中的参数列表精确的配对。这些参数包括了所有必要参数(以正确的定位顺序来传入函数的），关键字参数（以顺序或者不按顺序传入，但是带有参数列表中曾定义过的关键字），以及所有含有默认值，函数调用时不必要指定的参数。（声明函数时创建的）局部命名空间为各个参数值，创建了一个名字。一旦函数开始执行，即能访问这个名字。


11.5.1  Positional Arguments
11.5.1 位置参数

These are the standard vanilla parameters that we are all familiar with. Posi- tional arguments must be passed in the exact order in which they are defined for the functions that are called. Also, without the presence of 
any default arguments  (see  next  section),  the  exact  number  of  arguments  passed  to  a function (call) must be exactly the number declared:
这些我们都是熟悉的标准化参数。位置参数必须以在被调用函数中定义的准确顺序来传递。另外，没有任何默认参数（见下一个部分）的话，传入函数（调用）的参数的精确的数目必须和声明的数字一致。

>>> def foo(who):	# defined for only 1 argument
...	print 'Hello', who
...
>>> foo()	# 0 arguments... BAD Traceback (innermost last):
File "<stdin>", line 1, in ?
TypeError: not enough arguments; expected 1, got 0
>>>
>>> foo('World!')	# 1 argument... WORKS Hello World!
>>>
>>> foo('Mr.', 'World!')# 2 arguments... BAD Traceback (innermost last):
File "<stdin>", line 1, in ?
TypeError: too many arguments; expected 1, got 2

The foo() function has one positional argument. That means that any call to foo() must have exactly one argument, no more, no less. You will become extremely  familiar  with  TypeError otherwise.  Note  how  informative  the Python errors are. As a general rule, all positional arguments for a function must be provided whenever you call it. They may be passed into the function call in position or out of position, granted that a keyword argument is provided to match it to its proper position in the argument list (review Section 11.2.2). 
foo()函数有一个位置参数。那意味着任何对foo()的调用必须有唯一的一个参数，不多，不少。否则你会频频看到TypeError。看看，python的错误是多么具有信息性的。作为一个普遍的规则，无论何时调用函数，都必须提供函数的所有位置参数。可以不按位置地将关键字参数传入函数，给出关键字来匹配其在参数列表中的合适的位置是被准予的(可以回顾11.2.2小节）

Default arguments, however, do not have to be provided because of their nature.
由于默认参数的特质，他们是函数调用的可选部分。


2. Default Arguments
默认参数

Default arguments are parameters that are defined to have a default value if one is not provided in the function call for that argument. Such definitions are given in the function declaration header line. C++ supports default argu- ments too and has the same syntax as Python: the argument name is followed by an “assignment” of its default value. This assignment is merely a syntacti- cal way of indicating that this assignment will occur if no value is passed in for that argument.
对于默认参数如果在函数调用时没有为参数提供值则使用预先定义的的默认值。这些定义在函数声明的标题行中给出。c++也支持默认参数，和python有同样的语法：参数名等号默认值。这个从句法上来表明如果没有值传递给那个参数，那么这个参数将取默认值。
　The  syntax  for  declaring  variables  with  default  values  in  Python  is  such that all positional arguments must come before any default arguments:
    python中用默认值声明变量的语法是所有的位置参数必须出现在任何一个默认参数之前。
def func(posargs, defarg1=dval1, defarg2=dval2,...):
"function_documentation_string"
function_body_suite

　Each  default  argument  is  followed  by  an  assignment  statement  of  its default value. If no value is given during a function call, then this assignment is realized.
    每个默认参数都紧跟着一个用默认值的赋值语句。如果在函数调用时没有给出值，那么这个赋值就会实现。


Why Default Arguments?
为什么用默认参数？

Default  arguments  add  a  wonderful  level  of  robustness  to  applications because  they  allow  for  some  flexibility  that  is  not  offered  by  the  standard positional parameters. That gift comes in the form of 
simplicity for the appli- cations programmer. Life is not as complicated when there are a fewer num- ber of parameters that one needs to worry about. This is especially helpful when one is new to an API interface and 
does not have enough knowledge to provide more targeted values as arguments.
默认参数让程序的健壮性上升到极高的级别，因为它们补充了标准位置参数没有提供的一些灵活性。这种简洁极大的帮助了程序员。当少几个需要操心的参数时候，生活不再那么复杂。这在一个程序员刚接触到一个API接口时，没有足够的知识来给参数提供更对口的值时显得尤为有帮助。
　The  concept  of  using  default  arguments  is  analogous  to  the  process  of installing  software  on  your  computer.  How  often  does  one  choose  the “default  install”  over  the  “custom  install?”  I  would  say  probably  almost always. It is a matter of convenience and know-how, not to mention a time- saver.  And  if  you  are  one  of  those  gurus  who  always  chooses  the  custom install, please keep in mind that you are one of the minority.
   使用默认参数的概念与在你的电脑上安装软件的过程类似。一个人会有多少次选择默认安装而不是自定义安装？我可以说可能几乎都是默认安装。这既方便，易于操作，又能节省时间。如果你是那些总是选择自定义安装的顽固分子，请记着你只是少数人之一

　Another advantage goes to the developers, who are given more control over the software they create for their consumers. When providing default values, they can selectively choose the “best” default value possible, thereby hoping to give the user some freedom of not having to make that choice. Over time, as the users becomes more familiar with the system or API, they may eventu- ally be able to provide their own parameter values, no longer requiring the use of “training wheels.”
另外一个让开发者受益的地方在于，使开发者更好地控制为顾客开发的软件。当提供了默认值的时候，他们可以精心选择“最佳“的默认值，所以用户不需要马上面对繁琐的选项。随着时间流逝，当用户对系统或者api越来越熟悉的时候，他们最终能自行给出参数值，便不再需要使用“学步车“了

　Here is one example where a default argument comes in handy and has some usefulness in the growing electronic commerce industry:
    下面这个例子中默认参数派得上用场，并在日益增长的电子商务中多少有些用处

>>> def
taxMe(cost,
rate=0.0825):
...
return cost
+ (cost * rate)
...


>>> taxMe(100)
108.25
>>>
>>> taxMe(100, 0.05)
105.0
　In the example above, the taxMe() function takes the cost of an item and produces  a  total  sale  amount  with  sales  tax  added.  The  cost  is  a  required parameter while the tax rate is a default argument (in our example, 8.25%). Perhaps you are an online retail merchant, with most of your customers com- ing from the same state or county as your business. Consumers from locations with different tax rates would like to see 
their purchase totals with their corre- sponding sales tax rates. To override the default, all you have to do is provide your argument value, such as the case with taxMe(100, 0.05) in the above example. By specifying a 
rate of 5%, you provided an argument as the rate parameter, thereby overriding or bypassing its default value of 0.0825.
    在上面个例子中，taxMe()函数以一个项目的成本输入参数，计算出附加了销售税的销售价格。成本是一个必需的参数，但税率是一个默认参数（在我们的例子中为8.25%）。或许你是一个在线零售商，生意上的大部分客户来自相同的州或者国家。不同地方税率的顾客期望看见他们与当地销售税率相对应的购买价格总量。为了覆盖默认的税率，你所要做的就是提供一个参数值，比如在上面的例子中的taxMe(100,0.05)。通过指定5%税率，你提供了一个参数作为税率参数，所以覆盖或者说绕过了0.0825的默认值。

　All  required  parameters  must  be  placed  before  any  default  arguments. Why?  Simply  because  they  are  mandatory,  whereas  default  arguments  are not. Syntactically, it would be impossible for the 
interpreter to decide which values match which arguments if mixed modes were allowed. A SyntaxError
is raised if the arguments are not given in the correct order:
   所有必需的参数都要在默认参数之前。为什么？简单说来就是因为它们是强制性的，但默认参数不是。从句法构成上看，对于解释器来说，如果允许混合模式，确定什么值来匹配什么参数是不可能的。如果没有按正确的顺序给出参数，就会产生一个语法错误。

>>> def taxMe2(rate=0.0825, cost):
...	return cost * (1.0 + rate)
...
SyntaxError: non-default argument follows default argument

Let  us  take  a  look  at  keyword  arguments  again,  using  our  old  friend
net_conn().
让我们再看下关键字参数，用我们的老朋友net_conn()

def net_conn(host, port):
net_conn_suite



As  you  will  recall,  this  is  where  you  can  provide  your  arguments  out  of
order (positionally) if you name the arguments. With the above declarations, we can make the following (regular) positional or keyword argument calls:
读者应该还记得，如果命名了参数，这里可以不按顺序给出参数。由于有了上述声明，我们可以做出如下（规则的）位置或者关键字参数调用：

? net_conn('kappa', 8000)
? net_conn(port=8080, host='chino')
　However, if we bring default arguments into the equation, things change, although  the  above  calls  are  still  valid.  Let  us  modify  the  declaration  of net_conn() such that the port parameter has a default value of 
80 and add another  argument  named  stype (for  server  type)  with  a  default  value  of
'tcp':
   然而，如果我们将默认参数引入这个等式，情况就会不同，虽然上面的调用仍然有效。让我们修改下net_conn()的声明以使端口参数有默认值80，再增加另外的名为stype(服务器的类型)默认值为‘tcp‘的参数：

def net_conn(host, port=80, stype='tcp'):
net_conn_suite
　We have just expanded the number of ways we can call net_conn(). The following are all valid calls to net_conn():
    我们已经扩展了调用net_conn()的方式。以下就是所有对net_conn()有效的调用

? net_conn('phaze', 8000, 'udp')	# no def args used
? net_conn('kappa')	# both def args used
? net_conn('chino', stype='icmp')	# use port def arg
? net_conn(stype='udp', host='solo') # use port def arg
? net_conn('deli', 8080)	# use stype def arg
? net_conn(port=81, host='chino')	# use stype def arg
　What is the one constant we see in all of the above examples? The sole required  parameter,  host.  There  is  no  default  value  for  host,  thus  it  is expected in all calls to net_conn().Keyword arguments prove useful for providing for out-of-order positional arguments,  but,  coupled  with  default  arguments,  they  can  also  be  used  to
“skip over” missing arguments as well, as evidenced from our examples above.
在上面所有的例子中，我们发现什么是一直不变的？唯一的必须参数，host。host没有默认值，所以他必须出现在所有对net_conn()的调用中。关键字参数已经被证明能给不按顺序的位置参数提供参数，结合默认参数，它们同样也能被用于跳过缺失参数，上面例子就是极好的证据。

Default Function Object Argument Example
默认函数对象参数举例

We will now present yet another example of where a default argument may prove beneficial. The grabWeb.py script, given in Example 11.4, is a simple script whose main purpose is to grab a Web page from the 
Internet and tem- porarily store it to a local file for analysis. This type of application can be used to test the integrity of a Web site’s pages or to monitor the load on a server (by measuring connectability or download speed). The process() function can be anything we want, presenting an infinite number of uses. The one we chose  for  this  exercise  displays  the  first  and  last  non-blank lines  of  the retrieved Web page. Although this particular example may not prove too useful in the real world, you can imagine what kinds of applications you can build on top of this code.
我们现在将给出另外一个证明默认参数会让人受益的例子。grabWeb.py脚本，在例子11.4中给出，是一个主要目的是从互联网上抓取一个Web页面并暂时储存到一个本地文件中用于分析的简单脚本。这类程序能用来测试web站点页面的完整性或者能监测一个服务器的负载（通过测量可链接性或者下载速度）。process（）函数可以做我们想要的任何事，表现出了无限种的用途。我们为这个练习选择的用法是显示从web页面上获得的第一和最后的非空格行。虽然在现实中这个特别的例子或许没有多少用处，但是你可以以这段代码为基础，举一反三。

Example 11.4   Grabbing Web Pages (grabWeb.py)
例子 抓取网页

This script downloads a Web page (defaults to local www server) and displays the first and last non-blank lines of the HTML file. Flexibility is added due to both default arguments of the download() function, which will 
allow overriding with different URLs or specification of a different processing function.
这段脚本下载了一个web页面（默认为本地的www服务器）并显示了html文件的第一个以及最后一个非空格行。由于download()函数的双默认参数允许用不同的urls或者指定不同的处理函数来进行覆盖，灵活性得倒了提高。

1	#!/usr/bin/env python
2
3	from urllib import urlretrieve

4


7	if not eachLine.strip():
8	continue
9	else:

10	return eachLine










21	process=firstLast):
22	try:
23	retval = urlretrieve(url)[0]
24	except IOError:
25	retval = None
26	if retval:	# do some processing
27	process(retval)
28
29   if __name__ == '__main__':
30	download()




Running  this  script  in  our  environment  gives  the  following  output,
although your mileage will definitely vary since you will be viewing a com- pletely different Web page altogether.
在我们的环境下运行这个脚本会得到如下的输出，虽然你的内容是绝对不同的，因为你将浏览一个完全不同的网页。


$ grabWeb.py
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
</HTML>



6 Variable-Length Arguments
可变长度的参数

There  may  be  situations  where  your  function  is  required  to  process  an unknown number of arguments. These are called variable-length argument lists. Variable-length arguments are not named explicitly in 

function declara- tions  because  the  number  of  arguments  is  unknown  before  runtime  (and even during execution, the number of arguments may be different on succes- sive  calls),  an  obvious  difference  from  

formal  arguments  (positional  and default), which are named in function declarations. Python supports variable- length arguments in two ways because function calls provide for both key- word and non-keyword 

argument types.
可能会有需要用函数处理可变数量参数的情况。这时可使用可变长度的参数列表。变长的参数在函数声明中不是显式命名的，因为参数的数目在运行时之前是未知的（甚至在运行的期间，每次函数调用的参数的数目也可能是不同的），这和常规参数（位置和默认）明显不同，常规参数都是在函数声明中命名的。由于函数调用提供了关键字以及非关键字两种参数类型，python用两种方法来支持变长参数，
In Section 11.2.4, we looked at how you can use the * and ** characters
in function calls to specify grouped sets of arguments, non-keyword and key-
word arguments. In this section, we will see the same symbols again, but this time in function declarations, to signify the receipt of such arguments when functions are called. This syntax allows functions to accept 
more than just the declared formal arguments as defined in the function declaration.

在11.2.4小节中，我们了解了在函数调用中使用*和**符号来指定元组和字典的元素作为非关键字以及关键字参数的方法。在这个部分中，我们将再次使用相同的符号，但是这次在函数的声明中，表示在函数调用时接收这样的参数。这语法允许函数接收在函数声明中定义的形参之外的参数。


61. Non-keyword Variable Arguments (Tuple)
非关键字可变长参数（元组）

When a function is invoked, all formal (required and default) arguments are assigned to their corresponding local variables as given in the function decla- ration.  The  remaining  non-keyword  variable  arguments  are  

inserted  in order into a tuple for access. Perhaps you are familiar with “varargs” in C
(i.e., va_list, va_arg, and the ellipsis [ ... ]). Python provides equivalent support―iterating over the tuple elements is the same as using va_arg in C. For those who are not familiar with C or varargs, they just represent 

the syn- tax for accepting a variable (not fixed) number of arguments passed in a func- tion call.
当函数被调用的时候，所有的形参（必须的和默认的）都将值赋给了在函数声明中相对应的局部变量。剩下的非关键字参数按顺序插入到一个元组中便于访问。可能你对C中的“varargs“很熟悉（比如, va_list, va_arg,以及省略号[....])。Python提供了与之相等的支持---迭代过所有的元组元素和在C中用va_arg是相同的。对于那些不熟悉C或者"varargs"的人，这仅仅代表了在函数调用时，接受一个不定（非固定）数目的参数。
　The variable-length argument tuple must follow all positional and default parameters, and the general syntax for functions with tuple or non-keyword variable arguments is as follows:
     可变长的参数元组必须在位置和默认参数之后，带元组（或者非关键字可变长参数）的函数普遍的语法如下：

def function_name([formal_args,] *vargs_tuple):
"function_documentation_string"
function_body_suite

　The asterisk operator ( * ) is placed in front of the variable that will hold all remaining arguments once all the formal parameters if have been exhausted. The tuple is empty if there are no additional arguments given.
星号操作符之后的形参将作为元组传递给函数,元组保存了所有传递给函数的"额外"的参数(匹配了所有位置和具名参数后剩余的)。如果没有给出额外的参数，元组为空。
  
　As we saw earlier, a TypeError exception is generated whenever an incorrect number of arguments is given in the function invocation. By adding a variable argument list variable at the end, we can handle the 

situation when more than enough  arguments  are  passed  to  the  function  because  all  the  extra  (non- keyword) ones will be added to the variable argument tuple. (Extra keyword arguments require a keyword 

variable argument parameter [see the next section].) As expected, all formal arguments must precede informal arguments for the same reason that positional arguments must come before keyword arguments.
  正如我们先前看见的，只要在函数调用时给出不正确的函数参数数目，就会产生一个TypeError异常。通过末尾增加一个可变的参数列表变量，我们就能处理当超出数目的参数被传入函数的情形，因为所有的额外（非关键字）参数会被添加到变量参数元组。（额外的关键字参数需要关键字变量参数[参见下一小节].)正如预料的那样，由于和位置参数必须放在关键字参数之前一样的原因，所有的形式参数必须先于非正式的参数之前出现。

def tupleVarArgs(arg1, arg2='defaultB', *theRest):
'display regular args and non-keyword variable args'
print 'formal arg 1:', arg1 print 'formal arg 2:', arg1 for eachXtrArg in theRest:
print 'another arg:', eachXtrArg
We will now invoke this function to show how variable argument tuples work:
我们现在调用这个函数来说明可变参数元组是如何工作的。

>>> tupleVarArgs('abc')



>>>
>>> tupleVarArgs(23, 4.56)
formal arg
1:
23
formal arg
2:
4.56
>>>


>>> tupleVarArgs('abc', 123, 'xyz', 456.789)
formal arg 1: abc formal arg 2: 123 another arg: xyz another arg: 456.789


62. Keyword Variable Arguments (Dictionary)
关键字变量参数（Dictionary）

In the case where we have a variable number or extra set of keyword argu- ments,  these  are  placed  into  a  dictionary  where  the  “keyworded”  argument variable names are the keys, and the arguments are their 

corresponding values. Why  must  it  be  a  dictionary?  Because  a  pair  of  items  is  given  for  every argument―the name of the argument and its value―it is a natural fit to use a dictionary to hold these arguments. 
在我们有不定数目的或者额外集合的关键字的情况中， 参数被放入一个字典中，字典中键为参数名，值为相应的参数值。为什么一定要是字典呢?因为为每个参数-参数的名字和参数值--都是成对给出---用字典来保存这些参数自然就最适合不过了。

Here is the syntax of function definitions that use the variable argument dictionary for extra keyword arguments:
这给出使用了变量参数字典来应对额外关键字参数的函数定义的语法：

def function_name([formal_args,][*vargst,] **vargsd):
function_documentation_string function_body_suite


To differentiate keyword variable arguments from non-keyword informal
arguments, a double asterisk ( ** ) is used. The ** is overloaded so as not to be confused with exponentiation. The keyword variable argument dictionary should be the last parameter of the function definition prepended 

with the
'**'. We now present an example of how to use such a dictionary:
为了区分关键字参数和非关键字非正式参数，使用了双星号（**）。 **是被重载了的以便不与幂运算发生混淆。关键字变量参数应该为函数定义的最后一个参数，带**。我们现在展示一个如何使用字典的例子：

def dictVarArgs(arg1, arg2='defaultB', **theRest):
'display 2 regular args and keyword variable args'
print 'formal arg1:', arg1
print 'formal arg2:', arg2
for eachXtrArg in theRest.keys():
print 'Xtra arg %s: %s' % \
(eachXtrArg, str(theRest[eachXtrArg]))

Executing this code in the interpreter, we get the following output:
在解释器中执行这个代码，我们得到以下输出。

>>> dictVarArgs(1220, 740.0, c='grail')
formal arg1: 1220
formal arg2: 740.0
Xtra arg c: grail
>>>
>>> dictVarArgs(arg2='tales', c=123, d='poe', arg1='mystery')

formal arg1: mystery formal arg2: tales



>>> dictVarArgs('one', d=10, e='zoo', men=('freud', 'gaudi'))
formal arg1: one formal arg2: defaultB
Xtra arg men: ('freud', 'gaudi') Xtra arg d: 10
Xtra arg e: zoo

　Both keyword and non-keyword variable arguments may be used in the same function as long as the keyword dictionary is last and is preceded by the non-keyword tuple, as in the following example:
    关键字和非关键字可变长参数都有可能用在同一个函数中，只要关键字字典是最后一个参数并且非关键字元组先于它之前出现，正如在如下例子中的一样：
  
def newfoo(arg1, arg2, *nkw, **kw):
display regular args and all variable args'
print 'arg1 is:', arg1 print 'arg2 is:', arg2 for eachNKW in nkw:
print 'additional non-keyword arg:', eachNKW
for eachKW in kw.keys():
print "additional keyword arg '%s': %s" % \
(eachKW, kw[eachKW])



Calling our function within the interpreter, we get the following output:
在解释器中调用我们的函数，我们得到如下的输出：

>>> newfoo('wolf', 3, 'projects', freud=90, gamble=96)
arg1 is: wolf arg2 is: 3
additional non-keyword arg: projects additional keyword arg 'freud': 90 additional keyword arg 'gamble': 96


11.6.3  Calling Functions with Variable
Argument Objects
调用带有可变长参数对象函数

Above in Section 11.2.4, we introduced the use of * and ** to specify sets of arguments in a function call. Here we will show you more examples of that syntax, with a slight bias toward functions accepting variable 

arguments.
在上面的11.2.4部分中，我们介绍了在函数调用中使用*和**来指定参数集合。接下来带着对函数接受变长参数的些许偏见，我们会向你展示更多那种语法的例子，

　We will now use our friend newfoo(), defined in the previous section, to test the new calling syntax. Our first call to newfoo() will use the old-style method of listing all arguments individually, even the variable 
arguments that follow all the formal arguments:
  我们现在将用在前面部分定义的，我们的老朋友newfoo()，来测试新的调用语法。我们第一个对newfoo()的调用将会使用旧风格的方式来分别列出所有的参数，甚至跟在所有形式参数之后的变长参数：

>>> newfoo(10, 20, 30, 40, foo=50, bar=60)
arg1 is: 10
arg2 is: 20
additional non-keyword arg: 30 additional non-keyword arg: 40 additional keyword arg 'foo': 50 additional keyword arg 'bar': 60
　We will now make a similar call; however, instead of listing the variable arguments  individually,  we  will  put  the  non-keyword  arguments  in  a  tuple and the keyword arguments in a dictionary to make the call:
我们现在进行相似的调用；然而，我们将非关键字参数放在元组中将关键字参数放在字典中，而不是逐个列出变量参数：

>>> newfoo(2, 4, *(6, 8), **{'foo': 10, 'bar': 12})
arg1 is: 2
arg2 is: 4
additional non-keyword arg: 6 additional non-keyword arg: 8 additional keyword arg 'foo': 10 additional keyword arg 'bar': 12
　Finally, we will make another call but build our tuple and dictionary out- side of the function invocation:
  最终，我们将再另外进行一次调用，但是是在函数调用之外来创建我们的元组和字典。

>>> aTuple = (6, 7, 8)
>>> aDict = {'z': 9}
>>> newfoo(1, 2, 3, x=4, y=5, *aTuple, **aDict)



arg1 is: 1
arg2 is: 2
additional non-keyword arg: 3 additional non-keyword arg: 6 additional non-keyword arg: 7 additional non-keyword arg: 8 additional keyword arg 'z': 9 additional keyword arg 'x': 4 additional keyword arg 'y': 5


　Notice how our tuple and dictionary arguments make only a subset of the final  tuple  and  dictionary  received  within  the  function  call.  The  additional non-keyword  value  '3' and  keyword  pairs  for  'x' and  'y' 

were  also included in the final argument lists even though they were not part of the
'*' and '**' variable argument parameters.
注意我们的元组和字典参数仅仅是被调函数中最终接收的元组和字典的子集。额外的非关键字值‘3’以及‘x’和‘y'关键字对也被包含在最终的参数列表中，而它们不是’*‘和’**‘的可变参数中的元素。
  
Prior to 1.6, variable objects could only be passed to  apply() with the
function  object  for  invocation.  This  current  calling  syntax  effectively  obso-
letes the use of apply(). Below is an example of using these symbols to call any function object with any type of parameter set.
之前的1.6，过去变长对象只能通过apply（）函数传递给被调用函数。现在的调用语法已经可以有效取代apply（）的使用。下面演示了如何使用了这些符号来把任意类型任意个数的参数传递给任意函数对象。

Functional Programming Example
函数式编程举例

Another  useful  application  of  functional  programming  comes  in  terms  of debugging or performance measurement. You are working on functions that need to be fully tested or run through regressions every night, 

or that need to be timed over many iterations for potential improvements. All you need to do
is to create a diagnostic function that sets up the test environment, then calls the function in question. Because this system should be flexible, you want to allow the testee function to be passed in as an argument. So 

a pair of such functions, timeit() and testit(), would probably be useful to the soft- ware developer today.
函数式编程的另外一个有用的应用出现在调试和性能测量方面上。你正在使用需要每夜都被完全测试或通过衰退，或需要给对潜在改善进行多次迭代计时的函数来工作。你所要做的就是创建一个设置测试环境的诊断函数，然后对有疑问的地方，调用函数。因为系统应该是灵活的， 所以想testee函数作为参数传入。那么这样的函数对，timeit()和testit(),可能会对如今的软件开发者有帮助。

　We will now present the source code to one such example of a testit() function (see Example 11.5). We will leave a timeit() function as an exer- cise for the reader (see Exercise 11.12).
  我们现在将展示这样的一个testit（）函数的例子的源代码（见例子11.5）。我们将留下timeit()函数作为读者的练习（见习题11.12）
　This module provides an execution test environment for functions. The testit() function  takes  a  function  and  arguments,  then  invokes  that function with the given arguments under the watch of an exception han- 

dler. If the function completes successfully, a True return value packaged with the return value of the function is sent back to the caller. Any failure causes  False to  be  returned  along  with  the  reason  for  the  

exception.
  该模块给函数提供了一个执行测试的环境。testit()函数使用了一个函数和一些参数，然后在异常处理的监控下，用给定的参数调用了那个函数。如果函数成功的完成， 会返回True和函数的返回值给调用者。任何的失败都会导致False和异常的原因一同被返回。
(Exception is the root class for all runtime exceptions; review Chapter 10for details.)
（Exception是所有运行时刻异常的根类：复习第10章以获得更详细的资料）
Example 11.5  Testing Functions (testit.py)

testit() invokes a given function with its arguments, returning True packaged with the return value of the function on success or False with the cause of failure.
testit()用其参数地调用了一个给定的函数，成功的话，返回一个和那函数返回值打包的True的返回值，或者False和失败的原因。

1	#!/usr/bin/env python
2
3	def testit(func, *nkwargs, **kwargs):
4
5	try:
6	retval = func(*nkwargs, **kwargs)
7	result = (True, retval)
8	except Exception, diag:
9	result = (False, str(diag))
10	return result
11
12   def test():
13	funcs = (int, long, float)
14	vals = (1234, 12.34, '1234', '12.34')
15
16	for eachFunc in funcs:
17	print '-' * 20
18	for eachVal in vals:
19	retval = testit(eachFunc,
20	eachVal)
21	if retval[0]:
22	print '%s(%s) =' % \
23	(eachFunc.__name__, `eachVal`), retval[1]
24	else:
25	print '%s(%s) = FAILED:' % \
26	(eachFunc.__name__, `eachVal`), retval[1]
27
28   if __name__ == '__main__':
29	test()



The unit tester function test() runs a set of numeric conversion func-
tions on an input set of four numbers. There are two failure cases in this test
set to confirm such functionality. Here is the output of running the script:
单元测试函数test()在一个为4个数字的输入集合运行了一个数字转换函数的集合。为了确定这样的功能性，在测试中有两个失败的案例。这里是运行脚本的输出：

$ testit.py
-------------------- int(1234) = 1234 int(12.34) = 12 int('1234') = 1234
int('12.34') = FAILED: invalid literal for int(): 12.34
-------------------- long(1234) = 1234L



long(12.34) = 12L
long('1234') = 1234L
long('12.34') = FAILED: invalid literal for long(): 12.34
-------------------- float(1234) = 1234.0 float(12.34) = 12.34 float('1234') = 1234.0 float('12.34') = 12.34


7 Functional Programming
函数式编程

Python is not and will probably not ever claim to be a functional programming language, but it does support a number of valuable functional programming con- structs. There are also some that behave like functional 

programming mecha- nisms  but  may  not  be  traditionally  considered  as  such.  What  Python  does provide comes in the form of four built-in functions and lambda expressions.
Python不是也不大可能会成为一种函数式编程语言，但是它支持许多有价值的函数式编程语言构建。也有些表现得像函数式编程机制但是从传统上也不能被认为是函数式编程语言的构建。Python提供的以4种内建函数和lambda表达式的形式出现

71. Anonymous Functions and lambda
匿名函数与lambda

Python allows one to create anonymous functions using the lambda keyword. They are “anonymous” because they are not declared in the standard manner, i.e., using the def statement. (Unless assigned to a local 

variable, such objects do not create a name in any namespace either.) However, as functions, they may also have arguments. An entire lambda “statement” represents an expres- sion, and the body of that expression 

must also be given on the same line as the declaration. We now present the syntax for anonymous functions:

lambda [arg1[, arg2, ... argN]]: expression
python允许用lambda关键字创造匿名函数。匿名是因为不需要以标准的方式来声明，比如说，使用def语句。（除非赋值给一个局部变量，这样的对象也不会在任何的名字空间内创建名字.)然而，作为函数，它们也能有参数。一个完整的lambda“语句”代表了一个表达式，这个表达式的定义体必须和声明放在同一行。我们现在来演示下匿名函数的语法:

Arguments are optional, and if used, are usually part of the expression as well.
参数是可选的，如果使用的参数话，参数通常也是表达式的一部分。

CORE NOTE: lambda expression returns callable function object

Calling lambda with an appropriate expression yields a function object that can be used like any other function.They can be passed to other functions, aliased with additional references, be members of container 

objects, and as callable objects, be invoked (with any arguments, if necessary). When called, these objects will yield a result equivalent to the same expression if given the same arguments.They are indistinguishable
from functions that return the evaluation of an equivalent expression.
核心笔记：lambda表达式返回可调用的函数对象。

用合适的表达式调用一个lambda生成一个可以像其他函数一样使用的函数对象。它们可被传入给其他函数，用额外的引用别名化，作为容器对象以及作为可调用的对象被调用（如果需要的话，可以带参数）。当被调用的时候，如过给定相同的参数的话，这些对象会生成一个和相同表达式等价的结果。它们和那些返回等价表达式计算值相同的函数是不能区分的。

　Before we look at any examples using  lambda, we would like to review single-line statements and then show the resemblances to lambda expressions.
  在我们看任何一个使用lambda的例子之前，我们意欲复习下单行语句，然后展示下lambda表达式的相似之处。

def true():
return True
　The above function takes no arguments and always returns True. Single line functions in Python may be written on the same line as the header. Given that, we can rewrite our true() function so that it looks 

something like the following:
  上面的函数没有带任何的参数并且总是返回True。python中单行函数可以和标题写在同一行。如果那样的话，我们重写下我们的true()函数以使其看其来像如下的东西：
def true(): return True
   We will present the named functions in this manner for the duration of this chapter because it helps one visualize their lambda equivalents. For our true() function,  the  equivalent  expression  (no  arguments,  returns 
True) using lambda is:
   在整这个章节，我们将以这样的方式呈现命名函数，因为这有助于形象化与它们等价的lamdba表达式。至于我们的true()函数，使用lambda的等价表达式（没有参数，返回一个True）为：
lambda :True
　Usage of the named true() function is fairly obvious, but not for lambda. Do we just use it as is, or do we need to assign it somewhere? A lambda func- tion by itself serves no purpose, as we see here:
    命名的true（）函数的用法相当的明显，但lambda就不是这样。我们仅仅是这样用，或者我们需要在某些地方用它进行赋值吗？一个lambda函数自己就是无目地服务，正如在这里看到的：

>>> lambda :True
<function <lambda> at f09ba0>
In  the  above  example,  we  simply  used  lambda to  create  a  function (object), but did not save it anywhere nor did we call it. The reference count for this function object is set to True on creation of the function object, but because no reference is saved, goes back down to zero and is garbage-collected. To keep the object around, we can save it into a variable and invoke it any time after. Perhaps now is a good opportunity:
在上面的例子中，我们简单地用lambda创建了一个函数（对象），但是既没有在任何地方保存它,也没有调用它。这个函数对象的引用计数在函数创建时被设置为True，但是因为没有引用保存下来，计数又回到零，然后被垃圾回收掉。为了保留住这个对象，我们将它保存到一个变量中，以后可以随时调用。现在可能就是一个好机会。
>>> true = lambda :True
>>> true() True
　Assigning it looks much more useful here. Likewise, we can assign lambda expressions to a data structure such as a list or tuple where, based on some input criteria, we can choose which function to execute as 

well as what the arguments would be. (In the next section, we will show how to use lambda expressions with functional programming constructs.)
  这里用它赋值看起来非常有用。相似地，我们可以把lambda表达式赋值给一个如列表和元组的数据结构，其中，基于一些输入标准，我们可以选择哪些函数可以执行，以及参数应该是什么。（在下个部分中，我们将展示如何去使用带函数式编程构建的lambda表达式。
　Let us now design a function that takes two numeric or string arguments and returns the sum for numbers or the concatenated string. We will show the standard function first, followed by its unnamed equivalent.
  我们现在来设计一个带2个数字或者字符串参数，返回数字之和或者已拼接的字符串的函数。我们先将展示一个标准的函数，然后再是其未命名的等价物。

def add(x, y): return x + y  ?	lambda x, y: x + y


Default and variable arguments are permitted as well, as indicated in the
following examples:
默认以及可变的参数也是允许的，如下例所示：
def usuallyAdd2(x, y=2): return x+y ?   lambda x, y=2: x+y
def showAllAsTuple(*z): return z	?  lambda *z: z

　Seeing is one thing, so we will now try to make you believe by showing how you can try them in the interpreter:
    看上去是一回事，所以我们现在将通过演示如何能在解释器中尝试这种做法，来努力着让你相信：

>>> a = lambda x, y=2: x + y
>>> a(3)
5
>>> a(3,5)
8
>>> a(0)
2
>>> a(0,9)
9
>>>
>>> b = lambda *z: z
>>> b(23, 'zyx')
(23, 'zyx')
>>> b(42)
(42,)

　One final word on lambda: Although it appears that lambda is a one-line version  of  a  function,  it  is  not  equivalent  to  an  “inline”  statement  in  C++, whose  purpose  is  bypassing  function  stack  allocation  
during  invocation  for performance reasons. A lambda expression works just like a function, creating
a frame object when called.
 关于lambda最后补充一点：虽然看起来lambdda是一个函数的单行版本，但是它不等同于c++的内联语句，这种语句的目的是由于性能的原因，在调用时绕过函数的栈分配。lambda 表达式运作起来就像一个函数，当被调用时，创建一个框架对象。


11.7.2  Built-in Functions: apply(),
filter(), map(), reduce()
内建函数apply()、filter()、map()、reduce()


In  this  section,  we  will  look  at  the  apply(),  filter(),  map(),  and reduce() built-in functions as well as give some examples to show how they can be used. These functions provide the functional pr
ogramming 
features found in Python. A summary of these functions is given in Table 11.2. All take
a function object to somehow invoke.
As you may imagine, lambda functions fit nicely into applications using any
of these functions because all of them take a function object with which to exe- cute, and lambda provides a mechanism for creating functions on the fly.
在这个部分中，我们将看看apply()，filter(), map(), 以及reduce()内建函数并给出一些如何使用它们的例子。这些函数提供了在python中可以找到的函数式编程的特征。正如你想像的一样，lambda函数可以很好的和使用了这些函数的应用程序结合起来，因为它们都带了一个可执行的函数对象，lambda表达式提供了迅速创造这些函数的机制。

Table 11.2   Functional Programming Built-in Functions
表11.2 函数式编程的内建函数

Built-in Function	Description
内建函数 描述

apply(func[, nkw][, kw])a	Calls func with optional arguments, nkw for non-keyword arguments and kw for keyword arguments; the return value is
the return value of the function call
apply(func[, nkw][, kw]) a 用可选的参数来调用func，nkw为非关键字参数，kw为关键字参数；返回值是函数调用的返回值。

filter(func, seq)b	Invokes Boolean function func iteratively over each element of seq; returns a sequence for those elements for which func returned true
filter(func, seq)b  调用一个布尔函数func来迭代遍历每个seq中的元素； 返回一个使func返回值为ture的元素的序列。




map(func, seq1[,seq2...])b

Applies function func to each element of given sequence(s) and provides return values in a list; if func is None, func behaves as the identity function, returning a list consisting of n-tuples for sets of elements of each 
sequence

map(func, seq1[,seq2...])b 将函数func作用于给定序列（s)的每个元素，并用一个列表来提供返回值；如果func为None， func表现为一个身份函数，返回一个含有每个序列中元素集合的n个元组的列表。

reduce(func, seq[, init])	Applies binary function func to elements of sequence seq, taking a pair at a time (previous result and next sequence item), continually applying the current result with the next value to obtain the succeeding result, finally reducing our sequence to a single return value; if initial value init given, first compare will be of init and first sequence element rather than the first two sequence elements
reduce(func, seq[, init]) 将二元函数作用于seq序列的元素，每次携带一对（先前的结果以及下一个序列元素），连续的将现有的结果和下雨给值作用在获得的随后的结果上，最后减少我们的序列为一个单一的返回值；如果初始值init给定，第一个比较会是init和第一个序列元素而不是序列的头两个元素。

a.	 Effectively deprecated in 1.6 to be phased out in future versions of Python. b.	Partially deprecated by list comprehensions introduced in Python 2.0.
a.   可以有效的取代1.6，在其后的python版本中逐渐淘汰。 b.由于在python2.0中，列表的综合使用的引入，部分被摈弃。


*apply()
As mentioned before, the calling syntax for functions, which now allow for
a  tuple  of  variable  arguments  as  well  as  a  dictionary  of  keyword  variable arguments, effectively deprecates apply()as of Python 1.6. The function will be phased out and eventually removed in a future version of 

Python. We mention it here for historical purposes as well as for those maintaining code that uses apply().
正如前面提到的， 函数调用的语法， 现在允许变量参数的元组以及关键字可变参数的字典， 在python1.6中有效的摈弃了apply()。 这个函数将来会逐步淘汰，在未来版本中最终会消失。 我们在这里提及这个函数既是为了介绍下历史，也是出于维护具有applay()函数的代码的目的。

filter()
The second built-in function we examine in this chapter is filter(). Imagine going to an orchard and leaving with a bag of apples you picked off the trees. Wouldn’t it be nice if you could run the entire bag through a filter 

to keep just the good ones? That is the main premise of the filter() function.
Given a sequence of objects and a “filtering” function, run each item of the
sequence through the filter, and keep only the ones that the function returns true for. The filter() function calls the given Boolean function for each item  of  the  provided  sequence.  Each  item  for  which  filter() returns  

a non-zero (true) value is appended to a list. The object that is returned is a
“filtered” sequence of the original.
在本章中我们研究的第二个内建函数是filter()。想像下，去一个果园，走的时候带着一包你从树上采下的苹果。 如果你能通过一个过滤器，将包裹中好的苹果留下，不是一件很令人开心的事吗？这就是filter()函数的主要前提。给定一个对象的序列和一个“过滤”函数，每个序列元素都通过这个过滤器进行筛选， 保留函数返回为真的的对象。filter函数为已知的序列的每个元素调用给定布尔函数。每个filter返回的非零（true)值元素添加到一个列表中。返回的对象是一个从原始队列中“过滤后”的队列

　If we were to code filter() in pure Python, it might look something like this:
  如果我们想要用纯python编写filter()，它或许就像这样：

def filter(bool_func, seq):
filtered_seq = []
for eachItem in seq:
if bool_func(eachItem):
filtered_seq.append(eachItem)
return filtered_seq
　One way to understand filter() better is by visualizing its behavior. Fig- ure 11C1 attempts to do just that.
  一种更好地理解filter（）的方法就是形象化其行为。 图11-1试着那样做。
  
　In  Figure  11C1,  we  observe  our  original  sequence  at  the  top,  items seq[0],   seq[1], . . . seq[N-1] for a sequence of size N. For each call to bool_func(),  i.e.,  bool_func(seq[0]),  bool_func(seq[1]),  etc.,  a 

return value of False or True comes back (as per the definition of a Boolean function―ensure that indeed your function does return one or the other). If bool_func() returns True for any sequence item, that element is 

inserted


seq
seq[0]	seq[1]	seq[2]
[
seq[N-1]









“filtered”
filtered_seq


seq[1]


seq[2]


filter()



(filtered_seq[0])
(filtered_seq[1])


Figure 11C1   How the filter() built-in function works


into the return sequence. When iteration over the entire sequence has been completed, filter() returns the newly created sequence.We present below a script that shows one way to use filter() to obtain a short list of random odd numbers. The script generates a larger set of ran-dom numbers first, then filters out all the even numbers, leaving us with the desired dataset. When we first coded this example, oddnogen.py looked like the following:
 在图11-1中，我们观察到我们原始队列在顶端， 一个大小为n的队列，元素从eq[0],   seq[1], . . . seq[N-1]。每一次对bool_func()的调用，举例来说，bool_func（seq[1])， bool_func（seq[0])等等，每个为True或False的的返回值都会回现。（因为Boolean函数的每个定义--确保你的函数确实返回一个真或假）。如果bool_func()给每个序列的元返回一个真，那个元素将会被插入到返回的序列中。当迭代整个序列已经完成， filter()返回一个新创建的序列。我们下面展示在一个使用了filer（）来获得任意奇数的简短列表的脚本。该脚本产生一个较大的随机数集合，然后过滤出所有的的偶数，留给我们一个需要的数据集。当一开始编写这个例子的时候，oddnogen.py如下所示：

from random import randint

def odd(n):
return n % 2

allNums = []
for eachNum in range(9):
allNums.append(randint(1, 99))
print filter(odd, allNums)
　This code consists of two functions: odd(), a Boolean function that deter- mined if an integer was odd (true) or even (false), and main(), the primary driving component. The purpose of main() is to generate ten random 

num- bers  between  1  and  100;  then  filter() is  called  to  remove  all  the  even numbers. Finally, the set of odd numbers is displayed, preceded by the size
of our filtered list.
 代码包括两个函数：odd()， 确定一个整数是奇数（真） 或者 偶数（假）Boolean函数，以及main()， 主要的驱动部件。main()的目的是来产生10个在1到100之间的随机数：然后调用filter()来移除掉所有的偶数。最后，先显示出我们过滤列表的大小，然后是奇数的集合
Importing and running this module several times, we get the following output:
导入和运行这个模块几次后，我们能得到如下输出：

$ python oddnogen.py
[9, 33, 55, 65]

$ python oddnogen.py
[39, 77, 39, 71, 1]

$ python oddnogen.py
[23, 39, 9, 1, 63, 91]

$ python oddnogen.py
[41, 85, 93, 53, 3]

Refactoring Pass 1 第一次重构
We notice on second glance that odd() is simple enough to be replaced by a
lambda expression:
在第二次浏览时，我们注意到odd()是非常的简单的以致能用一个lambda表达式替换
from random import randint allNums = []
for eachNum in range(9):
allNums.append(randint(1, 99))
print filter(lambda n: n%2, allNums)



Refactoring Pass 2
We  have  already  mentioned  how  list  comprehensions  can  be  a  suitable replacement for filter()so here it is:
我们已经提到list综合使用如何能成为filter()合适的替代者，如下便是：

from random import randint

allNums = []
for eachNum in range(9):
allNums.append(randint(1, 99))
print [n for n in allNums if n%2]

Refactoring Pass 3
We can further simplify our code by integrating another list comprehen- sion to put together our final list. As you can see below, because of the flex- ible  syntax  of  list  comps,  there  is  no  longer  a  need  for  

intermediate variables. (To make things fit, we import randint() with a shorter name into our code.)
我们通过整合另外的列表解析将我们最后的列表放在一起，来进一步简化我们的代码。正如你如下看到的一样， 由于列表解析灵活的语法，就不再需要一个暂时的变量了。（为了简单，我们用一个较短的名字将randint()倒入到我们的代码中）

from random import randint as ri
print [n for n in [ri(1,99) for i in range(9)] if n%2]
　Although longer than it should be, the line of code making up the core part of this example is not as obfuscated as one might think.
   虽然比原来的长些， 但是这行扮演了该例子中核心部分的代码不再如其他人想的那么模糊不清。

map()
The map() built-in function is similar to filter() in that it can process a sequence through a function. However, unlike filter(), map() “maps” the function  call  to  each  sequence  item  and  returns  a  list  consisting  of  

all  the return values.
map()内建函数与filter()相似，因为它也能通过函数来处理序列。然而，不像filter()， map() 将函数调用“映射”到每个序列的元素上，并返回一个含有所有返回值的列表。

　In  its  simplest  form,  map() takes  a  function  and  sequence,  applies  the function to each item of the sequence, and creates a return value list that is comprised of each application of the function. So if your 

mapping function is
to add 2 to each number that comes in and you feed that function to map() along  with  a  list  of  numbers,  the  resulting  list  returned  is  the  same  set  of numbers as the original, but with 2 added to each number. 
  在最简单的形式中，map()带一个函数和队列， 将函数作用在序列的每个元素上， 然后创建由每次函数应用组成的返回值列表。所以如果你的映射函数是给每个进入的数字加2，并且你将这个函数和一个数字的列表传给map（），返回的结果列表是和原始集合相同的数字集合，但是每个数字都加了2.
  
If we were to code how this simple form of map() works in Python, it might look something like the code below that is illustrated in Figure 11C2.
如果我们要用python编写这个简单形式的map（）如何运作的， 它可能像在图11-2中阐释的如下代码：

def map(func, seq):
mapped_seq = []
for eachItem in seq:
mapped_seq.append(func(eachItem))
return mapped_seq




seq	[



mapped_s

[
seq[0]	seq[1]	seq[2]	seq[N-1]



func(seq[0])
func(seq[2])	func(seq[N-1])
func(seq[1])	map()


Figure 11C2   How the map() built-in function works




We can whip up a few quick lambda functions to show you how map()
works on real data:
我们可以列举一些简短的lambda函数来展示如何用map()处理实际数据：

>>> map((lambda x: x+2), [0, 1, 2, 3, 4, 5])
[2, 3, 4, 5, 6, 7]
>>>
>>> map(lambda x: x**2, range(6))
[0, 1, 4, 9, 16, 25]
>>> [x+2 for x in range(6)]
[2, 3, 4, 5, 6, 7]
>>>
>>>[x**2 for x in range(6)]
[0, 1, 4, 9, 16, 25]

　We have also discussed how map () can sometimes can be replaced by list comprehensions, so here we refactor our two examples above.The more general form of map() can take more than a single sequence as
its input. If this is the case, then map() will iterate through each sequence in parallel.  On  the  first  invocation,  it  will  bundle  the  first  element  of  each sequence into a tuple, apply the func function to it, and return the result as a tuple  into  the  mapped_seq mapped  sequence  that  is  finally  returned  as  a whole when map() has completed execution. Figure  11C2  illustrated  how  map() works  with  a  single  sequence.  If
we  used  map() with  M  sequences  of  N  objects  each,  our  previous  dia-gram  would  be  converted  to  something  like  the  diagram  presented  in
Figure 11C3.
  我们已经讨论了有时map()如何被列表解析取代， 所以这里我们再分析下上面的两个例子。形式更一般的map（）能以多个序列作为其输入。如果是这种情况， 那么map()会并行地迭代每个序列。在第一次调用时， map()会将每个序列的第一个元素捆绑到一个元组中， 将func函数作用到map（）上， 当map（）已经完成执行的时候，并将元组的结果返回到mapped_seq 映射的，最终以整体返回的序列上。图11-2阐释了一个map（）如何和单一的序列一起运行。如果我们用带有每个序列有N个对象的M个序列来的map（），我们前面的图表会转变成如图11-3中展示的图表那样。







seqM
0	1	N-1
[
:.	.:	:.	
seq2	[
seq1	[







mapped_s
[(	...	),(

...	),...(	...	)]
func(seq1[0], seq2[0], ... seqM [0])	func(seq1[N-1], ... seqM [N-1])
func(seq1[1], seq2[1], ... seqM [1])
map()


Figure 11C3   How the map() built-in function works with > 1 sequence
图11-3 内建函数map（）如何和>1的序列一起运作。


Here are several examples using map()with multiple sequences:
这里有些使用带多个序列的map（）的例子

>>> map(lambda x, y: x + y, [1,3,5], [2,4,6])
[3, 7, 11]
>>>
>>> map(lambda x, y: (x+y, x-y), [1,3,5], [2,4,6])
[(3, -1), (7, -1), (11, -1)]
>>>
>>> map(None, [1,3,5], [2,4,6])
[(1, 2), (3, 4), (5, 6)]
　The  last  example  above  uses  map() and  a  function  object  of  None to merge  elements  of  unrelated  sequences  together.  This  idiom  was  so  com- monly  used  prior  to  Python  2.0  that  a  new  built-in  

function,  zip(),  was added just to address it:
  上面最后的例子使用了map()和一个为None的函数对象来将不相关的序列归并在一起。这种思想在一个新的内建函数，zip，被加进来之前的python2.0是很普遍的。而zip是这样做的：
>>> zip([1,3,5], [2,4,6])
[(1, 2), (3, 4), (5, 6)]

reduce()
The final functional programming piece is reduce(), which takes a binary function  (a  function  that  takes  two  values,  performs  some  calculation  and returns  one  value  as  output),  a  sequence,  and  an  optional 
 initializer,  and methodologically “reduces” the contents of that list down to a single value, hence its name.  In other languages, this concept is known as folding.
函数式编程的最后的一部分是reduce（），reduce使用了一个二元函数（一个接收带带两个值作为输入，进行了一些计算然后返回一个值作为输出），一个序列，和一个可选的初始化器，卓有成效地将那个列表的内容“减少”为一个单一的值，如同它的名字一样。在其他的语言中，这种概念也被称作为折叠。
　It does this by taking the first two elements of the sequence and passing them to the binary function to obtain a single value. It then takes this value and the next item of the sequence to get yet another value, and 

so on until the sequence is exhausted and one final value is computed.
  它通过取出序列的头两个元素，将他们传入二元函数来获得一个单一的值来实现。然后又用这个值和序列的下一个元素来获得又一个值，然后继续直到整个序列的内容都遍历完毕以及最后的值会被计算出来为止。
You may try to visualize reduce() as the following equivalence example:
你可以尝试去形象化reduce如下面的等同的例子：

reduce(func, [1, 2, 3])	?	func(func(1, 2), 3)

　Some argue that the “proper functional” use of reduce() requires only one item to be taken at a time for reduce(). In our first iteration above, we took two items because we did not have a “result” from the previous 
values (because we did not have any previous values). This is where the optional ini- tializer comes in (see the init variable below). If the initializer is given, then the  first  iteration  is  performed  on  the  initializer  and  the  first  item  of  the sequence, and follows normally from there.
    有些人认为reduce（）合适的函数式使用每次只需要仅需要一个元素。在上面一开始的迭代中， 我们拿了两个元素因为我们没有从先前的值（因为我们没有任何先前的值）中获得的一个“结果”。这就是可选初始化器出现的地方（参见下面的init变量）。如果给定初始化器， 那么一开始的迭代会用初始化器和一个序列的元素来进行，接着和正常的一样进行。

If we were to try to implement reduce() in pure Python, it might look something like this:
如果我们想要试着用纯python实现reduce()， 它可能会是这样：


if init is None:	# initializer?
res = lseq.pop(0) #	no
else:
res = init	#	yes
for item in lseq:	# reduce sequence
res = bin_func(res, item) # apply function
return res	# return result
　This may be the most difficult of the four conceptually, so we should again show you an example as well as a functional diagram (see Figure 11C4). The
“hello  world”  of  reduce() is  its  use  of  a  simple  addition  function  or  its
lambda equivalent seen earlier in this chapter:
  从概念上说这可能4个中最难的一个， 所以我们应该再次向你演示一个例子以及一个函数式图表（见图11-4）。reduce()的“hello world”是其一个简单加法函数的应用或在这章前面看到的与之等价的lamda
? def mySum(x,y): return x+y
? lambda x,y: x+y
　Given a list, we can get the sum of all the values by simply creating a loop,  iteratively  going  through  the  list,  adding  the  current  element  to  a running  subtotal,  and  being  presented  with  the  result  once  

the  loop  has completed:
 给定一个列表， 我们可以简单地创建一个循环， 迭代地遍历这个列表，再将现在元素加到前面元素的累加和上，最后当循环结束就能获得所有值的总和。

>>> def mySum(x,y): return x+y
>>> allNums = range(5)	# [0, 1, 2, 3, 4]
>>> total = 0








seq  [
0              1              2	N-2	N-1

binCfunc
(a)





binCfunc
(b)





binCfunc





reduce()
binCfunc


res

(a) The value of this result is binCfunc(seq[0], seq[1])
(b) The value of this result is binCfunc(bin_func(seq[0], seq[1]), seq[2]), etc.
Figure 11C4   How the reduce() built-in function works
图11-4 reduce（）内建函数是如何工作的。


>>> for eachNum in allNums:
...	total = mySum(total, eachNum)
...
>>> print 'the total is:', total the total is: 10

Using lambda and reduce(), we can do the same thing on a single line:
使用lambda和reduce（）,我们可以以一行代码做出相同的事情。

>>> print 'the total is:', reduce((lambda x,y: x+y), range(5))
the total is: 10

　The reduce() function performs the following mathematical operations given the input above:
  给出了上面的输入，reduce（）函数运行了如下的算术操作。

((((0 + 1) + 2) + 3) + 4) ?   10

　It takes the first two elements of the list (0 and 1), calls mySum() to get 1, then calls mySum() again with that result and the next item 2, gets the result from that, pairs it with the next item 3 and calls mySum(), 

and finally takes the entire subtotal and calls mySum() with 4 to obtain 10, which is the final return value.
    用list的头两个元素（0，1），调用mySum()来得到1，然后用现在的结果和下一个元素2来再次调用mySum()，再从这次调用中获得结果，与下面的元素3配对然后调用mySum()，最终拿整个前面的求和和4来调用mySum()得到10，10即为最终的返回值。

11.7.3  Partial Function Application
11.7.3 偏函数应用

The  notion  of  currying  combines  the  concepts  of  functional  programming and default and variable arguments together. A function taking N arguments that is “curried” embalms the first argument as a fixed 

parameter and returns another function object taking (the remaining) N-1 arguments, akin to the actions of the LISP primitive functions car and cdr, respectively. Currying can  be  generalized  into  partial  function  

application  (PFA),  in  which  any number  (and  order)  of  arguments  is  parlayed  into  another  function  object with the remainder of the arguments to be supplied later.
  currying的概念将函数式编程的概念和默认参数以及可变参数结合在一起。一个带n个参数，curried的函数固化第一个参数为固定参数，并返回另一个带n-1个参数函数对象，分别类似于LISP的原始函数car和cdr的行为。Currying 能泛化成为偏函数应用（PFA）， 这种函数将任意数量（顺序）的参数的函数转化成另一个带剩余参数的函数对象。
  
　In a way, this seems similar to default arguments where if arguments are not provided, they take on a “default” value. In the case of PFAs, the argu- ments do not have a default value for all calls to a function, only to 

a specific set of calls. You can have multiple partial function calls, each of which may pass  in  different  arguments  to  the  function,  hence  the  reason  why  default arguments cannot be used.
    在某种程度上，这似乎和不提供参数，就会使用默认参数情形相似。 在PFA的例子中， 参数不需要调用函数的默认值，只需明确的调用集合。你可以有很多的偏函数调用，每个都能用不同的参数传给函数，这便是不能使用默认参数的原因。
　This feature was introduced in Python 2.5 and made available to users via the functools module.
    这个特征是在python2.5的时候被引入的，通过functools模块能很好的给用户调用。

Simple Functional Example
简单的函数式例子

How about creating a simple little example? Let us take two simple functions add() and mul(), both found in the operator module. These are just func- tional interfaces to the + and * operators that we are already 

familiar with, e.g., add(x, y) is the same as x + y. Say that we wanted to add one to a num- ber or multiply another by 100 quite often in our applications.
如何创建一个简单小巧的例子呢？我们来使用下两个简单的函数add()和mul()， 两者都来自operator模块。这两个函数仅仅是我们熟悉的+和*操作符的函数式接口，举例来说，add(x,y)与x+y一样。在我们的程序中，我们经常想要给和数字加一或者乘以100
　Rather  than  having  multiple  calls  like  add(1, foo), add(1, bar), mul(100, foo), mul(100, bar), would it not be nice to just have existing functions  that  simplify  the  function  call,  i.e.,  add1(foo), add1(bar), mul100
(foo), mul100(bar),   but   without   having   to   write   functions add1() and mul100()? Well, now you can with PFAs. You can create a PFA
by using the partial() function found in the functional module:
 除了大量的，如add（1，foo)，add（1，bar)，mul(100, foo), mul(100, bar)般的调用，拥有已存在的并使函数调用简化的函数不是一件很美妙的事吗？举例来说，add1(foo), add1(bar), mul100，但是却不用去实现函数add1()和mul100()？哦，现在用PFAs你就可以这样做。你可以通过使用functional模块中的partial（）函数来创建PFA:

(foo), mul100(bar),

>>> from operator import add, mul
>>> from functools import partial
>>> add1 = partial(add, 1)	# add1(x) == add(1, x)
>>> mul100 = partial(mul, 100) # mul100(x) == mul(100, x)
>>>
>>> add1(10)
11
>>> add1(1)
2




>>> mul100(10)
1000
>>> mul100(500)
50000

   This example may or may not open your eyes to the power of PFAs, but we have to start somewhere. PFAs are best used when calling functions that take many parameters. It is also easier to use PFAs with 
keyword arguments, because  specific  arguments  can  be  given  explicitly,  either  as  curried  argu- ments, or those more “variable” that are passed in at runtime, and we do not have to worry about ordering. Below is an example from the Python docu- mentation for use in applications where binary data (as strings) need to be converted to integers fairly often:
   这个例子或许不能让你看到PFAs的威力，但是我们不得不从从某个地方开始。当调用带许多参数的函数的时候，PFAs是最好的方法。使用带关键字参数的PFAs也是较简单的， 因为能显示给出特定的参数，要么作为curried参数，要么作为那些更多在运行时刻传入的变量， 并且我们不需担心顺序。下面的一个例子来自python文档中关于在应用程序中使用，在这些程序中需要经常将二进制（作为字符串）转换成为整数。
>>> baseTwo = partial(int, base=2)
>>> baseTwo.__doc__ = 'Convert base 2 string to an int.'
>>> baseTwo('10010')
18

　This example uses the int() built-in function and fixes the base to 2 spe- cifically for binary string conversion. Now instead of multiple calls to int() all with the same second parameter (of 2), e.g., int('10010', 2), we 

can simply use our new baseTwo() function with a single argument. Good style
is also followed because it adds a documentation string to the “new (partial) function,” and it is also another good use of “function attributes” (see Sec- tion 11.3.4 above). One important thing to note is that the keyword 

argument base is required here.
  这个例子使用了int()内建函数并将base固定为2来指定二进制字符串转化。现在我们没有多次用相同的第二参数（2）来调用int（），比如('10010', 2)，相反，可以只用带一个参数的新baseTwo（）函数。接着给新的（部分）函数加入了新的文档并又一次很好地使用了“函数属性”（见上面的11.3.4部分），这是很好的风格。要注意的是这里需要关键字参数base

Be Wary of Keywords
警惕关键字

If you create the partial function without the base keyword, e.g., baseTwo- BAD = partial(int, 2),  it  would  pass  the  arguments  to  int() in  the wrong order because the fixed arguments are always placed to the left of 
the runtime  arguments,  meaning  that  baseTwoBAD(x) == int(2, x).  If  you call it, it would pass in 2 as the number to convert and the base as '10010', resulting in an exception:
如果你创建了不带base关键字的偏函数，比如， baseTwo- BAD = partial(int, 2)，这可能会让参数以错误的顺序传入int（），因为固定参数的总是放在运行时刻参数的左边， 比如baseTwoBAD(x) == int(2, x)。如果你调用它， 它会将2作为需要转化的数字，base作为'10010'来传入，接着产生一个异常：

>>> baseTwoBAD = partial(int, 2)
>>> baseTwoBAD('10010')
Traceback (most recent call last): File "<stdin>", line 1, in <module>
TypeError: an integer is required


　With the keyword in place, the order is preserved properly since, as you know,  keyword  arguments  always  come  after  the  formal  arguments,  so baseTwo(x) == int(x, base=2).
     由于关键字放置在恰当的位置， 顺序就得固定下来，因为，如你所知，关键字参数总是出现在形参之后， 所以baseTwo(x) == int(x, base=2).

Simple GUI Class Example
简单GUI类的例子。

PFAs  also  extended  to  all  callables  like  classes  and  methods.  An  excellent example of using PFAs is in providing “partial-GUI templating.” GUI wid- gets often have many parameters, such as text, length, 

maximum size, back- ground and foreground colors, both active and otherwiseboth active and otherwise, etc. If we wanted
to “fix” some of those arguments, such as making all text labels be in white letters  on  a  blue  background,  you  can  customize  it  exactly  that  way  into  a pseudo template for similar objects.
PFAs也扩展到所有可调用的东西，如类和方法。一个使用PFAs的优秀的例子是提供了“部分gui模范化”。GUI小部件通常有很多的参数，如文本，长度，最大尺寸， 背景和前景色，活动或者非活动，等等。如果想要固定其中的一些参数， 如让所有的文本标签为蓝底白字， 你可以准确地以PFAs的方式，自定义为相似对象的伪模板。

Example 11.6   Partial Function Application GUI (pfaGUI.py)
例 11.6 偏函数应用GUI （ppfaGUI.py）

This a more useful example of partial function application, or more accurately,
“partial class instantiation” in this case . . . why?
这是较有用的偏函数应用的例子，或者更准确的说，“部分类实例化” 。。。。为什么呢？

1	#!/usr/bin/env python
2

3	from functools import partial



7	MyButton = partial(Tkinter.Button, root,
8	fg='white', bg='blue')
9	b1 = MyButton(text='Button 1')
10   b2 = MyButton(text='Button 2')
11   qb = MyButton(text='QUIT', bg='red',
12	command=root.quit)
13   b1.pack()
14   b2.pack()
15   qb.pack(fill=Tkinter.X, expand=True)
16   root.title('PFAs!')
17   root.mainloop()


In lines 7C8, we create the “partial class instantiator” (because that is what
it is instead of a partial function) for Tkinter.Button, fixing the parent win- dow argument root and both foreground and background colors. We create two buttons b1 and b2 matching this template providing only the text 

label as unique to each. The quit button (lines 11C12) is slightly more customized, taking  on  a  different  background  color  (red,  which  overrides  the  blue default) and installing a callback to close the window when 

it is pressed. (The other two buttons have no function when they are pressed.)
在7-8行，我们给Tkinter.Button创建了"部分类实例化器”（因为那便是它的名字，而不是偏函数）,固定好父类的窗口参数然后是前景色和背景色。我们创建了两个按钮b1和b2来与模板匹配，只让文本标签唯一。quit按钮（11-12行）是稍微自定义过的，带有不同的背景色（红色， 覆盖了默认的蓝色）并配置了一个回调的函数，当按钮被按下的时候，关闭窗口。（另外的的两个按钮没有函数，当他们被按下的的时候）

Without the MyButton “template,” you would have to use the “full” syntax each  time  (because  you  are  still  not  giving  all  the  arguments  as  there  are plenty of parameters you are not passing that have default values):
没有MyButton“模板”的话，你每次会不得不使用“完全”的语法（因为你仍然没有给全参数，由于有大量你不传入的，含有默认]值的参数）
b1 = Tkinter.Button(root, fg='white', bg='blue', text='Button 1') b2 = Tkinter.Button(root, fg='white', bg='blue', text='Button 2') qb = Tkinter.Button(root, fg='white', text='QUIT', bg='red',
command=root.quit)
Here is a snapshot of what this simple GUI looks like:
这就一个简单的GUI的截图：





　　Why bother with so much repetition when your code can be more com- pact  and  easy  to  read?  You  can  find  out  more  about  GUI  programming  in Chapter 18 (Section 18.3.5), where we feature a longer 
example of using PFAs. From what you have seen so far, you can see that PFA takes on the flavors of templating and “style-sheeting” in terms of providing defaults in a more functional programming environment. You can read more about them in the documentation  for  the  functools module  documentation  found  in the Python Library Reference, the “What’s New in Python 2.5” document, and the specifying PEP 309.
   当你的代码可以变得更紧凑和易读的时候，为什么要还有重复的做令人心烦的事？你能在18张章找到更多关于GUI编程的资料， 在那我们着重描写了一个使用PFAs的例子。从你迄今为止看到的内容中，可以发现，在以更函数化编程环境提供默认值方面，PFA带有模板以及“style-sheeting”的感觉。你可以在Python Library Reference，“What’s New in Python 2.5”文档和指定的PEP309里，关于functools模块的文档中阅读到更多关于pfa的资料。

11.8  Variable Scope
11.8 变量作用域

The scope of an identifier is defined to be the portion of the program where its  declaration  applies,  or  what  we  refer  to  as  “variable  visibility.”  In  other words,  it  is  like  asking  yourself  in  which  parts  of  a  
program  do  you  have access to a specific identifier. Variables either have local or global scope.
标识符的作用域是定义为其声明在程序里的可应用范围， 或者即是我们所说的变量可见性。换句话说，就好像在问你自己，你可以在程序里的哪些部分去访问一个制定的标识符。变量可以是局部域或者全局域。

11.8.1  Global versus Local Variables
11.8.1  全局变量与局部变量
Variables defined within a function have local scope, and those at the highest level in a module have global scope. In their famous “dragon” book on compiler theory, Aho, Sethi, and Ullman summarize it this way:
定义在函数内的变量有局部作用域，在一个模块中最高级别的变量有全局作用域。在编译器理论里有名的“龙“书中，Aho, Sethi, 和ULLman以这种方法进行了总结。

　 “The portion of the program to which a declaration applies is called the scope of that declaration. An occurrence of a name in a procedure is said to be local to the procedure if it is in the scope of a declaration within 

the pro- cedure; otherwise, the occurrence is said to be nonlocal.”
     “声明适用的程序的范围被称为了声明的作用域。在一个过程中，如果名字在过程的声明之内，它的出现即为过程的局部变量；否则的话，出现即为非局部的“
　One characteristic of global variables is that unless deleted, they have a lifespan that lasts as long as the script that is running and whose values are accessible to all functions, whereas local variables, like the 

stack frame they reside in, live temporarily, only as long as the functions they are defined in are currently active. When a function call is made, its local variables come into scope as they are declared. At that time, a 

new local name is created for that object, and once that function has completed and the frame deallocated, that variable will go out of scope.
    全局变量的一个特征是除非被删除掉，否则它们的存活到脚本运行结束，且对于所有的函数，他们的值都是可以被访问的，然而局部变量，就像它们存放的栈，暂时地存在，仅仅只依赖于定义它们的函数现阶段是否处于活动。当一个函数调用出现时，其局部变量就进入声明它们的作用域。在那一刻，一个新的局部变量名为那个对象创建了，一旦函数完成，框架被释放，变量将会离开作用域。

global_str = 'foo'
def foo():
local_str = 'bar'
return global_str + local_str
In the above example, global_str is a global variable while local_str is
a local variable. The foo() function has access to both global and local vari-
ables while the main block of code has access only to global variables.
上面的例子中，global_str是全局变量，而local_str是局部变量。foo()函数可以对全局和局部变量进行访问，而代码的主体部分只能访问全局变量。

CORE NOTE: Searching for identifiers (aka variables, names, etc.)
核心笔记：搜索标识符（aka变量，名字，等等）

When searching for an identifier, Python searches the local scope first. If the name is not found within the local scope, then an identifier must be found in the global scope or else a NameError exception is raised.
当搜索一个标识符的时候，python先从局部作用域开始搜索。如果在局部作用域内没有找到那个名字，那么就一定会在全局域找到这个变量否则就会被抛出NameError异常。

A variable’s scope is related to the namespace in which it resides. We will cover namespaces formally in Chapter 12; suffice it to say for now that namespaces are just naming domains that map names to objects, a 
virtual set of what variable names are currently in use, if you will.The concept of scope relates to the namespace search order that is used to find a variable. All names in the local namespace are within the local scope when a function is executing.That is the first namespace searched when looking for a variable. If it is not found there, then perhaps a globally scoped variable with that name can be found.These variables are stored (and searched) in the global and built-in namespaces.
一个变量的作用域和它寄住的名字空间相关。我们会在12章正式介绍名字空间；对于现在只能说子空间仅仅是将名字映射到对象的命名领域，现在使用的变量名字虚拟集合。作用域的概念和用于找到变量的名字空间搜索顺序相关。当一个函数执行的时候，所有在局部命名空间的名字都在局部作用域内。那就是当查找一个变量的时候，第一个被搜索的名字空间。如果没有在那找到变量的话，那么就可能找到同名的全局变量。这些变量存储（搜索）在一个全局以及内建的名字空间，。

It is possible to “hide” or override a global variable just by creating a local one. Recall that the local namespace is searched first, being in its local scope. If the name is found, the search does not continue to search for
a globally scoped variable, hence overriding any matching name in either the global or built-in namespaces.
仅仅通过创建一个局部变量来“隐藏“或者覆盖一个全局变量是有可能的。回想一下，局部名字空间是首先被搜索的，存在于其局部作用域。如果找到一个名字，搜索就不会继续去寻找一个全局域的变量，所以在全局或者内建的名字空间内，可以覆盖任何匹配的名字。

Also, be careful when using local variables with the same names as global variables. If you use such names in a function (to access the global value) before you assign the local value, you will get an exception (NameError or Unbound- LocalError), depending on which version of Python you are using.
同样，当使用全局变量同名的局部变量的时候要小心。如果在赋予局部变量值之前，你在函数中（为了访问这个全局变量）使用了这样的名字，你将会得到一个异常（NAMEERROR或者 Unbound- LocalError），而这取决于你使用的python版本。

2. global Statement
globa语句
Global  variable  names  can  be  overridden  by  local  variables  if  they  are declared within the function. Here is another example, similar to the first, but the global and local nature of the variable are not as clear.
如果将全局变量的名字声明在一个函数体内的时候，全局变量的名字能被局部变量给覆盖掉。这里有另外的例子，与第一个相似，但是该变量的全局和局部的特性就不是那么清晰了。

def foo():
print "\ncalling foo()..."
bar = 200
print "in foo(), bar is", bar
bar = 100
print "in __main__, bar is", bar foo()
print "\nin __main__, bar is (still)", bar
It gave the following output:
得到如下输出：

in __main__, bar is 100
calling foo()...
in foo(), bar is 200
in __main__, bar is (still) 100
　Our local bar pushed the global bar out of the local scope. To specifically reference a named global variable, one must use the global statement. The syntax for global is:
    我们局部的bar将全局的bar推出了局部作用域。为了明确地引用一个已命名的全局变量，必须使用global语句。global的语法如下：

global var1[, var2[, ... varN]]]
Modifying the example above, we can update our code so that we use the glo- bal version of is_this_global rather than create a new local variable.
修改上面的例子，可以更新我们代码，这样我们便可以用全局版本的is_this_global而无须创建一个新的局部变量。

>>> is_this_global = 'xyz'
>>> def foo():
...	global is_this_global
...	this_is_local = 'abc'
...	is_this_global = 'def'
...	print this_is_local + is_this_global
...
>>> foo()
abcdef
>>> print is_this_global def


3. Number of Scopes
作用域的数字

Python syntactically supports multiple levels of functional nesting, and as of Python 2.1, matching statically nested scoping. However, in versions prior to 2.1, a maximum of two scopes was imposed: a function’s local scope and the global scope. Even though more levels of functional nesting exist, you could not access more than two scopes:
python从句法上支持多个函数嵌套级别，就如在python2.1中的，匹配静态嵌套的作用域。然而，在2.1至前的版本中，最多为两个作用域：一个函数的局部作用域和全局作用域。虽然存在多个函数的嵌涛，但你不能访问超过两个作用域。

def foo():
m = 3
def bar():
n = 4
print m + n
print m bar()

Although this code executes perfectly fine today . . .
虽然这代码在今天能完美的运行....

>>> foo()
3
7
. . . executing it resulted in errors in Python before 2.1:
在python2.1之前执行它将会产生错误。

>>> foo()
Traceback (innermost last): File "<stdin>", line 1, in ?
 File "<stdin>", line 7, in foo File "<stdin>", line 5, in bar NameError: m

　The  access  to  foo()’s  local  variable  m within  function  bar() is  illegal because  m is  declared  local  to  foo().  The  only  scopes  accessible  from bar() are bar()’s local scope and the global scope. foo()’s local 

scope is not included in that short list of two. Note that the output for the “print
m” statement succeeded, and it is the function call to bar() that fails. For- tunately with Python’s current nested scoping rules, this is not a problem today.
    在函数bar()内访问foo()的局部变量m是非法的，因为m是声明为foo()的局部变量。从bar()中可访问唯一的作用域为局部作用域和全局作用域。foo()的局部作用域没有包含在上面两个作用域的列表中。注意'print m'语句的输出成功了，而而对bar()的函数调用却失败了。幸运的是，由于python的现有嵌套作用语规则，今天就不存在这个问题了。

11.8.4  Closures 11.8.4 闭包

With  Python’s  statically  nested  scoping,  it  becomes  useful  to  define  inner functions as we have seen earlier. In the next section, we will focus on scope and  lambda,  but  inner  functions  also  suffered  the  
same  problem  before Python 2.1 when the scoping rules changed to what they are today. If references are made from inside an inner function to an object defined in any outer scope (but not in the global scope), the inner function then is known as a closure. The variables defined in the outer function but used or referred to by the inner function are called free variables. Closures are an important con- cept  in  functional  programming  languages,  with  Scheme  and  Haskell  being two of them. Closures are syntactically simple (as simple as inner functions) yet still very powerful.
由于python的静态嵌套域，如我们早先看到的，定义内部函数变得很有用处。在下面的部分中，我们将着重讨论作用域和lambda，但是在python2.1之前，当作用域规改则变为今天这样之前，内部函数也会遭受到相同的问题。如果在一个内部函数里，对在外部作用域(但不是在全局作用域）的变量进行引用，那么内部函数就被认为是closure。定义在外部函数内的但由内部函数引用或者使用的变量被称为自由变量。closures在函数式编程中是一个重要的概念，Scheme和Haskell便是函数式编程中两种。Closures从句法上看很简单(和内部函数一样简单）但是仍然很有威力。

　A closure combines an inner function’s own code and scope along with the scope of an outer function. Closure lexical variables do not belong to the glo- bal  namespace  scope  or  the  local  one―they  belong  to  
someone  else’s namespace and carry an “on the road” kind of scope. (Note that they differ from objects in that those variables live in an object’s namespace while closure variables live in a function’s namespace and 
scope.) So why would you want to use closures?
    闭包将内部函数自己的代码和作用域以及外部函数的作用结合起来。闭包的词法变量不属于全局名字空间域或者局部的--而属于其他的名字空间，带着“流浪"的作用域。（注意这不同于对象因为那些变量是存活在一个对象的名字空间但是闭包变量存活在一个函数的名字空间和作用域）那么为什么你会想要用closues?

　Closures are useful for setting up calculations, hiding state, letting you move around function objects and scope at will. Closures come in handy in GUI or event-driven programming where a lot of APIs support 
callbacks. The same applies for retrieving database rows and processing the data in the exact same manner.  Callbacks  are  just  functions.  Closures  are  functions,  too,  but  they carry some additional scope with 
them. They are just functions with an extra feature . . . another scope.
    Closurs对于安装计算，隐藏状态，以及在函数对象和作用域中随意地切换是很有用的。closurs在GUI或者在很多API支持回调函数的事件驱动编程中是很有些用处的。以绝对相同的方式，应用于获取数据库行和处理数据。回调就是函数。闭包也是函数，但是他们能携带一些额外的作用域。它们仅仅是带了额外特征的函数……另外的作用域。

　You will probably feel that the use of closures draws a strong parallel to partial function application as introduced earlier in this chapter, but PFA is really more like currying than the use of closures because it is not 
as much as about function calling as it is about using variables defined in another scope.
    你可能会觉得闭包的使用和这章先前介绍的偏函数应用非常的相似，但是与闭包的使用相比，PFA更像是currying, 因为闭包和函数调用没多少相关，而是关于使用定义在其他作用域的变量。

Simple Closure Example
简单的闭包的例子

Below is a short example of using closures. We will simulate a counter and also simulate making an integer mutable by enclosing it as a single element
of a list.
下面是使用闭包简单的例子。我们会模拟一个计数器，同样也通过将整数包裹为一个列表的单一元素来模拟使整数易变。

def counter(start_at=0): count = [start_at] def incr():
count[0] += 1
return count[0]
return incr
　The only thing counter() does is to accept an initial value to start counting at and assigns it as the sole member of the list count. Then an incr() inner func- tion is defined. By using the variable count inside it, we 

have created a closure because it now carries with it the scope of counter(). incr() increments the

running count and returns it. Then the final magic is that counter() returns
incr, a (callable) function object.
If we run this interactively, we get the output below―note how similar it
looks to instantiating a counter object and executing the instance:
  counter()做的唯一一件事就是接受一个初始化的的值来开始计数，并将该值赋给列表count唯一一个成员。然后定义一个incr()的内部函数。通过在内部使用变量count，我们创建了一个闭包因为它现在携带了整个counter()作用域。incr()增加了正在运行的count然后返回它。然后最后的魔法就是counter()返回一个incr，一个（可调用的）函数对象。如我们交互地运行这个函数，我们将得到如下的输出---------注意这看起来和实例化一个counter对象并执行这个实例有多么相似：

>>> count = counter(5)
>>> print count()
6
>>> print count()
7
>>> count2 = counter(100)
>>> print count2()
101
>>> print count()
8

　The one difference is that we were able to do something that previously required  us  to  write  a  class,  and  not  only  that,  but  to  have  to  override  the
__call__() special method of that class to make its instances callable. Here we were able to do it with a pair of functions.
   有点不同的是我们能够做些原来需要我们写一个类做的事，并且不仅仅是要写，而且必需覆盖掉这个类的__call__()特别方法来使他的实例可调用。这里我们能够使用一对函数来做这事。

　Now,  in  many  cases,  a  class  is  the  right  thing  to  use.  Closures  are  more appropriate in cases whenever you need a callback that has to have its own scope, especially if it is something small and simple, 

and often, clever. As usual,
if you use a closure, it is a good idea to comment your code and/or use doc strings to explain what you are doing.
   现在，在很多情况下，类是最适合使用的。闭包更适合需要一个必需有自己的作用域的回调函数情况，尤其是回调函数是很小巧而且简单的，通常也很聪明。跟平常一样，如果你使用了闭包，对你的代码进行注释或者用文档字符串来解释你正做的事是很不错的主意


*Chasing Down Closure Lexical Variables
追踪闭包词法的变量

The next two sections contain material for advanced readers . . . feel free to skip it if you wish. We will discuss how you can track down free variables with a function’s func_closure attribute. Here is a code snippet that 
dem- onstrates it.If we run this piece of code, we get the following output:no f1 closure vars

下面两个部分包含了给高级读者的材料……如果你愿意的话，你可以跳过去。我们将讨论如何能使用函数的func_closure属性来追踪自由变量。这里有个显示追踪的代码片断。如果我们运行这段代码，将得到如下输入：
f2 closure vars: ['<cell at 0x5ee30: int object at
0x200377c>']
f3 closure vars: ['<cell at 0x5ee90: int object at
0x2003770>', '<cell at 0x5ee30: int object at
0x200377c>']
<int 'w' id=0x2003788 val=1>
<int 'x' id=0x200377c val=2>
<int 'y' id=0x2003770 val=3>
<int 'z' id=0x2003764 val=4>




Example 11.7  Tracking Closure Variables (closureVars.py)
例子11.7 追踪闭包变量(closureVars.py)

This example shows how we can track closure variables by using a function’s
func_closure variable.
这个例子说明了如何能通过使用函数的func_closure属性来追踪闭包变量

1	#!/usr/bin/env python
2
3	output = '<int %r id=%#0x val=%d>'
4	w = x = y = z = 1
5
6	def f1():
7	x = y = z = 2
8
9	def f2():

10	y = z = 3








19	clo = f3.func_closure
20	if clo:
21	print "f3 closure vars:", [str(c) for c in clo]
22	else:
23	print "no f3 closure vars"
24	f3()
25
26	clo = f2.func_closure
27	if clo:
28	print "f2 closure vars:", [str(c) for c in clo]
29	else:
30	print "no f2 closure vars"
31	f2()
32
33   clo = f1.func_closure
34   if clo:
35	print "f1 closure vars:", [str(c) for c in clo]
36   else:
37	print "no f1 closure vars"
38   f1()


Line-by-Line Explanation
逐行解释

Lines 1C4
This script starts by creating a template to output a variable: its name, ID, and value, and then sets global variables w, x, y, and z. We define the template so that we do not have to copy the same output format string 
multiple times.
这段脚本由创建模板来输出一个变量开始：它的名字，ID，以及值，然后设置变量w,x,y和z。我们定义了模板，这样便不需要多次拷贝相同输出格式的字符串

Lines 6C9, 26C31
The definition of the f1() function includes a creating local variables x, y, and z plus the definition of an inner function f2(). (Note that all local vari- ables shadow or hide accessing their equivalently named global 
variables.) If f2() uses any variables that are defined in f1()’s scope, i.e., not global and not local to f2(), those represent free variables, and they will be tracked by f1.func_closure.
f1()函数的定义包括创建一个局部变量x,y和z,以及一个内部函数f2()的定义。（注意所有的局部变量遮蔽或者隐藏了对他们同名的全局变量的访问）。如果f2()使用了任何的定义在f1()作用域的变量，比如说，非全局的和非f2()的局部域的，那么它们便是自由变量，将会被f1.func_closure追踪到。

Lines 9C10, 19C24
Practically duplicating the code for f1(), these lines do the same for f2(), which defines locals y and z plus an inner function f3(). Again, note that the locals here shadow globals as well as those in intermediate 

localized scopes, e.g., f1()’s. If there are any free variables for f3(), they will be displayed here.
这几行实际上是对f1()的拷贝，对f2()做相同的事，定义了局部变量y和z，以及对一个内部函数f3().此外，这里的局部变量会遮蔽全局以及那些在中间局部化作用域的变量，比如，f1()的。如果对于f3()有任何的自由变量，他们会在这里显示出来。

　You will no doubt notice that references to free variables are stored in cell objects,  or  simply,  cells.  What  are  these  guys?  Cells  are  basically  a  way  to keep references to free variables alive after their 
defining scope(s) have com- pleted (and are no longer on the stack).
    毫无疑问，你会注意到对自由变量的引用是存储在单元对象里，或者简单的说，单元。这些东西是什么呢？单元是在作用域结束后使自由变量的引用存活的一种基础方法。

　For example, let us assume that function f3() has been passed to some other function so that it can be called later, even after f2() has completed. You do not want to have f2()’s stack frame around because that will 
keep all of f2()’s vari- ables alive even if we are only interested in the free variables used by f3(). Cells hold on to the free variables so that the rest of f2() can be deallocated.
   举例来说，我们假设函数f3()已经被传入到其他一些函数，这样便可在稍后，甚至是f2()完成之后，调用它。你不想要让f2()的栈出现，因为即使我们仅仅在乎f3()使用的自由变量，栈也会让所有的f2()'s的变量保持存活。单元维持住自由变量以便f2()的剩余部分能被释放掉。

Lines 12C17
This block represents the definition of f3(), which creates a local variable z. We then display w, x, y, z, all chased down from the innermost scope outward. The variable w cannot be found in f3(), f2(), or f1(), therefore, it 

is a global. The variable x is not found in f3() or f2(), so it is a closure variable from f1(). Similarly, y is a closure variable from f2(), and finally, z is local to f3().
这个部分描绘了f3()的定义，创建一个局部的变量z。接着显示w,x,y,z，这4个变量从最内部作用域逐步向外的追踪到的。在f3(), f2(), 或者 f1()中都是找不到变量w的，所以，这是个全局变量。在f3()或者f2()中，找不到变量x，所以来自f1()的闭包变量。相似地，y是一个来自f2()的闭包变量。最后，z是f3()的局部变量。

Lines 33C38
The rest of main() attempts to display closure variables for f1(), but it will never  happen  since  there  are  no  scopes  in  between  the  global  scope  and f1()’s―there is no scope that f1() can borrow from, ergo no 

closure can be created―so  the  conditional  expression  on  line  34  will  never  evaluate  to True. This code is just here for decorative purposes.
main()中剩余的部分尝试去显示f1()的闭包变量，但是什么都不会发生因为在全局域和f1()的作用域之间没有任何的作用域---没有f1()可以借用的作用域，因此不会创建闭包---所以第34行的条件表达式永远不会求得True。这里的这段代码仅仅是有修饰的目的。

*Advanced Closures and Decorators Example
高级闭包和装饰器的例子

We saw a simple example of using closures and decorators in back in Section 11.3.6, deco.py. The following is a slightly more advanced example, to show you  the  real  power  of  closures.  The  application  “logs”  function  calls.The  user  chooses  whether  they  want  to  log  a  function  call  before  or after  it  has  been  invoked.  If  post-log  is  chosen,  the  execution  time  is also displayed.
回到11.3.6部分，我们看到了一个使用闭包和装饰器的简单例子，deco.py。接下来就是稍微高级点的例子，来给你演示闭包的真正的威力。应用程序“logs"函数调用。用户选择是要在函数调用之前或者之后，把函数调用写入日志。如果选择贴日志，执行时间也会显示出来。


Example 11.8   Logging Function Calls with Closures (funcLog.py)
例子11.8 用闭包将函数调用写入日至。

This example shows a decorator that takes an argument that ultimately determines which closure will be used. Also featured is the power of closures.
这个例子演示了带参数的装饰器，该参数最终决定哪一个闭包会被用的。这也是闭包的威力的特征。

1	#!/usr/bin/env python
2
3	from time import time

4


7	print '''Called:
8	function: %s
9	args: %r
10   kargs: %r''' % (f, args, kargs)

11


14	log(f, *args, **kargs)
15	return f(*args, **kargs)
16	return wrapper
17

18	def post_logged(f):



22	return f(*args, **kargs)
23	finally:
24	log(f, *args, **kargs)
25	print "time delta: %s" % (time()-now)
26	return wrapper
27
28	try:
29	return {"pre": pre_logged,
30	"post": post_logged}[when]
31	except KeyError, e:
32	raise ValueError(e), 'must be "pre" or "post"'
33
34   @logged("post")
35   def hello(name):
36	print "Hello,", name
37
38   hello("World!")



If you execute this script, you will get output similar to the following:
如果执行这个脚本，你将会得到和下面相似的输出：

$ funcLog.py Hello, World! Called:
function: <function hello at 0x555f0>
args: ('World!',)
kargs: {}
time delta: 0.000471115112305

Line-by-Line Explanation
逐行解释

Lines 5C10, 28C32
This body of code represents the core part of the logged() function, whose responsibility  it  is  to  take  the  user’s  request  as  to  when  the  function  call should be logged. Should it be before the target function is 
called or after? logged() has  three  helper  inner  functions  defined  within  its  definition: log(), pre_logged(), and post_logged().log() is the function that does the actual logging. It just displays to stan-dard output the name of the function and its arguments. If you were to use this function “in the real world,” you would most likely send this output to a file, a database, or perhaps standard error (sys.stderr).The last part of logged() in lines 28C32 is actually the first lines of code in the function that are not function declarations. It reads the user’s selection when, and returns one of the  *logged() functions so that  it can then be called with the target function to wrap it.
这段代码描绘了logged()函数的核心部分，其职责就是获得关于何时函数调用应该被写入日志的用户请求。它应该在目标函数被调用前还是之后呢？logged()有3个在它的定义体之内的助手内部函数：log(),pre_logged()以及post_logged()。log()是实际上做日志写入的函数。它仅仅是显示标准输出函数的名字和参数。如果你愿意在“真实的世界中”使用该函数的话，你很有可能会把输出写到一个文件，数据库，或者标准错误(sys.stderr)。logged()在28-32行的最后的部分实际上是函数中非函数声明的最开始的代码。读取用户的选择然后返回*logged()函数中的一个便能用目标函调用并包裹它。

Lines 12C26
    pre_logged() and post_logged() will both wrap the target function and log it in accordance with its name, e.g., post_logged() will log the function call  after  the  target  function  has  executed  while  pre_logged() does  it before execution.
    pre_logged()和post_logged()都会包装目标函数然后根据它的名字写入日志，比如，当目标函数已经执行之后，post_loggeed()会将函数调用写入日志，而pre_logged()则是在执行之前。

　Depending   on   the   user’s   selection,   one   of    pre_logged()  and post_logged() will be returned. When the decorator is called, it evaluates the  decorator  function  first  along  with  its  argument.  e.g.,  logged

(when). Then  the  returned  function  object  is  called  with  the  target  function  as  its parameter, e.g., pre_logged(f) or post_logged(f).
    根据用户的选择，pre_logged()和post_logged()其中之一会被返回。当这个装饰器被调用的时候，首先对装饰器和其参数进行求值，比如logged(什么时候）。然后返回的函数对象作为目标的函数的参数进行调用，比如，pre_logged(f)或者post_logged(f).
　Both *logged() functions include a closure named wrapper(). It calls the target function while logging it as appropriate. The functions return the wrapped function object, which then is reassigned to the original target 

func- tion identifier.
    两个*logged()函数都包括了一个名为wrapper()的闭包。当合适将其写入日志的时候，它便会调用目标函数。这个函数返回了包裹好的函数对象，该对象随后将被重新赋值给原始的目标函数标识符。

Lines 34C38
The  main  part  of  this  script  simply  decorates  the  hello() function  and executes it with the modified function object. When you call  hello() on line 38, it is not the same as the function object that was created on 

line 35. The decorator on line 34 wraps the original function object with the specified decoration and returns a wrapped version of hello().
这段脚本的主要部分简单地装饰了hello()函数并将用修改过的函数对象一起执行它。当你在38行调用hello()的时候，它和你在35行创建的函数对象已经不是一回事了。34行的装饰器用特殊的装饰将原始函数对象进行了包裹并返回这个包裹后的hello()版本。


11.8.5  Scope and lambda
11.8.5  作用域和lambda

Python’s lambda anonymous functions follow the same scoping rules as stan- dard functions. A lambda expression defines a new scope, just like a function definition, so the scope is inaccessible to any other part of 
the program except for that local lambda/function.
python的lambda匿名函数遵循和标准函数一样的作用域规则。一个lambda表达式定义了新的作用域，就像函数定义，所以这个作用域除了局部lambda/函数，对于程序其他部分，该作用域都是不能对进行访问的。
　Those lambda expressions declared local to a function are accessible only within that function; however, the expression in the  lambda statement has the same scope access as the function. You can also think of a 
function and a lambda expression as siblings.
    那些声明为函数局部变量的lambda表达式在这个函数体内是可以访问的；然而，在lambda语句中的表达式有和函数相同的作用域。你也可以认为函数和一个lambda表达式是同胞。

x = 10
def foo():
y = 5
bar = lambda :x+y
print bar()

We know that this code works fine now . . .
我们现在知道这段代码能很好的运行。

>>> foo()
15

　. . . however, we must again look to the past to see an extremely common idiom  that  was  necessary  to  get  code  to  work  in  older  versions  of  Python. Before 2.1, we would get an error like what you see 

below because while the function and lambda have access to global variables, neither has access to the other’s local scopes:
   .....然而，我们必须在回顾下过去，去看下原来的python版本中让代码运行必需的，一种极其普遍的做法。在2.1之前，我们将会得到一个错误，如同你在下面看到的一样，因为函数和lambda都可访问全局变量，但两者都不能访问彼此的局部作用域。

>>> foo()
Traceback (innermost last): File "<stdin>", line 1, in ?
File "<stdin>", line 4, in foo
 File "<stdin>", line 3, in <lambda> NameError: y


　In the example above, although the lambda expression was created in the local scope of foo(), it has access to only two scopes: its local scope and the global scope (also see Section 11.8.3). The solution was to 

add a variable with
a default argument so that we could pass in a variable from an outer local scope to an inner one. In our example above, we would change the line with the lambda to look like this:
  在上面的例子中，虽然lambda表达式在foo()的局部作用域中创建，但他仅仅只能访问两个作用域：它自己的局部作用域和全局的作用域（同样见Section 11.8.3).解决的方法是加入一个变量作为默认参数，这样我们便能从外面的局部作用域传递一个变量到内部。在我们上面的例子中，我们将lambda的那一行修改成这样：

bar = lambda y=y: x+y

　With this change, it now works. The outer y’s value will be passed in as an argument and hence the local y (local to the lambda function). You will see  this  common  idiom  all  over  Python  code  that  you  will  

come  across; however, it still does not address the possibility of the outer y changing val- ues, such as:
    由于这个改变，程序能运行了。外部y的值会作为一个参数传入，成为局部的y（lambda函数的局部变量）。你可以在所有你遇到的python代码中看到这种普遍的做法；然而，这不表明存在改变外部y值的可能性，比如：

x = 10
def foo():
y = 5
bar = lambda y=y: x+y
print bar()
y = 8
print bar()

The output is “totally wrong”:
输出“完全错误“

>>> foo()
15
15

The reason for this is that the value of the outer y was passed in and “set” in the lambda, so even though its value changed later on, the lambda defi-nition did not. The only other alternative back then was to add a local vari-able  z within  the  lambda expression  that  references  the  function  local variable y.
原因是外部y的值被传入并在lambda中“设置“，所以虽然其值在稍后改变了，但是lambda的定义没有变。那时唯一替代的方案就是在lambda表达式中加入对函数局部变量y进行引用的局部变量z。

x = 10
def foo():
y = 5
bar = lambda z:x+z
print bar(y)
y = 8
print bar(y)




All of this was necessary in order to get the correct output:
为了获得正确的输出所有的一切都是必需的：

>>> foo()
15
18

　This was also not preferred as now all places that call bar() would have to be changed to pass in a variable. Beginning in 2.1, the entire thing works per- fectly without any modification:
    这同样也不可取因为现在所有调用bar()的地方都必需改为传入一个变量。从python2.1开始，在没有任何修改的情况下整个程序都完美的运行。

x = 10
def foo():
y = 5
bar = lambda :x+y
print bar(y)
y = 8
print bar(y)
>>> foo()
15
18

Are you not glad that “correct” statically nested scoping was (finally) added
to Python? Many of the “old-timers” certainly are. You can read more about this important change in PEP 227.
正确的静态嵌套域（最后）被加入到python中，你会不高兴吗？许多老前辈一定不会。你可以在pep227中阅读到更多关于这个重要改变的信息。

11.8.6  Variable Scope and Namespaces
11.8.6  变量作用域和名字空间。

From our study in this chapter, we can see that at any given time, there are either one or two active scopes―no more, no less. Either we are at the top- level of a module where we have access only to the global 

scope, or we are executing in a function where we have access to its local scope as well as the global scope. How do namespaces relate to scope?
从我们在这章的学习中，我们可以看见任何时候，总有一个或者两个活动的作用域---不多，不少。我们要么在只能访问全局作用域的模块的最高级，要么在一个我们能访问函数局部作用域和全局作用域的函数体内执行。名字空间是怎么和作用域关联的呢？

　From the Core Note in Section 11.8.1 we can also see that, at any given time, there are either two or three active namespaces. From within a func- tion, the local scope encompasses the local namespace, the first 
place a name is searched for. If the name exists here, then checking the global scope (glo- bal and built-in namespaces) is skipped. From the global scope (outside of any function), a name lookup begins with the global namespace. If no match is found, the search proceeds to the built-in namespace.
    从11.8.1小节的核心笔记中，我们也可以发现，在任何给定的时间，存在两个或者三个的活动的名字空间。从函数内部，局部作用域包围了局部名字空间，第一个搜寻名字的地方。如果名字存在的话，那么将跳过检查全局作用域（全局和内建的名字空间）

　We will now present Example 11.9, a script with mixed scope everywhere. We leave it as an exercise to the reader to determine the output of the program.
     我们现在将给出例子11.9，一个到处混合了作用域的脚本。我们将确定此程序输出作为练习留给读者。



Example 11.9  Variable Scope (scope.py)
例子11.9 变量作用域(scope.py)

Local variables hide global variables, as indicated in this variable scope program. What is the output of this program? (And why?)
局部变量隐藏了全局变量，正如在这个变量作用程序中显示的。程序的输出会是什么呢？（以及为什么）

1	#!/usr/bin/env python
2	j, k = 1, 2
3
4	def proc1():
5
6	j, k = 3, 4
7	print "j == %d and k == %d" % (j, k)
8	k = 5
9
10   def proc2():
11
12	j = 6
13	proc1()
14	print "j == %d and k == %d" % (j, k)
15
16
17   k = 7
18   proc1()
19   print "j == %d and k == %d" % (j, k)
20
21   j = 8
22   proc2()
23   print "j == %d and k == %d" % (j, k)


Also see Section 12.3.1 for more on namespaces and variable scope.
12.3.1小节有更多关于名字空间和变量作用域的信息。


11.9  *Recursion
*递归


A function is recursive if it contains a call to itself. According to Aho, Sethi, and  Ullman,  “[a]  procedure  is  recursive  if  a  new  activation  can  begin before  an  earlier  activation  of  the  same  procedure  has  

ended.”  In  other words, a new invocation of the same function occurs within that function before it finished.
如果函数包含了对其自身的调用，该函数就是递归的。根据Aho, Sethi, 和Ullman, ”[a] 如果一个新的调用能在相同过程中较早的调用结束之前开始，那么该过程就是递归的“
　Recursion is used extensively in language recognition as well as in mathe- matical applications that use recursive functions. Earlier in this text, we took
a first look at the factorial function where we defined:
   递归广泛地应用于语言识别和使用递归函数的数学应用中。在本文的早先部分，我们第一次看到了我们定义的阶乘函数

N! ?  factorial(N) ?  1 * 2 * 3 ... * N



We can also look at factorial this way:
我们可以用这种方式来看阶乘:

factorial(N) = N!
= N * (N-1)!
= N * (N-1) * (N-2)!
:
= N * (N-1) * (N-2) ... * 3 * 2 * 1
We can now see that factorial is recursive because factorial(N) = N
* factorial(N-1). In other words, to get the value of factorial(N), one
needs to calculate factorial(N-1). Furthermore, to find factorial(N-
1), one needs to computer factorial(N-2), and so on.
We now present the recursive version of the factorial function:
我们现在可以看到阶乘是递归的，因为factorial(N) = N* factorial(N-1).换句话说，为了获得factorial(N)的值，需要计算factorial(N-1).而且，为了找到factorial(N-1)，需要计算factorial(N-2)等等。我们现在给出阶乘函数的递归版本。

def factorial(n):
if n == 0 or n == 1: # 0! = 1! = 1
return 1
else:
return (n * factorial(n-1))

8 Generators
生成器

Earlier in Chapter 8, we discussed the usefulness behind iterators and how they give non-sequence objects a sequence-like iteration interface. They are simple to understand because they only have one method, a 

next() that is called to get the next item.
早先在第8章，我们讨论了迭代器背后的有效性以及它们如何给非序列对象一个像序列的迭代器接口。这很容易明白因为他们仅仅只有一个方法，用于调用获得下个元素的next()

　However, unless you implement a class as an iterator, iterators really do not have much “intelligence.” Would it not be much more powerful to call a func- tion that somehow “generated” the next value in the iteration 
and returned with something as simple as a next() call? That is one motivation for generators. Another aspect of generators is even more powerful . . . the concept of corou- tines. A coroutine is an independent function 
call that can run, be paused or sus- pended,  and  be  continued  or  resumed  where  it  left  off.  There  is  also communication  between  the  caller  and  the  (called)  coroutine.  For  example, when a coroutine 
pauses, we can receive an intermediate return value from it, and when calling back into one, to be able to pass in additional or altered param- eters, yet still be able to pick up where we last left it, with all state still 
intact. Coroutines that are suspended yielding intermediate values and resumed multiple times are called generators, and that is exactly what Python genera- tors do. Generators were added to Python in 2.2 and made 
standard in 2.3(see PEP 255), and although powerful enough, they were significantly enhanced in  Python  2.5  (see  PEP  342).  These  enhancements  bring  generators  even closer to being full coroutines because values (and exceptions) are allowed to be passed back into a resumed function. Also, generators can now yield con- trol  while  waiting  for  a  generator  it  has  called  to  yield  a  result  instead  of blocking to wait for that result to come back before the calling generator can suspend (and yield a result). Let us take a closer look at generators starting from the top.
  然而，除非你实现了一个迭代器的类，迭代器真正的并没有那么“聪明“。难道调用函数还没有强大到在迭代中以某种方式生成下一个值并且返回和next()调用一样简单的东西？那就是生成器的动机之一。生成器的另外一个方面甚至更加强力.....协同程序的概念。协同程序是可以运行的独立函数调用，可以暂停或者挂起，并从程序离开的地方继续或者重新开始。在有调用者和（被调用的）协同程序也有通信。举例来说，当协同程序暂停的时候，我们能从其中获得一个中间的返回值，当调用回到程序中时，能够传入额外或者改变了的参数，但仍能够从我们上次离开的地方继续，并且所有状态完整。挂起返回出中间值并多次继续的协同程序被称为生成器，那就是python的生成器真正在做的事。在2.2的时候，生成器被加入到python中接着在2.3中成为标准（见PEP255)，虽然之前足够强大，但是在Python2.5的时候，得到了显著的提高（见pep342)。这些提升让生成器更加接近一个完全的协同程序，因为允许值（和异常）能传回到一个继续的函数中。同样地，当等待一个生成器的时候，生成器现在能返回控制。在调用的生成器能挂起（返回一个结果）之前，调用生成器返回一个结果而不是阻塞等待那个结果返回。让我们更进一步观察生成器自顶向下的启动
　What is a generator Python-wise? Syntactically, a generator is a function with a yield statement. A function or subroutine only returns once, but a generator  can  pause  execution  and  yield  intermediate  

results―that  is  the functionality of the yield statement, to return a value to the caller and to pause  execution.  When  the  next() method  of  a  generator  is  invoked,  it resumes right where it left off (when it yielded 

[a value and] control back to the caller).
   什么是python式的生成器？从句法上讲，生成器是一个带yield语句的函数。一个函数或者子程序只返回一次，但一个生成器能暂停执行并返回一个中间的结果----那就是yield语句的功能， 返回一个值给调用者并暂停执行。当生成器的next()方法被调用的时候，它会准确地从离开地方继续（当它返回[一个值以及]控制给调用者时）
　When  generators  were  added  back  in  2.2,  because  it  introduced  a  new keyword, yield, for backward compatibility, you needed to import genera- tors from the __future__ module in order to use them. This 

was no longer necessary when generators became standard beginning with 2.3.
   当在2.2生成器被加入的时候，因为它引入了一个新的关键字，yield，为了向下兼容，你需要从_future_模块中导入generators来使用生成器。从2.3开始，当生成器成为标准的时候，这就不再是必需的了。


1. Simple Generator Features
简单的生成器特性

Generators behave in another manner similar to iterators: when a real return
or end-of-function is reached and there are no more values to yield (when calling next()), a StopIteration exception is raised. Here is an example, the simplest of generators:
与迭代器相似，生成器以另外的方式来运作：当到达一个真正的返回或者函数结束没有更多的值返回（当调用next())，一个StopIteration异常就会抛出。这里有个例子，简单的生成器：

def simpleGen():
yield 1
yield '2 --> punch!'

　Now that we have our generator function, let us call it to get and save a generator  object  (so  that  we  can  call  its  next() method  to  get  successive intermediate values from it):
    现在我们有自己的生成器函数，让我们调用他来获得和保存一个生成器对象(以便我们能调用它的next()方法从这个对象中获得连续的中间值）

>>> myG = simpleGen()
>>> myG.next()
1
>>> myG.next()
'2 --> punch!'
>>> myG.next()
Traceback (most recent call last): File "", line 1, in ?
     myG.next() StopIteration



Since Python’s for loops have next() calls and a handler for StopIter-
ation, it is almost always more elegant to use a for loop instead of manually
iterating through a generator (or an iterator for that matter):
由于python的for循环有next()调用和对StopIteration的处理，使用一个for循环而不是手动迭代穿过一个生成器（或者那种事物的迭代器）总是要简洁漂亮得多。

>>> for eachItem in simpleGen():
...	print eachItem
...
1
'2 --> punch!'

　Of course that was a silly example: why not use a real iterator for that? More motivation comes from being able to iterate through a sequence that requires the power of a function rather than static objects already 

sitting in some sequence.
    当然这是个挺傻的例子：为什么不对这使用真正的迭代器呢？许多动机源自能够迭代穿越序列，而这需要函数威力而不是已经在某个序列中静态对象。

　In the following example, we are going to create a random iterator that takes a sequence and returns a random item from that sequence:
    在接下来的例子中，我们将要创建一个带序列并从那个序列中返回一个随机元素的随机迭代器：

from random import randint
def randGen(aList):
while len(aList) > 0:
yield aList.pop(randint(0, len(aList)))

　The  difference  is  that  each  item  returned  is  also  consumed  from  that sequence,   sort   of   like   a   combination   of   list.pop() and   random. choice():
    不同点在于每个返回的元素将从那个队列中消失，像一个list.pop()和random.choice()的结合的归类。

>>> for item in randGen(['rock', 'paper', 'scissors']):
...	print item
... scissors rock paper

　We will see a simpler (and infinite) version of this generator as a class iter- ator coming up in a few chapters when we cover Object-Oriented Program- ming.  Several  chapters  ago  in  Section  8.12 ,  we  discussed 

 the  syntax  of generator expressions. The object returned from using this syntax is a gener- ator, but serves as a short form, allowing for the simplistic syntax of a list com- prehension.
    在接下来的几章中，当我们谈到面向对象编程的时候，将看见这个生成器较简单（和无限）的版本作为类的迭代器。在几章前的8.12小节中，我们讨论了生成器表达式的语法。使用这个语法返回的对象是个生成器，但只以一个简单的形式，并允许使用过分简单化的列表解析的语法。

　These simple examples should give you an idea of how generators work, but you may be asking, “Where can I use generators in my application?” Or perhaps, you may be asking, “What are the most appropriate 
places for using this powerful construct?”
    这些简单的例子应该让你有点明白生成器是如何工作的，但你或许会问。"在我的应用中，我可以在哪使用生成器？“或许，你会问“最适合使用这些个强大的构建的地方在哪？“

　The “best” places to use generators are when you are iterating through a large dataset that is cumbersome to repeat or reiterate over, such as a large disk file, or a complex database query. For every row of data, 
you wish to per- form non-elementary operations and processing, but you “do not want to lose your place” as you are cursoring or iterating over it.
   使用生成器最好的地方就是当你正迭代穿越一个巨大的数据集合，而重复迭代这个数据集合是一个很麻烦的事，比如一个巨大的磁盘文件，或者一个复杂的数据库查询。对于每行的数据，你希望执行非元素的操作以及处理，但当正指向和迭代过它的时候，你“不想失去你的地盘“。

　You want to grab a wad of data, yield it back to the caller for processing and  possible  insertion  into  a(nother)  database  for  example,  and  then  you want to do a next() to get the next wad of data, and so forth. 
The state is preserved  across  suspends  and  resumptions,  so  you  are  more  comfortable that you have a safe environment in which to process your data. Without gen- erators, you application code will likely have 
a very long function, with a very lengthy for loop inside of it.
Of course, just because a language has a feature does not mean you have
to use it. If there does not appear to be an obvious fit in your application, then do not add any more complexity! You will know when generators are the right thing to use when you come across an appropriate situation.
   你想要抓取一块数据，比如，将它返回给调用者来处理以及可能的对（另外一个）数据库的插入，接着你想要运行一次next()来获得下一块的数据，等等。状态在挂起和再继续的过程中是保留了的，所以你会觉得很舒服有一个安全的处理数据的环境。没有生成器的话，你的程序代码很有可能会有很长的函数，里面有一个很长的循环。当然，这仅仅是因为一个语言这样的特征不意味着你需要用它。如果在你程序里没有明显适合的话，那就别增加多余的复杂性！当你遇到合适的情况时，你便会知道什么时候生成器正是要使用的东西。

11.10.2  Enhanced Generator Features
加强的生成器特性

A few enhancements were made to generators in Python 2.5, so in addition to next() to get the next value generated, users can now send values back into generators [send()], they can raise exceptions in generators 

[throw()], and request that a generator quit [close()].
在python2.5中，一些加强特性加入到生成器中，所以除了next()来获得下个生成的值，用户可以将值回送给生成器[send()]，在生成器中抛出异常，以及要求生成器退出[close()]

　Due to the two-way action involved with code calling send() to send val- ues to a generator (and the generator yielding values back out), the yield statement now must be an expression since you may be receiving an 

incom- ing object when resuming execution back in the generator. Below is a simple example demonstrating some of these features. Let us take our simple clo- sure example, the counter:
    由于双向的动作涉及到叫做 send()的代码来向生成器发送值（以及生成器返回的值发送回来），现在yield语句必须是一个表达式，因为当回到生成器中继续执行的时候，你或许正在接收一个进入的对象。下面是一个展示了这些特性的，简单的例子。我们用简单的闭包例子，counter:

def counter(start_at=0): count = start_at while True:
 val = (yield count) if val is not None: count = val
else:
count += 1
　This generator takes an initial value, and counts up by one for each call to continue  the  generator  [next()].  Users  also  have  the  option  to  reset  this value if they so desire by calling send() with the new counter 
value instead
of calling next(). This generator runs forever, so if you wish to terminate it,
call the close() method. If we run this code interactively, we get the follow-
ing output:
   生成器带有一个初始化的值，对每次对生成器[next()]调用以1累加计数。用户已可以选择重置这个值，如果他们非常想要用新的值来调用send()不是调用next()。这个生成器是永远运行的，所以如果你想要终结它，调用close()方法。如果我们交互的运行这段代码，会得到如下输出：

>>> count = counter(5)
>>> count.next()
5
>>> count.next()
6
>>> count.send(9)
9
>>> count.next()
10
>>> count.close()
>>> count.next()
Traceback (most recent call last): File "<stdin>", line 1, in <module>
StopIteration
You can read more about generators in PEPs 255 and 342, as well as in this
Linux Journal article introducing readers to the new features in Python 2.2:
你可以在PEP的255和342中，以及给读者介绍python2.2中新特性的linux期刊文章中阅读到更多关于生成器的资料：

http://www.linuxjournal.com/article/5597

11.11  Exercises
练习

11C1. Arguments. Compare the following three functions:
参数。比较下面3个函数：

def countToFour1():
for eachNum in range(5):
print eachNum,

def countToFour2(n):
for eachNum in range(n, 5):
print eachNum,

def countToFour3(n=1):
for eachNum in range(n, 5):
print eachNum,
What do you think will happen as far as output from the pro- gram, given the following input values? Enter the output into Table 11.2 below. Write in “ERROR” if you think one will occur with the given input or “NONE” if 

there is no output.
给定如下的输入直到程序输出，你认为什么会发生？向下表11.2填入输出。如果你认为给定的输入会发生错误的话填入“ERROR"或者如果没有输出的话填入“NONE"

11C2. Functions. Combine your solutions for Exercise 5C2 such that you create a combination function that takes the same pair of numbers and returns both their sum and product at the same time.
11-2.函数。结合你对练习5-2的解，以便你创建一个带相同对数字并同时返回一它们之和以及产物的结合函数。
Table 11.2   Output Chart for Problem 11-1
表11.2 问题11-1的输出图

Input	countToFour1	countToFour2	countToFour3

2

4

5

(nothing)



11C3.   Functions. In this exercise, we will be implementing the
max() and min() built-in functions.
11-3 函数。在这个练习中，我们将实现max()和min()内建函数。

(a) Write simple functions max2() and min2() that take
two items and return the larger and smaller item, respec-
tively. They should work on arbitrary Python objects. For example, max2(4, 8) and min2(4, 8) would each return 8 and 4, respectively.
写分别带两个元素返回一个较大和较小元素，简单的max2()核min2()函数。他们应该可以用任意的python对象运作。举例来说，max2(4,8)和min2(4,8)会各自每次返回8和4。

(b) Create new functions my_max() and my_min() that use your solutions in part (a) to recreate max() and min(). These functions return the largest and smallest item of non-empty sequences, respectively. They can 

also take
a set of arguments as input. Test your solutions for numbers and strings.
创建使用了在a部分中的解来重构max()和min()的新函数my_max()和my_min().这些函数分别返回非空队列中一个最大和最小值。它们也能带一个参数集合作为输入。用数字和字符串来测试你的解。

11C4.   Return Values. Create a complementary function to your solution for Exercise 5C13. Create a function that takes a total time in minutes and returns the equivalent in hours and minutes.
返回值。给你在5-13的解创建一个补充函数。创建一个带以分为单位的总时间以及返回一个以小时和分为单位的等价的总时间。

11C5.   Default Arguments. Update the sales tax script you created in Exercise 5C7 such that a sales tax rate is no longer
required as input to the function. Create a default argument using your local tax rate if one is not passed in on invocation.
默认参数。更新你在练习5-7中创建的销售税脚本以便让销售税率不再是函数输入的必要之物。创建使用你地方税率的默认参数如果在调用的时候没有值传入。

11C6.   Variable-Length Arguments. Write a function called
printf(). There is one positional argument, a format string. The rest are variable arguments that need to be displayed to standard output based on the values in the format string, which allows the special string format 

operator directives
such as %d, %f, etc. Hint: The solution is trivial―there is no need to implement the string operator functionality, but you do need to use the string format operator ( % ) explicitly.
变长参数。下一个称为printf()的函数。有一个值参数，格式字符串。剩下的就是根据格式化字符串上的值，要显示在标准输出上的可变参数，格式化字符串中的值允许特别的字符串格式操作指示符，如%d, %f, etc。提示：解是很琐碎的----无需实现字符串操作符功能性，但你需要显示用字符串格式化操作（%）




11C7.   Functional Programming with map(). Given a pair of identically
sized lists, say [1, 2, 3, ...], and ['abc', 'def',
'ghi', ...], merge both lists into a single list consisting of
tuples of elements of each list so that our result looks like:
{[(1, 'abc'), (2, 'def'), (3, 'ghi'), ...}.
(Although this problem is similar in nature to a problem in
Chapter 6, there is no direct correlation between their solu- tions.) Then create another solution using the zip() built-
in function.
用map()进行函数式编程。给定一对同一大小的列表，如[1，2，3]和['abc','def','ghi',....]，将两个标归并为一个由每个列表元素组成的元组的单一的表，以使我们的结果看起来像这样：{[(1, 'abc'), (2, 'def'), (3, 'ghi'), ...}.（虽然这问题在本质上和第六章的一个问题相似，那时两个解没有直接的联系）然后创建用zip内建函数创建另一个解。

11C8.   Functional Programming with filter(). Use the code you created for Exercise 5C4 to determine leap years. Update your code so that it is a function if you have not done so already. Then write some code to take 

a list of years and return a list of only leap years. Then convert it to using list comprehensions.
用filer()进行函数式编程.使用练习5-4你给出的代码来决定闰年。更新你的代码一边他成为一个函数如果你还没有那么做的话。然后写一段代码来给出一个年份的列表并返回一个只有闰年的列表。然后将它转化为用列表解析。

11C9.   Functional Programming with reduce(). Review the code in Section 11.7.2 that illustrated how to sum up a set of numbers using reduce(). Modify it to create a new func-
tion called average() that calculates the simple average of
a set of numbers.
 用reduce()进行函数式编程。复习11.7.2部分，阐述如何用reduce()数字集合的累加的代码。修改它，创建一个叫average()的函数来计算每个数字集合的简单的平均值。

11C10. Functional Programming with filter(). In the Unix file system, there are always two special files in each folder/ directory: '.' indicates the current directory and '..' repre- sents the parent directory. Given this 

knowledge, take a look at the documentation for the os.listdir() function and describe what this code snippet does:

files = filter(lambda x: x and x[0] != '.', os. listdir(folder))
 用filter()进行函数式编程。在unix文件系统中，在每个文件夹或者目录中都有两个特别的文件：'.'表示现在的目录，'..'表示父目录。给出上面的知识，看下os.listdir()函数的文档并描述这段代码做了什么：
files = filter(lambda x: x and x[0] != '.', os. listdir(folder))

11C11. Functional Programming with map(). Write a program that takes a filename and “cleans” the file by removing all leading and trailing whitespace from each line. Read in the original file and write out a new one, 
either creating a new file or overwriting the existing one. Give your user the option to
pick which of the two to perform.  Convert your solution to using list comprehensions.
 用map()进行函数式编程。写一个使用文件名以及通过除去每行中所有排头和最尾的空白来“清洁“文件。在原始文件中读取然后写入一个新的文件，创建一个新的或者覆盖掉已存在的。给你的用户一个选择来决定执行哪一个。将你的解转换成使用列表解析。

11C12. Passing Functions. Write a sister function to the testit() function described in this chapter. Rather than testing exe- cution for errors, timeit() will take a function object
(along with any arguments) and time how long it takes to
execute the function. Return the following values: function
return value, time elapsed. You can use time.clock() or time. time(), whichever provides you with greater accu- racy. (The general consensus is to use time.time() on POSIX and time.clock() on Win32 systems.) Note: 
The timeit() function is not related to the timeit module
(introduced in Python 2.3).
传递函数。给在这章中描述的testit()函数写一个姊妹函数。timeit()会带一个函数对象（和参数一起）以及计算出用了多少时间来执行这个函数，而不是测试执行时的错误。返回下面的状态：函数返回值，消耗的时间。你可以用time.clock()或者time.time()，无论哪一个给你提供了较高的精度。（一般的共识是在POSIX上用time.time()，在win32系统上用time.clock()）注意：timeit()函数与timeit模块不相关(在python2.3中引入）

11C13. Functional Programming with reduce() and Recursion. In
Chapter 8, we looked at N factorial or N! as the product of
all numbers from 1 to N.
(a) Take a minute to write a small, simple function called
mult(x, y) that takes x and y and returns their product.
(b) Use the mult() function you created in part (a) along
with reduce() to calculate factorials.
(c) Discard the use of mult() completely and use a lambda
expression instead.
(d) In this chapter, we presented a recursive solution to find- ing N! Use the timeit() function you completed in the problem above and time all three versions of your factorial function (iterative, reduce(), and recursive). 
Explain any differences in performance, anticipated and actual.
 使用reduce()进行函数式编程以及递归。在第8张中，我们看到N的阶乘或者N!作为从1到N所有数字的乘积。
(a) 用一分钟写一个带x,y并返回他们乘积的名为mult(x,y)的简单小巧的函数。
(b)用你在a中创建mult()函数以及reduce来计算阶乘。
(c)彻底抛弃掉mult()的使用，用lamda表达式替代。
(d)在这章中，我们描绘了一个递归解决方案来找到N!用你在上面问题中完成的timeit()函数，并给三个版本阶乘函数计时(迭代的，reduce()以及递归）

11C14. *Recursion. We also looked at Fibonacci numbers in Chapter
8. Rewrite your previous solution for calculating Fibonacci numbers (Exercise 8C9) so that it now uses recursion.
递归。我们也来看下在第八章中的Fibonacci数字。重写你先前计算Fibonacci数字的解(练习8-9）以便你可以使用递归。

11C15. *Recursion. Rewrite your solution to Exercise 6C5, which prints a string backwards to use recursion. Use recursion to print a string forward and backward.
递归。从写练习6-5的解，用递归向后打印一个字符串。用递归向前以及向后打印一个字符串。

11C16. Upgrading easyMath.py. This script, presented as Exam- ple 11.1, served as the beginnings of a program to help
young people develop their math skills. Further enhance
this program by adding multiplication as a supported opera- tion. Extra credit: Add division as well; this is more difficult as you must find valid integer divisors. Fortunately for you, there is already code to ensure the 
numerator is greater than
the denominator so you do not need to support fractions.
更新easyMath.py。这个脚本，如例子11.1描绘的那样，以入门程序来帮助年轻人强化他们的数学技能。通过加入乘法作为可支持的操作来更进一步提升这个程序。额外的加分：也加入除法；这比较难做些因为你要找到有效的整数除数。幸运的是，已经有代码来确定分子比分母大，所以不需要支持分数。

11C17. Definitions.
定义
(a) Describe the differences between partial function appli- cation and currying.
	描述偏函数应用和currying之间的区别。
(b) What are the differences between partial function appli- cation and closures?
    偏函数应用和闭包之间有什么区别？
(c) Finally, how do iterators and generators differ?
    最后，迭代器和生成器是怎么区别开的？
 


11C18. *Synchronized Function Calling. Go back and review the hus-
band and wife situation presented in Chapter 6 (Section 6.20) when introducing shallow and deep copies. They shared a common account where simultaneous access to their bank account might have adverse effects.
同步化函数调用。复习下第六章中当引入浅拷贝和深拷贝的时候，提到的丈夫和妻子情形（6.20小结）。他们共用了一个普通账户，同时对他们银行账户访问时会发生不利影响。

　Create an application where calls to functions that change the account balance must be synchronized. In other words, only one process or thread can execute the function(s) at any given time. Your first attempt may use files, but a real solu- tion will use decorators and synchronization primitives found in either the threading or mutex modules. You may look ahead to Chapter 17 for more inspiration.

创建一个程序，让调用改变账户收支的函数必需同步。换句话说，在任意给定时刻只能有个一进程或者线程来执行函数。一开始你试着用文件，但是一个真正的解决方法是用装饰器和在threading或者mutex模块中的同步指令。你看看第17张来获得更多的灵感。
