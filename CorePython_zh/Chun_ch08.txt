Conditionals and Loops 条件和循环
:- andelf (gt:andelf@gmail.com)已认领 
%%mtime(%c) 编译

%% 句子有些复杂, 翻译完成后自己先校对下 -by andelf

%%
%% 本章翻译结束
%% 个别排版无法识别.
%%  2007 - 10 - 20 14:02
%%  稍候自行校对

========================================================================

%!target: html
%!encoding: utf-8

%!options: --css-sugar --style style.css --enum-title --toc --toc-level 2

= 本章目录部分 =

Chapter Topics

 - if Statement
 - else Statement
 - elif Statement
 - Conditional Expressions
 - while Statement
 - for Statement
 - break Statement
 - continue Statement
 - pass Statement
 - else Statement . . . Take Two
 - Iterators
 - List Comprehensions
 - Generator Expressions


本章主题

 - if 语句
 - else 语句
 - elif 语句
 - 条件表达式
 - while 语句
 - for 语句
 - break 语句
 - continue 语句
 - pass 语句
 - else 语句 (再看)
 - Iterators 迭代器
 -  列表解析（List Comprehensions）
 - 生成器表达式（Generator Expressions ）

----------------------------------------------------------------
 
The primary focus of this chapter are Python’s conditional and looping
statements, and all their related components. We will take a close look
at if, while, for, and their friends else, elif, break, continue, and pass.
　　　
本章的主要内容是 Python 的条件和循环语句以及与它们相关的部分. 我们会深入探讨 
if , while , for 以及与他们相搭配的 else , elif , break , continue 和 pass 语句.

-------------------------------------------------------------------


= if 语句 =
8.1 if Statement

The if statement for Python will seem amazingly familiar. It is made up of three main components: the keyword itself, an expression that is tested for its truth value, and a code suite to execute if the expression evaluates to non- zero or true. The syntax for an if statement is:

```
if expression:
    expr_true_suite
```

The suite of the if clause, expr_true_suite, will be executed only if the above conditional expression results in a Boolean true value. Otherwise, execution resumes at the next statement following the suite.

Python 中的 if 子句看起来十分熟悉. 它由三部分组成: 关键字本身, 
用于判断结果真假的条件表达式, 以及当表达式为真或者非零时执行的代码块. 
if 语句的语法如下:

```
if expression:
    expr_true_suite
```

if 语句的 expr_true_suite 代码块只有在条件表达式的结果的布尔值为真时才执行, 
否则将继续执行紧跟在该代码块后面的语句.

== 多重条件表达式 ==
8.1.1 Multiple Conditional Expressions

The Boolean operators and, or, and not can be used to provide multiple condi- tional expressions or perform negation of expressions in the same if statement.

if not warn and (system_load >= 10): print "WARNING: losing resources" warn += 1

单个 if 语句可以通过使用布尔操作符 and , or 和 not 
实现多重判断条件或是否定判断条件.

```
if not warn and (system_load >= 10):
    print "WARNING: losing resources"
	warn += 1
```

== 单一语句的代码块 ==
8.1.2 Single Statement Suites

If the suite of a compound statement, i.e.,  if clause, while or for loop, consists  only  of  a  single  line,  it  may  go  on  the  same  line  as  the  header statement:

if make_hard_copy: send_data_to_printer()

Single line statements such as the above are valid syntax-wise; however, although it may be convenient, it may make your code more difficult to read,
so we recommend you indent the suite on the next line. Another good reason
is that if you must add another line to the suite, you have to move that line down anyway.

如果一个复合语句(例如 if 子句, while 或 for 循环)的代码块仅仅包含一行代码, 那么它可以和前面的语句写在同一行上:

```
if make_hard_copy: send_data_to_printer()
```

上边这样的单行语句是合法的,  尽管它可能方便, 但这样会使得代码更难阅读, 所以我们推荐将这行代码移到下一行并合理地缩进. 另外一个原因就是如果你需要添加新的代码, 你还是得把它移到下一行.
  
= else 语句 =
8.2 else Statement

Like other languages, Python features an else statement that can be paired with an if statement. The else statement identifies a block of code to be executed if the conditional expression of the if statement resolves to a false Boolean value. The syntax is what you expect:

if expression:
expr_true_suite
else:
expr_false_suite
Now we have the obligatory usage example:

if passwd == user.passwd:
ret_str = "password accepted"
id = user.id valid = True
else:
ret_str = "invalid password entered... try again!"
valid = False

和其他语言一样, Python 提供了与 if 语句搭配使用的 else 语句. 
如果 if 语句的条件表达式的结果布尔值为假, 那么程序将执行 else 语句后的代码. 它的语法你甚至可以猜到:

```
if expression:
    expr_true_suite
else:
    expr_false_suite
```

这里是样例代码:

```
if passwd == user.passwd:
    ret_str = "password accepted"
    id = user.id valid = True
else:
    ret_str = "invalid password entered... try again!"
    valid = False
```

== 避免“悬挂 else”==
8.2.1 “Dangling else” Avoidance


Python’s design of using indentation rather than braces for code block delimitation not only helps to enforce code correctness, but it even aids implicitly in avoiding potential problems in code that  is syntactically correct. One of those such problems is the (in)famous “dangling else” problem, a semantic optical illusion.

Python 使用缩进而不是用大括号标记代码块边界的设计, 不仅帮助强化了代码的正确性, 
而且还暗中帮助程序员避免了语法上正确的代码中存在潜在的问题. 
其中一个问题就是(臭名）昭著的 "悬挂 else (dangling else)"问题, 一种语义错觉.

We present some C code here to illustrate our example (which is also illu- minated by K&R and other programming texts):

我们在这里给出一段 C 代码来说明我们的例子( K&R 和其他的编程教材也给出过):

```
/* dangling-else in C */
if (balance > 0.00)
    if (((balance - amt) > min_bal) && (atm_cashout() == 1))
        printf("Here's your cash; please take all bills.\n");
else
    printf("Your balance is zero or negative.\n");
```

The question is, which if does the else belong to? In the C language, the rule  is  that  the  else stays  with  the  closest  if.  In  our  example  above, although  indented  for  the  outer  if statement,  the  else statement  really belongs to the inner if statement because the C compiler ignores superfluous whitespace. As a result, if you have a positive balance but it is below the minimum, you will get the horrid (and erroneous) message that your balance is either zero or negative.

问题是: else 属于哪个 if ? 在 C 语言中, 规则是 else 
与最近的 if 搭配. 所以我们上面的例子中, else 虽然是想和外层的 
if 搭配, 但是事实上 else 属于内部的 if ,因为 C 编译器会忽略额外的空白. 
结果, 如果你的 balance 是正数但小于最小值, 你将得到错误的输出, 
程序会显示你的 balance 是零或者为负数.

Although solving this problem may be easy due to the simplistic nature of the  example,  any  larger  sections  of  code  embedded  within  this  framework may be a hair-pulling experience to root out. Python puts up guardrails not necessarily to prevent you from driving off the cliff, but to steer you away from danger. The same example in Python will result in one of the following choices (one of which is correct):

由于这个例子很简单, 所以解决这个问题并不难, 但是如果是大块的代码嵌入到
了类似这样的框架中, 那么发现并改正程序中的错误需要耗费很多精力. 
Python 设置的护栏不仅阻止你掉下悬崖, 而且会带你离开危险的境地. 在 Python 
中相同的例子对应如下的两种代码(只有一种是正确的):

```
if balance > 0.00:
    if balance - amt > min_bal and atm_cashout():
        print "Here's your cash; please take all bills."
else:
    print 'Your balance is zero or negative.'
```

或者是:

```
if balance > 0.00:
    if balance - amt > min_bal and atm_cashout():
        print "Here's your cash; please take all bills."
    else:
        print 'Your balance is zero or negative.'
```                     
                       
Python’s use of indentation forces the proper alignment of code, giving the programmer the ability to make a conscious decision as to which if an else statement  belongs  to.  By  limiting  your  choices  and  thus  reducing  ambiguities,  Python  encourages  you  to  develop  correct  code  the  first  time.  It  is impossible to create a dangling else problem in Python. Also, since parentheses are not required, Python code is easier to read.

Python 的缩进使用强制使代码正确对齐, 让程序员来决定 else 属于哪一个 if . 
限制您的选择从而减少了不确定性, Python 鼓励您第一次就写出正确的代码. 
在 Python 中制造出“悬挂 else” 问题是不可能的, 而且, 由于大括号不再被使用, 
Python 代码更易读懂.

= elif (即 else-if )语句 =
8.3 elif (aka else-if) Statement

elif is the Python else-if statement. It allows one to check multiple expressions for truth value and execute a block of code as soon as one of the  conditions  evaluates  to  true.  Like  the  else,  the  elif statement  is optional. However, unlike else, for which there can be at most one statement,  there  can  be  an  arbitrary  number  of  elif statements  following an if.

elif 是 Python 的 else-if 语句, 它检查多个表达式是否为真, 并在为真时执行特定代码块中的代码. 和 else 一样, elif 声明是可选的, 
然而不同的是, if 语句后最多只能有一个 else 语句, 但可以有任意数量的 
elif 语句.

```
if expression1:
    expr1_true_suite
elif expression2:
    expr2_true_suite

elif expressionN:
    exprN_true_suite
else:
    none_of_the_above_suite
```    

Proxy for switch/case Statement?

switch/case 语句的替代品么?

At some time in the future, Python may support the switch or case state- ment, but you can simulate it with various Python constructs. But even a good  number  of  if-elif statements  are  not  that  difficult  to  read  in Python:

在将来的某天, Python 可能会支持 switch /case 语句, 但是你完全可以用其他的 Python 结构来模拟它. 在 Python 中, 大量的 if-elif 语句并不难阅读:

```
if user.cmd == 'create':
    action = "create item"

elif user.cmd == 'delete':
    action = 'delete item'

elif user.cmd == 'update':
    action = 'update item'

else:
    action = 'invalid choice... try again!'
```

Although  the  above  statements  do  work,  you  can  simplify  them  with  a sequence and the membership operator:

上面的语句完全可以满足我们的需要, 不过我们还可以用序列和成员关系操作符来简化它:

```
if user.cmd in ('create', 'delete', 'update'):
    action = '%s item' % user.cmd
else:
    action = 'invalid choice... try again!'
```

We can create an even more elegant solution using Python dictionaries, which we learned about in Chapter 7, “Mapping and Set Types”.

另外我们可以用 Python 字典给出更加优雅的解决方案, 我们将在第七章 "映射和集合类型" 中介绍字典.

```
msgs = {'create': 'create item',
    'delete': 'delete item',
    'update': 'update item'}
default = 'invalid choice... try again!'
action = msgs.get(user.cmd, default)
```
                   
One well-known benefit of using mapping types such as dictionaries is that the searching is very fast compared to a sequential lookup as in the above if- elif-else statements or using a for loop, both of which have to scan the elements one at a time.
　
众所周知, 使用映射对象(比如字典)的一个最大好处就是它的搜索操作比类似 
 if-elif-else 语句或是 for 循环这样的序列查询要快很多.

=条件表达式(即"三元操作符")=
8.4  Conditional Expressions
(aka “the Ternary Operator”)

If you are coming from the C/C++ or Java world, it is difficult to ignore or get over the fact that Python has not had a conditional or ternary operator (C ? X : Y) for the longest time. (C is the conditional expression; X represents the resultant expression if C is True and Y if C is False.) van Rossum Guido has resisted adding such a feature to Python because of his belief in keeping code simple and not giving programmers easy ways to obfuscate their code. However, after more than a decade, he has given in, mostly because of the error-prone ways in which people have tried to simulate it using and and or, many times incorrectly. According to the FAQ, the one way of getting it right is (C and [X] or [Y])[0]. The only problem was that the community could not agree on the syntax. (You really have to take a look at PEP 308 to see all the different proposals.) This is one of the areas of Python in which people have expressed strong feelings.
 
如果你来自 C/C++ 或者是 Java 世界, 那么你很难忽略的一个事实就是 
Python 在很长的一段时间里没有条件表达式(C ? X : Y), 或称三元运算符. (
 C 是条件表达式; X 是 C 为 True 时的结果, Y 是 C 为 False 时的结果) 
贵铎·范·罗萨姆一直拒绝加入这样的功能, 因为他认为应该保持代码简单, 
让程序员不轻易出错. 不过在十年多后, 他放弃了, 主要是因为人们试着用 
and 和 or 来模拟它, 但大多都是错误的. 根据 FAQ , 正确的方法(并不唯一)是 
(C and [X] or [Y])[0] . 唯一的问题是社区不同意这样的语法. (你可以
看一看 PEP 308, 其中有不同的方案.) 对于Python的这一问题，人们表达了极大的诉求.
 
The final decision came down to van Rossum Guido choosing the most favored
(and his most favorite) of all the choices, then applying it to various modules in the standard library. According to the PEP, “this review approximates a sampling of real-world use cases, across a variety of applications, written by a number
of programmers with diverse backgrounds.” And this is the syntax that was finally chosen for integration into Python 2.5: X if C else Y.

贵铎·范·罗萨姆最终选择了一个最被看好(也是他最喜欢)的方案, 然后把它运用于标准库
中的一些模块. 根据 PEP , "这个评审通过考察大量现实世界的案例, 包含不同的应用, 
以及由不同程序员完成的代码." 最后 Python 2.5 集成的语法确定为: X if C else Y .

The main motivation for even having a ternary operator is to allow the setting
of a value based on a conditional all on a single line, as opposed to the stan- dard  way  of  using  an  if-else statement,  as  in  this  min() example  using numbers x and y:

有了三元运算符后你就只需要一行完成条件判断和赋值操作, 
而不需要像下面例子中的min()那样，使用if-else语句实现对数字x和y的操作:

```
>>> x, y = 4, 3
>>> if x < y:
...	    smaller = x
... else:
...	    smaller = y
...
>>> smaller
3
```

In versions prior to 2.5, Python programmers at best could do this:

在 2.5 以前的版本中, Python 程序员最多这样做(其实是一个 hack ):

```
>>> smaller = (x < y and [x] or [y])[0]
>>> smaller
3
```

In versions 2.5 and newer, this can be further simplified to:

在 2.5 和更新的版本中, 你可以使用更简明的条件表达式：

```
>>> smaller = x if x < y else y
>>> smaller
3
```

= while 语句 =
8.5 while Statement


Python’s while is the first looping statement we will look at in this chapter. In fact, it is a conditional looping statement. In comparison with an  if state- ment where a true expression will result in a single execution of the if clause suite, the suite in a while clause will be executed continuously in a loop until that condition is no longer satisfied.

Python 的 while 是本章我们遇到的第一个循环语句. 事实它上是一个条件循环语句. 与 if 声明相比, 如果 if 后的条件为真,  就会执行一次相应的代码块. 而 while 中的代码块会一直循环执行, 直到循环条件不再为真.

== 一般语法 ==
8.5.1 General Syntax

while 循环的语法如下:

```
while expression:
    suite_to_repeat
```

The suite_to_repeat clause of the while loop will be executed continu-
ously in a loop until expression evaluates to Boolean False. This type of
looping mechanism is often used in a counting situation, such as the example
in the next subsection.

while 循环的 suite_to_repeat 子句会一直循环执行, 直到 expression 值为布尔假. 
这种类型的循环机制常常用在计数循环中, 请参见下节中例子.

== 计数循环 ==
8.5.2 Counting Loops

```
count = 0
while (count < 9):
    print 'the index is:', count 
    count += 1
```

The suite here, consisting of the print and increment statements, is executed repeatedly until count is no longer less than 9. With each iteration, the current value of the index count is displayed and then bumped up by
1. If we take this snippet of code to the Python interpreter, entering the source and seeing the resulting execution would look something like:

这里的代码块里包含了 print 和自增语句, 它们被重复执行, 直到 count 不再小于 9 . 
索引 count 在每次迭代时被打印出来然后自增 1 . 在 Python 解释器中输入这些代码
我们将得到这样的结果:

```
>>> count = 0
>>> while (count < 9):
...	    print 'the index is:', count
...	    count += 1
...

the index is: 0
the index is: 1
the index is: 2
the index is: 3
the index is: 4
the index is: 5
the index is: 6
the index is: 7
the index is: 8
```

==无限循环==
8.5.3 Infinite Loops

One  must  use  caution  when  using  while loops  because  of  the  possibility that the condition never resolves to a false value. In such cases, we would have a loop that never ends on our hands. These “infinite” loops are not nec- essarily bad things—many communications “servers” that are part of client/ server  systems  work  exactly  in  that  fashion.  It  all  depends  on  whether  or not the loop was meant to run forever, and if not, whether the loop has the possibility of terminating; in other words, will the expression ever be able to evaluate to false?

你必须小心地使用 while 循环, 因为有可能 condition 永远不会为布尔假. 
这样一来循环就永远不会结束. 这些"无限"的循环不一定是坏事, 
许多通讯服务器的客户端/服务器系统就是通过它来工作的. 这取决于循环
是否需要一直执行下去, 如果不是, 那么这个循环是否会结束; 也就是说, 
条件表达式会不会计算后得到布尔假?

```
while True:
    handle, indata = wait_for_client_connect() 
    outdata = process_request(indata) 
    ack_result_to_client(handle, outdata)
```

For example, the piece of code above was set deliberately to never end because True is not going to somehow change to False. The main point of this server code is to sit and wait for clients to connect, presumably over a network link. These clients send requests which the server understands and processes.

例如上边的代码就是故意被设置为无限循环的，因为True无论如何都不会变成False. 这是因为服务器代码是用来等待
客户端(可能通过网络)来连接的. 这些客户端向服务器发送请求, 
服务器处理请求.

After the request has been serviced, a return value or data is returned to the  client  who  may  either  drop  the  connection  altogether  or  send  another request. As far as the server is concerned, it has performed its duty to this one client and returns to the top of the loop to wait for the next client to come along. You will find out more about client/server computing in Chapter 16, “Network Programming” and Chapter 17, “Internet  Client Programming.”

请求被处理后, 服务器将向客户端返回数据, 而此时客户端可能断开连接或是发送另一个请求. 
对于服务器而言它已经完成了对这个客户端的任务, 它会返回最外层循环等待下一个
连接. 在第 16 章, "网络编程" 和第 17 章节 "Internet 客户端编程" 里你将了解
关于如何处理客户端/服务器的更多信息.

= for 语句 =
8.6 for Statement

The other looping mechanism in Python comes to us in the form of the for statement.  It  represents  the  single  most  powerful  looping  construct  in Python. It can loop over sequence members, it is used in list comprehensions and generator expressions, and it knows how to call an iterator’s next() method and gracefully ends by catching StopIteration exceptions (all under the covers). If you are new to Python, we will tell you now that you will be using for statements a lot.
Unlike the traditional conditional looping  for statement found in main-
stream languages like C/C++, Fortran, or Java, Python’s for is more akin to a
shell or scripting language’s iterative foreach loop.

Python 提供给我们的另一个循环机制就是 for 语句. 它提供了 Python 
中最强大的循环结构. 它可以遍历序列成员, 可以用在 列表解析 和 
生成器表达式中, 它会自动地调用迭代器的 next() 方法, 捕获 
StopIteration 异常并结束循环(所有这一切都是在内部发生的). 如果你刚刚接触 Python 
那么我们要告诉你, 在以后你会经常用到它的. 和传统语言(例如 C/C++ , Fortran, 
或者 Java )中的 for 语句不同, Python 的 for 更像是 shell 或是脚本语言中的 foreach 循环.

== 一般语法 ==
8.6.1 General Syntax

The  for loop  traverses  through  individual  elements  of  an  iterable  (like  a sequence or iterator) and terminates when all the items are exhausted. Here
is its syntax:

for 循环会访问一个可迭代对象(例如序列或是迭代器)中的所有元素, 并在所有条目都处理过后结束循环. 它的语法如下:

```
for iter_var in iterable:
    suite_to_repeat
```

With each loop, the iter_var iteration variable is set to the current ele-
ment  of  the  iterable  (sequence,  iterator,  or  object  that  supports  iteration),
presumably for use in suite_to_repeat.

每次循环, iter_var 迭代变量被设置为可迭代对象(序列, 迭代器, 或者是其他支持迭代的对象)的当前元素, 提供给 suite_to_repeat 语句块使用.

== 用于序列类型 ==
8.6.2 Used with Sequence Types
      
In  this  section,  we  will  see  how  the  for loop  works  with  the  different sequence types. The examples will include string, list, and tuple types.

本节中, 我们将学习用 for 循环迭代不同的序列对象. 样例将涵盖字符串, 列表, 以及元组.

```
>>> for eachLetter in 'Names':
...	print 'current letter:', eachLetter
...
current letter: N
current letter: a
current letter: m
current letter: e
current letter: s
```

When iterating over a string, the iteration variable will always consist of only single characters (strings of length 1). Such constructs may not necessar- ily be useful. When seeking characters in a string, more often than not, the programmer will either use in to test for membership, or one of the string
module functions or string methods to check for substrings.

当迭代字符串时, 迭代变量只会包含一个字符(长度为 1 的字符串). 但这并不常用。在字符串里中查找字符时, 
程序员往往使用 in 来测试成员关系, 或者使用 string 模块中的函数以及字符串方法来检查子字符串.

One place where seeing individual characters does come in handy is during the debugging of sequences in a for loop in an application where you are expecting strings or entire objects to show up in your print statements. If you see individual characters, this is usually a sign that you received a single string rather than a sequence of objects.

看到单个的字符在一种情况下有用，即在通过 print 语句调试for 循环中的序列时, 如果你在应该看到字符串的地方发现的却是单个的字符, 
那么很有可能你接受到的是一个字符串, 而不是对象的序列.

There are three basic ways of iterating over a sequence:

迭代序列有三种基本方法:

Iterating by Sequence Item

===通过序列项迭代===

```
>>> nameList = ['Walter', "Nicole", 'Steven', 'Henry']
>>> for eachName in nameList:
...	    print eachName, "Lim"
...
Walter Lim 
Nicole Lim 
Steven Lim 
Henry Lim
```

In  the  above  example,  a  list  is  iterated  over,  and  for  each  iteration,  the eachName variable contains the list element that we are on for that particu- lar iteration of the loop.

在上面的例子中, 我们迭代一个列表. 每次迭代, eacgName 变量都被设置为列表中特定某个元素, 
然后我们在代码块中打印出这个变量.

Iterating by Sequence Index

===通过序列索引迭代===

An alternative way of iterating through each item is by index offset into the sequence itself:

另个方法就是通过序列的索引来迭代:

```
>>> nameList = ['Cathy', "Terry", 'Joe', 'Heather',
'Lucy']
>>> for nameIndex in range(len(nameList)):
...	print "Liu,", nameList[nameIndex]
...
Liu, Cathy 
Liu, Terry 
Liu, Joe
Liu, Heather
Liu, Lucy
```

Rather than iterating through the elements themselves, we are iterating through the indices of the list.

我们没有迭代元素, 而是通过列表的索引迭代.

We employ the assistance of the len() built-in function, which provides the total number of elements in the tuple as well as the  range() built-in function (which we will discuss in more detail below) to give us the actual sequence to iterate over.

这里我们使用了内建的 len() 函数获得序列长度, 使用 range() 函数(我们将在下面详细讨论它)创建了要迭代的序列.
```
>>> len(nameList)
5
>>> range(len(nameList))
[0, 1, 2, 3, 4]
```

Using range(), we obtain a list of the indexes that nameIndex iterates over; and using the slice/subscript operator ( [ ] ), we can obtain the corre- sponding sequence element.

使用 range() 我们可以得到用来迭代 nameList 的索引数列表; 使用切片/下标操作符( [ ] ), 就可以访问对应的序列对象.

Those of you who are performance pundits will no doubt recognize that iteration by sequence item wins over iterating via index. If not, this is some- thing to think about. (See Exercise 8–13.)

如果你对性能有所了解的话, 那么毫无疑问你会意识到
直接迭代序列要比通过索引迭代快. 如果你不明白, 那么你可以仔细想想. 
(参见练习 8-13).

Iterating with Item and Index

===使用项和索引迭代===

The best of both worlds comes from using the enumerate() built-in function, which was added to Python in version 2.3. Enough said . . . here is some code:

两全其美的办法是使用内建的 enumerate() 函数, 它是 Python 2.3 的新增内容. 代码如下:

```
>>> nameList = ['Donn', 'Shirley', 'Ben', 'Janice',
...	    'David', 'Yen', 'Wendy']
>>> for i, eachLee in enumerate(nameList):
...	    print "%d %s Lee" % (i+1, eachLee)
...
1 Donn Lee
2 Shirley Lee
3 Ben Lee
4 Janice Lee
5 David Lee
6 Yen Lee
7 Wendy Lee
```

== 用于迭代器类型 ==
8.6.3 Used with Iterator Types

Using for loops with iterators is identical to using them with sequences. The only difference is that the for statement must do a little bit of extra work on your behalf. An iterator does not represent a set of items to loop over.

用 for 循环访问迭代器和访问序列的方法差不多. 唯一的区别就是 for 语句会为
你做一些额外的事情. 迭代器并不代表循环条目的集合.

Instead, iterator objects have a next() method, which is called to get sub- sequent items. When the set of items has been exhausted, the iterator raises the StopIteration exception to signal that it has finished. Calling next() and catching StopIteration is built-in to the for statement.

迭代器对象有一个 next() 方法, 调用后返回下一个条目. 所有条目迭代完后, 
迭代器引发一个 StopIteration 异常告诉程序循环结束. for 语句在内部调用 
next() 并捕获异常.

When you are using a for loop with an iterator, the code is nearly identical
to that of looping over sequence items. In fact, for most cases, you cannot tell
that you are iterating over a sequence or an iterator, hence the reason why you will see us refer to iterating over an iterable, which could mean a sequence, an iterator, or any object that supports iteration, e.g., has a next() method.

使用迭代器做 for 循环的代码与使用序列条目几乎完全相同. 事实上在大多情况下, 
你无法分辨出你迭代的是一个序列还是迭代器, 因此，这就是为什么我们在说要遍历一个迭代器时，实际上可能我们指的是要遍历一个序列，迭代器，或是一个支持迭代的对象（它有next()方法）。

== range() 内建函数 ==
8.6.4 range() Built-in Function
       

We mentioned above during our introduction to Python’s for loop that it is an iterative looping mechanism. Python also provides a tool that will let us use the for statement in a traditional pseudo-conditional setting, i.e., when counting from one number to another and quitting once the final number has been reached or some condition is no longer satisfied.

我们前面介绍 Python 的 for 循环的时候提到过它是一种迭代的循环机制. Python 
同样提供一个工具让我们在传统的伪条件设置下使用 for 声明, 
例如从一个数字开始计数到另外个数字, 一旦到达最后的数字或者某个条件不再满足就立刻退出循环.

The built-in function range() can turn your foreach-like for loop back into one that you are more familiar with, i.e., counting from 0 to 10, or count- ing from 10 to 100 in increments of 5.

内建函数 range() 可以把类似 foreach 的 for 循环变成你更加熟悉的语句. 例如从 0 到 10 计数, 或者从 10 到 100 一次递增 5 .
　

range() Full Syntax
=== range() 的完整语法===

Python presents two different ways to use range(). The full syntax requires that two or all three integer arguments are present:

Python 提供了两种不同的方法来调用 range() . 完整语法要求提供两个或三个整数参数:

```
range(start, end, step =1)
```

range() will then return a list where for any k, start <= k < end and k iterates from start to end in increments of step. step cannot be 0, or an error condition will occur.

range() 会返回一个包含所有 k 的列表, 这里 start <= k < end , 从 start 到 end , k 每次
递增 step . step 不可以为零,否则将发生错误.  

```
>>> range(2, 19, 3)
[2, 5, 8, 11, 14, 17]
```

If  step is  omitted  and  only  two  arguments  given,  step takes  a  default value of 1.

如果只给定两个参数，而省略 step, step就使用默认值 1 .

```
>>> range(3, 7)
[3, 4, 5, 6]
```

Let’s take a look at an example used in the interpreter environment:

我们来看看解释器环境下的例子

```
>>> for eachVal in range(2, 19, 3):
...	    print "value is:", eachVal
...
value is: 2 
value is: 5 
value is: 8 
value is: 11 
value is: 14 
value is: 17
```

Our for loop now “counts” from 2 to 19, incrementing by steps of 3. If you are familiar with C, then you will notice the direct correlation between the arguments of range() and those of the variables in the C for loop:

我们的循环从 2 "数" 到 19 , 每次递增 3 . 如果你对 C 熟悉的话, 你会发现，range()的参数与C的for循环变量有着直接的关系:

```
/* equivalent loop in C */
for (eachVal = 2; eachVal < 19; eachVal += 3) {
    printf("value is: %d\n", eachVal);
}
```

Although it seems like a conditional loop now (checking if eachVal<19), reality tells us that range() takes our conditions and generates a list that meets our criteria, which in turn is used by the same Python for statement.

虽然看起来像是一个条件循环(检查 eachVal< 19 ), 但实际上是 range() 先用我们指定的条件
生成一个列表, 然后把列表用于这个 for 语句.

range() Abbreviated Syntax
===range() 简略语法===

range() also has two abbreviated syntax formats:

range() 还有两种简略的语法格式:

```
range(end)

range(start, end)
```

We saw the shortest syntax earlier in Chapter 2. Given only a single value, start defaults to 0, step defaults to 1, and range() returns a list of num- bers from zero up to the argument end:

我们在第 2 章看到过最短的语法 接受一个值, start 默认为 0 , step 默认为 1 , 然后 range()
返回从 0 到 end 的数列.

```
>>> range(5)
[0, 1, 2, 3, 4]
```

Given two values, this midsized version of range() is exactly the same as the long version of range() taking two parameters with step defaulting to
1. We will now take this to the Python interpreter and plug in for and print
statements to arrive at:

range() 的中型版本和完整版本几乎完全一样, 只是 step 使用默认值 1 . 现在我们在 Python 
解释器中试下这条语句:

```
>>> for count in range(2, 5):
...	    print count
...
2
3
4
```


CORE NOTE: Why not just one syntax for range()?

核心笔记: 为什么 range() 不是只有一种语法?

Now that you know both syntaxes for range(), one nagging question
you may have is, why not just combine the two into a single one that looks
like this?

你已经知道了 range() 的所有语法, 有些人可能会问一个挑剔的问题, 为什么不把
这两种语法合并成一个下面这样的语法?

```
range(start=0, end, step =1) # 错误
```

This syntax will work for a single argument or all three, but not two. It is illegal because the presence of step requires start to be given. In other words, you cannot provide end and step in a two-argument version
because they will be (mis)interpreted as start and end.

这个语法不可以使用两个参数调用. 因为 step 要求给定 start . 换句话说, 你不能
只传递 end 和 step 参数. 因为它们会被解释器误认为是 start 和 end .


8.6.5 xrange() Built-in Function
=== xrange() 内建函数===

xrange() is similar to range() except that if you have a really large range list, xrange() may come in handier because it does not have to make a com- plete copy of the list in memory. This built-in was made for exclusive use in for loops. It does not make sense outside a for loop. Also, as you can imag- ine,  the  performance  will  not  be  as  good  because  the  entire  list  is  not  in memory. In future versions of Python, range() will eventually become like xrange(), returing an iterable object (not a list nor an iterator though)—it will be similar to views as discussed in the previous chapter.

xrange() 类似 range() , 不过当你有一个很大的范围列表时, xrange() 可能更为适合, 
因为它不会在内存里创建列表的完整拷贝. 它只被用在 for 循环中, 在 for 循环外使用它没有意义。
同样地, 你可以想到, 它的性能远高出 range(), 因为它不生成整个列表。
在 Python 的将来版本中, range() 可能会像 xrange() 一样, 返回一个可迭代对象(不是列表
也不是一个迭代器) - 它会像前边一章讨论的那样. 


8.6.6 Sequence-Related Built-in Functions
===与序列相关的内建函数===

sorted(), reversed(), enumerate(), zip()

Below  are  some  examples  of  using  these  loop-oriented  sequence-related functions. The reason why they are “sequence-related” is that half of them
(sorted()and  zip())  return  a  real  sequence  (list),  while  the  other  two
(reversed() and enumerate()) return iterators (sequence-like).

下边是使用循环相关和序列相关函数的例子. 为什么它们叫"序列相关"呢? 
是因为其中两个函数( sorted() 和  zip() )返回一个序列(列表), 而另外两个函数
( reversed() 和 enumerate() ) 返回迭代器(类似序列) 

```
>>> albums = ('Poe', 'Gaudi', 'Freud', 'Poe2')
>>> years = (1976, 1987, 1990, 2003)
>>> for album in sorted(albums):
...	    print album,
...
Freud Gaudi Poe Poe2
>>>
>>> for album in reversed(albums):
...	    print album,
...
Poe2 Freud Gaudi Poe
>>>
>>> for i, album in enumerate(albums):
...	    print i, album
...
0 Poe
1 Gaudi
2 Freud
3 Poe2
>>>
>>> for album, yr in zip(albums, years):
...	    print yr, album
...
1976 Poe
1987 Gaudi
1990 Freud
2003 Poe2
```

Now that we have covered all the loops Python has to offer, let us take a look at the peripheral commands that typically go together with loops. These include statements to abandon the loop (break) and to immediately begin the next iteration (continue).

我们已经涵盖了 Python 中的所有循环语句, 下面我们看看循环相关的语句, 
包括用于放弃循环的 break 语句, 和立即开始下一次迭代的 continue 语句. 

= break 语句 =
8.7 break Statement

The  break statement  in  Python  terminates  the  current  loop  and  resumes execution at the next statement, just like the traditional break found in C. The  most  common  use  for  break is  when  some  external  condition  is  triggered (usually by testing with an if statement), requiring a hasty exit from a loop. The break statement can be used in both while and for loops.

Python 中的 break 语句可以结束当前循环然后跳转到下条语句, 类似 C 中的传统 break . 常用在当某个外部条件被触发(一般通过 if 语句检查), 需要立即从循环中退出时. break 语句可以用在 while 和 for 循环中.

```
count = num / 2
while count > 0:
    if num % count == 0:
        print count, 'is the largest factor of', num
        break
    count -= 1
```

　The task of this piece of code is to find the largest divisor of a given num- ber num. We iterate through all possible numbers that could possibly be factors of num, using the count variable and decrementing for every value that does not divide num. The first number that evenly divides num is the largest factor, and once that number is found, we no longer need to continue and use break to terminate the loop.

上边这段代码用于寻找给定数字 num 的最大约数. 我们迭代所有可能的约数, count 变量依次递减, 第一个能整除 num 的就是我们要找的最大约数，找到后就不再再继续找了, 使用 break 语句退出循环.

```
phone2remove = '555-1212'
for eachPhone in phoneList:
    if eachPhone == phone2remove:
        print "found", phone2remove, '... deleting'
        deleteFromPhoneDB(phone2remove)
        break
```

The break statement here is used to interrupt the iteration of the list. The goal is to find a target element in the list, and, if found, to remove it from the database and break out of the loop.

这里的 break 语句用于打断列表的迭代. 目的是为了找到
列表中的目标元素, 如果找到, 则把它从数据库里删除然后退出循环.

=continue 语句=
8.8 continue Statement


CORE NOTE: continue statements

Whether in Python, C, Java, or any other structured language that features the continue statement, there is a misconception among some beginning programmers that the traditional continue statement “immediately starts the next iteration of a loop.” While this may seem to be the apparent
action, we would like to clarify this somewhat invalid supposition. Rather
than beginning the next iteration of the loop when a continue statement is encountered, a continue statement terminates or discards the remaining statements in the current loop iteration and goes back to the top. If we are in
a conditional loop, the conditional expression is checked for validity before beginning the next iteration of the loop. Once confirmed, then the next iteration begins. Likewise, if the loop were iterative, a determination must be
made as to whether there are any more arguments to iterate over. Only when
that validation has completed successfully can we begin the next iteration.

核心笔记: continue 语句

不管是Python, C, Java 还是其它任何支持continue语句的结构化语言中, 一些初学者有这样的一个误解:
continue 语句"立即启动循环的下一次迭代". 实际上, 当遇到continue 语句时, 程序会终止当
前循环,并忽略剩余的语句, 然后回到循环的顶端. 在开始下一次迭代前,如果是条件循环, 我们
将验证条件表达式.如果是迭代循环,我们将验证是否还有元素可以迭代. 
只有在验证成功的情况下, 我们才会开始下一次迭代.

==========================================


　The continue statement in Python is not unlike the traditional continue found in other high-level languages. The continue statement can be used in both while and for loops. The while loop is conditional, and the for loop is
iterative, so using  continue is subject to the same requirements (as high- lighted  in  the  Core  Note  above)  before  the  next  iteration  of  the  loop  can begin. Otherwise, the loop will terminate normally.

Python 里的 continue 语句和其他高级语言中的传统 continue 并没有什么不同. 它可以被用在 while 和 for 循环里. while 循环是条件性的, 而 for 循环是迭代的, 所以 continue 在开始下一次循环前要满足一些先决条件(前边的核心笔记中强调的), 否则循环会正常结束.

```
valid = False 
count = 3
while count > 0:
    input = raw_input("enter password")
    # check for valid passwd
    for eachPasswd in passwdList:
        if input == eachPasswd:
            valid = True
            break
        if not valid:	# (or valid == 0)
            print "invalid input"
            count -= 1
            continue 
        else:
            break
```

　In this combined example using while, for, if, break, and continue, we are looking at validating user input. The user is given three opportunities to enter the correct password; otherwise, the valid variable remains a false value
of 0, which presumably will result in appropriate action being taken soon after.

这里例子结合使用了 while , for , if , break 以及 continue , 用来验证用户输入. 用户有三次机会来输入正确的密码, 如果失败, 那么 valid 变量将仍为一个布尔假( 0 ), 然后我们可以采取必要的操作阻止用户猜测密码.

= pass 语句 =
8.9 pass Statement

One Python statement not found in C is the pass statement. Because Python does not use curly braces to delimit blocks of code, there are places where code is syntactically required. We do not have the equivalent empty braces or single semicolon the way C does to indicate “do nothing.” If you use a Python state- ment that expects a sub-block of code or suite, and one is not present, you will get a syntax error condition. For this reason, we have pass, a statement that does absolutely nothing—it is a true NOP, to steal the “No OPeration” assembly code jargon. Style- and development-wise, pass is also useful in places where your code will eventually go, but has not been written yet (in stubs, for example):

Python 还提供了 pass 语句( C 中没有提供对应的语句). Python 没有使用传统的大括号来标记代码块, 有时，有些地方在语法上要求要有代码, 而Python 中没有对应的空大括号或是分号( ; )来表示C语言中的 "不做任何事" , 如果你在需要子语句块的地方不写任何语句, 解释器会提示你语法错误. 因此, Python 提供了 pass 语句, 它不做任何事情 - 即 NOP , ( No OPeration , 无操作) 我们从汇编语言中借用这个概念. pass 同样也可作为开发中的小技巧, 标记你后来要完成的代码, 例如这样:  

```
def foo_func():
    pass
```

或是

```
if user_choice == 'do_calc':
　　pass else:
    pass
```


This code structure is helpful during the development or debugging stages
because you want the structure to be there while the code is being created, but you do not want it to interfere with the other parts of the code that have been completed already. In places where you want nothing to execute, pass is a good tool to have in the box.

这样的代码结构在开发和调试时很有用, 因为编写代码的时候你可能要先把结构定下来，但你不希望它干扰其他已经完成的代码. 在不需要它做任何事情地方, 放一个pass 将是一个很好的主意.

Another  popular  place  is  with  exception  handling,  which  we  will  take  a look at in Chapter 10; this is where you can track an error if it occurs, but take no action if it is not fatal (you just want to keep a record of the event or perform an operation under the covers if an error occurs).

另外它在异常处理中也被经常用到, 我们将在第 10 章中详细介绍; 比如你跟踪到了一个非致命的错误, 不想采取任何措施(你只是想记录一下事件或是在内部进行处理).

= 再谈 else 语句 =
8.10 else Statement . . . Take Two


In C (as well as in most other languages), you will not find an else statement outside the realm of conditional statements, yet Python bucks the trend again by offering these in while and for loops. How do they work? When used with loops, an else clause will be executed only if a loop finishes to completion, meaning they were not abandoned by break.

在 C (以及大多其他语言中), 你不会在条件语句范围外发现 else 语句, 但 Python 不同, 你可以在 while 和 for 循环中使用 else 语句. 它们是怎么工作的呢? 在循环中使用时, else 子句只在循环完成后执行, 也就是说 break 语句也会跳过 else 块.

One popular example of else usage in a while statement is in finding the
largest factor of a number. We have implemented a function that performs
this task, using the else statement with our while loop. The showMaxFac- tor() function in Example 8.1  (maxFact.py) utilizes the else statement
as part of a while loop.

展示 while 语句中 else 用法的一个例子就是寻找一个数的最大约数. 我们已经实现了完成这个任务的函数, 使用 while 循环和 else 语句. Example 8.1  (maxFact.py) 利用这个语法完成了 showMaxFactor() 函数.

Example 8.1  while-else Loop Example (maxFact.py)


This program displays the largest factors for numbers between 10 and 20. If the number is prime, the script will indicate that as well.

这个程序显示出 10 到 20 中的数字的最大约数. 该脚本也会提示这个数是否为素数.

　The loop beginning on line 3 in showMaxFactor() counts down from half the amount (starts checking if two divides the number, which would give the largest factor). The loop decrements each time (line 10) through until a divisor is found (lines 6–9). If a divisor has not been found by the time the loop decre- ments to 1, then the original number must be prime. The else clause on lines 11–12 takes care of this case. The main part of the program on lines 14 –15 fires off the requests to showMaxFactor() with the numeric argument. Running our program results in the following output:

showMaxFactor() 函数中第3行的循环从 amount 的一半开始计数(这样就可以检查这个数是否可以被 2 整除, 如果可以，那就找到了最大的约数). 
然后循环每次递减 1 (第 10 行), 直到发现约数(第 6-9 行). 如果循环递减到 1 还没有找到约数, 那么这个数一定是素数. 11-12 行的 else 子句负责处理这样的情况. 程序的主体( 14-15 行)用数字参数调用 showMaxFactor() .
执行该程序将得到这样的输出:

```
largest factor of 10 is 5
11 is prime
largest factor of 12 is 6
13 is prime
largest factor of 14 is 7 
largest factor of 15 is 5 
largest factor of 16 is 8
17 is prime
largest factor of 18 is 9
19 is prime
largest factor of 20 is 10
```

Likewise, a for loop can have a post-processing else. It operates exactly the same way as for a while loop. As long as the for loop exits normally (not via  break),  the  else clause  will  be  executed.  We  saw  such  an  example  in Section 8.5.3.

同样地, for 循环也可以有 else 用于循环后处理(post-processing). 它和 while 循环中的 else 处理方式相同. 只要for循环是正常结束的(不是通过 break ), else 子句就会执行. 我们在 8.5.3 已经见过这样的例子


　Table 8.1  summarizes with which conditional or looping statements auxil- iary statements can be used.

表 8.1 条件及循环语句中的辅助语句总结



Table 8.1  Auxiliary Statements to Loops and Conditionals

循环和条件语句中的辅助语句

+====================================================================+
|
|
|       什么????表格????
|
|
|
|
+====================================================================+
                                 Loops and Conditionals Auxiliary Statements	
if
while
for
elif		?
else	?	?	? break		?	? continue		?	?

passa
?          ?	?	

+====================================================================+
a.	pass is valid anywhere a suite (single or multiple statements) is required (also includes elif,
else, class, def, try, except, finally).

pass 在任何需要语句块(一个或多个语句)的地方都可以使用(例如 elif , else , clasa , def , try , except , finally ).


= 迭代器和 iter() 函数 =
8.11  Iterators and the iter() Function

8.11.1 What Are Iterators?
== 什么是迭代器? ==

Iterators were added to Python in version 2.2 to give sequence-like objects
a sequence-like interface. We formally introduced sequences back in Chapter 6. They are just data structures that you can “iterate” over by using their index starting at 0 and continuing till the final item of the sequence. Because you can do this “counting,” iterating over sequences is trivial. Iteration support
in Python works seamlessly with sequences but now also allows program- mers to   iterate   through   non-sequence   types,   including   user-defined objects.

迭代器是在版本 2.2 被加入 Python 的, 它为类序列对象提供了一个类序列的接口. 我们在前边的第 6 章已经正式地介绍过序列. 它们是一组数据结构，你可以利用它们的索引从0开始一直 "迭代" 到序列的最后一个条目. 用"计数"的方法迭代序列是很简单的. Python 的迭代无缝地支持序列对象, 而且它还允许程序员迭代非序列类型, 包括用户定义的对象.

Iterators come in handy when you are iterating over something that is not
a  sequence  but  exhibits  behavior  that  makes  it  seem  like  a  sequence,  for example, keys of a dictionary, lines of a file, etc. When you use loops to iterate over an object item, you will not be able to easily tell whether it is an iterator or a sequence. The best part is that you do not have to care because Python makes it seem like a sequence.

迭代器用起来很灵巧, 你可以迭代不是序列但表现出序列行为的对象, 例如字典的 key , 一个文件的行, 等等. 当你使用循环迭代一个对象条目时, 你几乎不可能分辨出它是迭代器还是序列. 你不必去关注这些, 因为 Python 让它象一个序列那样操作.



8.11.2 Why Iterators?
==为什么要迭代器?==


The defining PEP (234) cites that iterators:

援引 PEP (234) 中对迭代器的定义:

?	Provide an extensible iterator interface.
?	Bring performance enhancements to list iteration.
?	Allow for big performance improvements in dictionary iteration.
?	Allow for the creation of a true iteration interface as opposed to overriding methods originally meant for random element access.
?	Be backward-compatible with all existing user-defined classes and extension objects that emulate sequences and mappings.
?	Result in more concise and readable code that iterates over non-sequence collections (mappings and files, for instance).

 - 提供了可扩展的迭代器接口.
 - 对列表迭代带来了性能上的增强.
 - 在字典迭代中性能提升.
 - 创建真正的迭代接口, 而不是原来的随机对象访问.
 - 与所有已经存在的用户定义的类以及扩展的模拟序列和映射的对象向后兼容
 - 迭代非序列集合(例如映射和文件)时, 可以创建更简洁可读的代码.



8.11.3 How Do You Iterate?
==如何迭代?==

Basically, instead of an index to count sequentially, an iterator is any item that has a next() method. When the next item is desired, either you or a looping  mechanism  like  for will  call  the  iterators  next()method  to  get the  next  value.  Once  the  items  have  been  exhausted,  a  StopIteration exception is raised, not to indicate an error, but to let folks know that we are done.

根本上说, 迭代器就是有一个 next() 方法的对象, 而不是通过索引来计数. 当你或是一个循环机制(例如 for 语句)需要下一个项时, 调用迭代器的 next() 方法就可以获得它. 条目全部取出后, 会引发一个 StopIteration 异常, 这并不表示错误发生, 只是告诉外部调用者, 迭代完成.

Iterators  do  have  some  restrictions,  however.  For  example,  you  cannot move backward, go back to the beginning, or copy an iterator. If you want to iterate over the same objects again (or simultaneously), you have to create another iterator object. It isn’t all that bad, however, as there are various tools
to help you with using iterators.

不过, 迭代器也有一些限制. 例如你不能向后移动, 不能回到开始, 也不能复制一个迭代器. 如果你要再次(或者是同时)迭代同个对象, 你只能去创建另一个迭代器对象. 不过, 这并不糟糕，因为还有其他的工具来帮助你使用迭代器.

　There  is  a  reversed() built-in  function  that  returns  an  iterator  that traverses an iterable in reverse order. The enumerate() BIF also returns an iterator. Two new BIFs, any() and all(), made their debut in Python 2.5— they will return True if any or all items traversed across an iterator have a Boolean True value, respectively. We saw earlier in the chapter how you can use it in a for loop to iterate over both the index and the item of an iterable. There is also an entire module called itertools that contains various itera- tors you may find useful.

reversed() 内建函数将返回一个反序访问的迭代器. enumerate() 内建函数同样也返回迭代器. 另外两个新的内建函数, any() 和 all() , 在 Python 2.5 中新增, 如果迭代器中某个/所有条目的值都为布尔真时，则它们返回值为真. 本章先前部分我们展示了如何在 for 循环中通过索引或是可迭代对象来遍历条目. 同时 Python 还提供了一整个 itertools 模块, 它包含各种有用的迭代器.

8.11.4 Using Iterators with . . .
==使用迭代器==

Sequences
===序列===

As   mentioned   before,   iterating   through   Python   sequence   types   is   as expected:

正如先前提到的, 迭代 Python 的序列对象和你想像的一样:

```
>>> myTuple = (123, 'xyz', 45.67)
>>> i = iter(myTuple)
>>> i.next()
123
>>> i.next()
'xyz'
>>> i.next()
45.67
>>> i.next()
Traceback (most recent call last): File "", line 1, in ?
StopIteration
```

　If  this  had  been  an  actual  program,  we  would  have  enclosed  the  code inside a try-except block. Sequences now automatically produce their own iterators, so a for loop:

如果这是一个实际应用程序, 那么我们需要把代码放在一个 try-except 块中. 序列现在会自动地产生它们自己的迭代器, 所以一个 for 循环:

```
for i in seq:
    do_something_to(i)
```

under the covers now really behaves like this:

实际上是这样工作的:

```
fetch = iter(seq)
while True:
    try:
        i = fetch.next()
    except StopIteration:
        break
    do_something_to(i)
```

However, your code does not need to change because the for loop itself calls the iterator’s next() method (as well as monitors for StopIteration).

不过, 你不需要改动你的代码, 因为 for 循环会自动调用迭代器的 next() 方法(以及监视 StopIteration 异常).


Dictionaries
===字典===

Dictionaries and files are two other Python data types that received the itera- tion  makeover.  A  dictionary’s  iterator  traverses  its  keys.  The  idiom  for eachKey in myDict.keys() can  be  shortened  to  for eachKey in myDict as shown here:

字典和文件是另外两个可迭代的 Python 数据类型. 字典的迭代器会遍历它的键(keys). 
语句 for eachKey in myDict.keys() 可以缩写为 for eachKey in myDict , 例如:

```
>>> legends = { ('Poe', 'author'): (1809, 1849, 1976),
...	('Gaudi', 'architect'): (1852, 1906, 1987),
...	('Freud', 'psychoanalyst'): (1856, 1939, 1990)
... }
...
>>> for eachLegend in legends:
...	    print 'Name: %s\tOccupation: %s' % eachLegend
...	    print '	Birth: %s\tDeath: %s\tAlbum: %s\n' \
...	    % legends[eachLegend]
...
Name: Freud	Occupation: psychoanalyst
Birth: 1856	Death: 1939	Album: 1990

Name: Poe	Occupation: author
Birth: 1809	Death: 1849	Album: 1976

Name: Gaudi	Occupation: architect
Birth: 1852	Death: 1906	Album: 1987
```

In addition, three new built-in dictionary methods have been introduced
to  define  the  iteration:  myDict.iterkeys()(iterate  through  the  keys), myDict.itervalues() (iterate through the values), and myDict.iter- items() (iterate through key/value pairs). Note that the in operator has been modified  to  check  a  dictionary’s  keys.  This  means  the  Boolean  expression myDict.has_key(anyKey) can be simplified as anyKey in myDict.

另外, Python 还引进了三个新的内建字典方法来定义迭代: myDict.iterkeys() (通过 keys 迭代), myDict.itervalues() (通过 values 迭代), 以及 myDicit.iteritems() (通过 key/value 对来迭代). 注意, in 操作符也可以用于检查字典的 key 是否存在 , 之前的布尔表达式 myDict.has_key(anyKey) 可以被简写为 anyKey in myDict .


Files
===文件===

File objects produce an iterator that calls the readline() method. Thus, they loop through all lines of a text file, allowing the programmer to replace essentially  for eachLine in myFile.readlines() with  the  more  simplistic for eachLine in myFile:

文件对象生成的迭代器会自动调用 readline() 方法. 这样, 循环就可以访问文本文件的所有行. 程序员可以使用 更简单的 for eachLine in myFile 替换 for eachLine in myFile.readlines() :

```
>>> myFile = open('config-win.txt')
>>> for eachLine in myFile:
...	    print eachLine,	# comma suppresses extra \n
...
[EditorWindow]
font-name: courier new font-size: 10
>>> myFile.close()
```

8.11.5 Mutable Objects and Iterators
==可变对象和迭代器==

Remember  that  interfering  with  mutable  objects  while  you  are  iterating them is not a good idea. This was a problem before iterators appeared. One popular example of this is to loop through a list and remove items from it if certain criteria are met (or not):

记住，在迭代可变对象的时候修改它们并不是个好主意. 这在迭代器出现之前就是一个问题. 一个流行的例子就是循环列表的时候删除满足(或不满足)特定条件的项:

```
for eachURL in allURLs:
    if not eachURL.startswith('http://'):
        allURLs.remove(eachURL)	# YIKES!!
```

All sequences are immutable except lists, so the danger occurs only there. A sequence’s iterator only keeps track of the Nth element you are on, so if you change elements around during iteration, those updates will be reflected as you traverse through the items. If you run out, then StopIteration will be raised. When iterating through keys of a dictionary, you must not modify the dictio- nary. Using a dictionary’s keys() method is okay because keys() returns a list that is independent of the dictionary. But iterators are tied much more inti- mately with the actual object and will not let us play that game anymore:

除列表外的其他序列都是不可变的, 所以危险就发生在这里. 一个序列的迭代器只是记录你当前到达第多少个元素, 所以如果你在迭代时改变了元素, 更新会立即反映到你所迭代的条目上. 在迭代字典的 key 时, 你绝对不能改变这个字典. 使用字典的 keys() 方法是可以的, 因为 keys() 返回一个独立于字典的列表. 而迭代器是与实际对象绑定在一起的, 它将不会继续执行下去:

```
>>> myDict = {'a': 1, 'b': 2, 'c': 3, 'd': 4}
>>> for eachKey in myDict:
...	    print eachKey, myDict[eachKey]
...	    del myDict[eachKey]
... a 1
Traceback (most recent call last): File "", line 1, in ?
RuntimeError: dictionary changed size during iteration
```

This will help prevent buggy code. For full details on iterators, see PEP 234.

这样可以避免有缺陷的代码. 更多有关迭代器的细节请参阅 PEP 234 .

8.11.6 How to Create an Iterator
==如何创建迭代器==

You can take an item and call iter() on it to turn it into an iterator. Its syn- tax is one of the following:

对一个对象调用 iter() 就可以得到它的迭代器. 它的语法如下:

```
iter(obj)
iter(func, sentinel )
```

If you call iter() with one object, it will check if it is just a sequence, for which the solution is simple: It will just iterate through it by (integer) index from 0 to the end. Another way to create an iterator is with a class. As we will see  in  Chapter  13,  a  class  that  implements  the  __iter__() and  next() methods can be used as an iterator.
　If  you  call  iter() with  two  arguments,  it  will  repeatedly  call  func to obtain the next value of iteration until that value is equal to sentinel.
　 
如果你传递一个参数给 iter() , 它会检查你传递的是不是一个序列, 如果是, 那么很简单: 根据索引从 0 一直迭代到序列结束. 另一个创建迭代器的方法是使用类, 我们将在第 13 章详细介绍, 一个实现了 __iter__() 和 next() 方法的类可以作为迭代器使用.

如果是传递两个参数给 iter() , 它会重复地调用 func , 直到迭代器的下个值等于 sentinel . 
　


8.12 List Comprehensions
=列表解析=

List comprehensions (or “list comps” for short) come to us from the func- tional programming language Haskell. They are an extremely valuable, sim- ple, and flexible utility tool that helps us create lists on the fly. They were added to Python in version 2.0.

列表解析( List comprehensions, 或缩略为 list comps ) 来自函数式编程语言 Haskell . 它是一个非常有用, 简单, 而且灵活的工具, 可以用来动态地创建列表. 它在 Python 2.0 中被加入.

Up  ahead  in  Functions  (Chapter  11),  we  will  be  discussing  long-time Python functional programming features like lambda, map(), and filter(). They have been around in Python for quite a while, but with list comprehensions, they have simplified their use to only requiring a list comp instead. map() is a function that applies an operation to list members, and filter() filters out list members based on a conditional expression. Finally, lambda allows you to create one-line function objects on the fly. It is not important that you learn them now, but you will see examples of them in this section because we are discussing the merits of list comps. Let us take a look at the simpler list com- prehension syntax first:

在第 11 章, 函数中, 我们将讨论 Python 早就支持的函数式编程特性, 例如 lambda , map() , 以及 filter() 等, 这些存在于 Python 中已经很长时间了, 但通过列表解析 , 它们可以被简化为一个列表解析式子. map() 对所有的列表成员应用一个操作, filter() 基于一个条件表达式过滤列表成员. 最后, lambda 允许你快速地创建只有一行的函数对象. 你不需要现在就去掌握这些, 在本节中你将看到它们出现在例子里, 因为我们需要讨论列表解析的优势. 首先让我们看看列表解析的语法:

```
[expr for iter_var in iterable]
```

The core of this statement is the for loop, which iterates over each item of iterable. The prefixed expr is applied for each member of the sequence, and the resulting values comprise the list that the expression yields. The iter- ation variable need not be part of the expression.
Here is a sneak preview of some code from Chapter 11. It has a lambda
function that squares the members of a sequence:

这个语句的核心是 for 循环, 它迭代 iterable 对象的所有条目. 前边的 expr 应用于序列的每个成员, 最后的结果值是该表达式产生的列表. 迭代变量并不需要是表达式的一部分.

这里用到了第 11 章的一些代码. 它有一个计算序列成员的平方的 lambda 函数表达式:

```
>>> map(lambda x: x ** 2, range(6))
[0, 1, 4, 9, 16, 25]
```

We can replace this code with the following list comprehension statement:

我们可以使用下面这样的列表解析来替换它:

```
>>> [x ** 2 for x in range(6)]
[0, 1, 4, 9, 16, 25]
```

In the new statement, only one function call (range()) is made (as opposed
to  three—range(),  map(),  and  the  lambda function).  You  may  also  use
parentheses around the expression if [(x ** 2) for x in range(6)] is
easier for you to read. This syntax for list comprehensions can be a substitute for
and is more efficient than using the map() built-in function along with lambda.
List  comprehensions  also  support  an  extended  syntax  with  the  if
statement:

在新语句中, 只有一次函数调用( range() ), 而先前的语句中有三次函数调用(range() , map() , 以及 lambda ). 你也可以用括号包住表达式, 象 [(x ** 2) for x in range(6)] 这样, 更便于阅读. 列表解析的表达式可以取代内建的 map() 函数以及 lambda , 而且效率更高. 结合if语句，列表解析还提供了一个扩展版本的语法:

```
[expr for iter_var in iterable if cond_expr]
```

This syntax will filter or “capture” sequence members only if they meet the condition provided for in the cond_expr conditional expression during iteration.

这个语法在迭代时会过滤/捕获满足条件表达式 cond_expr 的序列成员.

Recall the following odd() function below, which determines whether a numeric argument is odd or even (returning 1 for odd numbers and 0 for even numbers):

回想下 odd() 函数, 它用于判断一个数值对象是奇数还是偶数(奇数返回 1 , 偶数返回 0 ):

```
def odd(n):
    return n % 2
```

We were able to take the core operation from this function, and use it with
filter() and lambda to obtain the set of odd numbers from a sequence:

我们可以借用这个函数的核心操作, 使用 filter() 和 lambda 挑选出序列中的奇数:

```
>>> seq = [11, 10, 9, 9, 10, 10, 9, 8, 23, 9, 7, 18, 12, 11, 12]
>>> filter(lambda x: x % 2, seq)
[11, 9, 9, 9, 23, 9, 7, 11]
```

As  in  the  previous  example,  we  can  bypass  the  use  of  filter() and
lambda to obtain the desired set of numbers with list comprehensions:

和先前的例子一样, 即使不用filter() 和 lambda，我们同样可以使用列表解析来完成操作，获得想要的数字:

```
>>> [x for x in seq if x % 2]
[11, 9, 9, 9, 23, 9, 7, 11]
```

Let us end this section with a few more practical examples.

我们使用更多实用的例子结束这节.

Matrix Example
===矩阵样例===

Do you want to iterate through a matrix of three rows and five columns? It is as easy as:

你需要迭代一个有三行五列的矩阵么? 很简单:

```
>>> [(x+1,y+1) for x in range(3) for y in range(5)]
[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (2, 1), (2, 2), (2,
3), (2, 4), (2, 5), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5)]
```

Disk File Example
===磁盘文件样例===

Now let us say we have the following data file and want to count the total number of non-whitespace characters in the file hhga.txt:

假设我们有如下这样一个数据文件 hhga.txt , 需要计算出所有非空白字符的数目:

```
And the Lord spake, saying, "First shalt thou take out the Holy Pin. Then shalt thou count to three, no more, no less. Three shall be the number thou shalt count, and the number of the counting shall be three. Four shalt thou not count, nei- ther count thou two, excepting that thou then proceed to three. Five is right out. Once the number three, being the third number, be reached, then lobbest thou thy Holy Hand Grenade of Antioch towards thy foe, who, being naughty in My sight, shall snuff it."
```

We know that we can iterate through each line with for line in data, but more than that, we can also go and split each line up into words, and we can sum up the number of words to get a total like this:

我们已经知道可以通过 for line in data 迭代文件内容, 不过, 除了这个, 我们还可以把每行分割( split )为单词, 然后我们可以像这样计算单词个数:

```
>>> f = open('hhga.txt', 'r')
>>> len([word for line in f for word in line.split()])
91
```

Let us get a quick total file size:

快速地计算文件大小

```
import os
>>> os.stat('hhga.txt').st_size
499L
```

Assuming  that  there  is  at  least  one  whitespace  character  in  the  file,  we know that there are fewer than 499 non-whitespace characters in the file. We can sum up the length of each word to arrive at our total:

假定文件中至少有一个空白字符, 我们知道文件中有少于 499 个非空字符. 我们可以把每个单词的长度加起来, 得到和.

```
>>> f.seek(0)
>>> sum([len(word) for line in f for word in line.split()])
408
```

Note  we  have  to  rewind  back  to  the  beginning  of  the  file  each  time through  because  the  iterator  exhausts  it.  But  wow,  a  non-obfuscated  one- liner now does something that used to take many lines of code to accomplish! As you can see, list comps support multiple nested  for loops and more than one if clause. The full syntax can be found in the official documenta- tion. You can also read more about list comprehensions in PEP 202.

这里我们用 seek() 函数回到文件的开头, 因为迭代器已经访问完了文件的所有行. 一个清晰明了的列表解析完成了之前需要许多行代码才能完成的工作! 如你所见, 列表解析支持多重嵌套 for 循环以及多个 if 子句. 完整的语法可以在官方文档中找到. 你也可以在 PEP 202 中找到更多关于列表解析的资料.

=生成器表达式=
8.13 生成器表达式

Generator   expressions   extend   naturally   from   list   comprehensions   (“list comps”). When list comps came into being in Python 2.0, they revolutionized
the  language  by  giving  users  an  extremely  flexible  and  expressive  way  to designate the contents of a list on a single line. Ask any long-time Python user what new features have changed the way they program Python, and list comps should be near the top of the list.
　
生成器表达式是列表解析的一个扩展. 在 Python 2.0 中我们加入了列表解析, 使语言有了一次革命化的发展, 提供给用户了一个强大的工具, 只用一行代码就可以创建包含特定内容的列表. 你可以去问一个有多年 Python 经验的程序员是什么改变了他们编写 Python 程序的方式, 那么列表解析一定会是最多的答案.

Another significant feature that was added to Python in version 2.2 was the generator. A generator is a specialized function that allows you to return a value and “pause” the execution of that code and resume it at a later time. We will discuss generators in Chapter 11.

另个在 Python 版本 2.2 时被加入的另一个重要特性是生成器. 生成器是特定的函数, 允许你返回一个值, 然后"暂停"代码的执行, 稍后恢复. 我们将在第 11 章中讨论生成器.

　The  one  weakness  of  list  comps  is  that  all  of  the  data  have  to  be  made available  in  order  to  create  the  entire  list.  This  can  have  negative  conse- quences if an iterator with a large dataset is involved. Generator expressions resolve this issue by combining the syntax and flexibility of list comps with the power of generators.

列表解析的一个不足就是必要生成所有的数据, 用以创建整个列表. 这可能对有大量数据的迭代器有负面效应. 生成器表达式通过结合列表解析和生成器解决了这个问题.

　Introduced in Python 2.4, generator expressions are similar to list compre- hensions in that the basic syntax is nearly identical; however, instead of build- ing a list with values, they return a generator that “yields” after processing each item. Because of this, generator expressions are much more memory efficient  by  performing  “lazy  evaluation.”  Take  a  look  at  how  similar  they appear to list comps:

生成器表达式在 Python 2.4 被引入, 它与列表解析非常相似，而且它们的基本语法基本相同; 不过它并不真正创建数字列表, 而是返回一个生成器，这个生成器在每次计算出一个条目后，把这个条目“产生”(yield)出来. 生成器表达式使用了"延迟计算"(lazy evaluation), 所以它在使用内存上更有效. 我们来看看它和列表解析到底有多相似:

LIST COMPREHENSION:

列表解析:

```
[expr for iter_var in iterable if cond_expr]
```

GENERATOR EXPRESSION:

生成器表达式:

```
(expr for iter_var in iterable if cond_expr)
```

Generator expressions do not make list comps obsolete. They are just a more memory-friendly construct, and on top of that, are a great use case of generators. We now present a set of generator expression examples, includ- ing a long-winded one at the end showing you how Python code has changed over the years.

生成器并不会让列表解析废弃, 它只是一个内存使用更友好的结构, 基于此, 有很多使用生成器地方. 下面我们提供了一些使用生成器表达式的例子, 最后例举一个冗长的样例, 从它你可以感觉到 Python 代码在这些年来的变化.


Disk File Example
===磁盘文件样例===

In the previous section on list comprehensions, we took a look at finding the total number of non-whitespace characters in a text file. In the final snippet
of code, we showed you how to perform that in one line of code using a list comprehension. If that file became unwieldy due to size, it would become fairly unfriendly memory-wise because we would have to put together a very long list of word lengths.

在前边列表解析一节, 我们计算文本文件中非空白字符总和. 最后的代码中, 我们展示了如何使用一行列表解析代码做所有的事. 如果这个文件的大小变得很大, 那么这行代码的内存性能会很低, 因为我们要创建一个很长的列表用于存放单词的长度.

Instead of creating that large list, we can use a generator expression to per-
form the summing. Instead of building up this long list, it will calculate individual lengths and feed it to the sum() function, which takes not just lists but also iterables like generator expressions. We can then shorten our example above
to be even more optimal (code- and execution-wise):

为了避免创建庞大的列表, 我们可以使用生成器表达式来完成求和操作. 它会计算每个单词的长度然后传递给 sum() 函数(它的参数不仅可以是列表，还可以是可迭代对象,比如生成器表达式). 这样, 我们可以得到优化后的代码(代码长度, 还有执行效率都很高效): 

```
>>> sum(len(word) for line in data for word in line.split())
408
```

All  we  did  was  remove  the  enclosing  list  comprehension  square
brackets: Two bytes shorter and it saves memory . . . very environmen-
tally friendly!

我们所做的只是把方括号删除: 少了两字节, 而且更节省内存 ... 非常地环保!

Cross-Product Pairs Example
=== 交叉配对例子 ===

Generator  expressions  are  like  list  comprehensions  in  that  they  are  lazy, which is their main benefit. They are also great ways of dealing with other lists and generators, like rows and cols here:

生成器表达式就好像是懒惰的列表解析(这反而成了它主要的优势). 它还可以用来处理其他列表或生成器, 例如这里的 rows 和 cols :

```
rows = [1, 2, 3, 17]

def cols():	# example of simple generator
    yield 56 
    yield 2 
    yield 1
```

We do not need to create a new list. We can piece together things on the fly. Let us create a generator expression for rows and cols:

不需要创建新的列表, 直接就可以创建配对. 我们可以使用下面的生成器表达式:

```
x_product_pairs = ((i, j) for i in rows for j in cols())
```

Now we can loop through x_product_pairs, and it will loop through
rows and cols lazily:

现在我们可以循环 x_product_pairs , 它会懒惰地循环 rows 和 cols :

```
>>> for pair in x_product_pairs:
...	    print pair
...
(1, 56)
(1, 2)
(1, 1)
(2, 56)
(2, 2)
(2, 1)
(3, 56)
(3, 2)
(3, 1)
(17, 56)
(17, 2)
(17, 1)
```

Refactoring Example
===  重构样例 ===

Let us look at some evolutionary code via an example that finds the longest line in a file. In the old days, the following was acceptable for reading a file:

我们通过一个寻找文件最长的行的例子来看看如何改进代码. 在以前, 我们这样读取文件:

```
f = open('/etc/motd', 'r')
longest = 0
while True:
    linelen = len(f.readline().strip())
    if not linelen: 
        break
    if linelen > longest:
        longest = linelen
f.close()
return longest
```

Actually, this is not that old. If it were really old Python code, the Boolean constant  True would  be  the  integer  one,  and  instead  of  using  the  string strip() method, you would be using the string module:

事实上, 这还不够老. 真正的旧版本 Python 代码中, 布尔常量应该写是整数 1 , 而且我们应该使用 string 模块而不是字符串的 strip() 方法:

```
import string
:
len(string.strip(f.readline()))
```

　Since  that  time,  we  realized  that  we  could  release  the  (file)  resource sooner if we read all the lines at once. If this was a log file used by many pro- cesses,  then  it  behooves  us  not  to  hold  onto  a  (write)  file  handle  for  an extended period of time. Yes, our example is for read, but you get the idea. So the preferred way of reading in lines from a file changed slightly to reflect this preference:

从那时起, 我们认识到如果读取了所有的行, 那么应该尽早释放文件资源. 如果这是一个很多进程都要用到的日志文件, 那么理所当然我们不能一直拿着它的句柄不释放. 是的, 我们的例子是用来展示的, 但是你应该得到这个理念. 所以读取文件的行的首选方法应该是这样:

```
f = open('/etc/motd', 'r')
longest = 0
allLines = f.readlines()
f.close()
for line in allLines:
    linelen = len(line.strip())
    if linelen > longest:
        longest = linelen
return longest
```

List comps allow us to simplify our code a little bit more and give us the ability  to  do  more  processing  before  we  get  our  set  of  lines.  In  the  next
snippet, in addition to reading in the lines from the file, we call the string
strip() method immediately instead of waiting until later.

列表解析允许我们稍微简化我们代码, 而且我们可以在得到行的集合前做一定的处理. 在下段代码中, 除了读取文件中的行之外，我们还调用了字符串的 strip() 方法处理行内容.

```
f = open('/etc/motd', 'r')
longest = 0
allLines = [x.strip() for x in f.readlines()]
f.close()
for line in allLines:
    linelen = len(line)
    if linelen > longest:
    longest = linelen
return longest
```

　Still, both examples above have a problem when dealing with a large file as readlines() reads in all its lines. When iterators came around, and files became  their  own  iterators,  readlines() no  longer  needed  to  be  called. While we are at it, why can’t we just make our data set the set of line lengths
(instead of lines)? That way, we can use the max() built-in function to get the longest string length:

然而, 两个例子在处理大文件时候都有问题, 因为 readlines() 会读取文件的所有行. 后来我们有了迭代器, 文件本身就成为了它自己的迭代器, 不需要调用 readlines() 函数. 我们已经做到了这一步, 为什么不去直接获得行长度的集合呢(之前我们得到的是行的集合)? 这样, 我们就可以使用 max() 内建函数得到最长的字符串长度:

```
f = open('/etc/motd', 'r')
allLineLens = [len(x.strip()) for x in f]
f.close()
return max(allLineLens)
```

The only problem here is that even though you are iterating over f line by line, the list comprehension itself needs all lines of the file read into memory
in  order  to  generate  the  list.  Let  us  simplify  our  code  even  more:  we  will replace the list comp with a generator expression and move it inside the call
to max() so that all of the complexity is on a single line:

这里唯一的问题就是你一行一行迭代 f 的时候, 列表解析需要文件的所有行读取到内存中, 然后生成列表. 我们可以进一步简化代码: 使用生成器表达式替换列表解析, 然后把它移到 max() 函数里, 这样, 所有的核心部分只有一行:

```
f = open('/etc/motd', 'r')
longest = max(len(x.strip()) for x in f)
f.close()
return longest
```

One more refactoring, which we are not as much fans of, is dropping the file mode (defaulting to read) and letting Python clean up the open file. It is not as bad as if it were a file open for write, however, but it does work:

最后, 我们可以去掉文件打开模式(默认为读取), 然后让 Python 去处理打开的文件. 当然, 文件用于写入的时候不能这么做, 但这里我们不需要考虑太多:

```
return max(len(x.strip()) for x in open('/etc/motd'))
```

We  have  come  a  long  way,  baby.  Note  that  even  a  one-liner  is  not obfuscated  enough  in  Python  to  make  it  difficult  to  read.  Generator expressions were added in Python 2.4, and you can read more about them
in PEP 289.

我们走了好长一段路. 注意，即便是这只有一行的 Python 程序也不是很晦涩. 生成器表达式在 Python 2.4 中被加入, 你可以在 PEP 289 中找到更多相关内容.

= 相关模块 =
8.14 Related Modules

Iterators were introduced in Python 2.2, and the  itertools module was added in the next release (2.3) to aid developers who had discovered how useful iterators were but wanted some helper tools to aid in their development. The interesting thing is that if you read the documentation for the various utilities in itertools, you will discover generators. So there is a relationship between iterators and generators. You can read more about this relationship
in Chapter 11, “Functions.”

Python 2.2 引进了迭代器, 在下一个发行 (2.3) 中, itertools 模块被加入, 用来帮助那些发现迭代器威力但又需要一些辅助工具的开发者. 有趣的是如果你阅读关于 itertools 中实用程序的文档, 你会发现生成器. 所以在迭代器和生成器间有一定的联系. 你可以在第 11 章 "函数" 中了解更多.

=    练习 =
8.15  Exercises
   

8–1.   Conditionals. Study the following code:
条件语句. 请看下边的代码

```
# statement A
if x > 0:
    # statement B
    pass

elif x < 0:
    # statement C
    pass

else:
    # statement D
    pass
    # statement E
```

(a) Which of the statements above (A, B, C, D, E) will be exe- cuted if x < 0?
    如果 x< 0 , 上面哪个语句(A, B, C, D, E)将被执行
(b) Which of the statements above will be executed if x == 0?
    如果 x== 0 , 上面哪个居于将被执行? 
(c) Which of the statements above will be executed if x > 0?
    如果 x> 0 , 上面哪个语句将被执行?

    
8–2.   Loops. Write a program to have the user input three (3) numbers: (f)rom, (t)o, and (i)ncrement. Count from f to t in increments of i, inclusive of f and t. For example, if the input
is f == 2, t == 26, and i == 4, the program would output: 2, 6,
10, 14, 18, 22, 26.

循环. 编写一个程序, 让用户输入三个数字: (f)rom, (t)o, 和 (i)ncrement . 以 i 为步长, 从 f 计数到 t , 包括 f 和 t . 例如, 如果输入的是 f == 2, t == 26, i == 4 , 
程序将输出 2, 6, 10, 14, 18, 22, 26.

8–3.   range(). What argument(s) could we give to the range()
built-in function if we wanted the following lists to be generated?

range() . 如果我们需要生成下面的这些列表, 分别需要在 range() 内建函数中提供那些参数?

(a) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
(b) [3, 6, 9, 12, 15, 18]
(c) [-20, 200, 420, 640, 860]


8–4.   Prime Numbers. We presented some code in this chapter to
determine a number’s largest factor or if it is prime. Turn this code into a Boolean function called isprime() such that
the input is a single value, and the result returned is True if
the number is prime and False otherwise.

素数. 我们在本章已经给出了一些代码来确定一个数字的最大约数或者它是否是一个素数. 请把相关代码转换为一个返回值为布尔值的函数，函数名为 isprime() . 如果输入的是一个素数, 那么返回 True , 否则返回 False . 

8–5.   Factors. Write a function called getfactors() that takes a
single integer as an argument and returns a list of all its fac-
tors, including 1 and itself.

约数. 完成一个名为 getfactors() 的函数. 它接受一个整数作为参数, 返回它所有约数的列表, 包括 1 和它本身, 

8–6.   Prime Factorization. Take your solutions for isprime() and getfactors() in the previous problems and create a function that takes an integer as input and returns a list of its prime factors. This process, known as prime factorization, should output a list of
factors such that if multiplied together, they will result in the origi- nal number. Note that there could be repeats in the list. So if you gave an input of 20, the output would be [2, 2, 5].

素因子分解. 以刚才练习中的 isprime() 和 getfactors() 函数为基础编写一个函数, 它接受一个整数作为参数, 返回该整数所有素数因子的列表. 这个过程叫做求素因子分解, 它输出的所有因子之积应该是原来的数字. 注意列表里可能有重复的元素. 例如输入 20 , 返回结果应该是 [2, 2, 5] .

8–7.   Perfect Numbers. A perfect number is one whose factors (except itself ) sum to itself. For example, the factors of 6 are 1, 2, 3, and 6. Since 1 ? 2 ? 3 is 6, it (6) is considered a perfect number. Write a function called isperfect() which takes a single integer input and outputs 1 if the number is perfect and 0 otherwise.

完全数. 完全数被定义为这样的数字: 它的约数(不包括它自己)之和为它本身. 例如: 6 的约数是 1, 2, 3, 因为 1 + 2 + 3 = 6 , 所以 6 被认为是一个完全数. 编写一个名为 isperfect() 的函数, 它接受一个整数作为参数, 如果这个数字是完全数, 返回 1 ; 否则返回 0 .

8–8.   Factorial. The factorial of a number is defined as the product of all values from one to that number. A shorthand for N factorial is N! where N! == factorial(N) == 1

阶乘. 一个数的阶乘被定义为从 1 到该数字所有数字的乘积. N 的阶乘简写为 N! .

{这里的表格看不懂是什么东西?}

?	?	?
2   3
. . .
?	?
(N-2)

(N-1)
?
N. So 4! == 1
?	?	?
2    3
4. 
Write a routine such that
given N, the value N! is returned.

写一个函数, 指定N, 返回 N! 的值.

8–9.   Fibonacci Numbers. The Fibonacci number sequence is 1, 1,
2, 3, 5, 8, 13, 21, etc. In other words, the next value of the sequence is the sum of the previous two values in the sequence. Write a routine that, given N, displays the value of the Nth Fibonacci number. For example, the first Fibonacci number
is 1, the 6th is 8, and so on.

Fibonacci 数列. Fibonacci 数列形如 1, 1, 2, 3, 5, 8, 13, 21, 等等. 也就是说, 下一个值是序列中前两个值之和. 写一个函数, 给定 N , 返回第 N 个 Fibonacci 数字. 例如, 第 1 个 Fibonacci 数字是 1 , 第 6 个是 8 .

8–10.   Text Processing. Determine the total number of vowels, conso- nants, and words (separated by spaces) in a text sentence.
Ignore special cases for vowels and consonants such as “h,” “y,”
“qu,” etc. Extra credit: create code to handle those special case.

文本处理. 统计一句话中的元音, 辅音以及单词(以空格分割)的个数. 忽略元音和辅音的特殊情况, 如 "h", "y", "qu" 等. 附加题: 编写处理这些特殊情况的代码.

8–11.   Text Processing. Write a program to ask the user to input a list of names, in the format “Last Name, First Name,” i.e.,
last name, comma, first name. Write a function that manages the input so that when/if the user types the names in the wrong order, i.e., “First Name Last Name,” the error is cor- rected, and the user is notified. This function should also
keep track of the number of input mistakes. When the user
is done, sort the list, and display the sorted names in “Last
Name, First Name” order.

文本处理. 要求输入一个姓名列表，输入格式是“Last Name, First Name,” 即 姓, 逗号, 名. 编写程序处理输入, 如果用户输入错误, 比如“First Name Last Name,” , 请纠正这些错误, 并通知用户. 同时你还需要记录输入错误次数. 当用户输入结束后, 给列表排序, 然后以 "姓 , 名" 的顺序显示.

EXAMPLE input and output (you don’t have to do it this way exactly):

输入输出示例(你不需要完全按照这里里例子完成):

```
% nametrack.py
Enter total number of names: 5

Please enter name 0: Smith, Joe
Please enter name 1: Mary Wong
>> Wrong format... should be Last, First.
>> You have done this 1 time(s) already. Fixing input... Please enter name 2: Hamilton, Gerald
Please enter name 3: Royce, Linda
Please enter name 4: Winston Salem
>> Wrong format... should be Last, First.
>> You have done this 2 time(s) already. Fixing input...

The sorted list (by last name) is: 
    Hamilton, Gerald
    Royce, Linda 
    Salem, Winston 
    Smith, Joe 
    Wong, Mary
```

8–12. (Integer) Bit Operators. Write a program that takes begin and end values and prints out a decimal, binary, octal, hexadeci- mal chart like the one shown below. If any of the characters are printable ASCII characters, then print those, too. If none is, you may omit the ASCII column header.

(整数)位操作. 编写一个程序, 用户给出起始和结束数字后给出一个下面这样的表格, 分别显示出两个数字间所有整数的十进制, 二进制, 八进制和十六进制表示. 如果字符是可打印的 ASCII 字符, 也要把它打印出来, 如果没有一个是可打印字符, 就省略掉 ASCII 那一栏的表头. 请参考下面的输入输出格式:

```
+---------------------------------+
| 此处有一幽默的"表格"            |
+---------------------------------+
```

8–13. Performance. In Section 8.5.2, we examined two basic ways
of iterating over a sequence: (1) by sequence item, and (2) via sequence index. We pointed out at the end that the latter
does not perform as well over the long haul (on my system here, a test suite shows performance is nearly twice as bad
[83% worse]). Why do you think that is?

程序执行性能. 在 8.5.2 节里, 我们介绍了两种基本的迭代序列方法: (1) 通过序列项, 以及 (2) 通过序列索引遍历. 该小节的末尾我们指出后一种方法在序列很长的时候性能不佳. (在我的系统下, 性能差了将近两倍[83%]) 你认为它的原因是什么?
