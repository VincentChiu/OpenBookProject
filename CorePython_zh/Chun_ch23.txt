Miscellaneous
其它话题

Chapter Topics
本章主题

	Introduction
	引言
	Web Services
	Web服务
	Programming Microsoft Office with Win32 COM
	用Win32的COM来操作Microsoft Office
	Python and Java Programming with Jython
	用Jython写Python和Java的程序
	Exercises
	练习
23

in this chapter, we will give brief preview introductions to miscellaneous
areas of Python programming we did not have time to explore more fully.
We hope to eventually develop these into full chapters for future editions of this book.
本章将简单介绍一下有关Python编程一些杂项，很可惜，我们没有足够的时间来更深入的探讨这些主题。
希望在本书的下一版中，将每个相关主题单列一章。

23.1 Web Services
Web服务

There are many Web services and applications on the Net, providing a wide
variety of services. You will find application programmer interfaces (APIs)
from most of the big players today, i.e., Yahoo!, Google, eBay, and Amazon, to
name a few. In the past, APIs have been used just to access data using these
services; however, today ’s APIs are different. They are rich and fully
featured, and you are able to actually integrate services into your own
personal Web sites and Web pages, commonly known as “Mash-ups.”
在网络上，有大量的Web服务和应用，它们提供各式各样的服务。您会发现多数大型服务商都会提供（其服务的）应用程序接口(API)，比如Yahoo!、Google、 eBay和Amazon等等。在过去，API
仅仅被用来访问使用这些服务的数据，但是今天的API已经不同，它们不但丰富而且功能齐全，
而且您可以将这些Web服务整合到您自己的个人网站和网页中，这通常被称作“Mash-ups.”

This is an area of active interest that we will continue to explore (REST, XML,
RSS, etc.), but for now, we are going to take a trip back in time to play
around with an older interface that is both useful and has longevity, the stock
quote server from Yahoo! at http://finance.yahoo.com.
这是一些很有意思的功能，但是，暂时我们只简单的尝试一个很有用，同时提供时间也比较长的服务，即Yahoo!提供的股票报价服务。其网址是http://finance.yahoo.com。

23.1.1 Yahoo! Finance Stock Quote Server
Yahoo!金融股票报价服务器

If you visit the Web site and pull up a quotation for any stock, you will find
a Uniform Resource Locator (URL) link under the basic quote data labeled
“Download Data,” which lets users download a CSV file suitable for importing
into Microsoft Excel or Intuit Quicken:
如果您访问下面的网站查询某支股票的价格，您会在标了“Download Data”的基本报价那里看到
一个连接。这个连接允许你下载一个可以导入Microsoft Excel和Intuit Quicken的CSV格式的文件。

http://finance.yahoo.com/d/quotes.csv?s=GOOG&f=sl1d1t1c1ohgv&e=.csv


让用户下载CSV文件

If your browser’s MIME settings are set correctly, your browser will actually
launch Excel with the resulting data. This is due primarily to the final
variable (key-value) pair found in the link, e=.csv. This variable is actually
not used by the server as it always sends back data in CSV format anyway.
如果浏览器的MIME的设置正确的话，你的浏览器将启动Excel打开下载好的文件。这主要是
因为连接中包含了e=.csv的设置。这样的设置将使server返回CSV格式的结果。

If we use our friend urllib.urlopen(), we see that for any stock ticker symbol,
one CSV string is returned:
如果我们使用urllib.urlopen()来得到报价，会得到一行CSV格式的返回结果：

>>> from urllib import urlopen
>>> u = urlopen('http://quote.yahoo.com/d/quotes.csv?s=YHOO&f=sl1d1t1c1ohgv')
>>> for row in u:
...	print 'row'
...
'"YHOO",30.76,"5/23/2006","4:00pm",+0.30,31.07,31.63,30.76,28594020\r\n'
>>> f.close()

The string would then have to be manually parsed (by stripping the trailing
whitespace and splitting on the comma delimiter). As an alternative to parsing
the data string ourselves, we can use the csv module, introduced in Python 2.3,
which does both the string split and the whitespace strip. Using csv, we can
replace the for loop above with the following assuming all other lines are left
intact:
您可以手工解析这个返回的字符串（去掉头尾的空白字符，根据逗号进行分割）。或者也
可以使用Python2.3版本新加入的csv模块。这个模块自动完成字符串分割和去掉头尾的空
白字符的功能。使用csv的话，我们就可以其它的代码不变，把上面的那个for循环改为：

>>> import csv
>>> for row in csv.reader(u):
...	print row
...
['YHOO', '30.76', '5/23/2006', '4:00pm', '+0.30',
'31.07', '31.63', '30.76', '28594020']


By analyzing the argument field f passed to the server and from reading
Yahoo!’s online help for this service, you will see that the symbols
(sl1d1t1c1ohgv) correspond to: ticker symbol, last price, date, time, change,
open price, daily high, daily low, and volume.
分析传递给server的f参数并看了Yahoo!的这个服务的在线帮助后，我们可以知道，符号
sl1d1t1c1ohgv对应着：订单号，最后的价格，日期，时间，变化量，开盘价，当日最高，
当日最低和成交量。

You can get more information by checking the Yahoo! Finance Help pages ―just
search for “download data” or “download spreadsheet format.”
您可以通过访问Yahoo!  Finance帮助页面获得更多的信息---只要搜索“download data”或“download spreadsheet format”就可以了。

Further analysis of the API reveals a few more options such as the previous
closing price, the percentage change of the current price to the previous
close, the 52-week high and low, etc. All in all, the options can be summa-
rized in Table 23.1 along with the formats of the returned components.
深入的分析这个API，我们可以得到更多的信息，如：上一次收盘价，52周的最高和最低价等
总而言之，表23.1列出了返回数据的格式。

The field names are given in the order you want them from the server. Just
concatenate them together as a single argument to the field parameter f as part
of the requesting URL. As mentioned in the returned value footnote,
每一段的名字按你想要的数据的顺序排列。只要把它们连接在一起整个做为参数f，加到
请求URL中。

Table 23.1  Yahoo! Finance Stock Quote Server Parameters
表23.1 Yahoo! Finance股票报价服务器参数




Stock Quotation Data
Field
Namea

Format Returnedb

Stock ticker symbol	s	"YHOO"

Price of last trade	l1	328

Last trade date	d1	"2/2/2000" Time of last trade	t1	"4:00pm" Change from previous close	c1	+10.625
Percentage change from previous close	p2	"+3.35%"

Previous closing price	p	317.375

Last opening price	o	321.484375

Daily high price	h	337

Daily low price	g	317

52-week range	w	"110 - 500.125"

Volume for the day	v	6703300

Market capitalization	j1	86.343B

Earnings per share	e	0.20

Price-to-earnings ratio	r	1586.88

Company name	n	"YAHOO INC"
公司名字

a.	First character of field name is alphabetic; the second, if any, is numeric.
b.	Some values returned quoted although all are returned in one CSV string.

a. 字段名的第一个字符是一个字母，第二个字符（如果有的话）是数字
b. 有一些值是用双引号引起来的。



some of components returned are quoted separately. It is up to the parser to
properly extract the data. Observe the resulting (sub)strings when parsed
manually vs. using the csv module in our example above. If a value is not
available, the quote server returns “N/A” (separately quoted since that field
is, which makes it consistent . . . a good thing).
有些返回结果是用引号引起来的。解析代码要能正确的解析这些数据。观察上面手工
解析返回字符串和用csv模块解析返回字符串所得到的结果。如果某个值不存在，报价
服务器会返回“N/A“

For example, if we give the server a field request of f=sl1d1c1p2, we get a
string like the following returned for a valid stock ticker:
例如，如果我们给服务器的f字段为f=sl1d1c1p2，我们会得到如下的字符串：

"YHOO",166.203125,"2/23/2000",+12.390625,"+8.06%"

For the case where the stock is no longer publicly traded, we get something
like this instead (note again how fields that come back quoted still do, even
if N/A):
如果是不公开交易的股票，我们会得到如下的结果（注意，不少列都是双引号引起来的，
包括N/A）：

"PBLS.OB",0.00,"N/A",N/A,"N/A"
The quote server will also allow you to specify multiple stock ticker symbols,
as in s=YHOO,GOOG,EBAY,AMZN. You will get back one row of data like the above
for each company. Just keep in mind that “[any] redistribution of quotes data
displayed on Yahoo! is strictly prohibited,” as quoted in the Yahoo! Finance
Help pages, so you should only be using these data for personal reasons. Also
be aware that all of the quotes you download are delayed. Using what we know
now, let us build an example (Example 23.1) application that will read and
display some stock quote data for some of our favorite Internet companies.
报价服务器也支持同时指定多支股票，如s=YHOO,GOOG,EBAY,AMZN.返回的结果是每支股票
信息占一行。要记住Yahoo! Finance帮助页面所说的：任何把Yahoo!显示的数据再次发布
的行为都是严格禁止的。所以，你只能把这些信息用于私人用途。同时也要记住，所有
你得到的数据，都是有一定延时的。用我们已有的知识，我们可以实现一个应用程序
(例23.1)，用于读取并显示一些我们关心的互连网公司的股票报价信息。

Example 23.1  Yahoo! Finance Stock Quote Example (stock.py)
例23.1 Yahoo! Finance股票报价例子 (stock.py)

This script downloads and displays stock prices from the Yahoo! quote server.
这个脚本能从Yahoo!报价服务器下载并显示股票的价格。

1	#!/usr/bin/env python
2
3	from time import ctime
4	from urllib import urlopen
5
6	ticks = ('YHOO', 'GOOG', 'EBAY', 'AMZN')
7	URL = 'http://quote.yahoo.com/d/quotes.csv?s=%s&f=sl1c1p2'
8
9	print '\nPrices quoted as of:', ctime()
10	print '\nTICKER'.ljust(9), 'PRICE'.ljust(8), 'CHG'.ljust(5), '%AGE'
11	print '------'.ljust(8), '-----'.ljust(8), '---'.ljust(5), '----'
12	u = urlopen(URL % ','.join(ticks))
13
14	for row in u:
15	tick, price, chg, per = row.split(',')
16	print eval(tick).ljust(7), \
17	('%.2f' % round(float(price), 2)).rjust(6), \
18	chg.rjust(6), eval(per.rstrip()).rjust(6)
19
20	u.close()

If we run this script, we will get output that looks like the following:
如果我们执行这个脚本，会得到如下的输出：

$ stock.py

Prices quoted as of: Sat May 27 03:25:56 2006

TICKER
PRICE
CHG	%AGE
------
-----
---	----
YHOO
33.02
+0.10 +0.30%
GOOG
381.35
-1.64 -0.43%
EBAY
34.20
+0.32 +0.94%
AMZN
36.07
+0.44 +1.23%



23.2  Programming Microsoft Office with Win32 COM
23.2 用Win32的COM来操作Microsoft Office

One of the most useful things that you can do in an everyday business envi-
ronment is to integrate support for Win32 applications. Being able to read data
from and write data to such applications can often be very handy. Your
department may not be necessarily be running in a Win32 environment, but
chances are, your management and other project teams are. Mark Hammond’s
Windows Extensions for Python allows programmers to interact natively with
Win32 applications in their native environment. (It can be downloaded at the
book’s Web site.)
在你日常工作环境中所能做的最有用的事情之一就是集成对Win32程序的支持。实现从
这样的应用程序中读写数据是很容易的事。虽然你所在的部分可能用不着Win32环境，
但很有可能你的经理或是其它的工程组在用。Mark Hammond的Python的Windows扩展使得
程序员可以在本地环境直接与Win32程序进行交互。（该扩展可以在本书的网站上下载）


The Win32 programming universe is expansive. Most of it available from the
Windows Extensions for Python package, i.e., Windows API, processes, Microsoft
Foundation Classes (MFC) Graphical User Interface (GUI) development, Windows
multithreaded programming, services, remote access, pipes, server-side COM
programming, and events. And don’t forget about IronPython
(http://codeplex.com/Wiki/View.aspx?ProjectName=IronPython), an implementation
of the Python language in C# for the .NET/Mono development environment. In this
section, we are going to focus on one part of the Win32 programming universe,
which easily has practical applications for clientside, COM programming.
Win32编程是一个相当广泛的概念。Python的Windows扩展包包含了其中的大部分。如：
Windows API，进程，Microsoft Foundation Classes (MFC) 图形界面接口 (GUI)开发，
Windows多线程开发，服务，远程访问，管道，COM服务端编程以及事件。还有一个能在
.NET/Mono开发环境中使用的Python语言的C#实现：IronPython。在本节，我们主要关注
Win32程序设计的一部分--客户端COM编程，它有着相当广泛的实际用途。


23.2.1 Client-Side COM Programming
客户端COM编程

We can use Component Object Model, better known as COM (or its marketing
name, ActiveX), to communicate with tools such as Outlook and Excel. For
programmers, the pleasure comes with being able to ‘‘control” a native Office
application directly from their Python code.
我们可以使用组件对象模型，另一个比较熟悉的名字是COM (市场化的名字是ActiveX)
来与诸如Outlook和Excel之类的工具进行通讯。对于程序员来说，能在Python代码中，
直接控制一个本地Office应用程序是一件很快乐的事情。

Specifically, when discussing the use of a COM object, e.g., launching of an
application and allowing code to access methods and data of that applications,
this is referred to as COM client-side programming. Server-side COM programming
is where you are implementing a COM object for clients to access.
特别地，当说到使用一个COM对象时，即启动一个应用程序，并允许代码访问该应用程序
提供的方法，被称为是客户端的COM编程。当你实现一个COM对象，供其它客户端调用则
被称为是服务端的COM编程。



CORE NOTE: Python and Microsoft COM (Client-Side) Programming
核心笔记：Python与Microsoft COM(客户端)编程

Python on the Windows 32-bit platform contains connectivity to COM, a Microsoft
interfacing technology that allows objects to talk to one another, or more
higher-level applications to talk to one another, without any language- or
format-dependence.We will see in this section how the combination of Python and
COM (client programming) presents a unique opportunity to create scripts that
can communicate directly with Microsoft Office applications such as Word,
Excel, PowerPoint, and Outlook.
在Windows 32位平台上，Python与COM是可以相互操作的。COM是微软的一种接口技术，它
定义了语言及格式无关的对象与对象之间或是更高层次的应用程序与应用程序之间的通讯。
本节中，我们将看来如何把Python与COM(客户端编程)组合起来，与Microsoft Office的应
用程序如Word, Excel, PowerPoint和Outlook之间进行通讯。

The prerequisites to this section include running on a Win32 platform with both
Python and the Windows Extensions for Python installed. You must also have one
or more Microsoft applications available to try the examples with. The download
instructions for the Windows Extensions should be adequate to get your system
ready to go. Since PythonWin comes with the Extensions distribution, we
recommend IDE for building and testing your Win32 scripts.
本节的先决条件是要运行在Win32平台上，并且安装了Python和Python的Windows扩展。
同时，必需要安装一个或多个例子中用到的Microsoft应用程序。Python的Windows扩展的下载说明
很容易看懂，照着做一般不会出问题。我们推荐用扩展自带的PythonWin做为创建和测试你
Win32脚本的IDE。

In this section, we will show you how you can interact with an Office applica-
tion. We will present a few examples, some of them quite useful, and describe
how they work in detail. You will also find several of these at the “Python
Cookbook” Web site. We confess to readers that we are not COM or VisualBasic
experts and we are well aware that our examples can be vastly improved. We
would like to solicit the readership to drop us a line and send us any
comments, suggestions, or improvements that you would consider for the general
audience. 
在本节中，我们将演示如何与Office应用程序进行交互。我们将给出几个示例，并详细解释
它们。其中有一些例子是非常实用的。你也能在"“Python Cookbook“网站找到一部分例子。
必需要承认的是，我们并不是COM或是Visual Basic的专家，同时，我们也知道，这些
例子还有很大的可以改进的空间。我们强烈希望所有读者把您认为对大家有用的评论，建议或
改进发给我们。

Let us start with very simple examples of how to launch and interact with
Microsoft Excel, Word, PowerPoint, and Outlook. Before we show you examples
of all we have discussed, we want to point out that client-side COM
applications all follow similar steps in execution. The typical way in which
you would interact with these applications is something like this:
我们先从很简单的Microsoft Excel, Word, PowerPoint, Outlook的启动和交互开始。
在展示例子之前，我们要先指出，客户端COM应用程序运行时都遵循相同的几个步骤。
与这些应用程序进行交互的典型的方法是这样的：

1. Launch application
2. Add appropriate document to work on (or load one from disk)
3. Make application visible (if desired)
4. Perform all desired work on document
5. Save or discard document
6. Quit
                                     
1. 启动应用程序
2. 打开要编辑的文档
3. 显示应用程序（如果有必要的话）
4. 对文档做一定的操作
5. 保存或放弃文档
6. 退出


Enough talking . . . let us take a look at some code. Below are a series of
scripts that control a different Microsoft application. All import the
win32com.client module as well as a couple of Tk modules to control the
launching (and completion) of each application. Also like we did in Chapter 19,
we use the .pyw file extension to suppress the unneeded DOS command window.
说的够多了，下面，开始看一些代码吧。以下是一系列脚本，用于控制不同的微软的应用
程序。这些脚本都导入了win32com.client模块和一些Tk模块来控制各个应用程序的启动
（和其它操作）。同第19章一样，我们采用.pyw后缀来避免不必要的DOS命令窗口。

23.2.2 Microsoft Excel
微软Excel

Our first example is a demonstration using Excel. Of the entire Office suite,
we find Excel to be the most programmable. It is quite useful to pass data to
Excel so that you can both take advantage of the spreadsheet’s features as well
as viewing data in a nice printable format. It is also useful to be able to
read data from a spreadsheet and process data with the power of a real
programming language like Python. We will present a more complex example using
Excel at the end of this section, but we have to start somewhere. So, we start
with Example 23.2.
我们的第一个例子演示如何使用Excel。在整个的Office系列软件中，我们发现Excel是最可
编程的。用Excel处理数据非常的有用，一方面可以利用电子表格的功能优势，另一方面可
以用非常好的打印格式来查看数据。而且可以从电子表格中读取数据，然后使用像Python
这样的编程语言来处理处理数据，这一点也非常有用。在这一部分的最后我们会给出一个使
用Excel的更加复杂一点的例子，但是我们总得开始吧，所以我们先从例23.2开始。


Example 23.2  Excel Example (excel.pyw)
例23.2 Excel 例子(excel.pyw)

This script launches Excel and writes data to spreadsheet cells.
这个脚本启动Excel，然后将数据填到电子表格的空格中。

1    #!/usr/bin/env python
2
3    from Tkinter import Tk
4    from time import sleep
5    from tkMessageBox import showwarning
6    import win32com.client as win32
7
8    warn = lambda app: showwarning(app, 'Exit?')
9    RANGE = range(3, 8)
10
11  def excel():
12	app = 'Excel'
13	xl = win32.gencache.EnsureDispatch('%s.Application' % app)
14	ss = xl.Workbooks.Add()
15	sh = ss.ActiveSheet
16	xl.Visible = True
17	sleep(1)
18
19	sh.Cells(1,1).Value = 'Python-to-%s Demo' % app
20	sleep(1)
21	for i in RANGE:
22	sh.Cells(i,1).Value = 'Line %d' % i
23	sleep(1)
24	sh.Cells(i+2,1).Value = "Th-th-th-that's all folks!"
25
26	warn(app)
27	ss.Close(False)
28	xl.Application.Quit()
29
30  if __name__=='__main__':
31	Tk().withdraw()
32	excel()

Line-by-Line Explanation
逐行解释

Lines 1C6, 31
1C6, 31行
We import Tkinter and tkMessageBox only to use the showwarning message box upon
termination of the demonstration. We withdraw() the Tk top-level window to
suppress it (line 31) before bringing up the dialog box (line 26). If you do
not initialize the top level beforehand, one will automatically be created
for you; it won’t be withdrawn and will be an annoyance on-screen.
我们导入Tkinter和tkMessageBox模块只是为了使用showwarning消息框来终止演示。在显示
对话框(行 26)之前，我们调用withdraw()函数先绘出Tk最顶层的窗口（行31）。如果您不
首先初始化顶层窗口，系统会自动地为您创建一个，不过，自动创建的不会自动关闭，会
很讨厌的显示在屏幕上。


Lines 11C17
11C17行
After the code starts (or “dispatches”) Excel (an application), we add a work-
book (a spreadsheet that contains sheets that the data are written to; these
sheets are organized as tabs in a workbook), and grab a handle to the active
sheet, meaning the sheet that is displayed. Do not get all worked up about the
terminology, which may be confusing mostly because a “spreadsheet contains
sheets.”
当代码启动(或调用)Excel后，我们添加了一个工作簿(就是包含了多个可以写数据的工作表
的电子表格)。并得到了正在显示的活动表格的句柄。不要在术语上花太多精力，因为，
“工作簿包含好几个工作表”这种话很容易使人迷惑。


CORE NOTE: Static and dynamic dispatch
核心笔记：静态和动态调用

On line 13, we use what is known as static dispatch. Before starting up the
script, we ran the Makepy utility from PythonWin. (Start the IDE, select Tools
?  COM Makepy utility and choose the appropriate application object library.)
This utility program creates and caches the objects that are needed for the
application.Without this prep work, the objects and attributes will have to be
built during runtime; this is known as dynamic dispatch. If you want to run
dynamically, then use the regular Dispatch() function:

xl = win32com.client.Dispatch('%s.Application' % app)
在第13行，我们使用的是静态调用。在运行这个脚本之前，我们从PythonWin中运行Makepy
工具（启动IDE，选择Tools --> COM Makepy工具，然后选择相应的应用程序库），这个工具创
建并缓存应用程序需要的对象。没有这些预先准备工作，对象和属性得在运行时建立。如果
是在运行时创建对象和属性，那么就叫做动态调用。如果您想动态运行，那么请使用常用的
Dispatch()函数。



The Visible flag must be set to True to make the application visible on your
desktop, then pause so that the user can see each step in the demonstration
(line 16). For an explanation of the sleep() call on line 17, just read the
next paragraph.
Visible标记必须设为True，这样才可以让应用程序显示在桌面上，然后停下来，这样用户
可以看到演示的每一步(行16)。要知道第17行sleep()调用的含义，请阅读接下来的内容。
　


Lines 19C24
19C24行
In the application portion of the script, we write out the title of our
demonstration to the first and upper leftmost cell, (A1) or (1, 1). We then
skip a row and then write “Line N” where N is numbered from 3 to 7, pausing 1
second in between each row so that users can see our updates happening live.
(The cell updates would occur too quickly without the delay.)
在这个脚本程序的应用部分（application portion），我们把这个演示的标题写到了左
上角的第一格，也就是(A1)或(1, 1)，然后跳过了一行，把“Line N”写到相应的格中，N
是从3到7的数字。在写每一行的时候中间停顿1秒，这样您就可以看到演示过程了（如果
没有延迟，写每一行的过程会非常的快）。


Lines 26C32
26C32行
A warning dialog box comes up after the demo letting the user know that he or
she can quit this demo once they have observed the output. The spreadsheet is
closed without saving, ss.Close([SaveChanges=]False), and the application
exits. Finally, the “main” part of the script just initializes Tk and runs the
core part of the application.
Running this script results in an Excel application window, which should look
similar to Figure 23C1.
在演示结束的时候，会弹出一个消息对话框，以方便用户在看完输出后，结束演示程序。
电子表格关闭时不会被保存，首先调用ss.Close([SaveChanges=]False)，然后应用程序结束。
最后，脚本的“main”部分只是初始化Tk，然后执行应用程序的核心部分。
运行这个脚本程序，会弹出一个Excel应用程序窗口，如图23C1所示。
             
23.2.3 Microsoft Word
微软Word

The next demonstration is with Word. Using Word for documents is not as
applicable to the programming world as there is not much data involved. One
could consider using Word for generating form letters, however. In Example
23.3, we create a document by simply writing one line of text after another.
下面来演示一下如何使用Word。由于涉及到的数据不多，用Word写文档的可编程性就不是
那么强了。你可以考虑用Word来自动生成格式化的信件等。不过，在例23.3中，我们将
创建一个文档，然后简单的写几行字。

Figure 23C1    Python-to-Excel demonstration script (excel.pyw)
Example 23.3  Word Example (word.pyw)
图23C1  

This script launches Word and writes data to the document.
这个脚本启动Word，然后向文档中写数据。

1    #!/usr/bin/env python
2
3    from Tkinter import Tk
4    from time import sleep
5    from tkMessageBox import showwarning
6    import win32com.client as win32
7
8    warn = lambda app: showwarning(app, 'Exit?')
9    RANGE = range(3, 8)
10
11  def word():
12	app = 'Word'
13	word = win32.gencache.EnsureDispatch('%s.Application' % app)
14	doc = word.Documents.Add()
15	word.Visible = True
16	sleep(1)
17
18	rng = doc.Range(0,0)
19	rng.InsertAfter('Python-to-%s Test\r\n\r\n'	% app)       //Check codes here
20	sleep(1)	
21	for i in RANGE:	
22	rng.InsertAfter('Line %d\r\n' % i)
23	sleep(1)
24	rng.InsertAfter("\r\nTh-th-th-that's all folks!\r\n")
25
26	warn(app)
27	doc.Close(False)
28	word.Application.Quit()
29
30  if __name__=='__main__':
31	Tk().withdraw()
32	word()

The Word example follows pretty much the same script as the Excel example. The
only difference is that instead of writing in cells, we have to insert the
strings into the text “range” of our document and move the cursor forward after
each write. We also have to manually provide the line termination characters of
carriage RETURN following by NEWLINE (\r\n).  
这个Word的例子和上面的Excel例子非常的相似，唯一的不同是我们得在文档“范围”内插入
字符串，每写一次得向前移动一下光标，而不是像在Excel中那样，得写在每一格中。我们
还得在程序中写明行结束符，也就是回车换行(\r\n)。

If we run this script, a resulting screen might look like Figure 23C2.
如果我们执行这个脚本程序，会显示如图23C2的界面。

Figure 23C2    Python-to-Word demonstration script (word.pyw)
                            图23C2 


23.2.4 Microsoft PowerPoint
微软PowerPoint

Applying PowerPoint in an application may not seem commonplace, but you could
consider using it when you are rushed to make a presentation. You can create
your bullet points in a text file on the plane, then upon arrival at the hotel
that evening, use a script that parses the file and auto-generates a set of
slides. You can further enhance those slides by adding in a background,
animation, etc., all of which are possible through the COM interface. Another
use case would be if you had to auto-generate or modify new or existing pre-
sentations. You can create a COM script controlled via a shell script to create
and tweak each presentation generated. Okay, enough speculation . . . now let
us take a look at our PowerPoint example (i.e., Example 23.4).
在应用程序中使用PowerPoint并不太常见，但是当您急于制作演示文稿的时候可能会考虑
使用它。您可以在飞机上用文本文件写下核心内容，然后在抵达酒店的夜里用脚本程序处
理这个文件来自动生成一系列的幻灯片。您甚至可以通过添加背景和动画等东西来增强
效果，这些都可以通过COM接口做到。另外一个使用到的情况就是当您不得不自动生成或
修改新的或已存在的演示文档的时候。您可以通过shell脚本程序控制COM脚本来创建来创建
或者调整每个生成的幻灯片。好了，太多的解释了……。现在来看一下我们的PowerPoint例
子，如例23.4所示。


Again, you will notice similarities to both the Excel and Word demonstrations
above. Where PowerPoint differs is in the objects you write data to. Instead of
a single active sheet or document, PowerPoint is somewhat trickier because each
presentation slide can have a different layout. With a presentation, you have
multiple slides, and each slide can have a different layout. (Recent versions
of PowerPoint have 30 different layouts!) The actions you can perform on a
slide depend on which layout you have chosen for each page.

您会再一次注意到这个例子和上面的Excel和Word演示非常的相似。PowerPoint的不同之处
在于您写入数据的对象不一样了。不是向单独的表格或文档中写入数据，PowerPoint更为
复杂，因为每一张幻灯片可以有不同的布局。在一个演示文档中，您有多张幻灯片，其中
每一张幻灯片可以有不同的布局。(最新版本的PowerPoint有30种不同的布局。)你可以进行
的操作依您所选的布局不一样而各有不同。

In our example, we just use a (title and) text layout (line 17) and fill in the
main title (lines 19C20), Shape[0] or Shape(1)―Python sequences begin at index
0 while Microsoft software starts at 1―, and the text portion (lines 22C26),
Shape[1] or Shape(2). To figure out which constant to use, you will need a list
of all the ones available to you. For example, ppLayoutText is defined as a
constant with a value of 2 (integer), ppLayoutTitle is 1, etc. You can find the
constants in most Microsoft VB/Office programming books or online by just
searching on the names. Alternatively, you can just use the integer constants
without having to name them via win32.constants.
The PowerPoint screenshot is shown in Figure 23C3.
在本例中，我们选用一个只有标题和文本的布局(17行)，并填充主标题(19-20行)，即Shape[0]
或Shape(1)――Python的下标从0开始，微软的软件从1开始――然后填充文本(22-26行)，即
Shape[1]或Shape(2)。为了了解要使用哪一个常量，你需要一个所有可用的常量列表。例如，
ppLayoutText常量的值被定义为2(整型)，ppLayoutTitle为1，等。你可以在大多数微软
VB/Office编程的书中或根据名字在线查找相关的定义。或者，你也可以直接使用整型值，而
不使用win32.constants中的名字。


Example 23.4  PowerPoint Example (ppoint.pyw)
例23.4 PowerPoint例子(ppoint.pyw)

This script launches PowerPoint and writes data to the “shapes” on a slide.
这个脚本启动PowerPoint并在幻灯片中写入一些数据。


1    #!/usr/bin/env python
2
3    from Tkinter import Tk
4    from time import sleep
5    from tkMessageBox import showwarning
6    import win32com.client as win32
7
8    warn = lambda app: showwarning(app, 'Exit?')
9    RANGE = range(3, 8)
10
11  def ppoint():
12	app = 'PowerPoint'
13	ppoint = win32.gencache.EnsureDispatch('%s.Application' % app)
14	pres = ppoint.Presentations.Add()
15	ppoint.Visible = True
16
17	s1 = pres.Slides.Add(1, win32.constants.ppLayoutText)
18	sleep(1)
19	s1a = s1.Shapes[0].TextFrame.TextRange
20	s1a.Text = 'Python-to-%s Demo' % app
21	sleep(1)
22	s1b = s1.Shapes[1].TextFrame.TextRange
23	for i in RANGE:
24	s1b.InsertAfter("Line %d\r\n" % i)
25	sleep(1)
26	s1b.InsertAfter("\r\nTh-th-th-that's all folks!")
27
28	warn(app)
29	pres.Close()
30	ppoint.Quit()
31
32  if __name__=='__main__':
33	Tk().withdraw()
34	ppoint()




23.2.5 Microsoft Outlook
微软Outlook


Finally, we give an Outlook demonstration, which uses even more constants than
PowerPoint. As a fairly common and versatile tool, use of Outlook in an
application makes sense, like it does for Excel. There are always e-mail
addresses, messages, and other data that can be easily manipulated in a Python
program. Example 23.5 is an Outlook example that does a little bit more than
our previous examples.
最后，我们给一个Outlook的例子，它使用了比PowerPoint例子更多的常量，作为一个十分
常见和通用的工具软件，在应用程序中使用Outlook非常有意义，这与前面Excel的例子
一样。总是有电子邮件地址、邮件和其它数据可以在Python程序中轻松地处理。例23.5就是
Outlook的一个例子，但是比前面的例子都要复杂一点。

Figure 23C3    Python-to-PowerPoint demonstration script (ppoint.pyw)
图23C3


In this example, we use Outlook to send an e-mail to ourselves. In order to
make the demonstration work, you need to turn off your network access so that
you do not really send the message, and thus are able to view it in your Outbox
folder (and delete it if desired after viewing it). After launching Outlook, we
create a new mail message and fill out the various fields such as recipient,
subject, and body (lines 15C21). We then call the send() method (line 22) to
spool the message to the Outbox where it will be moved to “Sent Mail” once the
message has actually been transmitted to the mail server.
在这个例子中，我们用Outlook给自己发了一封电子邮件。为了更好的演示这个例子，你
需要先关闭网络访问，以确保你的email并不会真正的被发送出去，这样，你就可以在发
件箱里看到这封邮件（如果需要的话，还可以在看完后删除它）。启动Outlook后，我们
写一封新的电子邮件，然后填好各个栏，例如收信人、主题和信件内容等(15C21行)。
然后调用send()(22行)将信存储到发件箱，在这里，信件一旦被确实发送到邮件服务器
上，就会被移动到“已发送”。

Like PowerPoint, there are many constants available . . . olMailItem (with a
constant value of 0) is the one used for e-mail messages. Other popular Outlook
items include olAppointmentItem (1), olContactItem (2), and olTaskItem (3). Of
course, there are more, so you will have to find a VB/ Office programming book
or search for the constants and their values online.
象PowerPoint一样，Outlook有很多可以使用的常量……。olMailItem(其值为0)常量被用于
e-mail信息。其它常用的Outlook常量有：olAppointmentItem (1), olContactItem (2), 
olTaskItem (3)。当然，还有很多没有一一列出，你可以在介绍VB/Office编程的书中或者在线文档中查找相关常量的定义。

In the next section (lines 24C27), we use another constant, olFolderOutbox (4),
to open the Outbox folder and bring it up for display. We find the most recent
item (hopefully the one we just created) and display it as well. Other popular
folders include: olFolderInbox (6), olFolderCalendar (9), olFolderContacts
(10), olFolderDrafts (16), olFolderSentMail (5), and olFolderTasks (13). If you
use dynamic dispatch, you will likely have to use the numeric values instead of
the constants’ names (see previous Core Note).
下一部分(24-27行)，我们使用了另一个常量olFolderOutbox (4)，来打开并显示发件箱目
录，我们找到最新的几封邮件（有可能是我们刚刚创建的），并显示它们。其它几个常用的
目录有：olFolderInbox (6), olFolderCalendar (9), olFolderContacts
(10), olFolderDrafts (16), olFolderSentMail (5), 和olFolderTasks (13)。如果你
使用动态调用，你可能要使用具体的数值，而不是常量的名字（见之前的核心笔记）。
　
Example 23.5  Outlook Example (olook.pyw)
例23.5 Outlook例子(olook.pyw)

This script launches Outlook, creates a new message, “sends” it, and lets you
view it by opening and displaying both the Outbox and the message itself.
这个脚本启动Outlook，创建一封邮件，“发送”这封邮件，并允许你打开发件箱浏览这封
邮件。

1    #!/usr/bin/env python
2
3    from Tkinter import Tk
4    from time import sleep
5    from tkMessageBox import showwarning
6    import win32com.client as win32
7
8    warn = lambda app: showwarning(app, 'Exit?')
9    RANGE = range(3, 8)
10
11  def outlook():
12	app = 'Outlook'
13	olook = win32.gencache.EnsureDispatch('%s.Application' % app)
14
15	mail = olook.CreateItem(win32.constants.olMailItem)
16	recip = mail.Recipients.Add('you@127.0.0.1')
17	subj = mail.Subject = 'Python-to-%s Demo' % app
18	body = ["Line %d" % i for i in RANGE]
19	body.insert(0, '%s\r\n' % subj)
20	body.append("\r\nTh-th-th-that's all folks!")
21	mail.Body = '\r\n'.join(body)
22	mail.Send()
23
24	ns = olook.GetNamespace("MAPI")
25	obox = ns.GetDefaultFolder(win32.constants.olFolderOutbox)
26	obox.Display()
27	obox.Items.Item(1).Display()
28
29	warn(app)
30	olook.Quit()
31
32  if __name__=='__main__':
33	Tk().withdraw()
34	outlook()




Figure 23C4 shows a screen capture of just the message window.
图23-4为邮件窗口的的截图

Before we get this far, however, from its history we know that Outlook has been
vulnerable to all kinds of attacks, so Microsoft has built some protection into
Outlook for restricting access to your address book and being able to send mail
on your behalf. When attempting to access your Outlook data, the screen shown
in Figure 23C5 pops up where you must explicitly give permission to an outside
program.
由于，之前的Outlook总是被用于各种各样的攻击中，微软在Outlook中，加入了一些保护措
施，来限制对通讯簿的访问以及代表你发送邮件。当外部程序想要访问你的Outlook的数据
的时候，会弹出一个如图23-5所示的对话框，以征取你的同意。

Then when you are trying to send a message from an external program, you get
the warning dialog shown in Figure 23C6, where you have to wait until the timer
expires before you are allowed to select “Yes.”
当你想要用外部程序发送邮件的时候，你会看到一个如图23-6所示的警告对话框。你必需
等到计时器倒数结束后才能点击“确定”按钮。

Figure 23C4    Python-to-Outlook demonstration script (olook.pyw)
图23C4 Python-to-Outlook示例脚本 (olook.pyw)



Once you pass all the security checks, everything else should work smoothly.
There is software available to help get you around these checks but they have
to be downloaded and installed separately.
一旦你完成了所有安全检查，其它所有的事都能很顺利的完成。也有一些软件可以帮助你
绕过这些检查，但它们需要单独下载和安装。

On this book’s Web site at http://corepython.com, you will find an alternative
script that combines these four smaller ones into a single application that
lets users choose which of these demonstrations to run.
在本书的网站http://corepython.com上，你能找到一个把这所有4个小脚本集成在一起的
一个脚本，允许用户选择要运行哪一个示例。

Figure 23C5    Outlook address book access warning
图23C5 Outlook地址簿访问警告




Figure 23C6    Outlook e-mail transmission warning
图23C6 Outlook 电子邮件传输警告


23.2.6 Intermediate Example
中等规模的例子

Now that we have gotten a good taste of Office programming, let us build a more
useful application by combining the material from this section with that of the
Web Services section. If we were to combine the stock quote example with our
Excel demonstration script, we would get an application that would download
stock quotes from the net and pop them directly into Excel without having to
create or use CSV files as a medium (see Example 23.6).
现在，我们对Office编程已经有了一些概念，接下来，我们要把本节所列的知识与Web服务
那一节的知识组合起来，写一个更实用的应用程序。如果我们把股票报价的例子与Excel
演示脚本合起来，就能形成一个能从网上下载股票报价，并把结果直接放到Excel中的应用
程序，而不用把数据放在CSV文件中做为中介。

Line-by-Line Explanation
逐行解释

Lines 1C13
We import all of the attributes from both the original Web services stock quote
(stock.py) above and Excel scripts here as well as define the same constants.
我们导入股票报价和Excel脚本两个例子中的所使用的模块与常量。

Lines 15C32
The first part of the core function launches Excel as seen earlier (lines
17C21). The title and timestamp are then written to cells (lines 23C29), along
with the column headings, which are then bolded (line 30). The remaining cells
are dedicated to writing the actual stock quote data, starting in row 6 (line
32).
核心功能的第一部分是像之前那个脚本(17-21行)那样启动Excel。把标题和时间写到相应
的单元格中(23-29行)，然后是粗体(30行)的列的头。从第6行开始(32行)的单元格会写入
实际的股票报价的数据

Lines 34C43
We open the URL as before (line 34), but instead of just writing the data to
standard output, we fill in the spreadsheet cells, one column of data at a
time, and one company per row (lines 35C42).
如同之前一样，打开一个URL(34行)，但不再把结果写到标准输出，我们把结果填到电子
表格的单元格中。一次放一列数据，每行一个公司的股票信息(35-42行)。

Lines 45C51
The remaining lines of our script mirror code that we have seen before.
脚本的剩下几行作用与之前看到的一样。

Example 23.6  Stock Quote and Excel Example (estock.pyw)
例23.6 股票报价与Excel例子 (estock.pyw)

This script downloads stock quotes from Yahoo! and writes the data to Excel.
这个脚本从Yahoo!下载股票报价并把数据写入到Excel。

1    #!/usr/bin/env python
2
3    from Tkinter import Tk
4    from time import sleep, ctime
5    from tkMessageBox import showwarning
6    from urllib import urlopen
7    import win32com.client as win32
8
9    warn = lambda app: showwarning(app, 'Exit?')
10  RANGE = range(3, 8)
11  TICKS = ('YHOO', 'GOOG', 'EBAY', 'AMZN')
12  COLS = ('TICKER', 'PRICE', 'CHG', '%AGE')
13  URL = 'http://quote.yahoo.com/d/quotes.csv?s=%s&f=sl1c1p2'
14
15  def excel():
16	app = 'Excel'
17	xl = win32.gencache.EnsureDispatch('%s.Application' % app)
18	ss = xl.Workbooks.Add()
19	sh = ss.ActiveSheet
20	xl.Visible = True
21	sleep(1)
22
23	sh.Cells(1, 1).Value = 'Python-to-%s Stock Quote Demo' % app
24	sleep(1)
25	sh.Cells(3, 1).Value = 'Prices quoted as of: %s' % ctime()
26	sleep(1)
27	for i in range(4):
28	sh.Cells(5, i+1).Value = COLS[i]
29	sleep(1)
30	sh.Range(sh.Cells(5, 1), sh.Cells(5, 4)).Font.Bold = True
31	sleep(1)
32	row = 6
33
34	u = urlopen(URL % ','.join(TICKS))
35	for data in u:
36	tick, price, chg, per = data.split(',')
37	sh.Cells(row, 1).Value = eval(tick)
38	sh.Cells(row, 2).Value = ('%.2f' % round(float(price), 2))
39	sh.Cells(row, 3).Value = chg
40	sh.Cells(row, 4).Value = eval(per.rstrip())
41	row += 1
42	sleep(1)
43	u.close()
44
45	warn(app)
46	ss.Close(False)
47	xl.Application.Quit()
48
49  if __name__=='__main__':
50	Tk().withdraw()
51	excel()


Figure 23C7 shows a window with real data after executing our script.
图23C7显示的是，运行了我们的脚本后，有实际数据的窗口。

Figure 23C7    Python-to-Excel stock quote demonstration script (estock.pyw)
图23C7 Python-to-Excel股票报价示例脚本 (estock.pyw)

Note that the data columns lose the original formatting of the numeric strings
because Excel stores them as numbers using the default cell format. We lose the
formatting of the numbers to two places after the decimal point, e.g., “34.2”
is displayed even though Python passed in “34.20”; and for the “change from
previous close column,” we lose not only the decimal places but also the plus
sign ( + ) indicating a positive change in value. (Compare the output in Excel
to the output from the original text version [stock.py]. These problems will be
addressed by an exercise at chapter’s end.)
注意，存放数字的那几列的原始格式信息已经没有了，因为，Excel用默认的单元格格式把
它们存为数字了。我们把数字的格式改为保留小数点后两位。虽然Python传的是"34.20"，
但显示的时候，还是显示"34.2"。而“自上次收盘的变动”那一列，则不仅少了小数点后的
数字，而且，数字前面的用于表示升值的正号(+)也没了。(这是Excel的输出和原始文本版的
比较。这些问题在本章结尾的练习中有详细说明。)


23.3  Python and Java Programming with Jython
用Jython写Python和Java的程序


23.3.1 What Is Jython?
什么是Jython

Jython is one of those tools that can unite two diverse programming popula-
tions. For one, it caters to Python programmers embedded in a Java develop-
ment environment and gives them the ability to rapidly prototype solutions that
seamlessly integrate into an existing Java platform. Another reason is that it
helps simplify the lives of millions of Java programmers out there by giving
Java a scripting language environment. No longer do Java programmers have to
write a test harness or driver application to simply test a class they have
just written.
Jython是一种可以把两种不同的编程语言结合在一起的工具。首先，它使Python
程序员介入到Java开发环境并让他们能快速开发方案原型，以便无缝地集成到现有的Java
平台上。其次，它能在Java中加入脚本语言，并以此来简化数计百万计的Java程
序员的工作。Java程序员们，再也不用为他们刚写的一个类写一大堆的测试用例或驱动
程序。

Jython gives you most of what Python has to offer along with the ability to
instantiate and interact with Java classes too! Jython code is dynamically com-
piled into Java bytecode, plus you can extend Java classes in Jython. You can
also extend Python using Java. It is quite easy to write a class in Python and
then use it as a Java class. You can always statically compile a Jython script
into Java bytecode.
Jython提供了Python的大部分功能，以及实例化Java类并与Java类交互的功能。Jython
代码被动态地编译成Java字节码，因此，你可以用Jython扩展Java类。也可以用
Java来扩展Python。在Python中写一个类，像使用Java类一样使用这个类是很容易的事情。
你甚至可以把Jython脚本静态地编译为Java字节码。

Jython can be downloaded from the book’s Web site or at http://jython.org.
After installation and seeing some default startup notices of processing new
.jar files, starting up Jython’s interactive interpreter looks eerily like
you’re using Python. And yes, Virginia, you can still do the same old “Hello
World!” in Python:
你可以从本书的网站或http://jython.org下载Jython。在安装完，并阅读了一些处理
新的.jar文件的默认启动注意事项后，启动Jython的交互解释器就跟用Python一样简单。
而且，你也可以像在Python中一样，写一个“Hello World!”：

$ jython
Jython 2.2a1 on java1.4.2_09 (JIT: null)
Type "copyright", "credits" or "license" for more information.
>>> print 'Hello World!' Hello World!
>>>
>>> import sys
>>> sys.stdout.write('Hello World!\n') Hello World!

The only difference is that you now have (to wait for) Java’s long startup
time. Once you have accepted that inevitability, you can move on to greater
things. The more interesting thing about the Jython interactive interpreter is
that now you can do “Hello World!” using Java(!):
唯一的不同是，现在，你不得不等待Java那超长的启动时间。如果你能忍受这个，你
就能做一些更有用的事了。用Jython交互解释器的一个更有趣的方面就是，现在，你
可以用Java来写“Hello World!”了：

>>> from java.lang import System
>>> System.out.write('Hello World!\n') Hello World!

Java gives Python users the added bonuses of native exception handling (not
available in standard Python, or “CPython” as it is called, when being referred
to among other implementations) as well as use of Java’s own garbage
collector (so Python’s did not have to be [re]implemented for Java).
Java给了Python用户一些额外的好处，即可以使用本地异常处理(这在标准Python――相对
于其它实现来说，也被称为“CPython”――里是没有的。)以及可以使用Java的垃圾收集器
(这样就没必要再为Java开发一套Python的实现了)。

23.3.2 Swing GUI Development (Java or Python!)
Swing GUI 开发(Java或者Python!)

By having access to all Java classes, we have a much broader universe of what
is possible. One example is GUI development. In Python, we have the default GUI
of Tk via the Tkinter module, but Tk is not a native Python toolkit. However,
Java does have Swing, and it is native. With Jython, we can actually write a
GUI application using Swing components . . . not with Java, but using Python.
具有对所有Java类的访问能力，我们能做的事就太多了。比方说，图形界面(GUI)的开发。
在Python中，我们用Tkinter模块中的Tk做为默认GUI，但是，Tk不是Python的本地工具包。
不过，Java有Swing，它是本地的。用Jython，我们可以用Swing组件写一个GUI应用程序，
不是用Java，而是用Python。

A simple “Hello World!” GUI written in Java followed by its equivalent in
Python is given in Examples 23.7 and 23.8, respectively, both of which mimic
the Tk examples tkhello3.py found earlier in the GUI programming chapter.
These programs are called swhello.java and swhello.py, respectively.
一个简单的“Hello World!”GUI程序的Java版本和对应的Python版本分别在例23.7和23.8
中给出。这两个版本都模仿了图像界面编程那一章的Tk例子tkhello3.py。这两段程序
分别叫swhello.java和swhello.py。

Example 23.7  Swing “Hello World” in Java (swhello.java)
例23.7 Java中，用Swing写“Hello World” (swhello.java)

This program creates a GUI just like tkhello3.py but uses Swing instead of Tk.
It is written in Java.
本程序像tkhello3.py那样，创建一个GUI。使用Swing而不是Tk。使用的语言是Java。

1   import java.awt.*;
2   import java.awt.event.*;
3   import javax.swing.*;
4   import java.lang.*;
5
6   public class swhello extends JFrame {
7	JPanel box;
8	JLabel hello;
9	JButton quit;
10
11	public swhello() {
12	super("JSwing");	
		BorderLayout());
13	JPanel box = new JPanel(new
14	JLabel hello = new JLabel("Hello World!");
15	JButton quit = new JButton("QUIT");
16
17	ActionListener quitAction = new ActionListener() {
18	public void actionPerformed(ActionEvent e) {
19	System.exit(0);
20	}
21	};
22	quit.setBackground(Color.red);
23	quit.setForeground(Color.white);
24	quit.addActionListener(quitAction);
25	box.add(hello, BorderLayout.NORTH);
26	box.add(quit, BorderLayout.SOUTH);
27
28	addWindowListener(new WindowAdapter() {
29	public void windowClosing(WindowEvent e) {
30	System.exit(0);
31	}
32	});
33	getContentPane().add(box);
34	pack();
35	setVisible(true);
36	}
37
38	public static void main(String args[]) {
39	swhello app = new swhello();
40	}
41 }
Example 23.8  Swing “Hello World” in Python (swhello.py)
例23.8 Python中，用Swing写“Hello World” (swhello.py)

This is an equivalent Python script to the above Java program and executed with
the Jython interpreter.
下面的Python脚本代码具有和上面的Java程序具有相同的功能，需要在Jython解释器中执行。

1	#!/usr/bin/env jython
2
3	from pawt import swing
4	import sys
5	from java.awt import Color, BorderLayout
6
7	def quit(e):
8	sys.exit()
9		
10	top	= swing.JFrame("PySwing")
11	box	= swing.JPanel()

12    hello = swing.JLabel("Hello World!")
13    quit = swing.JButton("QUIT", actionPerformed=quit,
14	background=Color.red, foreground=Color.white)
15		
16	box.add("North",	hello)
17	box.add("South",	quit)

18    top.contentPane.add(box)
19    top.pack()
20    top.visible = 1	# or True for Jython 2.2+


The code for both matches that of tkhello3.py except they use Swing instead of
Tk. The hallmark of the Python version is the significant reduction in the
number of lines of code necessary to do the same thing in Java. The Python code
is more expressive, with each line of code having more significance. In short,
there is less “white noise.” Java code tends to have a lot more boilerplate
code to get work done, while Python lets you concentrate on the important parts
of your application: the solution to the problem you are trying to solve.
两段代码都与tkhello3.py一致，唯一的区别就是它们使用了Swing而不是Tk。Python版本的
特点是，做同样的事，Python所要写的代码相比Java大幅减少。Python代码的表达能力更强，
所以，每一行都显得更为重要。简单地说，就是“白色噪音”更少了。Java的代码更趋向于用
更多的“样板”代码来完成工作，而Python则让你把注意力集中在你的应用的重要部位，即
你要解决的问题的解决方案上。


Since both applications are compiled to Java bytecode, it is no surprise that
both applications look exactly alike when executing on the same platform
(see Figure 23C8).
由于两个程序都会被编译为Java字节码，在同一个平台上两个程序看上去完全一样也就没
什么好奇怪的了(见图23-8)。

Jython is a great development tool because you get the expressiveness of Python
plus the rich API in the Java libraries. If you are a current Java developer,
we hope that we have whet your appetite in terms of what you can now do with
the power of Python behind you. If you are new to Java, Jython will be able to
ease you in gently. You can prototype in Jython, then port easily to Java as
necessary.
Jython是一个很伟大的工具。因为，你同时得到了Python的强大的表达能力，以及Java库中
丰富的API。如果你现在是一个Java程序员，希望我们已经引起了你对你身后Python强大
力量的兴趣。如果你是Java新手，Jython能让你更为轻松。你可以用Jython写原型，然后，
在必要的时候，轻松的移植到Java中。

MacOS X





Win32


Java	Python
Figure 23C8    Swing Hello World Demonstration Scripts (swhello.{java,py})
图23-8 Swing的Hello World示例脚本(swhello.java和swhello.py)

23.4 Exercises
练习

Web Services
Web服务

23C1.   Web Services. Take the Yahoo! stock quote example (stock.py) and change
the application to save the quote data to a file instead of displaying it to
the screen. 
Optional: You may change the script so that users can choose to display the
quote data or save it to a file.
23-1. Web服务。使用yahoo!股票报价示例(stock.py)并把这个程序改为把报价数据保存到
一个文件中，而不在屏幕上显示。可选题：你可以修改脚本，让用户可以选择是显示报价
还是保存到文件中。

23C2.   Web Services. Update the Yahoo! stock quote example (stock.py)  to
download other stock quote data given the additional parameters listed above.
Optional: You may add this feature to your solution to the above exercise.
23-2. Web服务。修改yahoo!股票报价示例(stock.py)，让程序可以下载上面所列的其它
参数数据。可选题：你可以把这个功能加到上一题的程序中。

23C3.   Web Services and the csv Module. Convert stock.py to using the csv
module to parse the incoming data, like we did in the example code snippet.
Extra Credit: Do the same thing to the Excel version of this script
(estock.py).
23-3. Web服务和csv模块。修改stock.py，像我们在示例代码中那样，使用csv模块来
解析得到的数据。附加题：用同样的方法修改这个脚本的Excel版本(estock.py)。

23C4.   REST and Web Services. Study how REST and XML are used in more
modern-day Web services APIs and applications. Describe the additional
functionality you get over older systems like the Yahoo! quote server, which
uses URL parameters.
23-4. REST与Web服务。学习现在的Web服务APIs和应用程序中，REST与XML是如何被使用的。
与老式的Web服务，像Yahoo!报价服务这种用URL参数的方式相比较，额外提供了哪些的功能。

23C5.   REST and Web Services. Build an application framework using Python’s
support for REST and XML that will allow you to share and reuse this code when
writing applications that use any of the newer Web services and APIs available
today. Display your code using APIs from Yahoo!, Google, eBay, and/or Amazon.
23-5. REST与Web服务。利用Python对REST和XML的支持，创建一个应用程序的框架，这个
框架要能在写使用如今这些更新的Web服务和API应用程序的时候，能实现代码的共享和重用。展示
你的使用Yahoo!, Google, eBay及(或)Amazon服务的代码。


Microsoft Office Programming
微软Office编程

23C6.   Microsoft Excel and Web Pages. Create an application that will read
data from an Excel spreadsheet and map all of it to an equivalent HTML table.
(You may use the third-party HTMLgen module if desired.)
23-6 微软Excel和网页。创建一个应用程序，读取Excel电子表格中的数据，并生成一个
对应的HTML表格。（你可能需要第三方的HTMLgen模块）

23C7.   Microsoft Office Applications and Web Services. Interface to any
existing Web service, whether REST- or URL-based, and write data to an Excel
spreadsheet or format the data nicely into a Word document. Format them
properly for printing. Extra Credit: Support both Excel and Word.
23-7. 微软Office应用程序与Web服务。连接到任何现有的Web服务，无论是基于REST还是URL的，
并把数据写到Excel电子表格中，或设置一个比较好看的格式，然后放到Word文档中。
格式要适于打印。附加题：要同时支持Excel和Word。

23C8.   Microsoft Outlook and Web Services. Similar to the previous problem, do
the same thing, but put the data into a new e-mail message that you send with
Outlook. Extra Credit: Do the same thing but send the e-mail with regular SMTP
instead. (You may wish to refer to Chapter 17 on Internet Client Programming.)
23-8. 微软Outlook和Web服务。与之前的问题相似，做同样的事情，并把数据放到一封新的
email中，并用Outlook发送出去。附加题：做同样的事，但是用普通的SMTP服务器来发送
email，而不使用Outlook。（你可能想要参考第17章Internet客户端编程）

23C9.   Microsoft PowerPoint. Design a presentation slide creator. Design the
specification of a text file that users will create with Word or a normal text
editor. Using the specification format, read in the presentation data and
create the appropriate PowerPoint slides all as part of a single presentation.
23-9. 微软PowerPoint。设计一个演示文档生成器。设计一种用Word，或普通文本编辑器
就能生成的文本文件的格式。从遵循该格式的文本文件中，读出要演示的数据，并生成
对应的PowerPoint幻灯片放在一个演示文档中。

23C10.   Microsoft Outlook, Databases, and Your Address Book. Write a program
that will extract the contents of an Outlook address book and store the desired
fields into a database. The database can be a text file, DBM file, or even an
RDBMS. (You may wish to refer to Chapter 21, Database Programming.) Extra
Credit: Do the reverse . . . read in contact information from a database (or
allow for direct user input) and create or update records in Outlook.
23-10. 微软Outlook，数据库和你的地址簿。写一个程序，从Outlook的地址簿中读出数据，
把想要的字段保存到数据库中。数据库可以是一个文本文件，DBM文件，或是一个关系数据
库。（你可能想要参考第21章，数据库编程）。附加题：完成反向的工作。即，从数据库
（或允许用户直接输入）中读取联系人的信息，添加或更新记录到Outlook中。

23C11.   Microsoft Outlook and E-mail. Develop a program that backs up your
e-mail by taking the contents of your Inbox and/or other important folders and
saves them in (as close to) regular “box” format to disk.
23-11. 微软Outlook和Email。开发一个程序读取收件箱和（或）其它重要的文件夹的数据，
并把它们用普通的“box”格式保存到磁盘上。

23C12.   Microsoft Outlook Calendar. Write a simple script that creates new
Outlook appointments. Take at least the following as user input: start date and
time, appointment name or subject, and duration of appointment.
23-12. 微软Outlook日历。写一个脚本创建新的Outlook任务。至少要允许用户输入以下
信息：开始日期和时间，任务名字或主题以及任务持续时间。

23C13.   Microsoft Outlook Calendar. Build an application that dumps the
contents of your appointments to a destination of your choice, i.e., to the
screen, to a database, to Excel, etc. Extra Credit: Do the same thing to your
set of Outlook tasks.
23-13. 微软Outlook日历。创建一个应用程序，导出你的所有任务信息到一个你指定的地方，
如，屏幕上，数据库里，Excel里等。附加题：程序也要可以导出Outlook任务。

23C14.   Multithreading. Update the Excel version of the stock quote download
script (estock.pyw) so that the downloads of data happen “concurrently” using
multiple Python threads.  Optional: You may also try this exercise with Visual
C++ threads using win32process.beginthreadex().
23-14. 多线程。修改股票报价下载脚本(estock.pyw)，使用多个Python线程，让数据下载
部分可以“并行”。可选题：你也可以试试用win32process.beginthreadex()来产生Visual
C++的线程来做这一题。

23C15.   Excel Cell Formatting. In the spreadsheet version of the stock quote
download script (estock.pyw), we saw in Figure 23C7 how the stock price does
not default to two places after the decimal point even if we pass in a string
with the trailing zero(s). When Excel converts it to a number, it uses the
default setting for the number format.
23-15. Excel单元格格式。在股票报价下载脚本(estock.pyw)的电子表格版本中，我们在
图23-7中看到股票价格并不是默认到小数点后两位，就算我们传进去的是有后缀0的也不行。
当Excel把这个字符串转为数字的时候，就自动使用数字格式的设定。
(a) Change the numeric format to correctly go out to two decimal places by
changing the cell’s NumberFormat attribute to “0.00.”
(a) 把单元格的NumberFormat属性设为"0.00"就可以把数字的格式正确的设定为两个小数位。

(b) We can also saw that the “change from previous close” column loses the “+”
in addition to the decimal point formatting.  However, we discover that making
the correction in part (a) to both columns only solves the decimal place
problem … the plus sign is automatically dropped for any number. The solution
here is to change this column to be text instead of a number. You can do this
by changing the cell’s NumberFormat attribute to “@.”
(b) 我们也看到“自上次收盘的变动”那一列除了小数点后的小数之外，还丢了“+”号。可是，
方法(a)中的修正方法只能解决小数点后的小数的问题。对所有的数字，那个正号都会被
自动丢掉。解决方法是，把这一栏设为文本，而不是数字。你可以把单元格的NumberFormat
属性设为“@”来解决这个问题。

(c) By changing the cell’s numeric format to text, however, we lose the right
alignment that comes automatically with numbers.  In addition to your solution
to part (b), you must also now set the cell’s HorizontalAlignment attribute to
the Win32 Excel constant xlRight. 
(c) 问题是，把单元格的格式由数字改为文本的一个问题是，我们丢失了数字的自动对齐
方式。在(b)的解决方案之外，还要再设置单元格的HorizontalAlignment属性为Win32
Excel的xlRight常量。

After you come up with the solutions to all three parts, your output will now
look more acceptable, as shown in Figure 23C9.
当你完成了上面三部分后，你的输出结果看上去就更令人满意了。如图23-9。

Figure 23C9    Improving the Python-to-Excel stock quote script (estock.pyw)
图23-9 改进Python-to-Excel股票报价脚本 (estock.pyw)



Java, Python, Jython
Java、Python、Jython

23C16.   Jython. What is the difference between Jython and CPython?
23-16. Jython。Jython与CPython的区别是什么？

23C17.   Java and Python. Take an existing Java application and port it to
Python. Write down your experience in a journal. When complete, give an
executive summary of what has to be accomplished, what some of the important
steps are, and what common operations you have to perform to make it happen.
23-17. Java和Python。选一个已经存在的Java应用程序，移植到Python中。在日记中
写下你的经验。完成后，总结一下，都有哪些事是必需要做的，最重要的步骤是什么，
移植的中一定要做的，公共的部分有哪些。

23C18.   Java and Python. Study the Jython source code. Describe how some of
Python standard types are implemented in Java.
23-18. Java和Python。研究Jython的源代码。描述一些Python标准类型是如何在Java
中实现的。

23C19.   Java and Python. Extend Python by writing an extension in Java. What
are the necessary steps? Demonstrate your working solution by showing how it
works in with the Jython interactive interpreter.
23-19. Java和Python。用Java写一个扩展来扩展Python。哪几步是必要的？在Jython
交互解释器中演示你的结果。

23C20.   Jython and Databases. Find an interesting exercise from the Chapter 21
and port it to Jython. One of the best things about Jython is that starting in
2.1, it now comes with a JDBC database module called zxJDBC that is nearly
Python DB-API 2.0Ccompliant.
23-20. Jython和数据库。从第21章中找到一个比较有意思的练习，移植到Jython中。Jython
最好的一件事就是，在2.1版本开始，它自带了一个JDBC数据库模块叫zxJDBC，而且它基本上
遵循Python DB-API 2.0版本协议。

23C21. Python and Jython. Find a Python module not available in Jython (yet)
and port it. Consider submitting it as a patch to the Jython distribution.
23-21. Python和Jython。找到一个目前Jython中还没有的Python模块，并移植它。并考虑把
移植的结果做为一个补丁提交给Jython发布版。

