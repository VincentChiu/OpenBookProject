<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<META NAME="generator" CONTENT="http://txt2tags.sf.net">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<TITLE>Python Standard Library</TITLE>

<!-- Included style.css -->
<STYLE TYPE="text/css">
body, td, {
	font-family: verdana, sans-serif;
	font-size: 12px;
}

body {
	background-color: #FDFBFC;
	margin:20px 20px 20px 20px;
}


p {
	margin-top:10px;
	margin-bottom:10px;
}

a {font-weight:normal; text-decoration:underline;}
a:link {color:#0000FF;}
a:visited {color:#0000FF;}
a:active {color:#0000FF;}
a:hover {color:#700000;}

strong a {
    font-weight: bold;
}

.toc {
	background-color: #EEEEFB;
	border: 1px solid;
	/*padding:10px 8px 10px 15px;*/
	float : right ; width : 37%;
	margin : 5px; padding: 5px;
	margin: 5px;
}

.toc a:link , .toc a:visited  { color : #003399; }

.toc a:hover { 
	color : #EEEEFB;
	text-decoration : none;
	background-color: black;
}

.trailbold {
	font-weight:bold;
}

.light {
	background-color: #EFEFEF;
}

.dark {
	background-color: #D2D2D2;
}

.smalllogo {
	float:left;
}

.headerbar {
	padding-bottom:60px;
}
	
.header {
	font-weight: bold;
	font-size: 20px;
}

.smallheader {
	font-weight: bold;
	font-size: 16px;
}

.filelist {
	font-size:14px;
	margin: 10px 10px 10px 70px;
	line-height:25px;
}

.dirheader {
	font-size:13px;
	margin: 10px 50px 10px 20px
}

.toolbar {
	text-align:right;
	margin: 0px 10px 0px 10px
}

.copyright {
	padding-top: 30px;
	text-align:center;
	font-size:9px;
	color: #5F5F5F;
}

.small {
	font-size:9px;
}

.sforgelogo {
	text-align:right;
	height: 40px;
}

pre, .source {
	width:auto;
	border		: 1px solid #666;
	background	: #eee;
	margin		: 2em 4em;
	padding		: 1em 2em;
}

/*code {
	color		: #DB1416;
	
}*/
code { 
font-size: 1.2em;
font-family:courier,courier new,monospace;
background: #666666;
border-top: 0.03em solid #000;
border-right: 0.03em solid #000;
border-bottom: 0.03em solid #ccc;
border-left: 0.03em solid #ccc;
color: white;
}

blockquote{
  margin: 2em 5em ; 
 } 


</STYLE>

</HEAD>
<BODY BGCOLOR="green">
<A NAME="toptop"></A>
<DIV CLASS="header" ID="header">
<H1>Python Standard Library</H1>
<H2>翻译: Python 江湖群</H2>
<H3>2008-03-28 13:35:37</H3>
</DIV>

<DIV CLASS="body" ID="body">
<DIV CLASS="toc" ID="toc">
  <OL>
  <LI><A HREF="#toc1">其他模块</A>
    <UL>
    <LI><A HREF="#toc2">1.1. 概览</A>
    <LI><A HREF="#toc3">1.2. pyclbr 模块</A>
    <LI><A HREF="#toc4">1.3. filecmp 模块</A>
    <LI><A HREF="#toc5">1.4. cmd 模块</A>
    <LI><A HREF="#toc6">1.5. rexec 模块</A>
    <LI><A HREF="#toc7">1.6. Bastion 模块</A>
    <LI><A HREF="#toc8">1.7. readline 模块</A>
    <LI><A HREF="#toc9">1.8. rlcompleter 模块</A>
    <LI><A HREF="#toc10">1.9. statvfs 模块</A>
    <LI><A HREF="#toc11">1.10. calendar 模块</A>
    <LI><A HREF="#toc12">1.11. sched 模块</A>
    <LI><A HREF="#toc13">1.12. statcache 模块</A>
    <LI><A HREF="#toc14">1.13. grep 模块</A>
    <LI><A HREF="#toc15">1.14. dircache 模块</A>
    <LI><A HREF="#toc16">1.15. dircmp 模块</A>
    <LI><A HREF="#toc17">1.16. cmp 模块</A>
    <LI><A HREF="#toc18">1.17. cmpcache 模块</A>
    <LI><A HREF="#toc19">1.18. util 模块</A>
    <LI><A HREF="#toc20">1.19. soundex 模块</A>
    <LI><A HREF="#toc21">1.20. timing 模块</A>
    <LI><A HREF="#toc22">1.21. posixfile 模块</A>
    <LI><A HREF="#toc23">1.22. bisect 模块</A>
    <LI><A HREF="#toc24">1.23. knee 模块</A>
    <LI><A HREF="#toc25">1.24. tzparse 模块</A>
    <LI><A HREF="#toc26">1.25. regex 模块</A>
    <LI><A HREF="#toc27">1.26. regsub 模块</A>
    <LI><A HREF="#toc28">1.27. reconvert 模块</A>
    <LI><A HREF="#toc29">1.28. regex_syntax 模块</A>
    <LI><A HREF="#toc30">1.29. find 模块</A>
    </UL>
  </OL>

</DIV>
<P></P>
<HR NOSHADE SIZE=5>
<P></P>
<P>
<A HREF="index.html">返回首页</A>
</P>
<HR NOSHADE SIZE=5>
<P></P>
<A NAME="toc1"></A>
<H1><A href='#toptop'> 1. 其他模块 </A></H1>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc2"></A>
<H2><A href='#toptop'> 1.1. 概览 </A></H2>
<P>
本章描述的是一些并不怎么常见的模块. 一些是很实用的, 另些是已经废弃的模块.
</P>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc3"></A>
<H2><A href='#toptop'> 1.2. pyclbr 模块 </A></H2>
<P>
<CODE>pyclbr</CODE> 模块包含一个基本的 Python 类解析器, 如 <A HREF="#eg-14-1">Example 14-1</A> 所示.
</P>
<P>
版本 1.5.2 中, 改模块只包含一个 <CODE>readmodule</CODE> 函数, 解析给定模块, 返回一个模块所有顶层类组成的列表.
</P>
<A NAME="eg-14-1"></A>
<H4><A href='#toptop'> 1.2.0.1. Example 14-1. 使用 pyclbr 模块 </A></H4>
<PRE>
File: pyclbr-example-1.py

import pyclbr

mod = pyclbr.readmodule("cgi")

for k, v in mod.items():
    print k, v

*B*MiniFieldStorage &lt;pyclbr.Class instance at 7873b0&gt;
InterpFormContentDict &lt;pyclbr.Class instance at 79bd00&gt;
FieldStorage &lt;pyclbr.Class instance at 790e20&gt;
SvFormContentDict &lt;pyclbr.Class instance at 79b5e0&gt;
StringIO &lt;pyclbr.Class instance at 77dd90&gt;
FormContent &lt;pyclbr.Class instance at 79bd60&gt;
FormContentDict &lt;pyclbr.Class instance at 79a9c0&gt;*b*
</PRE>
<P></P>
<P>
2.0 及以后版本中, 添加了另个接口 <CODE>readmodule_ex</CODE> , 它还会读取全局函数. 如 <A HREF="#eg-14-2">Example 14-2</A> 所示.
</P>
<A NAME="eg-14-2"></A>
<H4><A href='#toptop'> 1.2.0.2. Example 14-2. 使用 pyclbr 模块读取类和函数 </A></H4>
<PRE>
File: pyclbr-example-3.py

import pyclbr

# 2.0 and later
mod = pyclbr.readmodule_ex("cgi")

for k, v in mod.items():
    print k, v

*B*MiniFieldStorage &lt;pyclbr.Class instance at 00905D2C&gt;
parse_header &lt;pyclbr.Function instance at 00905BD4&gt;
test &lt;pyclbr.Function instance at 00906FBC&gt;
print_environ_usage &lt;pyclbr.Function instance at 00907C94&gt;
parse_multipart &lt;pyclbr.Function instance at 00905294&gt;
FormContentDict &lt;pyclbr.Class instance at 008D3494&gt;
initlog &lt;pyclbr.Function instance at 00904AAC&gt;
parse &lt;pyclbr.Function instance at 00904EFC&gt;
StringIO &lt;pyclbr.Class instance at 00903EAC&gt;
SvFormContentDict &lt;pyclbr.Class instance at 00906824&gt;
...*b*
</PRE>
<P></P>
<P>
访问类实例的属性可以获得关于类的更多信息, 如 <A HREF="#eg-14-3">Example 14-3</A> 所示.
</P>
<A NAME="eg-14-3"></A>
<H4><A href='#toptop'> 1.2.0.3. Example 14-3. 使用 pyclbr 模块 </A></H4>
<PRE>
File: pyclbr-example-2.py

import pyclbr
import string

mod = pyclbr.readmodule("cgi")

def dump(c):
    # print class header
    s = "class " + c.name
    if c.super:
        s = s +  "(" + string.join(map(lambda v: v.name, c.super), ", ") + ")"
    print s + ":"
    # print method names, sorted by line number
    methods = c.methods.items()
    methods.sort(lambda a, b: cmp(a[1], b[1]))
    for method, lineno in methods:
        print "  def " + method
    print

for k, v in mod.items():
    dump(v)

*B*class MiniFieldStorage:
  def _ _init_ _
  def _ _repr_ _

class InterpFormContentDict(SvFormContentDict):
  def _ _getitem_ _
  def values
  def items

...*b*
</PRE>
<P></P>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc4"></A>
<H2><A href='#toptop'> 1.3. filecmp 模块 </A></H2>
<P>
( 2.0 新增) <CODE>filecmp</CODE> 模块用于比较文件和目录, 如 <A HREF="#eg-14-4">Example 14-4</A> 所示.
</P>
<A NAME="eg-14-4"></A>
<H4><A href='#toptop'> 1.3.0.1. Example 14-4. 使用 filecmp 模块 </A></H4>
<PRE>
File: filecmp-example-1.py

import filecmp

if filecmp.cmp("samples/sample.au", "samples/sample.wav"):
    print "files are identical"
else:
    print "files differ!"

# files differ!
</PRE>
<P></P>
<P>
1.5.2 以及先前版本中, 你可以使用 <CODE>cmp</CODE> 和 <CODE>dircmp</CODE> 模块代替.
</P>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc5"></A>
<H2><A href='#toptop'> 1.4. cmd 模块 </A></H2>
<P>
<CODE>cmd</CODE> 模块为命令行接口( command-line interfaces , CLI )提供了一个简单的框架. 
它被用在 <CODE>pdb</CODE> 模块中, 当然你也可以在自己的程序中使用它, 如 <A HREF="#eg-14-5">Example 14-5</A> 所示. 
</P>
<P>
你只需要继承 <I>Cmd</I> 类, 定义 <CODE>do</CODE> 和 <CODE>help</CODE> 方法. 基类会自动地将这些方法转换为对应命令.
</P>
<A NAME="eg-14-5"></A>
<H4><A href='#toptop'> 1.4.0.1. Example 14-5. 使用 cmd 模块 </A></H4>
<PRE>
File: cmd-example-1.py

import cmd
import string, sys

class CLI(cmd.Cmd):

    def _ _init_ _(self):
        cmd.Cmd._ _init_ _(self)
        self.prompt = '&gt; '

    def do_hello(self, arg):
        print "hello again", arg, "!"

    def help_hello(self):
        print "syntax: hello [message]",
        print "-- prints a hello message"

    def do_quit(self, arg):
        sys.exit(1)

    def help_quit(self):
        print "syntax: quit",
        print "-- terminates the application"

    # shortcuts
    do_q = do_quit

#
# try it out

cli = CLI()
cli.cmdloop()

*B*&gt; help

Documented commands (type help &lt;topic&gt;):
========================================
hello           quit

Undocumented commands:
======================
help            q

&gt; hello world
hello again world !
&gt; q*b*
</PRE>
<P></P>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc6"></A>
<H2><A href='#toptop'> 1.5. rexec 模块 </A></H2>
<P>
Feather 注: 版本 2.3 时取消了改模块的支持, 具体原因请参阅 :
<A HREF="http://www.amk.ca/python/howto/rexec/">http://www.amk.ca/python/howto/rexec/</A> 和
<A HREF="http://mail.python.org/pipermail/python-dev/2002-December/031160.html">http://mail.python.org/pipermail/python-dev/2002-December/031160.html</A>
</P>
<P>
解决方法请参阅: <A HREF="http://mail.python.org/pipermail/python-list/2003-November/234581.html">http://mail.python.org/pipermail/python-list/2003-November/234581.html</A> 
</P>
<P>
<CODE>rexec</CODE> 模块提供了在限制环境下的 <CODE>exec</CODE> , <CODE>eval</CODE> , 
以及 <CODE>import</CODE> 语句, 如 <A HREF="#eg-14-6">Example 14-6</A> 所示. 
在这个环境下, 所有可能对机器造成威胁的函数都不可用. 
</P>
<A NAME="eg-14-6"></A>
<H4><A href='#toptop'> 1.5.0.1. Example 14-6. 使用 rexec 模块 </A></H4>
<PRE>
File: rexec-example-1.py

import rexec

r = rexec.RExec()
print r.r_eval("1+2+3")
print r.r_eval("_ _import_ _('os').remove('file')")

*B*6
Traceback (innermost last):
  File "rexec-example-1.py", line 5, in ?
    print r.r_eval("_ _import_ _('os').remove('file')")
  File "/usr/local/lib/python1.5/rexec.py", line 257, in r_eval
    return eval(code, m._ _dict_ _)
  File "&lt;string&gt;", line 0, in ?
AttributeError: remove*b*
</PRE>
<P></P>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc7"></A>
<H2><A href='#toptop'> 1.6. Bastion 模块 </A></H2>
<P>
Feather 注: 版本 2.3 时取消了改模块的支持, 具体原因请参阅 :
<A HREF="http://www.amk.ca/python/howto/rexec/">http://www.amk.ca/python/howto/rexec/</A> 和 
<A HREF="http://mail.python.org/pipermail/python-dev/2003-January/031848.html">http://mail.python.org/pipermail/python-dev/2003-January/031848.html</A>
</P>
<P>
<CODE>Bastion</CODE> 模块, 允许你控制给定对象如何使用, 如 <A HREF="#eg-14-7">Example 14-7</A> 所示. 
你可以通过它把对象从未限制部分传递到限制部分.
</P>
<P>
默认情况下, 所有的实例变量都是隐藏的, 所有的方法以下划线开头.
</P>
<A NAME="eg-14-7"></A>
<H4><A href='#toptop'> 1.6.0.1. Example 14-7. 使用 Bastion 模块 </A></H4>
<PRE>
File: bastion-example-1.py

import Bastion

class Sample:
    value = 0

    def _set(self, value):
        self.value = value

    def setvalue(self, value):
        if 10 &lt; value &lt;= 20:
            self._set(value)
        else:
            raise ValueError, "illegal value"

    def getvalue(self):
        return self.value

#
# try it

s = Sample()
s._set(100) # cheat
print s.getvalue()

s = Bastion.Bastion(Sample())
s._set(100) # attempt to cheat
print s.getvalue()

*B*100
Traceback (innermost last):
...
AttributeError: _set*b*
</PRE>
<P></P>
<P>
你可以控制发布哪个函数. 在 <A HREF="#eg-14-8">Example 14-</A> 中, 内部方法可以从外部调用, 
但 getvalue 不再起作用.
</P>
<A NAME="eg-14-8"></A>
<H4><A href='#toptop'> 1.6.0.2. Example 14-8. 使用 Bastion 模块处理非标准过滤器 </A></H4>
<PRE>
File: bastion-example-2.py

import Bastion

class Sample:
    value = 0

    def _set(self, value):
        self.value = value

    def setvalue(self, value):
        if 10 &lt; value &lt;= 20:
            self._set(value)
        else:
            raise ValueError, "illegal value"

    def getvalue(self):
        return self.value

#
# try it

def is_public(name):
    return name[:3] != "get"

s = Bastion.Bastion(Sample(), is_public)
s._set(100) # this works
print s.getvalue() # but not this

*B*100
Traceback (innermost last):
...
AttributeError: getvalue*b*
</PRE>
<P></P>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc8"></A>
<H2><A href='#toptop'> 1.7. readline 模块 </A></H2>
<P>
(可选) <CODE>readline</CODE> 模块使用 GNU readline 库(或兼容库)实现了 Unix 下增强的输入编辑支持. 
如 <A HREF="#eg-14-9">Example 14-9</A> 所示.
</P>
<P>
该模块提供了增强的命令行编辑功能, 例如命令行历史等. 它还增强了 <CODE>input</CODE> 和 <CODE>raw_input</CODE> 函数.
</P>
<A NAME="eg-14-9"></A>
<H4><A href='#toptop'> 1.7.0.1. Example 14-9. 使用 readline 模块 </A></H4>
<PRE>
File: readline-example-1.py

import readline # activate readline editing
</PRE>
<P></P>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc9"></A>
<H2><A href='#toptop'> 1.8. rlcompleter 模块 </A></H2>
<P>
(可选, 只用于 Unix ) <CODE>rlcompleter</CODE> 模块为 readline 模块提供了单词自动完成功能.
</P>
<P>
导入该模块就可以启动自动完成功能. 默认情况下完成函数被绑定在了 Esc 键上. 
按两次 Esc 键就可以自动完成当前单词. 你可以使用下面的代码修改所绑定的键:
</P>
<PRE>
import readline
readline.parse_and_bind("tab: complete")
</PRE>
<P></P>
<P>
<A HREF="#eg-14-10">Example 14-10</A> 展示了如何在程序中使用自动完成函数.
</P>
<A NAME="eg-14-10"></A>
<H4><A href='#toptop'> 1.8.0.1. Example 14-10. 使用 rlcompleter 模块展开名字 </A></H4>
<PRE>
File: rlcompleter-example-1.py

import rlcompleter
import sys

completer = rlcompleter.Completer()

for phrase in "co", "sys.p", "is":
    print phrase, "=&gt;",
    # emulate readline completion handler
    try:
        for index in xrange(sys.maxint):
            term = completer.complete(phrase, index)
            if term is None:
                break
            print term,
    except:
        pass
    print

co =&gt; continue compile complex coerce completer
sys.p =&gt; sys.path sys.platform sys.prefix
is =&gt; is isinstance issubclass
</PRE>
<P></P>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc10"></A>
<H2><A href='#toptop'> 1.9. statvfs 模块 </A></H2>
<P>
<CODE>statvfs</CODE> 模块包含一些与 <CODE>os.statvfs</CODE> (可选)函数配合使用的常量和函数, 
该函数会返回文件系统的相关信息. 如 Example 14-11 所示.
</P>
<A NAME="eg-14-11"></A>
<H4><A href='#toptop'> 1.9.0.1. Example 14-11. 使用 statvfs 模块 </A></H4>
<PRE>
File: statvfs-example-1.py

import statvfs
import os

st = os.statvfs(".")

print "preferred block size", "=&gt;", st[statvfs.F_BSIZE]
print "fundamental block size", "=&gt;", st[statvfs.F_FRSIZE]
print "total blocks", "=&gt;", st[statvfs.F_BLOCKS]
print "total free blocks", "=&gt;", st[statvfs.F_BFREE]
print "available blocks", "=&gt;", st[statvfs.F_BAVAIL]
print "total file nodes", "=&gt;", st[statvfs.F_FILES]
print "total free nodes", "=&gt;", st[statvfs.F_FFREE]
print "available nodes", "=&gt;", st[statvfs.F_FAVAIL]
print "max file name length", "=&gt;", st[statvfs.F_NAMEMAX]

*B*preferred block size =&gt; 8192
fundamental block size =&gt; 1024
total blocks =&gt; 749443
total free blocks =&gt; 110442
available blocks =&gt; 35497
total file nodes =&gt; 92158
total free nodes =&gt; 68164
available nodes =&gt; 68164
max file name length =&gt; 255*b*
</PRE>
<P></P>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc11"></A>
<H2><A href='#toptop'> 1.10. calendar 模块 </A></H2>
<P>
<CODE>calendar</CODE> 模块是 Unix <I>cal</I> 命令的 Python 实现. 它可以将给定年份/月份的日历输出到标准输出设备上.
</P>
<P>
<CODE>prmonth(year, month)</CODE> 打印给定月份的日历, 如 <A HREF="#eg-14-12">Example 14-12</A> 所示.
</P>
<A NAME="eg-14-12"></A>
<H4><A href='#toptop'> 1.10.0.1. Example 14-12. 使用 calendar 模块 </A></H4>
<PRE>
File: calendar-example-1.py

import calendar
calendar.prmonth(1999, 12)

*B*    December 1999
Mo Tu We Th Fr Sa Su
       1  2  3  4  5
 6  7  8  9 10 11 12
13 14 15 16 17 18 19
20 21 22 23 24 25 26
27 28 29 30 31*b*
</PRE>
<P></P>
<P>
<CODE>prcal(year)</CODE> 打印给定年份的日历, 如 <A HREF="#eg-14-13">Example 14-13</A> 所示.
</P>
<A NAME="eg-14-13"></A>
<H4><A href='#toptop'> 1.10.0.2. Example 14-13. 使用 calendar 模块 </A></H4>
<PRE>
File: calendar-example-2.py

import calendar
calendar.prcal(2000)

*B*                                  2000

       January                  February                    March
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
                1  2          1  2  3  4  5  6             1  2  3  4  5
 3  4  5  6  7  8  9       7  8  9 10 11 12 13       6  7  8  9 10 11 12
10 11 12 13 14 15 16      14 15 16 17 18 19 20      13 14 15 16 17 18 19
17 18 19 20 21 22 23      21 22 23 24 25 26 27      20 21 22 23 24 25 26
24 25 26 27 28 29 30      28 29                     27 28 29 30 31
31

        April                      May                      June
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
                1  2       1  2  3  4  5  6  7                1  2  3  4
 3  4  5  6  7  8  9       8  9 10 11 12 13 14       5  6  7  8  9 10 11
10 11 12 13 14 15 16      15 16 17 18 19 20 21      12 13 14 15 16 17 18
17 18 19 20 21 22 23      22 23 24 25 26 27 28      19 20 21 22 23 24 25
24 25 26 27 28 29 30      29 30 31                  26 27 28 29 30

        July                     August                   September
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
                1  2          1  2  3  4  5  6                   1  2  3
 3  4  5  6  7  8  9       7  8  9 10 11 12 13       4  5  6  7  8  9 10
10 11 12 13 14 15 16      14 15 16 17 18 19 20      11 12 13 14 15 16 17
17 18 19 20 21 22 23      21 22 23 24 25 26 27      18 19 20 21 22 23 24
24 25 26 27 28 29 30      28 29 30 31               25 26 27 28 29 30
31

       October                  November                  December
Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su      Mo Tu We Th Fr Sa Su
                   1             1  2  3  4  5                   1  2  3
 2  3  4  5  6  7  8       6  7  8  9 10 11 12       4  5  6  7  8  9 10
 9 10 11 12 13 14 15      13 14 15 16 17 18 19      11 12 13 14 15 16 17
16 17 18 19 20 21 22      20 21 22 23 24 25 26      18 19 20 21 22 23 24
23 24 25 26 27 28 29      27 28 29 30               25 26 27 28 29 30 31
30 31*b*
</PRE>
<P></P>
<P>
注意这里的日历是按照欧洲习惯打印的, 也就是说星期一是一个星期的第一天, 
其他情况需要请参考模块中的几个类. (和咱们一样, 不用管了)
</P>
<P>
该模块中的其他类或函数可以帮助你输出自己需要的格式.
</P>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc12"></A>
<H2><A href='#toptop'> 1.11. sched 模块 </A></H2>
<P>
sched 模块为非线程环境提供了一个简单的计划任务模式. 如 Example 14-14 所示.
</P>
<A NAME="eg-14-14"></A>
<H4><A href='#toptop'> 1.11.0.1. Example 14-14. 使用 sched 模块 </A></H4>
<PRE>
File: sched-example-1.py

import sched
import time, sys

scheduler = sched.scheduler(time.time, time.sleep)

# add a few operations to the queue
scheduler.enter(0.5, 100, sys.stdout.write, ("one\n",))
scheduler.enter(1.0, 300, sys.stdout.write, ("three\n",))
scheduler.enter(1.0, 200, sys.stdout.write, ("two\n",))

scheduler.run()

*B*one
two
three*b*
</PRE>
<P></P>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc13"></A>
<H2><A href='#toptop'> 1.12. statcache 模块 </A></H2>
<P>
<CODE>statcache</CODE> 模块提供了访问文件相关信息的相关函数. 它是 <CODE>os.stat</CODE> 的扩展模块, 
而且它会缓存收集到的信息. 如 <A HREF="#eg-14-15">Example 14-15</A> 所示.
</P>
<P>
2.2 后该模块被废弃, 请使用 <CODE>os.stat()</CODE> 函数代替, 原因很简单, 
它导致了更复杂的缓存管理, 反而降低了性能.
</P>
<A NAME="eg-14-15"></A>
<H4><A href='#toptop'> 1.12.0.1. Example 14-15. 使用 statcache 模块 </A></H4>
<PRE>
File: statcache-example-1.py

import statcache
import os, stat, time

now = time.time()
for i in range(1000):
    st = os.stat("samples/sample.txt")
print "os.stat", "=&gt;", time.time() - now

now = time.time()
for i in range(1000):
    st = statcache.stat("samples/sample.txt")
print "statcache.stat", "=&gt;", time.time() - now

print "mode", "=&gt;", oct(stat.S_IMODE(st[stat.ST_MODE]))
print "size", "=&gt;", st[stat.ST_SIZE]
print "last modified", "=&gt;", time.ctime(st[stat.ST_MTIME])

*B*os.stat =&gt; 0.371000051498
statcache.stat =&gt; 0.0199999809265
mode =&gt; 0666
size =&gt; 305
last modified =&gt; Sun Oct 10 18:39:37 1999*b*
</PRE>
<P></P>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc14"></A>
<H2><A href='#toptop'> 1.13. grep 模块 </A></H2>
<P>
<CODE>grep</CODE> 模块提供了在文本文件中搜索字符串的另种方法, 如 Example 14-16 所示.
</P>
<P>
版本 2.1 时被声明不支持, 及就是说, 当前版本已经无法使用该模块.
</P>
<A NAME="eg-14-16"></A>
<H4><A href='#toptop'> 1.13.0.1. Example 14-16. 使用 grep 模块 </A></H4>
<PRE>
File: grep-example-1.py

import grep
import glob

grep.grep("\&lt;rather\&gt;", glob.glob("samples/*.txt"))

# 4: indentation, rather than delimiters, might become
</PRE>
<P></P>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc15"></A>
<H2><A href='#toptop'> 1.14. dircache 模块 </A></H2>
<P>
(已经废弃) 与 <CODE>statcache</CODE> 类似, 该模块是 <CODE>os.listdir</CODE> 函数的一个扩展, 提供了缓存支持, 
可能因为同样的原因被废弃吧~ MUHAHAHAHAHA~~~~ . 请使用 <CODE>os.listdir</CODE> 代替.
如 <A HREF="#eg-14-17">Example 14-17</A> 所示.
</P>
<A NAME="eg-14-17"></A>
<H4><A href='#toptop'> 1.14.0.1. Example 14-17. 使用 dircache 模块 </A></H4>
<PRE>
File: dircache-example-1.py

import dircache

import os, time

# 
# test cached version

t0 = time.clock()

for i in range(100):
    dircache.listdir(os.sep)

print "cached", time.clock() - t0

# 
# test standard version

t0 = time.clock()

for i in range(100):
    os.listdir(os.sep)

print "standard", time.clock() - t0

*B*cached 0.0664509964968
standard 0.5560845807*b*
</PRE>
<P></P>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc16"></A>
<H2><A href='#toptop'> 1.15. dircmp 模块 </A></H2>
<P>
(已废弃, 只用于 1.5.2) <CODE>dircmp</CODE> 模块用于比较两个目录的内容, 
如 <A HREF="#eg-14-18">Example 14-18</A> 所示.
</P>
<A NAME="eg-14-18"></A>
<H4><A href='#toptop'> 1.15.0.1. Example 14-18. 使用 dircmp 模块 </A></H4>
<PRE>
File: dircmp-example-1.py

import dircmp

d = dircmp.dircmp()
d.new("samples", "oldsamples")
d.run()
d.report()

*B*diff samples oldsamples
Only in samples : ['sample.aiff', 'sample.au', 'sample.wav']
Identical files : ['sample.gif', 'sample.gz', 'sample.jpg', ...]*b*
</PRE>
<P></P>
<P>
Python 2.0 后, 该模块被 <CODE>filecmp</CODE> 替换.
</P>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc17"></A>
<H2><A href='#toptop'> 1.16. cmp 模块 </A></H2>
<P>
(已废弃, 只用于 1.5.2) <CODE>cmp</CODE> 模块用于比较两个文件, 如 <A HREF="#eg-14-19">Example 14-19</A> 所示.
</P>
<A NAME="eg-14-19"></A>
<H4><A href='#toptop'> 1.16.0.1. Example 14-19. 使用 cmp 模块 </A></H4>
<PRE>
File: cmp-example-1.py

import cmp

if cmp.cmp("samples/sample.au", "samples/sample.wav"):
    print "files are identical"
else:
    print "files differ!"

*B*files differ!*b*
</PRE>
<P></P>
<P>
Python 2.0 后, 该模块被 <CODE>filecmp</CODE> 替换.
</P>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc18"></A>
<H2><A href='#toptop'> 1.17. cmpcache 模块 </A></H2>
<P>
(已废弃, 只用于 1.5.2) <CODE>cmpcache</CODE> 模块用于比较两个文件. 它是 cmp 模块的扩展, 
提供了缓存支持. 如 <A HREF="#eg-14-20">Example 14-20</A> 所示.
</P>
<A NAME="eg-14-20"></A>
<H4><A href='#toptop'> 1.17.0.1. Example 14-20. 使用 cmpcache 模块 </A></H4>
<PRE>
File: cmpcache-example-1.py

import cmpcache

if cmpcache.cmp("samples/sample.au", "samples/sample.wav"):
    print "files are identical"
else:
    print "files differ!"

*B*files differ!*b*
</PRE>
<P></P>
<P>
Python 2.0 后, 该模块被 <CODE>filecmp</CODE> 替换.
</P>
<P>
但 <CODE>filecmp</CODE> 已经不提供缓存支持.
</P>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc19"></A>
<H2><A href='#toptop'> 1.18. util 模块 </A></H2>
<P>
(已废弃, 只用于 1.5.2) <CODE>util</CODE> 模块提供了常见操作的封装函数. 
新代码可以使用如 Examples 14-21 到 14-23 的实现方法.
</P>
<P>
<A HREF="#eg-14-21">Example 14-21</A> 展示了 <CODE>remove(sequence, item)</CODE> 函数.
</P>
<A NAME="eg-14-21"></A>
<H4><A href='#toptop'> 1.18.0.1. Example 14-21. 实现 util 模块的 remove 函数 </A></H4>
<PRE>
File: util-example-1.py

def remove(sequence, item):
    if item in sequence:
        sequence.remove(item)
</PRE>
<P></P>
<P>
<A HREF="#eg-14-22">Example 14-22</A> 展示了 <CODE>readfile(filename) =&gt; string</CODE> 函数.
</P>
<A NAME="eg-14-22"></A>
<H4><A href='#toptop'> 1.18.0.2. Example 14-22. 实现 util 模块的 readfile 函数 </A></H4>
<PRE>
File: util-example-2.py

def readfile(filename):
    file = open(filename, "r")
    return file.read()
</PRE>
<P></P>
<P>
<A HREF="#eg-14-23">Example 14-23</A> 展示了 <CODE>`readopenfile(file) =&gt; string</CODE> 函数.
</P>
<A NAME="eg-14-23"></A>
<H4><A href='#toptop'> 1.18.0.3. Example 14-23. 实现 util 模块的 readopenfile 函数 </A></H4>
<PRE>
File: util-example-3.py

def readopenfile(file):
    return file.read()
</PRE>
<P></P>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc20"></A>
<H2><A href='#toptop'> 1.19. soundex 模块 </A></H2>
<P>
(已废弃, 只用于 1.5.2) <CODE>soundex</CODE> 实现了一个简单的 hash 算法, 
基于英文发音将单词转换为 6 个字符的字符串.
</P>
<P>
版本 2.0 后, 该模块已从标准库中删除.
</P>
<P>
<CODE>get_soundex(word)</CODE> 返回给定单词的 soundex 字符串. 
<CODE>sound_similar(word1, word2)</CODE> 判断两个单词的 soundex 是否相同. 
一般说来发音相似的单词有相同的 soundex . 如 <A HREF="#eg-14-24">Example 14-24</A> 所示.
</P>
<A NAME="eg-14-24"></A>
<H4><A href='#toptop'> 1.19.0.1. Example 14-24. 使用 soundex 模块 </A></H4>
<PRE>
File: soundex-example-1.py

import soundex

a = "fredrik"
b = "friedrich"

print soundex.get_soundex(a), soundex.get_soundex(b)

print soundex.sound_similar(a, b)

*B*F63620 F63620
1*b*
</PRE>
<P></P>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc21"></A>
<H2><A href='#toptop'> 1.20. timing 模块 </A></H2>
<P>
(已废弃, 只用于 Unix ) <CODE>timing</CODE> 用于监控 Python 程序的执行时间. 如 <A HREF="#eg-14-25">Example 14-25</A> 所示.
</P>
<A NAME="eg-14-25"></A>
<H4><A href='#toptop'> 1.20.0.1. Example 14-25. 使用 timing 模块 </A></H4>
<PRE>
File: timing-example-1.py

import timing
import time

def procedure():
    time.sleep(1.234)

timing.start()
procedure()
timing.finish()

print "seconds:", timing.seconds()
print "milliseconds:", timing.milli()
print "microseconds:", timing.micro()

*B*seconds: 1
milliseconds: 1239
microseconds: 1239999*b*
</PRE>
<P></P>
<P>
你可以按照 <A HREF="#eg-14-26">Example 14-26</A> 中的方法用 <CODE>time</CODE> 模块实现 <CODE>timing</CODE> 模块的功能.
</P>
<A NAME="eg-14-26"></A>
<H4><A href='#toptop'> 1.20.0.2. Example 14-26. 模拟 timing 模块 </A></H4>
<PRE>
File: timing-example-2.py

import time

t0 = t1 = 0

def start():
    global t0
    t0 = time.time()


def finish():
    global t1
    t1 = time.time()

def seconds():
    return int(t1 - t0)

def milli():
    return int((t1 - t0) * 1000)

def micro():
    return int((t1 - t0) * 1000000)
</PRE>
<P></P>
<P>
<CODE>time.clock()</CODE> 可以替换 <CODE>time.time()</CODE> 获得 CPU 时间.
</P>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc22"></A>
<H2><A href='#toptop'> 1.21. posixfile 模块 </A></H2>
<P>
(已废弃, 只用于 Unix ) <CODE>posixfile</CODE> 提供了一个类文件的对象( file-like object ), 
实现了文件锁定的支持. 如 <A HREF="#eg-14-27">Example 14-27</A> 所示. 新程序请使用 <CODE>fcntl</CODE> 模块代替.
</P>
<A NAME="eg-14-27"></A>
<H4><A href='#toptop'> 1.21.0.1. Example 14-27. 使用 posixfile 模块 </A></H4>
<PRE>
File: posixfile-example-1.py

import posixfile
import string

filename = "counter.txt"

try:
    # open for update
    file = posixfile.open(filename, "r+")
    counter = int(file.read(6)) + 1
except IOError:
    # create it
    file = posixfile.open(filename, "w")
    counter = 0

file.lock("w|", 6)

file.seek(0) # rewind
file.write("%06d" % counter)

file.close() # releases lock
</PRE>
<P></P>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc23"></A>
<H2><A href='#toptop'> 1.22. bisect 模块 </A></H2>
<P>
<CODE>bisect</CODE> 模块用于向排序后的序列插入对象.
</P>
<P>
<CODE>insort(sequence, item)</CODE> 将条目插入到序列中, 并且保证序列的排序. 
序列可以是任意实现了 <CODE>_ _getitem_ _</CODE> 和 <CODE>insert</CODE> 方法的序列对象. 如 <A HREF="#eg-14-28">Example 14-28</A> 所示.
</P>
<A NAME="eg-14-28"></A>
<H4><A href='#toptop'> 1.22.0.1. Example 14-28. 使用 bisect 模块向列表插入条目 </A></H4>
<PRE>
File: bisect-example-1.py

import bisect

list = [10, 20, 30]

bisect.insort(list, 25)
bisect.insort(list, 15)

print list

*B*[10, 15, 20, 25, 30]*b*
</PRE>
<P></P>
<P>
<CODE>bisect(sequence, item) =&gt; index</CODE> 返回条目插入后的索引值, 不对序列做任何修改. 
如 <A HREF="#eg-14-29">Example 14-29</A> 所示. 
</P>
<A NAME="eg-14-29"></A>
<H4><A href='#toptop'> 1.22.0.2. Example 14-29. 使用 bisect 模块获得插入点位置 </A></H4>
<PRE>
File: bisect-example-2.py

import bisect

list = [10, 20, 30]

print list
print bisect.bisect(list, 25)
print bisect.bisect(list, 15)

*B*[10, 20, 30]
2
1*b*
</PRE>
<P></P>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc24"></A>
<H2><A href='#toptop'> 1.23. knee 模块 </A></H2>
<P>
<CODE>knee</CODE> 模块用于 Python 1.5 中导入包( package import )的实现. 
当然 Python 解释器已经支持了这个, 所以这个模块几乎没有什么作用, 
不过你可以看看它的代码, 明白这一切是怎么完成的. 
</P>
<P>
代码请参见 Python-X.tgz\Python-2.4.4\Demo\imputil\knee.py 
</P>
<P>
当然, 你可以导入该模块,如 <A HREF="#eg-14-30">Example 14-30</A> 所示.
</P>
<A NAME="eg-14-30"></A>
<H4><A href='#toptop'> 1.23.0.1. Example 14-30. 使用 knee 模块 </A></H4>
<PRE>
File: knee-example-1.py

import knee

# that's all, folks!
</PRE>
<P></P>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc25"></A>
<H2><A href='#toptop'> 1.24. tzparse 模块 </A></H2>
<P>
(已废弃) <CODE>tzparse</CODE> 模块用于解析时区标志( time zone specification ). 
导入时它会自动分析 <CODE>TZ</CODE> 环境变量. 如 <A HREF="#eg-14-31">Example 14-31</A> 所示.
</P>
<A NAME="eg-14-31"></A>
<H4><A href='#toptop'> 1.24.0.1. Example 14-31. 使用 tzparse 模块 </A></H4>
<PRE>
File: tzparse-example-1.py

import os
if not os.environ.has_key("TZ"):
    # set it to something...
    os.environ["TZ"] = "EST+5EDT;100/2,300/2"

# importing this module will parse the TZ variable
import tzparse

print "tzparams", "=&gt;", tzparse.tzparams
print "timezone", "=&gt;", tzparse.timezone
print "altzone", "=&gt;", tzparse.altzone
print "daylight", "=&gt;", tzparse.daylight
print "tzname", "=&gt;", tzparse.tzname

*B*tzparams =&gt; ('EST', 5, 'EDT', 100, 2, 300, 2)
timezone =&gt; 18000
altzone =&gt; 14400
daylight =&gt; 1
tzname =&gt; ('EST', 'EDT')*b*
</PRE>
<P></P>
<P>
除了这些变量之外, 该模块还提供了一些用于时间计算的函数.
</P>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc26"></A>
<H2><A href='#toptop'> 1.25. regex 模块 </A></H2>
<P>
(已废弃) <CODE>regex</CODE> 模块是旧版本的(1.5 前)正则表达式模块, 用法如 <A HREF="#eg-14-32">Example 14-32</A> 所示. 
新代码请使用 <CODE>re</CODE> 模块实现. 
</P>
<P>
注意在 Python 1.5.2 中 <CODE>regex</CODE> 比 <CODE>re</CODE> 模块要快. 
但在新版本中 <CODE>re</CODE> 模块更快. 
</P>
<A NAME="eg-14-32"></A>
<H4><A href='#toptop'> 1.25.0.1. Example 14-32. 使用 regex 模块 </A></H4>
<PRE>
File: regex-example-1.py

import regex

text = "Man's crisis of identity in the latter half of the 20th century"

p = regex.compile("latter") # literal
print p.match(text)
print p.search(text), repr(p.group(0))

p = regex.compile("[0-9]+") # number
print p.search(text), repr(p.group(0))

p = regex.compile("\&lt;\w\w\&gt;") # two-letter word
print p.search(text), repr(p.group(0))

p = regex.compile("\w+$") # word at the end
print p.search(text), repr(p.group(0))

*B*-1
32 'latter'
51 '20'
13 'of'
56 'century'*b*
</PRE>
<P></P>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc27"></A>
<H2><A href='#toptop'> 1.26. regsub 模块 </A></H2>
<P>
(已废弃) <CODE>regsub</CODE> 模块提供了基于正则表达式的字符串替换操作. 用法如 <A HREF="#eg-14-33">Example 14-33</A> 所示. 
新代码请使用 <CODE>re</CODE> 模块中的 <CODE>replace</CODE> 函数代替.
</P>
<A NAME="eg-14-33"></A>
<H4><A href='#toptop'> 1.26.0.1. Example 14-33. 使用 regsub 模块 </A></H4>
<PRE>
File: regsub-example-1.py

import regsub

text = "Well, there's spam, egg, sausage, and spam."

print regsub.sub("spam", "ham", text) # just the first
print regsub.gsub("spam", "bacon", text) # all of them

*B*Well, there's ham, egg, sausage, and spam.
Well, there's bacon, egg, sausage, and bacon.*b*
</PRE>
<P></P>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc28"></A>
<H2><A href='#toptop'> 1.27. reconvert 模块 </A></H2>
<P>
(已废弃) <CODE>reconvert</CODE> 提供了旧样式正则表达式( <CODE>regex</CODE> 模块中使用)到新样式( <CODE>re</CODE> 模块)的转换工具. 
如 <A HREF="#eg-14-34">Example 14-34</A> 所示. 它也可以作为一个命令行工具.
</P>
<A NAME="eg-14-34"></A>
<H4><A href='#toptop'> 1.27.0.1. Example 14-34. 使用 reconvert 模块 </A></H4>
<PRE>
File: reconvert-example-1.py

import reconvert

for pattern in "abcd", "a\(b*c\)d", "\&lt;\w+\&gt;":
    print pattern, "=&gt;", reconvert.convert(pattern)

*B*abcd =&gt; abcd
a\(b*c\)d =&gt; a(b*c)d
\&lt;\w+\&gt; =&gt; \b\w+\b*b*
</PRE>
<P></P>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc29"></A>
<H2><A href='#toptop'> 1.28. regex_syntax 模块 </A></H2>
<P>
(已废弃) <CODE>regex_syntax</CODE> 模块用于改变正则表达式的模式, 如 <A HREF="#eg-14-35">Example 14-35</A> 所示.
</P>
<A NAME="eg-14-35"></A>
<H4><A href='#toptop'> 1.28.0.1. Example 14-35. 使用 regex_syntax 模块 </A></H4>
<PRE>
File: regex-syntax-example-1.py

import regex_syntax
import regex

def compile(pattern, syntax):
    syntax = regex.set_syntax(syntax)
    try:
        pattern = regex.compile(pattern)
    finally:
        # restore original syntax
        regex.set_syntax(syntax)
    return pattern

def compile_awk(pattern):
    return compile(pattern, regex_syntax.RE_SYNTAX_AWK)

def compile_grep(pattern):
    return compile(pattern, regex_syntax.RE_SYNTAX_GREP)

def compile_emacs(pattern):
    return compile(pattern, regex_syntax.RE_SYNTAX_EMACS)
</PRE>
<P></P>
<HR NOSHADE SIZE=1>
<P></P>
<A NAME="toc30"></A>
<H2><A href='#toptop'> 1.29. find 模块 </A></H2>
<P>
(已废弃, 只用于 1.5.2) <CODE>find</CODE> 模块用于在给定目录及其子目录中查找符合给定匹配模式的文件, 
如 <A HREF="#eg-14-36">Example 14-36</A> 所示.
</P>
<P>
匹配模式的语法与 <CODE>fnmatch</CODE> 中相同.
</P>
<A NAME="eg-14-36"></A>
<H4><A href='#toptop'> 1.29.0.1. Example 14-36. 使用 find 模块 </A></H4>
<PRE>
File: find-example-1.py

import find

# find all JPEG files in or beneath the current directory
for file in find.find("*.jpg", "."):
    print file

*B*.\samples\sample.jpg*b*
</PRE>
<P></P>
<HR NOSHADE SIZE=5>
<P></P>
</DIV>

<!-- html code generated by txt2tags 2.4 (http://txt2tags.sf.net) -->
<!-- cmdline: txt2tags chapter14.t2t -->
</BODY></HTML>
