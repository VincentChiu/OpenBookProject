CHAPTER V -- INTERNET TOOLS AND TECHNIQUES
第五章 -- 互联网工具和技术
-------------------------------------------------------------------

    Be strict in what you send, and lenient in what you accept.
    严格要求你所送出, 慈悲对待你所收到的.
      -- Internet Engineering Task Force
      -- 互联网工程特遣队

  Internet protocols in large measure are descriptions of textual
  formats. At the lowest level, TCP/IP is a binary protocol, but
  virtually every layer run on top of TCP/IP consists of textual
  messages exchanged between servers and clients. Some basic
  messages govern control, handshaking, and authentication issues,
  but the information content of the Internet predominantly
  consists of texts formatted according to two or three general
  patterns.
  互联网协议很大程度上是在描述文本格式. 最底层的TCP/IP是个二进制的
  协议, 但事实上位于其上的各层在服务器和客户端通信时,
  均使用文本信息. 一些基本消息被用来管理控制,握手以及认证相关的问题,
  但在互联网上占主导地位的信息只有两到三种常见模式.

  The handshaking and control aspects of Internet protocols usually
  consist of short commands--and sometimes challenges--sent during
  an initial conversation between a client and server. Fortunately
  for Python programmers, the Python standard library contains
  intermediate-level modules to support all the most popular
  communication protocols: [poplib], [smtplib], [ftplib],
  [httplib], [telnetlib], [gopherlib], and [imaplib]. If you want
  to use any of these protocols, you can simply provide required
  setup information, then call module functions or classes to
  handle all the lower-level interaction. Unless you want to do
  something exotic--such as programming a custom or less common
  network protocol--there is never a need to utilize the
  lower-level services of the [socket] module.
  互联网协议的握手和控制通常由短小的命令组成--有时候也有问题--它们
  在服务器和客户端初始会话时发送. 幸运的是对于Python程序员而言, Python
  标准库已经包含了支持几乎所有常见通讯协议的中级模块: [poplib], 
  [smtplib], [ftplib], [httplib], [telnetlib], [gopherlib], 以及
  [imaplib]。如果你需要使用其中任意协议，只需要提供必需的设置信息，
  然后调用模块函数或者类来处理所有的底层交互。除非你想要做一些
  奇怪的事情--例如编写一个自定义或者较少人使用的协议--根本没有必要
  使用[socket]模块的底层服务。

  The communication level of Internet protocols is not primarily a
  text processing issue. Where text processing comes in is with
  parsing and production of compliant texts, to contain the
  -content- of these protocols. Each protocol is characterized by
  one or a few message types that are typically transmitted over
  the protocol. For example, POP3, NNTP, IMAP4, and SMTP protocols
  are centrally means of transmitting texts that conform to
  RFC-822, its updates, and associated RFCs. HTTP is firstly a
  means of transmitting Hypertext Markup Language (HTML) messages.
  Following the popularity of the World Wide Web, however, a
  dizzying array of other message types also travel over HTTP:
  graphic and sounds formats, proprietary multimedia plug-ins,
  executable byte-codes (e.g., Java or Jython), and also more
  textual formats like XML-RPC and SOAP.
  互联网协议的通讯层并非主要用于处理文字。文字处理用于解析和
  生成兼容的文字，以包含这些协议的-内容-. 每个协议都有其典型的
  消息类型. 例如，POP3, NNTP, IMAP4, 以及SMTP协议发送的文字都
  符合RFC-822, 及其更新版本和相关RFC. HTTP 一开始是用来发送
  超文本标记语言 (HTML) 消息. 但是自从互联网流行以后, 很多
  其他消息类型也以HTTP传播：图像和声音格式, 专有格式的多媒体插件,
  可执行的比特码(例如Java和Jython), 还有很多文本格式的，譬如XML-PRC和
  SOAP.

  The most widespread text format on the Internet is almost®
  certainly human-readable and human-composed notes that follow
  RFC-822 and friends. The basic form of such a text is a series of
  headers, each beginning a line and separated from a value by a
  colon; after a header comes a blank line; and after that a
  message body. In the simplest case, a message body is just
  free-form text; but MIME headers can be used to nest structured
  and diverse contents within a message body. Email and (Usenet)
  discussion groups follow this format. Even other protocols, like
  HTTP, share a top envelope structure with RFC-822.
  互联网上使用最广的文本格式可以确认为符合RFC-822以及相关标准的
  消息, 它们是人类可读和可编写的. 此类文本的基本格式是一系列信头,
  每个均新起一行, 使用冒号将其与值隔开; 每个信头后面都有一个空行;
  再后面是消息体. 在最简单的例子中, 消息体只是任意文本; 但是MIME信头
  可以用来在消息体内嵌入有组织的不同内容. 电子邮件和 (Usenet)讨论组
  就遵循这种格式. 甚至其他协议, 例如HTTP, 也使用了RFC-822的一种
  高级封装结构.
  
  ## header -> 头文件??
  ## -> 信头, 感谢夏清然

  A strong second as Internet text formats go is HTML. And in third
  place after that is XML, in various dialects. HTML, of course, is
  the lingua franca of the Web; XML is a more general standard for
  defining custom "applications" or "dialects," of which HTML is
  (almost) one. In either case, rather than a header composed of
  line-oriented fields followed by a body, HTML/XML contain
  hierarchically nested "tags" with each tag indicated by
  surrounding angle brackets. Tags like HTML's '<body>', '<cite>',
  and '<blockquote>' will be familiar already to most readers of
  this book. In any case, Python has a strong collection of tools
  in its standard library for parsing and producing HTML and XML
  text documents. In the case of XML, some of these tools assist
  with specific XML dialects, while lower-level underlying
  libraries treat XML sui generis. In some cases, third-party
  modules fill gaps in the standard library.
  第二个使用广泛的互联网文本格式是HTML. 紧随其后的是XML, 它有若干
  变种. HTML, 理所当然是网络的混合语; XML是一个更加通用的标准,
  用于定义定制的"程序"或者"方言",HTML可以算是其中一个. 任一个情况中,
  都不是使用基于行的域来编写信头, 后面再跟一个消息体. HTML/XML包含了
  一级一级嵌套的"标签", 每个标签前后使用尖括号围住. 例如HTML中
  '<body>','<cite>'以及'<blockquote>'的标签对于本书的绝大部分读者
  来说, 应该是比较熟悉的了. 对于任意一种格式来说, Python的标准库都
  拥有强大的工具集来解析和生成HTML和XML文本文档. 对于XML来说,
  一些工具还配备了特定的XML变种, 还有一些底层的库对待XML sui generis.
  在某些时候, 第三方模块可以弥补标准库中的缺陷.

  Various Python Internet modules are covered in varying depth in
  this chapter. Every tool that comes with the Python standard
  library is examined at least in summary. Those tools that I feel
  are of greatest importance to application programmers (in text
  processing applications) are documented in fair detail and
  accompanied by usage examples, warnings, and tips.
  本章以不同的深度覆盖了若干个Python互联网模块. 每个Python标准库
  自带的工具都会至少介绍摘要. 那些我认为对(文本处理的)程序员比较重要的
  工具, 将会有详细的文档, 配以使用例子, 警告和提示.


SECTION 1 -- Working with Email and Newsgroups
第一节 -- 和电子邮件和新闻组一起工作
------------------------------------------------------------------------

  Python provides extensive support in its standard library for
  working with email (and newsgroup) messages.  There are three
  general aspects to working with email, each supported by one or
  more Python modules.
  Python利用它的标准库为电子邮件(和新闻组)消息提供了多方面的支持.
  和email一起工作主要有三个方面, 每个方面都有至少一个Pyhon模块
  来支持.

  1.  Communicating with network servers to actually transmit
      and receive messages. The modules [poplib], [imaplib],
      [smtplib], and [nntplib] each address the protocol
      contained in its name. These tasks do not have a lot to do
      with text processing per se, but are often important for
      applications that deal with email. The discussion of each
      of these modules is incomplete, addressing only those
      methods necessary to conduct basic transactions in the
      case of the first three modules/protocols. The module
      [nntplib] is not documented here under the assumption that
      email is more likely to be automatically processed than
      are Usenet articles. Indeed, robot newsgroup posters are
      almost always frowned upon, while automated mailing is
      frequently desirable (within limits).
      与网络服务器通讯实际上是发送和接受消息. 模块[poplib], [imaplib],
      [smtplib]以及[nntplib]每个在名字中都说明了它们支持的协议.
      本质上这些任务和文本处理并无太大关系, 但是对于处理电子邮件
      的程序而言, 通常很重要. 对于这些模块的讨论并非很全面, 仅仅涵盖了
      前三个库中基本处理所必须的方法. 模块[nntplib]在此处并未涉及,
      因为我们假设电子邮件比Usenet文章更需要自动处理. 实际上, 
      使用机器人张贴的新闻基本上都招人白眼, 而自动的邮件列表
      则通常受到欢迎(, 在某些限制).

  2.  Examining the contents of message folders.  Various email
      and news clients store messages in a variety of formats,
      many providing hierarchical and structured folders.  The
      module [mailbox] provides a uniform API for reading the
      messages stored in all the most popular folder formats.
      In a way, [imaplib] serves an overlapping purpose, insofar
      as an IMAP4 server can also structure folder, but folder
      manipulation with IMAP4 is discussed only cursorily--that
      topic also falls afield of text processing.  However,
      local mailbox folders are definitely text formats, and
      [mailbox] makes manipulating them a lot easier.
      检查消息文件夹中的内容. 不同的电子邮件和新闻组客户端将消息
      存储于不同的格式中, 其中许多提供了分级的和有组织的文件夹.
      模块[mailbox]提供了一个统一的API, 以读入几乎所有常见文件夹
      格式中存储的消息. 从某种方面来说, [imaplib]的服务目的有些
      重复, IMAP4服务器也可以组织文件夹, 但是它的文件夹操作只将
      粗略地讨论--因为这个话题同样偏离了文本处理的主题. 但是,
      本地的邮箱文件夹肯定是文本格式, [mailbox]使得对其的操作
      非常容易.

  3.  The core text processing task in working with email is
      parsing, modifying, and creating the actual messages.
      RFC-822 describes a format for email messages and is the
      lingua franca for Internet communication.  Not every
      Mail User Agent (MUA) and Mail Transport Agent (MTA)
      strictly conforms to the RFC-822 (and
      superset/clarification RFC-2822) standard--but they all
      generally try to do so.  The newer [email] package and the
      older [rfc822], [rfc1822], [mimify], [mimetools],
      [MimeWriter], and [multifile] modules all deal with
      parsing and processing email messages.
      和电子邮件一起工作的文本处理核心任务是解析,修改, 以及创建
      实际的消息. RFC-822描述了电子邮件消息的一种格式, 它是
      互联网通迅的混合语. 并非所有Mail User Agent (MUA) 和 Mail
      Transport Agent (MTA) 都严格遵循RFC-822标准--但它们通常
      都会尽量能够. 新的[email]包和老一些的[rfc822], [rfc1822], [mimify],
      [mimetools], [MimeWriter]以及[multifile]模块都涉及解析和处理电子
      邮件消息.

  Although existing applications are likely to use [rfc822],
  [mimify], [mimetools], [MimeWriter], and [multifile], the
  package [email] contains more up-to-date and better-designed
  implementations of the same capabilities.  The former modules
  are discussed only in synopsis while the various subpackages of
  [email] are documented in detail.
  尽管现有程序很有可能都在使用[rfc822], [mimify], [minetools], [MimeWrite]
  以及[multifile], [email]包含同样的能力, 但却是最新的, 实现上也设计得
  更妙. 前者几个模块仅仅以概要地形式讨论, 而[email]的几个子包会
  详细讲述.

  There is one aspect of working with email that all good-hearted
  people wish was unnecessary.  Unfortunately, in the real-world,
  a large percentage of email is spam, viruses, and frauds; any
  application that works with collections of messages practically
  demands a way to filter out the junk messages.  While this
  topic generally falls outside the scope of this discussion,
  readers might benefit from my article, "Spam Filtering
  Techniques," at:
  和电子邮件一起工作, 有个方面让好心人都很无奈. 不幸的是, 在现实社会中,
  很大比例的电子邮件是垃圾邮件,病毒, 以及诈骗; 任何操作消息集合的程序
  都需要某种方法来过滤垃圾消息. 这个主题已经偏出本讨论的范围,
  但是读者可以从我的文章, "垃圾邮件过滤技术", 中获取有用信息, 此文
  位于:

    <http://gnosis.cx/publish/programming/filtering-spam.html>.

  A flexible Python project for statistical analysis of message
  corpora, based on naive Bayesian and related models, is
  SpamBayes:
  有一个灵活的Python项目,  叫做SpamBayes, 用于统计分析消息的主体, 
  它是基于纯贝叶斯和相关模型的:

    <http://spambayes.sourceforge.net/>


  TOPIC --  Manipulating and Creating Message Texts
  主题 -- 操作和创建消息文本
  --------------------------------------------------------------------

  =================================================================
    PACKAGE -- email : Work with email messages
    包 -- email : 和电子邮件一起工作
  =================================================================

  Without repeating the whole of RFC-2822, it is worth mentioning
  the basic structure of an email or newsgroup message. Messages
  may themselves be stored in larger text files that impose
  larger-level structure, but here we are concerned with the
  structure of a single message. An RFC-2822 message, like most
  Internet protocols, has a textual format, often restricted to
  true 7-bit ASCII.
  复述整个RFC-2822毫无必要, 但是提一下电子邮件或者新闻组消息的基本结构
  还是值得的. 消息本身可能被保存在文本文件中, 后者组成更高层的结构,
  但在这儿我们只关注单个消息的结构. 一个RFC-2822的消息, 就如
  大部分互联网协议一样, 拥有一个文本格式, 通常被限制为7比特的ASCII.

  A message consists of a header and a body. A body in turn can
  contain one or more "payloads." In fact, MIME 'multipart/*' type
  payloads can themselves contain nested payloads, but such nesting
  is comparatively unusual in practice. In textual terms, each
  payload in a body is divided by a simple, but fairly long,
  delimiter; however, the delimiter is pseudo-random, and you need
  to examine the header to find it. A given payload can either
  contain text or binary data using base64, quoted printable, or
  another ASCII encoding (even 8-bit, which is not generally safe
  across the Internet). Text payloads may either have MIME type
  'text/*' or compose the whole of a message body (without any
  payload delimiter).
  消息由信头和信体组成. 信体按照顺序可以包含一个或者更多"负荷".
  实际上, MIME 'multipart/*' 类型的负荷能包含嵌套的负荷,
  但相比较而言, 此类嵌套在实用中不常见. 在文本类的术语中, 
  每个身体中的负荷使用一个简单但是相当长的分隔符来隔开;
  但是, 此分隔符是伪随机的, 你需要检查信头来找到它. 某给定的
  负荷可以是文本, 也可以是使用base64编码的二进制数据, 
  引号中的话也是可以打印的, 或者另外的ASCII编码 (即使8比特, 它
  在互联网上传输时, 也不总是很安全). 文本负荷要么拥有
  MIME类型'text/*', 要么成为整个消息体 (没有任何负荷的分隔符).
## payload -> 负荷, 这个翻译太猥琐了,  需要改正

  An RFC-2822 header consists of a series of fields. Each field
  name begins at the beginning of a line and is followed by a colon
  and a space. The field value comes after the field name, starting
  on the same line, but potentially spanning subsequence lines. A
  continued field value cannot be left aligned, but must instead be
  indented with at least one space or tab. There are some
  moderately complicated rules about when field contents can split
  between lines, often dependent upon the particular type of value
  a field holds. Most field names occur only once in a header (or
  not at all), and in those cases their order of occurrence is not
  important to email or news applications. However, a few field
  names--notably 'Received'--typically occur multiple times and in
  a significant order. Complicating headers further, field values
  can contain encoded strings from outside the ASCII character set.
  RFC-2822信头包含了一系列的域. 每个域的名字从行首开始, 后面跟着
  一个冒号和一个空格. 域值位于域名之后, 即从同一行开始, 但可以扩展
  到后面几行上. 延续的域值不能左对齐, 而是必须以至少一个空格或制表符
  进行缩进. 关于域的内容如何在行间分割, 有一些稍稍复杂的规则,
  通常依赖于此域值的类别. 绝大部分域名只在整个信头中出现一次 (或者根本
  不出现),在这种情况下, 它们在前面的出现对于电子邮件或者新闻组程序而言,
  并不重要. 尽管如此, 有些域名--比较有名的是"Received"--通常会出现
  多次, 其次序有重要的意义. 复杂的信头, 或者说域值, 可以包含ASCII字符集
  以外的编码字符串.

  The most important element of the [email] package is the class
  `email.Message.Message`, whose instances provide a data
  structure and convenience methods suited to the generic
  structure of RFC-2822 messages.  Various capabilities for
  dealing with different parts of a message, and for parsing a
  whole message into an `email.Message.Message` object, are
  contained in subpackages of the [email] package.  Some of the
  most common facilities are wrapped in convenience functions in
  the top-level namespace.
  [email]包的最重要的元素是类`email.Message.Message`, 它的实例
  提供了适用于常见RFC-2822消息结构的数据结构和方法. [email]的子包
  还包含了处理消息不同部分的能力, 还能将消息解析成一个
  'email.Message.Message'对象. 许多这种常用方法被包装后放在
  顶层的名字空间中.

  A version of the [email] package was introduced into the standard
  library with Python 2.1. However, [email] has been independently
  upgraded and developed between Python releases. At the time this
  chapter was written, the current release of [email] was 2.4.3,
  and this discussion reflects that version (and those API details
  that the author thinks are most likely to remain consistent in
  later versions). I recommend that, rather than simply use the
  version accompanying your Python installation, you download the
  latest version of the [email] package from
  <http://mimelib.sourceforge.net> if you intend to use this
  package. The current (and expected future) version of the [email]
  package is directly compatible with Python versions back to 2.1.
  See this book's Web site, <http://gnosis.cx/TPiP/>, for
  instructions on using [email] with Python 2.0. The package is
  incompatible with versions of Python before 2.0.
  Python 2.1 的标准库中第一次引入了[email]包. 但是, [email]却是
  独立于Python的发布而更新开发的. 在本章写作的时候, 最新的
  [email]发布了2.4.5版本, 这儿的讨论限于此版本(以及那些笔者认为
  将来不会变的API细节). 我推荐的做法是, 不要使用Python自带的[email],
  而是从<http://mimelib.sourceforge.net>下载最新的[email]包.
  当前的(预期将来的)版本Python的版本向下兼容到Python的2.1版本.
  本书的网站<http://gnosis.cx/TPiP/>说明了如何在Python 2.0中使用
  [email]. 此包和Python 2.0之前的版本不兼容.

  CLASSES:
  类:

  Several children of `email.Message.Message` allow you to easily
  construct message objects with special properties and
  convenient initialization arguments.  Each such class is
  technically contained in a module named in the same way as the
  class rather than directly in the [email] namespace, but each
  is very similar to the others.
  `email.Message.Message`的若干子类都允许你使用特别的属性
  和常见初始参数来轻松构造消息对象. 技术上来说, 每个子类都包含于一个
  与类同名的模块中, 而非直接包含在[email]名字空间中,
  但彼此都非常相似.
  

  email.MIMEBase.MIMEBase(maintype, subtype, **params)
      Construct a message object with a 'Content-Type' header
      already built.  Generally this class is used only as a
      parent for further subclasses, but you may use it directly
      if you wish:
      使用一个已经建好的'Content-Type'信头来构造一个消息对象. 
      通常来说, 此类仅被用作创建子类, 但是你愿意的话, 也可以
      直接使用:

      >>> mess = email.MIMEBase.MIMEBase('text','html',charset='us-ascii')
      >>> print mess
      From nobody Tue Nov 12 03:32:33 2002
      Content-Type: text/html; charset="us-ascii"
      MIME-Version: 1.0

  email.MIMENonMultipart.MIMENonMultipart(maintype, subtype, **params)
      Child of `email.MIMEBase.MIMEBase`, but raises
      'MultipartConversionError' on calls to '.attach()'.
      Generally this class is used for further subclassing.
      `email.MIMEBase.MIMEBase`的子类, 但是当调用'.attach()'的
      会引发'MultipartConversionError'. 通查此类也是用于
      创建子类.

  email.MIMEMultipart.MIMEMultipart([subtype="mixed" [boundary,
    -?                               [,*subparts [,**params]]]])
      Construct a multipart message object with subtype
      'subtype'.  You may optionally specify a boundary with the
      argument 'boundary', but specifying 'None' will cause a
      unique boundary to be calculated.  If you wish to populate
      the message with payload object, specify them as additional
      arguments.  Keyword arguments are taken as parameters to
      the 'Content-Type' header.
      使用子类别'subtype'来构造多块消息. 你可以选择用参数'boundary'
      来指定一个边界, 但是给出'None'将导致只计算唯一的一个边界. 
      如果你想要让此消息使用更广, 可以用额外的参数来指定负荷.
      关键词参数作为'Content-Type'信头的参数.

      >>> from email.MIMEBase import MIMEBase
      >>> from email.MIMEMultipart import MIMEMultipart
      >>> mess = MIMEBase('audio','midi')
      >>> combo = MIMEMultipart('mixed', None, mess, charset='utf-8')
      >>> print combo
      From nobody Tue Nov 12 03:50:50 2002
      Content-Type: multipart/mixed; charset="utf-8";
              boundary="===============5954819931142521=="
      MIME-Version: 1.0
      
      --===============5954819931142521==
      Content-Type: audio/midi
      MIME-Version: 1.0
      
      --===============5954819931142521==--

  email.MIMEAudio.MIMEAudio(audiodata [,subtype [,encoder [,**params]]])
      Construct a single part message object that holds audio
      data.  The audio data stream is specified as a string in
      the argument 'audiodata'.  The Python standard library
      module [sndhdr] is used to detect the signature of the
      audio subtype, but you may explicitly specify the argument
      'subtype' instead.  An encoder other than base64 may be
      specified with the 'encoder' argument (but usually should
      not be).  Keyword arguments are taken as parameters to the
      'Content-Type' header.
      构造一个消息对象, 其中包含音频数据. 此音频数据流在参数'audiodata'
      中作为字符串指定. Python标准库模块[sndhdr]在这儿被用来检测
      音频子类型的签名, 但是你也可以显式指定'subtype'的参数. 
      除了base64之外的编码也可以用'encoder'参数来指定(但通常不应该这样做).
      关键词参数作为'Content-Type'信头的参数.

      >>> from email.MIMEAudio import MIMEAudio
      >>> mess = MIMEAudio(open('melody.midi').read())

      SEE ALSO, `sndhdr`
      参见`sndhdr`

  email.MIMEImage.MIMEImage(imagedata [,subtype [,encoder [,**params]]])
      Construct a single part message object that holds image
      data.  The image data is specified as a string in the
      argument 'imagedata'.  The Python standard library module
      [imghdr] is used to detect the signature of the image
      subtype, but you may explicitly specify the argument
      'subtype' instead.  An encoder other than base64 may be
      specified with the 'encoder' argument (but usually should
      not be).  Keyword arguments are taken as parameters to the
      'Content-Type' header.
      构造一个消息对象, 其中包含图像数据. 此图像数据在参数'imagedata'
      中作为字符串指定. Python标准库模块[imghdr]在这儿被用来检测
      图像子类型的签名, 但是你也可以显式指定'subtype'的参数. 
      除了base64之外的编码也可以用'encoder'参数来指定(但通常不应该这样做).
      关键词参数作为'Content-Type'信头的参数.

      >>> from email.MIMEImage import MIMEImage
      >>> mess = MIMEImage(open('landscape.png').read())

      SEE ALSO, `imghdr`
      参见`imghdr`

  email.MIMEText.MIMEText(text [,subtype [,charset]])
      Construct a single part message object that holds text
      data.  The  data is specified as a string in the argument
      'text'.  A character set may be specified in the 'charset'
      argument:
      构造一个单块消息对象, 其中包含文本数据. 此数据在参数'text'
      中以字符串指定. 可以在'charset'参数中指定字符集:

      >>> from email.MIMEText import MIMEText
      >>> mess = MIMEText(open('TPiP.tex').read(),'latex')

  FUNCTIONS:
  函数:

  email.message_from_file(file [,_class=email.Message.Message [,strict=0]])
      Return a message object based on the message text contained
      in the file-like object 'file'.  This function call is
      exactly equivalent to:
      返回一个消息对象, 其基于类文件对象'file'中包含的消息文本. 
      此函数调用完全等同于:

      #*---------------- Underlying constructor ----------------#
      #*---------------- 底层构造函数 ----------------#
            email.Parser.Parser(_class, strict).parse(file)

      SEE ALSO, `email.Parser.Parser.parse()`
      参见`email.Parser.Parser.parse()`

  email.message_from_string(s [,_class=email.Message.Message [,strict=0]])
      Return a message object based on the message text contained
      in the string 's'.  This function call is exactly equivalent
      to:
      返回一个消息对象, 其基于字符串's'中包含的消息文本. 
      此函数调用完全等同于:

      #*---------------- Underlying constructor ----------------#
      #*---------------- 底层构造函数 ----------------#
      email.Parser.Parser(_class, strict).parsestr(file)

      SEE ALSO, `email.Parser.Parser.parsestr()`
      参见`email.Parser.Parser.parsestr()`

  =================================================================
    MODULE -- email.Encoders : Encoding message payloads
    模块 -- email.Encoders : 对消息负荷进行编码
  =================================================================

  The module [email.Encoder] contains several functions to encode
  message bodies of single part message objects. Each of these
  functions sets the 'Content-Transfer-Encoding' header to an
  appropriate value after encoding the body. The 'decode' argument
  of the '.get_payload()' message method can be used to retrieve
  unencoded text bodies.
  模块[email.Encoder]包含了若干函数, 以对单块消息对象的消息体进行编码.
  每个函数在编码之后将 'Content-Transfer-Encoding'信头设置为适当的值.
  '.get_payload()'消息方法的'decode'参数可以用来取得未编码的文本体.

  FUNCTIONS:
  函数:

  email.Encoders.encode_quopri(mess)
      Encode the message body of message object 'mess' using
      quoted printable encoding.  Also sets the header
      'Content-Transfer-Encoding'.
      将消息对象'mess'的消息信体用quoted printable encoding编码.
      同时设置信头'Content-Transfer-Encoding'.

  email.Encoders.encode_base64(mess)
      Encode the message body of message object 'mess' using base64
      encoding.  Also sets the header 'Content-Transfer-Encoding'.
      将消息对象'mess'的消息信体用base64编码.
      同时设置信头'Content-Transfer-Encoding'.

  email.Encoders.encode_7or8bit(mess)
      Set the 'Content-Transfer-Encoding' to '7bit' or '8bit'
      based on the message payload; does not modify the payload
      itself.  If 'mess' already has a 'Content-Transfer-Encoding'
      header, calling this will create a second one--it is
      probably best to delete the old one before calling this
      function.
      基于消息的负荷, 将'Content-Transfer-Encoding'设置为'7bit'或者'8bit';
      并不修改负荷本身. 如果'mess'已经有了一个'Content-Transfer-Encoding'
      信头, 调用此函数将创建第二个--所以最好在调用前将旧的删除.

  SEE ALSO, `email.Message.Message.get_payload()`, [quopri], [base64]
  参见`email.Message.Message.get_payload()`, [quopri], [base64]

  =================================================================
    MODULE -- email.Errors : Exceptions for [email] package
    模块 -- email.Errors : [email]包的异常
  =================================================================

  Exceptions within the [email] package will raise specific
  errors and may be caught at the desired level of generality.
  The exception hierarchy of [email.Errors] is shown in Figure
  5.1.
  [email]包中的异常将会引发特定错误, 可以在需要的层将其捕获.
  [email.Errors]的例外体系展示于图5.1中.

      #----- Standard email.Errors exceptions -----#
      #----- 标准email.Errors异常 -----#
      <<email_exception_hierarchy.eps>>

  SEE ALSO, [exceptions]
  参见[exceptions]

  =================================================================
    MODULE -- email.Generator : Create text representation of messages
    模块 -- email.Generator : 创建消息的文本表示
  =================================================================

  The module [email.Generator] provides support for the
  serialization of `email.Message.Message` objects. In principle,
  you could create other tools to output message objects to
  specialized formats--for example, you might use the fields of an
  `email.Message.Message` object to store values to an XML format
  or to an RDBMS. But in practice, you almost always want to write
  message objects to standards-compliant RFC-2822 message texts.
  Several of the methods of `email.Message.Message` automatically
  utilize [email.Generator].
  模块[email.Generator]为`email.Message.Message`对象的序列号提供了
  支持. 原则上, 你可以创建其他工具将消息对象以特殊格式输出--例如, 你
  可以使用`email.Message.Message`对象中的域来保存XML格式或者RDBMS
  的值. 但在实际应用中, 你会总是把消息对象以符合RFC-2822的消息文本
  输出. `email.Message.Message`的几个方法自动使用了[email.Generator].

  CLASSES:
  类:

  email.Generator.Generator(file [,mangle_from_=1 [,maxheaderlen=78]])
      Construct a generator instance that writes to the file-like
      object 'file'.  If the argument 'mangle_from_' is specified
      as a true value, any occurrence of a line in the body that
      begins with the string 'From' followed by a space is
      prepended with '>'.  This (nonreversible) transformation
      prevents BSD mailboxes from being parsed incorrectly.  The
      argument 'maxheaderlen' specifies where long headers will
      be split into multiple lines (if such is possible).
      构造一个生成器实例, 以向类文件对象'file'中写入. 如果参数
      'mangle_from_'被指定为true值, 消息信体内任何以字符串'From '开始的行
      将在前面添加'>'. 这个(不可逆)转换可以防止BSD邮箱被错误解析.
      参数'maxheaderlen'指定长信头于何处分割成多行(如果可能的话).
      
  email.Generator.DecodedGenerator(file [,mangle_from_ [,maxheaderlen [,fmt]]])
      Construct a generator instance that writes RFC-2822
      messages.  This class has the same initializers as its
      parent `email.Generator.Generator`, with the addition of an
      optional argument 'fmt'.
      构造一个生成器实例, 以写入RFC-2822消息. 此类和父类`email.Generator.Generator`
      一样初始化, 除了一个额外的可选参数'fmt'.

      The class `email.Generator.DecodedGenerator` only writes
      out the contents of 'text/*' parts of a multipart message
      payload.  Nontext parts are replaced with the string
      'fmt', which may contain keyword replacement values.  For
      example, the default value of 'fmt' is:
      类`email.Generator.DecodedGenerator`只写出多块消息负荷中
      'text/*'部分的内容. 非字符部分使用字符串'fmt'来代替, 后者可以
      包含关键词替换值. 例如, 默认的'fmt'值是:

      #*--------------- Default 'fmt' string ------------------#
      #*--------------- 默认的'fmt'值 ------------------#
      [Non-text (%(type)s) part of message omitted, filename %(filename)s]

      Any of the keywords 'type', 'maintype', 'subtype',
      'filename', 'description', or 'encoding' may be used as
      keyword replacements in the string 'fmt'.  If any of these
      values is undefined by the payload, a simple description
      of its unavailability is substituted.
      任何一个关键词'type', 'maintype', 'subtype',  'filename', 'description', or 'encoding'
      都可以用作字符串'fmt'中的关键词替换. 如果负荷并未定义其中
      一个值, 它就被一个简短描述代替, 后者表明此值不可用.

  METHODS:
  方法:

  email.Generator.Generator.clone()
  email.Generator.DecodedGenerator.clone()
      Return a copy of the instance with the same options.
      返回此实例的一个相同选项的副本.

  email.Generator.Generator.flatten(mess [,unixfrom=0])
  email.Generator.DecodedGenerator.flatten(mess [,unixfrom=0])
      Write an RFC-2822 serialization of message object 'mess' to
      the file-like object the instance was initialized with.  If
      the argument 'unixfrom' is specified as a true value, the
      BSD mailbox 'From_' header is included in the
      serialization.
      将消息对象'mess'以RFC-2822标准序列化到其初始化的那个类文件对象中.
      如果参数'unixfrom'指定为true值, 则BSD邮箱的'From_'信头被包括于
      序列化中.
      
  email.Generator.Generator.write(s)
  email.Generator.DecodedGenerator.write(s)
      Write the string 's' to the file-like object the instance
      was initialized with.  This lets a generator object itself
      act in a file-like manner, as an implementation
      convenience.
      将字符串's'写入实例初始化的类文件对象中. 这将使得生成器对象
      本身可以作为类文件对待, 这样实现上比较方便.

  SEE ALSO, [email.Message], [mailbox]
  参见[email.Message], [mailbox]

  =================================================================
    MODULE -- email.Header : Manage headers with non-ASCII values
    模块 -- email.Header : 管理非ASCII值的信头
  =================================================================

  The module [email.Charset] provides fine-tuned capabilities for
  managing character set conversions and maintaining a character
  set registry. The much higher-level interface provided by
  [email.Header] provides all the capabilities that almost all
  users need in a friendlier form.
  模块[email.Charset]提供了仔细调整过的能力, 来管理字符集约定,
  维护一个字符集登记册. [email.Header]提供了更高层次的接口, 以及
  所有用户都需要的友好形式.
  
  The basic reason why you might want to use the [email.Header]
  module is because you want to encode multinational (or at least
  non-US) strings in email headers. Message bodies are somewhat
  more lenient than headers, but RFC-2822 headers are still
  restricted to using only 7-bit ASCII to encode other character
  sets. The module [email.Header] provides a single class and two
  convenience functions. The encoding of non-ASCII characters in
  email headers is described in a number of RFCs, including
  RFC-2045, RFC-2046, RFC-2047, and most directly RFC-2231.
  需要[email.Header]模块的基本理由是, 你想要对电子邮件
  信头中的多国语言(或者至少不是英语)字符串进行编码. 消息信体
  比信头更加宽松, 但是RFC-2822信头被限制为只用7比特的ASCII来对其他
  字符集进行编码. 模块[email.Header]提供了一个类和两个便利函数.
  许多RFC都描述了如何在电子邮件信头中对非ASCII字符进行编码, 其中
  有RFC-2045, RFC-2046, RFC-2047, 还有最直接的RFC-2231.

  CLASSES:
  类:

  email.Header.Header([s="" [,charset [,maxlinelen=76 [,header_name=""
    -?                 [,continuation_ws=" "]]]]])
      Construct an object that holds the string or Unicode string
      's'.  You may specify an optional 'charset' to use in
      encoding 's'; absent any argument, either 'us-ascii' or
      'utf-8' will be used, as needed.
      构造一个对象, 其中包含了字符串或者Unicode字符串's'. 你可以指定
      可选的'charset'来对's'进行编码; 如果缺少参数, 在必要的情况下会使用
      'us-ascii'或者'utf-8'.

      Since the encoded string is intended to be used as an email
      header, it may be desirable to wrap the string to multiple
      lines (depending on its length).  The argument 'maxlinelen'
      specifies where the wrapping will occur; 'header_name' is
      the name of the header you anticipate using the encoded
      string with--it is significant only for its length.
      Without a specified 'header_name', no width is set aside
      for the header field itself.  The argument
      'continuation_ws' specified what whitespace string should
      be used to indent continuation lines; it must be a
      combination of spaces and tabs.
      因为编码的字符串是准备用作电子邮件信头的, 可能需要(根据它的长度)
      分为多行. 参数'maxlinelen'指定于何处分行; 'header_name'是
      你预期使用此字符串的信头的名字--只有它的长度有意义.
      如未指定'header_name', 在信头域本身不会设置宽度. 参数
      'continuation_ws'指定了何种空白字符串应该用来缩进延续的行;
      它必须是空格和制表符的混合.

      Instances of the class `email.Header.Header` implement a
      '.__str__()' method and therefore respond to the built-in
      `str()` function and the `print` command.  Normally the
      built-in techniques are more natural, but the method
      `email.Header.Header.encode()` performs an identical
      action.  As an example, let us first build a non-ASCII
      string:
      类`email.Header.Header`的实例实现了一个'.__str__()'方法,
      因此对内建的`str()`函数和`print`命令做出反应. 通常
      这种内建技术更为自然, 但是方法`email.Header.Header.encode()`
      实现了同样的动作. 作为例子, 让我们先创建一个非ASCII字符串:

      >>> from unicodedata import lookup
      >>> lquot = lookup("LEFT-POINTING DOUBLE ANGLE QUOTATION MARK")
      >>> rquot = lookup("RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK")
      >>> s = lquot + "Euro-style" + rquot + " quotation"
      >>> s
      u'\xabEuro-style\xbb quotation'
      >>> print s.encode('iso-8859-1')
      ?Euro-style? quotation

      Using the string 's', let us encode it for an RFC-2822
      header:
      让我们对字符串's'进行编码以用于RFC-2822信头:

      >>> from email.Header import Header
      >>> print Header(s)
      =?utf-8?q?=C2=ABEuro-style=C2=BB_quotation?=
      >>> print Header(s,'iso-8859-1')
      =?iso-8859-1?q?=ABEuro-style=BB_quotation?=
      >>> print Header(s,'utf-16')
      =?utf-16?b?/v8AqwBFAHUAcgBvAC0AcwB0AHkAbABl?=
       =?utf-16?b?/v8AuwAgAHEAdQBvAHQAYQB0AGkAbwBu?=
      >>> print Header(s,'us-ascii')
      =?utf-8?q?=C2=ABEuro-style=C2=BB_quotation?=

      Notice that in the last case, the `email.Header.Header`
      initializer did not take too seriously my request for an
      ASCII character set, since it was not adequate to represent
      the string.  However, the class is happy to skip the
      encoding strings where they are not needed:
      注意到最后一个例子中, `email.Header.Header`初始化程序
      并未在意我曾要求ASCII字符集, 因为它对于当前的字符串并不适当.
      当然, 此类也乐于略过那些不需要的编码字符串:

      >>> print Header('"US-style" quotation')
      "US-style" quotation
      >>> print Header('"US-style" quotation','utf-8')
      =?utf-8?q?=22US-style=22_quotation?=
      >>> print Header('"US-style" quotation','us-ascii')
      "US-style" quotation

  METHODS:
  方法:

  email.Header.Header.append(s [,charset])
      Add the string or Unicode string 's' to the end of the
      current instance content, using character set 'charset'.
      Note that the charset of the added text need not be the
      same as that of the existing content.
      将字符串或者Unicode字符串's'添加到当前实例内容尾部,
      使用'charset'作为字符集. 注意添加内容的字符集无需
      和已有内容一样.

      >>> subj = Header(s,'latin-1',65)
      >>> print subj
      =?iso-8859-1?q?=ABEuro-style=BB_quotation?=
      >>> unicodedata.name(omega), unicodedata.name(Omega)
      ('GREEK SMALL LETTER OMEGA', 'GREEK CAPITAL LETTER OMEGA')
      >>> subj.append(', Greek: ', 'us-ascii')
      >>> subj.append(Omega, 'utf-8')
      >>> subj.append(omega, 'utf-16')
      >>> print subj
      =?iso-8859-1?q?=ABEuro-style=BB_quotation?=, Greek:
       =?utf-8?b?zqk=?= =?utf-16?b?/v8DyQ==?=
       >>> unicode(subj)
       u'\xabEuro-style\xbb quotation, Greek: \u03a9\u03c9'

  email.Header.Header.encode()
  email.Header.Header.__str__()
      Return an ASCII string representation of the instance
      content.
      返回实例内容的ASCII字符串表示.

  FUNCTIONS:
  函数:

  email.Header.decode_header(header)
      Return a list of pairs describing the components of the
      RFC-2231 string held in the header object 'header'.  Each
      pair in the list contains a Python string (not Unicode) and
      an encoding name.
      返回一个列表的配对, 其描述了信头对象'header'中的RFC-2231字符串
      中的组件. 列表中的每个配对都包含了一个Python字符串(不是Unicode)
      以及一个编码名字.

      >>> email.Header.decode_header(Header('spam and eggs'))
      [('spam and eggs', None)]
      >>> print subj
      =?iso-8859-1?q?=ABEuro-style=BB_quotation?=, Greek:
       =?utf-8?b?zqk=?= =?utf-16?b?/v8DyQ==?=
      >>> for tup in email.Header.decode_header(subj): print tup
      ...
      ('\xabEuro-style\xbb quotation', 'iso-8859-1')
      (', Greek:', None)
      ('\xce\xa9', 'utf-8')
      ('\xfe\xff\x03\xc9', 'utf-16')

      These pairs may be used to construct Unicode strings using
      the built-in `unicode()` function.  However, plain ASCII
      strings show an encoding of 'None', which is not acceptable
      to the `unicode()` function.
      这些配对可以使用内建`unicode()`函数来构造Unicode字符串.
      但是, 普通ASCII字符串展示的编码是'None', `unicode`函数
      是不接受的.

      >>> for s,enc in email.Header.decode_header(subj):
      ...     enc = enc or 'us-ascii'
      ...     print `unicode(s, enc)`
      ...
      u'\xabEuro-style\xbb quotation'
      u', Greek:'
      u'\u03a9'
      u'\u03c9'

      SEE ALSO, `unicode()`, `email.Header.make_header()`
      参见`unicode()`, `email.Header.make_header()`

  email.Header.make_header(decoded_seq [,maxlinelen [,header_name
    -?                      [,continuation_ws]]])
      Construct a header object from a list of pairs or the type
      returned by `email.Header.decode_header()`.  You may also,
      of course, easily construct the list 'decoded_seq'
      manually, or by other means.  The arguments 'maxlinelen',
      'header_name', and 'continuation_ws' are the same as with
      this `email.Header.Header` class.
      从配对列表或者`email.Header.decode_header()`返回的类别中构造
      一个信头对象. 当然你还可以轻松构造'decoded_seq'列表, 手工或者
      其他方法都行. 参数'maxlinelen', 'header_name', 以及 'continuation_ws'
      和`email.Header.Header`类中的一样.

      >>> email.Header.make_header([('\xce\xa9','utf-8'),
      ...                           ('-man','us-ascii')]).encode()
      '=?utf-8?b?zqk=?=-man'

      SEE ALSO, `email.Header.decode_header()`, `email.Header.Header`
      参见`email.Header.decode_header()`, `email.Header.Header`

  =================================================================
    MODULE -- email.Iterators : Iterate through components of messages
    模块 -- email.Iterators : 遍历消息组件
  =================================================================

  The module [email.Iterators] provides several convenience
  functions to walk through messages in ways different from
  `email.Message.Message.get_payload()` or
  `email.Message.Message.walk()`.
  模块[email.Iterators]提供了若干便利函数, 以不同于
  `email.Message.Message.get_payload()`和`email.Message.Message.walk()`
  的方法遍历消息.

  FUNCTIONS:
  函数:

  email.Iterators.body_line_iterator(mess)
      Return a generator object that iterates through each
      content line of the message object 'mess'.  The entire body
      that would be produced by 'str(mess)' is reached,
      regardless of the content types and nesting of parts.  But
      any MIME delimiters are omitted from the returned lines.
      返回一个生成器对象, 它可以遍历消息对象'mess'的每个内容行.
      整个信体利用'str(mess)'生成, 与内容类别和嵌套无关. 
      但是所有的MIME分界符都从返回行中忽略.

      >>> import email.MIMEText, email.Iterators
      >>> mess1 = email.MIMEText.MIMEText('message one')
      >>> mess2 = email.MIMEText.MIMEText('message two')
      >>> combo = email.Message.Message()
      >>> combo.set_type('multipart/mixed')
      >>> combo.attach(mess1)
      >>> combo.attach(mess2)
      >>> for line in email.Iterators.body_line_iterator(combo):
      ...     print line
      ...
      message one
      message two

  email.Iterators.typed_subpart_iterator(mess [,maintype="text" [,subtype]])
      Return a generator object that iterates through each
      subpart of message whose type matches 'maintype'.  If a
      subtype 'subtype' is specified, the match is further
      restricted to 'maintype/subtype'.
      返回一个生成器对象, 它遍历了消息的每个类型匹配为'maintype'的子块.
      如果指定了子类型'subtype', 匹配则被限定为'maintype/subtype'.

  email.Iterators._structure(mess [,file=sys.stdout])
      Write a "pretty-printed" representation of the structure
      of the body of message 'mess'.  Output to the file-like
      object 'file'.
      将消息'mess'信体的结构用"优美打印"的格式给出.
      输出到类文件对象'file'中.

      >>> email.Iterators._structure(combo)
      multipart/mixed
          multipart/digest
              image/png
              text/plain
          audio/mp3
          text/html

  SEE ALSO, `email.Message.Message.get_payload()`,
  `email.Message.Message.walk()`
  参见 `email.Message.Message.get_payload()`,
  `email.Message.Message.walk()`

  =================================================================
    MODULE -- email.Message : Class representing an email message
    模块 -- email.Message : 表示电子邮件消息的类
  =================================================================

  A message object that utilizes the [email.Message] module
  provides a large number of syntactic conveniences and support
  methods for manipulating an email or news message. The class
  `email.Message.Message` is a very good example of a customized
  datatype. The built-in `str()` function--and therefore also the
  'print' command--cause a message object to produce its RFC-2822
  serialization.
  使用[email.Message]模块构造的消息对象提供了很多的符合造句法的便利,
  还有很多支持方法以操作电子邮件或者新闻组消息. 类`email.Message.Message`
  是自定义数据类型的一个极好例子. 内建的`str()`函数--当然还有'print'命令--使得
  消息对象生成其RFC-2822序列化.

  In many ways, a message object is dictionary-like. The
  appropriate magic methods are implemented in it to support keyed
  indexing and assignment, the built-in `len()` function,
  containment testing with the 'in' keyword, and key deletion.
  Moreover, the methods one expects to find in a Python dict are
  all implemented by `email.Message.Message`: '.has_key()',
  '.keys()', '.values()', '.items()', and '.get()'. Some usage
  examples are helpful:
  从很多方面来看, 消息对象都像字典. 它内部实现了适当的魔术方法, 以
  支持按键索引和赋值, 内建的`len()`函数,  使用'in'关键词来测试包含关系,
  以及键删除. 而且, 大家对Python字典所期望的方法都在
  `email.Message.Message`中实现了: '.has_key()',
  '.keys()', '.values()', '.items()', 以及 '.get()'. 下面一些例子比较有用:

      >>> import mailbox, email, email.Parser
      >>> mbox = mailbox.PortableUnixMailbox(open('mbox'),
      ...                        email.Parser.Parser().parse)
      >>> mess = mbox.next()
      >>> len(mess)                 # number of headers
      16
      >>> 'X-Status' in mess        # membership testing
      1
      >>> mess.has_key('X-AGENT')   # also membership test
      0
      >>> mess['x-agent'] = "Python Mail Agent"
      >>> print mess['X-AGENT']     # access by key
      Python Mail Agent
      >>> del mess['X-Agent']       # delete key/val pair
      >>> print mess['X-AGENT']
      None
      >>> [fld for (fld,val) in mess.items() if fld=='Received']
      ['Received', 'Received', 'Received', 'Received', 'Received']

  This is dictionary-like behavior, but only to an extent. Keys are
  case-insensitive to match email header rules. Moreover, a given
  key may correspond to multiple values--indexing by key will
  return only the first such value, but methods like '.keys()',
  '.items()', or '.get_all()' will return a list of all the
  entries. In some other ways, an `email.Message.Message` object is
  more like a list of tuples, chiefly in guaranteeing to retain a
  specific order to header fields.
  这些行为类似字典, 但只是某种程度上的. 键都是大小写不敏感的, 这样
  匹配电子邮件信头规则. 而且, 一个键可能对应多个值--键索引将
  只返回其中第一个值, 但是诸如 '.keys()', '.items()', 或者 '.get_all()' 此类
  的法那个法会返回一个包括所有条目的列表. 从某些其他角度来看,
  `email.Message.Message`对象更像一个tuple的列表, 主要是为了
  保留信头域的特定顺序.

  A few more details of keyed indexing should be mentioned.
  Assigning to a keyed field will add an -additional- header,
  rather than replace an existing one. In this respect, the
  operation is more like a `list.append()` method. Deleting a
  keyed field, however, deletes every matching header. If you
  want to replace a header completely, delete first, then assign.
  还有一些关于键索引的细节需要提一下. 对一个有键的域赋值会增加
  一个-另外的-信头, 而不是取代已经存在的那个. 在这个方面, 此
  操作就更像一个`list.append()`方法. 但是删除一个有键的域, 会
  删除每个匹配的信头. 如果你想要彻底的替换某个信头, 那就先
  删除, 再赋值.

  The special syntax defined by the `email.Message.Message` class
  is all for manipulating headers. But a message object will
  typically also have a body with one or more payloads. If the
  'Content-Type' header contains the value 'multipart/*', the body
  should consist of zero or more payloads, each one itself a
  message object. For single part content types (including where
  none is explicitly specified), the body should contain a string,
  perhaps an encoded one. The message instance method
  '.get_payload()', therefore, can return either a list of message
  objects or a string. Use the method '.is_multipart()' to
  determine which return type is expected.
  `email.Message.Message`类定义的特殊语法都是用来操作信头的.
  但是消息对象通常还有信体, 后者有一个或更多负荷. 如果'Content-Type'
  信头包含了值'multipart/*',  那么信体应该有零个或者更多负荷组成,
  后者本身是一个消息对象.  对于单块内容类型(包括那些没有显式指定的),
  信体应该包含一个字符串, 也可以是编码后的. 消息实例方法'.get_payload()'
  因此也返回一个消息对象的列表, 或者一个字符串. 使用方法'.is_multipart()'
  来确定预期何种类型.

  As the epigram to this chapter suggests, you should strictly
  follow content typing rules in messages you construct yourself.
  But in real-world situations, you are likely to encounter
  messages with badly mismatched headers and bodies. Single part
  messages might claim to be multipart, and vice versa. Moreover,
  the MIME type claimed by headers is only a loose indication of
  what payloads actually contain. Part of the mismatch comes from
  spammers and virus writers trying to exploit the poor standards
  compliance and lax security of Microsoft applications--a
  malicious payload can pose as an innocuous type, and Windows will
  typically launch apps based on filenames instead of MIME types.
  But other problems arise not out of malice, but simply out of
  application and transport errors.  Depending on the source of
  your processed messages, you might want to be lenient about the
  allowable structure and headers of messages.
  正如本章的警句所说, 你应该在你自己打造的消息中遵守内容类型规则.
  但是在现实社会中, 你会遇到某些消息, 它们的信头和信体严重不匹配.
  单块消息可能宣称是多块的, 反之亦然. 而且, 信头声称的MIME类型
  只是负荷实际包含物的宽松表示. 这种不匹配的行为一部分来自垃圾邮件
  发送者和病毒编写者, 它们试图利用可怜的标准一致性和微软程序松懈
  的安全性--恶意负荷会假装无害的类型, 而Windows通常会根据文件名
  而不是MIME类别来启动程序. 另外一个问题不是关于恶意邮件的, 而只是
  关于程序和传输错误. 根据你处理消息的来源, 你可能想要宽大处理
  允许的消息结构和信头.

  SEE ALSO, [UserDict], [UserList]
  参见 [UserDict], [UserList]

  CLASSES:
  类:

  email.Message.Message()
      Construct a message object.  The class accepts no
      initialization arguments.
      构造消息对象. 此类不接受初始化参数.

  METHODS AND ATTRIBUTES:
  方法和属性:

  email.Message.Message.add_header(field, value [,**params])
      Add a header to the message headers.  The header field is
      'field', and its value is 'value'.The effect is the same as
      keyed assignment to the object, but you may optionally
      include parameters using Python keyword arguments.
      向消息信头中添加一个信头. 信头域是'field', 它的值是'value'.
      效果和向对象中键赋值一样, 但你可以选择使用Python关键词
      来包含参数.

      >>> import email.Message
      >>> msg = email.Message.Message()
      >>> msg['Subject'] = "Report attachment"
      >>> msg.add_header('Content-Disposition','attachment',
      ...                 filename='report17.txt')
      >>> print msg
      From nobody Mon Nov 11 15:11:43 2002
      Subject: Report attachment
      Content-Disposition: attachment; filename="report17.txt"

  email.Message.Message.as_string([unixfrom=0])
      Serialize the message to an RFC-2822-compliant text string.
      If the 'unixfrom' argument is specified with a true value,
      include the BSD mailbox "From_" envelope header.
      Serialization with `str()` or `print` includes the "From_"
      envelope header.
      将消息序列化为一个RFC-2822兼容的文本字符串.
      如果'unixfrom'参数被指定为一个true值, 则包括BSD邮箱
      "From_"信封信头. 使用`str()` 或 `print`会包括"From_"
      信封信头.
## argument vs parameter? 如何翻译

  email.Message.Message.attach(mess)
      Add a payload to a message.  The argument 'mess' must
      specify an `email.Message.Message` object.  After this
      call, the payload of the message will be a list of message
      objects (perhaps of length one, if this is the first object
      added).  Even though calling this method causes the method
      '.is_multipart()' to return a true value, you still need to
      separately set a correct 'multipart/*' content type for the
      message to serialize the object.
      向消息中添加一个负荷. 参数'mess'必须指定一个
      `email.Message.Message`对象. 在此调用后, 此消息的
      负荷将会是一个消息对象的列表(如果这是第一个增加的对象, 长度为一).
      即使此调用导致方法'.is_multipart()'返回一个true值, 要序列化一个
      对象, 你仍然需要单独设置正确的'multipart/*'内容.
      
      >>> mess = email.Message.Message()
      >>> mess.is_multipart()
      0
      >>> mess.attach(email.Message.Message())
      >>> mess.is_multipart()
      1
      >>> mess.get_payload()
      [<email.Message.Message instance at 0x3b2ab0>]
      >>> mess.get_content_type()
      'text/plain'
      >>> mess.set_type('multipart/mixed')
      >>> mess.get_content_type()
      'multipart/mixed'

      If you wish to create a single part payload for a message
      object, use the method `email.Message.Message.set_payload()`.
      如果你希望为一个消息对象创建一个单块的负荷, 使用方法
      `email.Message.Message.set_payload()`.

      SEE ALSO, `email.Message.Message.set_payload()`
      参见 `email.Message.Message.set_payload()`

  email.Message.Message.del_param(param [,header="Content-Type"
    -?                            [,requote=1]])
      Remove the parameter 'param' from a header.  If the
      parameter does not exist, no action is taken, but also no
      exception is raised.  Usually you are interested in the
      'Content-Type' header, but you may specify a different
      'header' argument to work with another one.  The argument
      'requote' controls whether the parameter value is quoted
      (a good idea that does no harm).
      从信头中移除参数'param'. 如果参数不存在, 不采取任何行动, 
      但也不引发任何异常. 通常来说, 你会对'Content-Type'信头
      有兴趣, 但你可以指定一个不同的'header'参数以和其他的一起工作.
      参数'requote'控制参数值是否用引号括起来(这是一个好主意, 而且没有坏处).

      >>> mess = email.Message.Message()
      >>> mess.set_type('text/plain')
      >>> mess.set_param('charset','us-ascii')
      >>> print mess
      From nobody Mon Nov 11 16:12:38 2002
      MIME-Version: 1.0
      Content-Type: text/plain; charset="us-ascii"

      >>> mess.del_param('charset')
      >>> print mess
      From nobody Mon Nov 11 16:13:11 2002
      MIME-Version: 1.0
      content-type: text/plain

  email.Message.Message.epilogue
      Message bodies that contain MIME content delimiters can
      also have text that falls outside the area between the
      first and final delimiter.  Any text at the very end of the
      body is stored in `email.Message.Message.epilogue`.
      包含MIME内容分界符的消息信体还能拥有在第一和最后一个分界符
      之外的文本. 任何在信体最后面的文本都存储在
      `email.Message.Message.epilogue`.

      SEE ALSO, `email.Message.Message.preamble`
      参见 `email.Message.Message.preamble`

  email.Message.Message.get_all(field [,failobj=None])
      Return a list of all the headers with the field name
      'field'.  If no matches exist, return the value specified
      in argument 'failobj'.  In most cases, header fields occur
      just once (or not at all), but a few fields such as
      'Received' typically occur multiple times.
      返回一个列表, 其中是所有的域名为'field'的信头. 
      如果没有匹配成功, 返回参数'failobj'中指定的值. 
      在绝大部分情况下, 信头域只出现一次(或者根本不出现), 但是
      一些域如'Received'通常出现多次.

      The default nonmatch return value of 'None' is probably
      not the most useful choice.  Returning an empty list will
      let you use this method in both 'if' tests and iteration
      context:
      匹配不成功默认的返回值'None'可能不是最有用的选择. 返回一个
      空的列表可以让你在'if'测试和迭代中使用此方法:

      >>> for rcv in mess.get_all('Received',[]):
      ...     print rcv
      ...
      About that time
      A little earlier
      >>> if mess.get_all('Foo',[]):
      ...     print "Has Foo header(s)"

  email.Message.Message.get_boundary([failobj=None])
      Return the MIME message boundary delimiter for the message.
      Return 'failobj' if no boundary is defined; this -should-
      always be the case if the message is not multipart.
      返回此消息的MIME消息边界定界符. 如果没有定义任何边界,
      返回'failobj'; 如果此消息不是多块的话, -应该-总是这种情形.

  email.Message.Message.get_charsets([failobj=None])
      Return list of string descriptions of contained character
      sets.
      返回一个字符串列表, 描述包含的字符集.

  email.Message.Message.get_content_charset([failobj=None])
      Return a string description of the message character set.
      返回一个字符串, 描述消息的字符集.

  email.Message.Message.get_content_maintype()
      For message 'mess', equivalent to
      'mess.get_content_type().split("/")[0]'.
      对于消息'mess', 等价于
      'mess.get_content_type().split("/")[0]'.

  email.Message.Message.get_content_subtype()
      For message 'mess', equivalent to
      'mess.get_content_type().split("/")[1]'.
      对于消息'mess', 等价于
      'mess.get_content_type().split("/")[1]'.

  email.Message.Message.get_content_type()
      Return the MIME content type of the message object.  The
      return string is normalized to lowercase and contains
      both the type and subtype, separated by a '/'.
      返回消息对象的MIME内容类型. 返回的字符串被统一为小写字母,
      包含了类别和子类别, 使用'/'分隔.

      >>> msg_photo.get_content_type()
      'image/png'
      >>> msg_combo.get_content_type()
      'multipart/mixed'
      >>> msg_simple.get_content_type()
      'text/plain'

  email.Message.Message.get_default_type()
      Return the current default type of the message.  The
      default type will be used in decoding payloads that are not
      accompanied by an explicit 'Content-Type' header.
      返回消息当前的默认类型. 它会用于对那些没有显式给出
      'Content-Type'信头的负荷进行解码.

  email.Message.Message.get_filename([failobj=None])
      Return the 'filename' parameter of the
      'Content-Disposition' header.  If no such parameter exists
      (perhaps because no such header exists), 'failobj' is
      returned instead.
      返回'Content-Disposition'信头的'filename'参数.
      如果不存在这样的参数(也许因为不存在此信头), 会返回'failobj'.

  email.Message.Message.get_param(param [,failobj [,header=... [,unquote=1]]])
      Return the parameter 'param' of the header 'header'.  By
      default, use the 'Content-Type' header.  If the parameter
      does not exist, return 'failobj'.  If the argument
      'unquote' is specified as a true value, the quote marks are
      removed from the parameter.
      返回'header'信头的'param'参数. 默认使用'Content-Type'信头.
      如果参数不存在, 返回'failobj'. 如果'unquote'参数指定为true值,
      参数中的引号会被移除.

      >>> print mess.get_param('charset',unquote=1)
      us-ascii
      >>> print mess.get_param('charset',unquote=0)
      "us-ascii"

      SEE ALSO, `email.Message.Message.set_param()`
      参见`email.Message.Message.set_param()`

  email.Message.Message.get_params([,failobj=None [,header=... [,unquote=1]]])
      Return all the parameters of the header 'header'.  By
      default, examine the 'Content-Type' header.  If the header
      does not exist, return 'failobj' instead.  The return
      value consists of a list of key/val pairs.  The argument
      'unquote' removes extra quotes from values.
      返回'header'信头所有的参数. 默认检查'Content-Type'信头.
      如果信头不存在, 则返回'failobj'. 返回值由一个键值对列表组成.
      参数'unquote'移除值中多余的引号.

      >>> print mess.get_params(header="To")
      [('<mertz@gnosis.cx>', '')]
      >>> print mess.get_params(unquote=0)
      [('text/plain', ''), ('charset', '"us-ascii"')]

  email.Message.Message.get_payload([i [,decode=0]])
      Return the message payload.  If the message method
      'is_multipart()' returns true, this method returns a list
      of component message objects.  Otherwise, this method
      returns a string with the message body.  Note that if the
      message object was created using `email.Parser.HeaderParser`,
      then the body is treated as single part, even if it
      contains MIME delimiters.
      返回消息负荷. 如果消息方法'is_multipart()'返回true, 此方法
      返回一个列表, 包含了组成的消息对象. 否则, 此方法返回
      一个字符串, 其中是消息信体. 注意如果消息对象是使用
      `email.Parser.HeaderParser`创建的, 信体会作为单块对待,
      即使它包含了MIME定界符.

      Assuming that the message is multipart, you may specify the
      'i' argument to retrieve only the indexed component.
      Specifying the 'i' argument is equivalent to indexing on the
      returned list without specifying 'i'.  If 'decode' is
      specified as a true value, and the payload is single part,
      the returned payload is decoded (i.e., from quoted printable
      or base64).
      假设此消息是多块的, 你可以指定'i'参数来取回被索引的组件.
      指定'i'参数和对没有指定'i'返回的列表进行索引是等价的. 如果'decode'
      被指定为true值, 而且负荷是单块, 返回的负荷会被编码(即, 使用quoted pritable
      或者base64).

      I find that dealing with a payload that may be either a
      list or a text is somewhat awkward.  Frequently, you would
      like to simply loop over all the parts of a message body,
      whether or not MIME multiparts are contained in it.  A
      wrapper function can provide uniformity:
      我发现如果负荷是列表或者文本, 处理起来会比较笨拙. 你会经常
      仅仅对某消息信体所有部分都循环一遍, 不管是否有MIME多块包含其中.
      使用包装函数可以提供一致性:

      #---------------- write_payload_list.py ------------------#
      #!/usr/bin/env python
      "Write payload list to separate files"
      "将负荷列表写入分隔的文件中"
      import email, sys
      def get_payload_list(msg, decode=1):
          payload = msg.get_payload(decode=decode)
          if type(payload) in [type(""), type(u"")]:
              return [payload]
          else:
              return payload
      mess = email.message_from_file(sys.stdin)
      for part,num in zip(get_payload_list(mess),range(1000)):
          file = open('%s.%d' % (sys.argv[1], num), 'w')
          print >> file, part

      SEE ALSO, [email.Parser],
                `email.Message.Message.is_multipart()`,
                `email.Message.Message.walk()`
      参见 [email.Parser],
                `email.Message.Message.is_multipart()`,
                `email.Message.Message.walk()`

  email.Message.Message.get_unixfrom()
      Return the BSD mailbox "From_" envelope header, or 'None'
      if none exists.
      返回BSD信箱"From_"信封信头, 如果不存在则返回'None'.

      SEE ALSO, [mailbox]
      参见 [mailbox]

  email.Message.Message.is_multipart()
      Return a true value if the message is multipart.  Notice
      that the criterion for being multipart is having multiple
      message objects in the payload; the 'Content-Type' header
      is not guaranteed to be 'multipart/*' when this method
      returns a true value (but if all is well, it -should- be).
      如果消息是多块的, 返回true值. 注意成为多块的条件是, 
      在负荷中有多个消息对象; 当此方法返回true值是, 
      'Content-Type'信头不能保证为'multipart/*'(但是一切正常的话,
      它-应该-是).

      SEE ALSO, `email.Message.Message.get_payload()`
      参见 `email.Message.Message.get_payload()`

  email.Message.Message.preamble
      Message bodies that contain MIME content delimiters can
      also have text that falls outside the area between the
      first and final delimiter.  Any text at the very beginning
      of the body is stored in `email.Message.Message.preamble`.
      包含MIME内容定界符的消息信体, 还能拥有位于第一和最后一个
      定界符之外的文本. 任何位于信体最开始的文本都被存储于
      `email.Message.Message.preamble`.

      SEE ALSO, `email.Message.Message.epilogue`
      参见 `email.Message.Message.epilogue`

  email.Message.Message.replace_header(field, value)
      Replaces the first occurrence of the header with the name
      'field' with the value 'value'.  If no matching header is
      found, raise 'KeyError'.
      将第一次出现的名字为'field'的信头, 替换为值'value'. 如果
      没有找到匹配的信头, 引发'KeyError'.

  email.Message.Message.set_boundary(s)
      Set the boundary parameter of the 'Content-Type' header to
      's'.  If the message does not have a 'Content-Type' header,
      raise 'HeaderParserError'.  There is generally no reason to
      create a boundary manually, since the [email] module
      creates good unique boundaries on it own for multipart
      messages.
      将'Content-Type'信头的边界参数设为's'. 如果此消息并无'Content-Type'
      信头, 引发'HeaderParserError'. 通常没有理由来手工创建边界,
      因为[email]模块自己为多块信息创建了一个不错的唯一的边界.

  email.Message.Message.set_default_type(ctype)
      Set the current default type of the message to 'ctype'. The
      default type will be used in decoding payloads that are not
      accompanied by an explicit 'Content-Type' header.
      将消息当前的默认类型设置为'ctype'. 此默认类型会用于解码
      未显式指定'Content-Type'信头的负荷.

  email.Message.Message.set_param(param, value [,header="Content-Type"
    -?                             [,requote=1 [,charset [,language]]]])
      Set the parameter 'param' of the header 'header' to the
      value 'value'. If the argument 'requote' is specified as a
      true value, the parameter is quoted.  The arguments
      'charset' and 'language' may be used to encode the
      parameter according to RFC-2231.
      将信头'header'的'param'参数设置为值'value'. 如果参数
      'requoted'被指定为true值, 此参数用引号括住. 参数
      'charset'和'language'可根据RFC-2231对参数进行编码.

  email.Message.Message.set_payload(payload [,charset=None])
      Set the message payload to a string or to a list of message
      objects.  This method overwrites any existing payload the
      message has.  For messages with single part content, you
      must use this method to configure the message body (or use
      a convenience message subclass to construct the message in
      the first place).
      将消息负荷设置为一个字符串, 或者一个消息对象列表. 此方法
      覆盖所有此消息中已有负荷. 对于单块内容的消息, 你必须使用此
      方法来配置消息信体(或者使用便利消息子类在第一个位置构造消息).

      SEE ALSO, `email.Message.Message.attach()`,
                `email.MIMEText.MIMEText`,
                `email.MIMEImage.MIMEImage`,
                `email.MIMEAudio.MIMEAudio`
      参见 `email.Message.Message.attach()`,
                `email.MIMEText.MIMEText`,
                `email.MIMEImage.MIMEImage`,
                `email.MIMEAudio.MIMEAudio`
                
  email.Message.Message.set_type(ctype [,header="Content-Type" [,requote=1]])
      Set the content type of the message to 'ctype', leaving any
      parameters to the header as is.  If the argument 'requote'
      is specified as a true value, the parameter is quoted.  You
      may also specify an alternative header to write the content
      type to, but for the life of me, I cannot think of any
      reason you would want to.
      将消息的内容类别设置为'ctype', 其他信头中的参数保持不变. 如果
      参数'requote'指定为true值, 使用引号括住此参数. 你还可以将内容类型
      写入另外指定的信头, 但是以鄙人经验而言, 实在想不出会有任何理由导致
      你这样做.

  email.Message.Message.set_unixfrom(s)
      Set the BSD mailbox envelope header.  The argument 's'
      should include the word 'From' and a space, usually
      followed by a name and a date.
      设置BSD信箱的信封信头. 参数's'应该包括单词'From'和一个空格,
      通常后面跟随名字和日期.

      SEE ALSO, [mailbox]
      参见 [mailbox]

  email.Message.Message.walk()
      Recursively traverse all message parts and subparts of the
      message.  The returned iterator will yield each nested
      message object in depth-first order.
      递归遍历所有消息的块和子块. 返回的迭代子以深度为第一顺序给出
      每个嵌套的消息对象.

      >>> for part in mess.walk():
      ...    print part.get_content_type()
      multipart/mixed
      text/html
      audio/midi

      SEE ALSO, `email.Message.Message.get_payload()`
      参见 `email.Message.Message.get_payload()`

  =================================================================
    MODULE -- email.Parser : Parse a text message into a message object
    模块 -- email.Parser : 将文本消息解析成一个消息对象
  =================================================================

  There are two parsers provided by the [email.Parser] module:
  `email.Parser.Parser` and its child `email.Parser.HeaderParser`.
  For general usage, the former is preferred, but the latter allows
  you to treat the body of an RFC-2822 message as an unparsed
  block. Skipping the parsing of message bodies can be much faster
  and is also more tolerant of improperly formatted message bodies
  (something one sees frequently, albeit mostly in spam messages
  that lack any content value as well).
  [email.Parser]模块提供两个解析器: `email.Parser.Parser` 及其子类
   `email.Parser.HeaderParser`. 对于一般使用, 倾向于使用前者, 但是后者
   允许你将RFC-2822消息的信体作为未解析的块对待. 略过对消息信体的解析使得
   速度更快, 对于那些格式不正确的消息信体而言, 更有容错性(我们经常遇到这种消息,
   尽管绝大部分都是垃圾邮件, 它们也毫无有价值的内容).

  The parsing methods of both classes accept an optional
  'headersonly' argument. Specifying 'headersonly' has a stronger
  effect than using the `email.Parser.HeaderParser` class. If
  'headersonly' is specified in the parsing methods of either
  class, the message body is skipped altogether--the message object
  created has an entirely empty body.  On the other hand, if
  `email.Parser.HeaderParser` is used as the parser class, but
  'headersonly' is specified as false (the default), the body is
  always read as a single part text, even if its content type is
  'multipart/*'.
  两个类的解析方法都接受一个可选的'headersonly'参数. 指定
  'headersony'比使用`email.Parser.HeaderParser`类有更强的
  效果. 如果其中一个类的解析方法指定了'headersonly', 消息信体被统统
  略过--创建的消息对象信体将是空空如也. 从另一方面而言, 如果使用
  `email.Parser.HeaderParser`作为解析类, 但是'headersonly'被指定为
  false(默认值), 信体总是作为单块文本读入, 即使它的内容类型是'multipart/*'.

  CLASSES:
  类:

  email.Parser.Parser([_class=email.Message.Message [,strict=0]])
      Construct a parser instance that uses the class '_class' as
      the message object constructor.  There is normally no
      reason to specify a different message object type.
      Specifying strict parsing with the 'strict' option will
      cause exceptions to be raised for messages that fail to
      conform fully to the RFC-2822 specification.  In practice,
      "lax" parsing is much more useful.
      构造一个解析器实例, 使用类'_class'作为消息对象构造器. 通常没有理由
      指定一个不同的消息对象类型. 使用'strict'选项可以指定严格解析, 对于
      不完全符合RFC-2822规格的消息, 会引发异常. 在实际应用中,
      "lax"解析通常更有用.

  email.Parser.HeaderParser([_class=email.Message.Message [,strict=0]])
      Construct a parser instance that is the same as an
      instance of `email.Parser.Parser` except that multipart
      messages are parsed as if they were single part.
      构造一个解析器实例, 和`email.Parser.Parser`一样, 除了
      多块消息是当作单块来解析的.

  METHODS:
  方法:

  email.Parser.Parser.parse(file [,headersonly=0])
  email.Parser.HeaderParser.parse(file [,headersonly=0])
      Return a message object based on the message text found in
      the file-like object 'file'.  If the optional argument
      'headersonly' is given a true value, the body of the
      message is discarded.
      基于类文件对象'file'中找到的消息文本, 返回一个消息对象.
      如果给与可选参数'headersonly'的值是true, 消息信体被抛弃.

  email.Parser.Parser.parsestr(s [,headersonly=0])
  email.Parser.HeaderParser.parsestr(s [,headersonly=0])
      Return a message object based on the message text found in
      the string 's'.  If the optional argument 'headersonly' is
      given a true value, the body of the message is discarded.
      基于字符串's'中找到的消息文本, 返回一个消息对象. 
      如果给与可选参数'headersonly'的值是true, 消息信体被抛弃.

  =================================================================
    MODULE -- email.Utils : Helper functions for working with messages
    模块 -- email.Utils : 与消息协作时的帮助函数
  =================================================================

  The module [email.Utils] contains a variety of convenience
  functions, mostly for working with special header fields.
  模块[email.Utils]包含了各种各样的便利函数, 绝大部分都是
  为了与特殊信头域协作.

  FUNCTIONS:
  函数:

  email.Utils.decode_rfc2231(s)
      Return a decoded string for RFC-2231 encoded string 's':
      将RFC-2231编码的字符串's'解码后返回:

      >>> Omega = unicodedata.lookup("GREEK CAPITAL LETTER OMEGA")
      >>> print email.Utils.encode_rfc2231(Omega+'-man@gnosis.cx')
      %3A9-man%40gnosis.cx
      >>> email.Utils.decode_rfc2231("utf-8''%3A9-man%40gnosis.cx")
      ('utf-8', '', ':9-man@gnosis.cx')

  email.Utils.encode_rfc2231(s [,charset [,language]])
      Return an RFC-2231-encoded string from the string 's'.  A
      charset and language may optionally be specified.
      将字符串's'进行RFC-2231编码后返回. 可选选项charset和language.

  email.Utils.formataddr(pair)
      Return formatted address from pair '(realname,addr)':
      从对'(realname,addr)'中返回格式化后的地址:

      >>> email.Utils.formataddr(('David Mertz','mertz@gnosis.cx'))
      'David Mertz <mertz@gnosis.cx>'

  email.Utils.formataddr([timeval [,localtime=0]])
      Return an RFC-2822-formatted date based on a time value as
      returned by `time.localtime()`.  If the argument
      'localtime' is specified with a true value, use the local
      timezone rather than UTC.  With no options, use the current
      time.
      根据`time.localtime()`返回的时间值, 返回一个RFC-2822格式的时间.
      如果参数'localtime'指定为true值, 使用当地市区, 而非UTC. 如果
      没有选项, 使用当前时间.

      >>> email.Utils.formatdate()
      'Wed, 13 Nov 2002 07:08:01 -0000'

  email.Utils.getaddresses(addresses)
      Return a list of pairs '(realname,addr)' based on the list
      of compound addresses in argument 'addresses'.
      基于参数'addresses'中的复合地址列表, 返回一个列表, 其中是
      '(realname,addr)'对.

      >>> addrs = ['"Joe" <jdoe@nowhere.lan>','Jane <jroe@other.net>']
      >>> email.Utils.getaddresses(addrs)
      [('Joe', 'jdoe@nowhere.lan'), ('Jane', 'jroe@other.net')]

  email.Utils.make_msgid([seed])
      Return a unique string suitable for a 'Message-ID' header.
      If the argument 'seed' is given, incorporate that string
      into the returned value; typically a 'seed' is the sender's
      domain name or other identifying information.
      返回唯一的一个字符串, 适合作为'Message-ID'信头.
      如果给出了参数'seed', 将此字符串混合进返回的值;
      通常'seed'是发送者的域名或者其他识别信息.

      >>> email.Utils.make_msgid('gnosis')
      '<20021113071050.3861.13687.gnosis@localhost>'

  email.Utils.mktime_tz(tuple)
      Return a timestamp based on an `email.Utils.parsedate_tz()`
      style tuple.
      基于`email.Utils.parsedate_tz()`风格元组, 返回一个时间戳.

      >>> email.Utils.mktime_tz((2001, 1, 11, 14, 49, 2, 0, 0, 0, 0))
      979224542.0

  email.Utils.parseaddr(address)
      Parse a compound address into the pair '(realname,addr)'.
      将复合地址解析为'(realname,addr)'对.

      >>> email.Utils.parseaddr('David Mertz <mertz@gnosis.cx>')
      ('David Mertz', 'mertz@gnosis.cx')

  email.Utils.parsedate(datestr)
      Return a date tuple based on an RFC-2822 date string.
      基于RFC-2822时间字符串, 返回一个时间元组.

      >>> email.Utils.parsedate('11 Jan 2001 14:49:02 -0000')
      (2001, 1, 11, 14, 49, 2, 0, 0, 0)

      SEE ALSO, [time]
      参见  [time]

  email.Utils.parsedate_tz(datestr)
      Return a date tuple based on an RFC-2822 date string.
      Same as `email.Utils.parsedate()`, but adds a tenth tuple
      field for offset from UTC (or 'None' if not determinable).
      基于RFC-2822时间字符串, 返回一个时间元组.
      和`email.Utils.parsedate()`相同, 但增加第十个元组域, 其值
      为对UTC的位移(如果不能确定, 返回'None').

  email.Utils.quote(s)
      Return a string with backslashes and double quotes escaped.
      返回一个字符串, 其中的反斜杠和双引号都被转义.

      >>> print email.Utils.quote(r'"MyPath" is d:\this\that')
      \"MyPath\" is d:\\this\\that

  email.Utils.unquote(s)
      Return a string with surrounding double quotes or angle
      brackets removed.
      返回一个字符串, 包围的双引号或者尖括号都被移除.

      >>> print email.Utils.unquote('<mertz@gnosis.cx>')
      mertz@gnosis.cx
      >>> print email.Utils.unquote('"us-ascii"')
      us-ascii


  TOPIC --  Communicating with Mail Servers
  主题 -- 与邮件服务器通信
  --------------------------------------------------------------------

  =================================================================
    MODULE -- imaplib : IMAP4 client
    模块 -- imaplib : IMAP4 客户端
=================================================================

  The module [imaplib] supports implementing custom IMAP clients.
  This protocol is detailed in RFC-1730 and RFC-2060. As with the
  discussion of other protocol libraries, this documentation aims
  only to cover the basics of communicating with an IMAP
  server--many methods and functions are omitted here. In
  particular, of interest here is merely being able to retrieve
  messages--creating new mailboxes and messages is outside the
  scope of this book.
  模块[imaplib]支持实现自定义IMAP客户端. RFC-1730和RFC-2060描述了
  此协议. 和其他协议库的讨论一样, 这个文档只涵盖与IMAP服务器通信
  的基础内容--许多方法和函数都被忽略了. 需要特别指出的是, 这儿的兴趣
  几乎都是取回消息--创建新邮箱和新消息超出了本书的范围.

  The _Python Library Reference_ describes the POP3 protocol as
  obsolescent and recommends the use of IMAP4 if your server
  supports it. While this advice is not incorrect technically--IMAP
  indeed has some advantages--in my experience, support for POP3 is
  far more widespread among both clients and servers than is
  support for IMAP4. Obviously, your specific requirements will
  dictate the choice of an appropriate support library.
  _Python库参考_将POP3协议描述为即将过时的, 而推荐使用IMAP4, 如果
  你的服务器支持的话. 这个建议技术上来说, 并非不正确--IMAP确实
  拥有一些优势--根据我的经验, 客户和服务器两端对POP3的支持都比对
  IMAP4的支持更加广泛. 显然, 你特定的要求将决定如何选择合适的支持库.

  Aside from using a more efficient transmission strategy (POP3 is
  line-by-line, IMAP4 sends whole messages), IMAP4 maintains
  multiple mailboxes on a server and also automates filtering
  messages by criteria. A typical (simple) IMAP4 client application
  might look like the one below. To illustrate a few methods, this
  application will print all the promising subject lines, after
  deleting any that look like spam. The example does not itself
  retrieve regular messages, only their headers.
  除了使用更加高效的传输策略(POP3是每行传输, 而IMAP4传送整个消息),
  IMAP4在服务器上维护多个信箱, 还自动根据标准来过滤消息.
  一个典型(简单)的IMAP4客户端程序也许看上去和下面这个很像.
  为了展示一些方法, 该程序将删除所有看似垃圾邮件的主题行, 
  再打印出所有看上去没有问题的主题行. 这个例子并不取回通常的信件,
  而只取回它们的信头.
  

      #------------- check_imap_subjects.py --------------------#
      #!/usr/bin/env python
      import imaplib, sys
      if len(sys.argv) == 4:
          sys.argv.append('INBOX')
      (host, user, passwd, mbox) = sys.argv[1:]
      i = imaplib.IMAP4(host, port=143)
      i.login(user, passwd)
      resp = i.select(mbox)
      if r[0] <> 'OK':
          sys.stderr.write("Could not select %s\n" % mbox)
          sys.exit()
      # delete some spam messages
      typ, spamlist = i.search(None, '(SUBJECT) "URGENT"')
      i.store(','.join(spamlist.split()),'+FLAGS.SILENT','\deleted')
      i.expunge()
      typ, messnums = i.search(None,'ALL').split()
      for mess in messnums:
          typ, header = i.fetch(mess, 'RFC822.HEADER')
          for line in header[0].split('\n'):
              if string.upper(line[:9]) == 'SUBJECT: ':
                  print line[9:]
      i.close()
      i.logout()

  There is a bit more work to this than in the POP3 example, but
  you can also see some additional capabilities. Unfortunately,
  much of the use of the [imaplib] module depends on passing
  strings with flags and commands, none of which are
  well-documented in the _Python Library Reference_ or in the
  source to the module.  A separate text on the IMAP protocol is
  probably necessary for complex client development.
  和POP3中的例子相比, 这儿的工作多了一点, 但你也能够看到额外的能力.
  不幸的是, 对于[imaplib]模块的使用, 依赖于使用旗标和命令来传送
  字符串, 而在_Python库参考_或模块源代码中都没有良好的文档.
  为了开发复杂的客户端, 关于IMAP协议的单独文档是很必要的.

  CLASSES:
  类:

  imaplib.IMAP4([host="localhost" [port=143]])
      Create an IMAP instance object to manage a host connection.
      创建一个IMAP实例对象来管理主机连接.

  METHODS:
  方法:

  imaplib.IMAP4.close()
      Close the currently selected mailbox, and delete any
      messages marked for deletion.  The method
      `imaplib.IMAP4.logout()` is used to actually disconnect
      from the server.
      关闭当前选择的信箱, 并删除所有标记为删除的消息.
      使用方法`imaplib.IMAP4.logout()`来从服务器实际断开.

  imaplib.IMAP4.expunge()
      Permanently delete any messages marked for deletion in the
      currently selected mailbox.
      将当前选择的邮箱中标记删除的消息, 永久删除.

  imaplib.IMAP4.fetch(message_set, message_parts)
      Return a pair '(typ,datalist)'.  The first field 'typ' is
      either 'OK' or 'NO', indicating the status.  The second
      field 'datalist' is a list of returned strings from the
      fetch request.  The argument 'message_set' is a
      comma-separated list of message numbers to retrieve.  The
      'message_parts' describe the components of the messages
      retrieved--header, body, date, and so on.
      返回'(typ,datalist)'对. 第一个域'typ'要么是'OK', 要么是'NO',
      昭示了状态. 第二个域'datalist'是个列表, 其中是从获取请求中返回的字符串.
      参数'message_set'是使用逗号隔开的列表, 其中是需要取回的消息号码.
      'message_parts'描述了取回消息的组件--信头, 信体, 时间, 等等.

  imaplib.IMAP4.list([dirname="" [,pattern="*"])
      Return a '(typ,datalist)' tuple of all the mailboxes in
      directory 'dirname' that match the glob-style pattern
      'pattern'.  'datalist' contains a list of string names of
      mailboxes.  Contrast this method with
      `imaplib.IMAP4.search()`, which returns numbers of
      individual messages from the currently selected mailbox.
      将目录'dirname'中所有吻合glob风格模式'pattern'的邮箱
      以'(typ,datalist)'元组返回. 'datalist'包含了一个字符串列表,
      其中是邮箱名字. 和`imaplib.IMAP4.search()`不同的是,
      后者将当前选择邮箱中的许多消息单独返回.

  imaplib.IMAP4.login(user, passwd)
      Connect to the IMAP server specified in the instance
      initialization, using the authentication information given
      by 'user' and 'passwd'.
      连接到在实例初始化过程中指定的IMAP服务器, 使用
      'user'和'passwd'给出的授权信息.

  imaplib.IMAP4.logout()
      Disconnect from the IMAP server specified in the instance
      initialization.
      从实例初始化过程中指定的那个IMAP服务器断开.

  imaplib.IMAP4.search(charset, criterion1 [,criterion2 [,...]])
      Return a '(typ,messnums)' tuple where 'messnums' is a
      space-separated string of message numbers of matching
      messages. Message criteria specified in 'criterion1', and
      so on may either be 'ALL' for all messages or flags
      indicating the fields and values to match.
      返回一个'(typ,messnums)'元组, 此处'messnums'是使用
      空格分隔的数字字符串, 每个数字表示匹配消息的号码.
      'criterion1'等指定的消息条件, 可以是'ALL', 表示所有消息,
      也可以是旗标, 表明要匹配的域和值.

  imaplib.IMAP4.select([mbox="INBOX" [,readonly=0])
      Select the current mailbox for operations such as
      `imaplib.IMAP4.search()` and `imaplib.IMAP4.expunge()`.
      The argument 'mbox' gives the name of the mailbox, and
      'readonly' allows you to prevent modification to a mailbox.
      选择当前信箱, 以进行`imaplib.IMAP4.search()` 和
      `imaplib.IMAP4.expunge()`之类的操作. 参数'mbox'给出
      信箱的名字, 而'readonly'防止对邮箱进行修改.

  SEE ALSO, [email], [poplib], [smtplib]
  参见 [email], [poplib], [smtplib]

  =================================================================
    MODULE -- poplib : A POP3 client class
    模块 -- poplib : POP3客户端类
  =================================================================

  The module [poplib] supports implementing custom POP3 clients.
  This protocol is detailed in RFC-1725. As with the discussion of
  other protocol libraries, this documentation aims only to cover
  the basics of communicating with a POP3 server--some methods or
  functions may be omitted here.
  模块[poplib]支持实现自定义POP3客户端. RFC-1725给出了此协议的
  细节. 正如对其他协议库的讨论, 此文档只覆盖与POP3服务器的通信的基础
  内容--有些方法和函数在这里略过不提.

  The _Python Library Reference_ describes the POP3 protocol as
  obsolescent and recommends the use of IMAP4 if your server
  supports it.  While this advice is not incorrect
  technically--IMAP indeed has some advantages--in my experience,
  support for POP3 is far more widespread among both clients and
  servers than is support for IMAP4.  Obviously, your specific
  requirements will dictate the choice of an appropriate support
  library.
  _Python库参考_将POP3描述为即将过时的, 而推荐使用IMAP4, 如果你的
  服务器支持的话. 这个建议在技术上并非不正确--IMAP确实有一些优势--
  而根据我的经验, 在客户和服务器两端对POP3的支持都比对IMAP的支持
  更加广泛. 显然, 你特定的要求将决定如何选择合适的支持库.

  A typical (simple) POP3 client application might look like the
  one below. To illustrate a few methods, this application will
  print all the promising subject lines, and retrieve and delete
  any that look like spam. The example does not itself retrieve
  regular messages, only their headers.
  一个典型(简单)的POP3客户端程序可能看上去像下面这个. 
  为了展示一些方法, 此程序将会打印所有正常的主题行, 并取回删除
  那些看上去像垃圾邮件的消息. 此例子本身取回的不是正常消息, 仅仅
  信头而已.
## 需要核对

      #--------------- new_email_subjects.py -------------------#
      #!/usr/bin/env python
      import poplib, sys, string
      spamlist = []
      (host, user, passwd) = sys.argv[1:]
      mbox = poplib.POP3(host)
      mbox.user(user)
      mbox.pass_(passwd)

      for i in range(1, mbox.stat()[0]+1):
          # messages use one-based indexing
          headerlines = mbox.top(i, 0)[1]    # No body lines
          for line in headerlines:
              if string.upper(line[:9]) == 'SUBJECT: ':
                  if -1 <> string.find(line,'URGENT'):
                      spam = string.join(mbox.retr(i)[1],'\n')
                      spamlist.append(spam)
                      mbox.dele(i)
                  else:
                       print line[9:]

      mbox.quit()
      for spam in spamlist:
          report_to_spamcop(spam)     # assuming this func exists

  CLASSES:
  类:

  poplib.POP3(host [,port=110])
      The [poplib] module provides a single class that
      establishes a connection to a POP3 server at host 'host',
      using port 'port'.
      [poplib]模块提供了一个类, 使用端口'port'来确立和主机'host'
      上POP3服务器的连接.

  METHODS:
  方法:

  poplib.POP3.apop(user, secret)
      Log in to a server using APOP authentication.
      使用APOP授权登录到服务器.

  poplib.POP3.dele(messnum)
      Mark a message for deletion.  Normally the actual deletion
      does not occur until you log off with `poplib.POP3.quit()`,
      but server implementations differ.
      将某消息标记为删除. 除非你使用`poplib.POP3.quit()`退出,
      否则实际删除并不会发生, 不过系统实现上都有不同.

  poplib.POP3.pass_(password)
      Set the password to use when communicating with the POP
      server.
      设定与POP服务器通信时所用密码.

  poplib.POP3.quit()
      Log off from the connection to the POP server.  Logging off
      will cause any pending deletions to be carried out.  Call
      this method as soon as possible after you establish a
      connection to the POP server; while you are connected, the
      mailbox is locked against receiving any incoming messages.
      退出与POP服务器的连接. 这将导致执行待决删除. 当你确立了
      和POP服务器的连接之后, 尽快调用此方法; 因为当你连接的时候,
      此邮箱被锁定,  无法接受任何进来的信息.

  poplib.POP3.retr(messnum)
      Return the message numbered 'messnum' (using one-based
      indexing).  The return value is of the form
      '(resp,linelist,octets)', where 'linelist' is a list of the
      individual lines in the message.  To re-create the whole
      message, you will need to join these lines.
      返回号码为'messnum'(使用one-based索引)的消息.
      返回值的格式是'(resp,linelist,octets)', 此处'linelist'是
      消息中每一行组成的一个列表. 为了重新建立整个消息,
      你需要将这些行拼接起来.

  poplib.POP3.rset()
      Unmark any messages marked for deletion.  Since server
      implementations differ, it is not good practice to mark
      messages using `poplib.POP3.dele()` unless you are pretty
      confident you want to erase them.  However,
      `poplib.POP3.rset()` can usually save messages should
      unusual circumstances occur before the connection is logged
      off.
      取消删除标记. 因为系统实现上的不同, 使用`poplib.POP3.dele()`
      来标记消息, 并非一个很好的习惯, 除非你非常确定你要删除它们.
      但是, `poplib.POP3.rset()`通常能在退出连接前挽救消息, 
      避免不正常情况.
## ???

  poplib.POP3.top(messnum, lines)
      Retrieve the initial lines of message 'messnum'.  The
      header is always included, along with 'lines' lines from
      the body.  The return format is the same as with
      `poplib.POP3.retr()`, and you will typically be interested
      in offset 1 of the returned tuple.
      取回消息'messnum'的初始行. 信头总是包括在内, 还有信体
      的'lines'行. 返回的格式和`poplib.POP3.retr()`一样, 你通常
      会对返回元组的位移1比较感兴趣.

  poplib.POP3.stat()
      Retrieve the status of the POP mailbox in the format
      '(messcount,mbox_size)'.  'messcount' gives you the total
      number of message pending; 'mbox_size' is the total size of
      all pending messages.
      取回POP信箱的状态, 格式为'(messcount,mbox_size)'.
      'messcount'告诉你待决消息的总共数目; 'mbox_size'则是
      所有待决消息的总共大小.

  poplib.POP3.user(username)
      Set the username to use when communicating with the POP
      server.
      设定与POP服务器通信时的用户名.

  SEE ALSO, [email], [smtplib], [imaplib]
  参见 [email], [smtplib], [imaplib]

  =================================================================
    MODULE -- smtplib : SMTP/ESMTP client class
    模块 -- smtplib : SMTP/ESMTP 客户端类
  =================================================================

  The module [smtplib] supports implementing custom SMTP clients.
  This protocol is detailed in RFC-821 and RFC-1869. As with the
  discussion of other protocol libraries, this documentation aims
  only to cover the basics of communicating with an SMTP
  server--most methods and functions are omitted here. The modules
  [poplib] and [imaplib] are used to retrieve incoming email, and
  the module [smtplib] is used to send outgoing email.
  模块[smtplib]支持实现自定义SMTP客户端. RFC-821和RFC-1869给出
  了此协议的细节. 正如对其他协议库的讨论, 此文档旨于涵盖与SMTP服务器
  通信的基础知识--绝大部分方法和函数在此处都略过不提. 模块
  [poplib]和[imaplib]被用来取回收到的信件, 而模块[smmtplib]被用来发送
  邮件.

  A typical (simple) SMTP client application might look like the
  one below. This example is a command-line tool that accepts as a
  parameters the mandatory 'To' message envelope header, constructs
  the 'From' using environment variables, and sends whatever text
  is on STDIN. The 'To' and 'From' are also added as RFC-822
  headers in the message header.
  一个典型(简单)的SMTP客户端程序也许看起来和下面这个类似. 这个例子
  是个命令行工具, 它以参数形式接受托管的'To'消息信封信头, 使用
  环境变量构造'From', 并将STDIN的文本发送出去. 'To'和'From'还以
  RFC-822信头加入到消息信头中.

      #-------------------- send_email.py ----------------------#
      #!/usr/bin/env python
      import smtplib
      from sys import argv, stdin
      from os import getenv
      host = getenv('HOST', 'localhost')
      if len(argv) >= 2:
          to_ = argv[1]
      else:
          to_ = raw_input('To: ').strip()
      if len(argv) >=3:
          subject = argv[2]
          body = stdin.read()
      else:
          subject = stdin.readline()
          body = subject + stdin.read()
      from_ = "%s@%s" % (getenv('USER', 'user'), host)
      mess = '''From: %s\nTo: %s\n\n%s' % (to_, from_, body)
      server = smtp.SMTP(host)
      server.login
      server.sendmail(from_, to_, mess)
      server.quit()

  CLASSES:
  类:

  smtplib.SMTP([host="localhost" [,port=25]])
      Create an instance object that establishes a connection to
      an SMTP server at host 'host', using port 'port'.
      创建一个实例对象, 使用端口'port'与主机'host'上的SMTP服务器
      建立连接.

  METHODS:
  方法:

  smtplib.SMTP.login(user, passwd)
      Login to an SMTP server that requires authentication.
      Raises an error if authentication fails.
      登录到需要授权的SMTP服务器. 如果授权失败,
      引发一个错误.

      Not all--or even most--SMTP servers use password
      authentication.  Modern servers support direct
      authentication, but since not all clients support SMTP
      authentication, the option is often disabled.  One commonly
      used strategy to prevent "open relays" (servers that allow
      malicious/spam messages to be sent through them) is "POP
      before SMTP."  In this arrangement, an IP address is
      authorized to use an SMTP server for a period of time after
      that same address has successfully authenticated with a
      POP3 server on the same machine.  The timeout period is
      typically a few minutes to hours.
      并非所有--或者说几乎所有--SMTP服务器都使用密码授权. 
      现代服务器支持直接授权, 但是因为并非所有客户端支持
      SMTP授权, 此选项通常被关闭. 为了防止"open relays"
      (允许发送恶意/垃圾邮件的服务器), 一个通常使用的策略是
      "先POP, 再SMTP". 这样的安排下, 一个IP地址需要先成功获得
      一个POP3服务器的授权, 然后此IP地址获权在某时间段内使用同一个主机上
      的SMTP服务器. 超时期限通常是几分钟到几个小时.

  smtplib.SMTP.quit()
      Terminate an SMTP connection.
      终止SMTP连接.

  smtplib.SMTP.sendmail(from_, to_, mess [,mail_options=[] [,rcpt_options=[]]])
      Send the message 'mess' with 'From' envelope 'from_', to
      recipients 'to_'.  The argument 'to_' may either be a
      string containing a single address or a Python list of
      addresses.  The message should include any desired RFC-822
      headers.  ESMTP options may be specified in arguments
      'mail_options' and 'rcpt_options'.
      使用'From'信封'from_', 发送消息'mess'到接受者'to_'.
      参数'to_'要么是一个字符串,其中只有一个电子邮件地址,
      要么是一个Python列表, 其中有若干地址, 消息应该包含任何
      想要的RFC-822信头. ESMPT选项可在参数'mail_options' 和
      'rcpt_options'中指定.

  SEE ALSO, [email], [poplib], [imaplib]
  参见 [email], [poplib], [imaplib]


  TOPIC -- Message Collections and Message Parts
  主题 -- 消息集合以及消息零件
  --------------------------------------------------------------------

  =================================================================
    MODULE -- mailbox : Work with mailboxes in various formats
    模块 -- mailbox : 与不同格式的邮箱协作
  =================================================================

  The module [mailbox] provides a uniform interface to email
  messages stored in a variety of popular formats. Each class in
  the [mailbox] module is initialized with a mailbox of an
  appropriate format, and returns an instance with a single method
  '.next()'. This instance method returns each consecutive
  message within a mailbox upon each invocation.  Moreover, the
  '.next()' method is conformant with the iterator protocol in
  Python 2.2+, which lets you loop over messages in recent
  versions of Python.
  电子邮件存储有多个流行的格式, 而模块[mailbox]为电子邮件消息
  提供了统一的接口. [mailbox]模块的每个类都以适当格式的信箱初始化,
  返回的实例只有一个方法'.next()'. 每次调用, 实例方法返回信箱中
  连续的一个消息. 而且, '.next()'方法符合Python 2.2+中的迭代协议,
  后者让你可以在Python最近的版本中循环操作消息.
  
  By default, the messages returned by 'mailbox' instances are
  objects of the class `rfc822.Mailbox`. These message objects
  provide a number of useful methods and attributes. However, the
  recommendation of this book is to use the newer [email] module in
  place of the older [rfc822]. Fortunately, you may initialize a
  [mailbox] class using an optional message constructor. The only
  constraint on this constructor is that it is a callable object
  that accepts a file-like object as an argument--the [email]
  module provides two logical choices here.
  'mailbox'实例返回的消息默认都是`rfc822.Mailbox`类的对象.
  这些消息对象提供了许多有用的方法和属性. 但是,
  本书的推荐是使用更新的[email]模块来取代老的[rfc822]. 幸运的是,
  你可以使用可选的消息构造器来初始化[mailbox]类. 这个消息构造器
  的唯一限制是它是一个可调用对象, 接受类文件对象作为参数--[email]
  模块在这儿提供了两个符合逻辑的选择.

      >>> import mailbox, email, email.Parser
      >>> mbox = mailbox.PortableUnixMailbox(open('mbox'))
      >>> mbox.next()
      <rfc822.Message instance at 0x41d770>
      >>> mbox = mailbox.PortableUnixMailbox(open('mbox'),
      ...                        email.message_from_file)
      >>> mbox.next()
      <email.Message.Message instance at 0x5e43e0>
      >>> mbox = mailbox.PortableUnixMailbox(open('mbox'),
      ...                        email.Parser.Parser().parse)
      >>> mbox.next()
      <email.Message.Message instance at 0x6ee630>

  In Python 2.2+ you might structure your application as:
  在Python 2.2+中, 你可以组织你的程序如下:

      #----------- Looping through a mailbox in 2.2+ -----------#
      #!/usr/bin/env python
      from mailbox import PortableUnixMailbox
      from email import message_from_file as mff
      import sys
      folder = open(sys.argv[1])
      for message in PortableUnixMailbox(folder, mff):
          # do something with the message...
          print message['Subject']

  However, in earlier versions, this same code will raise an
  'AttributeError' for the missing '.__getitem__()' magic method.
  The slightly less elegant way to write the same application in
  an older Python is:
  但是, 在早期版本中, 同样的代码会引发'AttributeError', 因为
  缺少'.__getitem__()'魔术方法. 有个稍缺优雅的方法, 可以在老版本
  Python中编写同样的程序:

      #------- Looping through a mailbox in any version  -------#
      #!/usr/bin/env python
      "Subject printer, older Python and rfc822.Message objects"
      import sys
      from mailbox import PortableUnixMailbox
      mbox = PortableUnixMailbox(open(sys.argv[1]))
      while 1:
          message = mbox.next()
          if message is None:
              break
          print message.getheader('Subject')

  CLASSES:
  类:

  mailbox.UnixMailbox(file [,factory=rfc822.Message])
      Read a BSD-style mailbox from the file-like object 'file'.
      If the optional argument 'factory' is specified, it
      must be a callable object that accepts a file-like object
      as its single argument (in this case, that object is a
      portion of an underlying file).
      从类文件对象'file'中读入一个BSD风格的邮箱. 如果指定可选参数
      'factory'的话, 它必须是一个可调用对象, 唯一接受的一个参数是
      类文件对象(在这种情况下, 此对象是下面文件的一部分).
      
      A BSD-style mailbox divides messages with a blank line
      followed by a "Unix From_" line.  In this strict case, the
      "From_" line must have 'name' and 'time' information on it
      that matches a regular expression.  In most cases, you are
      better off using `mailbox.PortableUnixMailbox`, which
      relaxes the requirement for recognizing the next message in
      a file.
      BSD风格的邮箱分隔各消息使用的是, 空白行后面跟着一个
      "Unix From_"行. 在严格的情况下, "From_"行中必须有
      'name'和'time'信息, 它们符合某个正则表达式. 在绝大部分情况中,
      你最好使用`mailbox.PortableUnixMailbox`, 它对于识别文件中
      的下一个消息, 要求不是很高.

  mailbox.PortableUnixMailbox(file [,factory=rfc822.Message])
      The arguments to this class are the same as for
      `mailbox.UnixMailbox`.  Recognition of the messages within
      the mailbox 'file' depends only on finding 'From' followed
      by a space at the beginning of a line.  In practice, this
      is as much as you can count on if you cannot guarantee that
      all mailboxes of interest will be created by a specific
      application and version.
      本类的参数与`mailbox.UnixMailbox`相同. 识别信箱'file'中的
      消息, 仅仅依赖于寻找行首的'From'后面跟随一个空格. 在实际运用中,
      如果你不能保证感兴趣的信箱都是某个特定程序的特定版本所创建,
      这是所有你能依赖的.

  mailbox.BabylMailbox(file [,factory=rfc822.Message])
      The arguments to this class are the same as for
      `mailbox.UnixMailbox`.  Handles mailbox files in Babyl
      format.
      本类的参数和`mailbox.UnixMailbox`相同. 处理Babyl格式
      的信箱文件.

  mailbox.MmdfMailbox(file [,factory=rfc822.Message])
      The arguments to this class are the same as for
      `mailbox.UnixMailbox`.  Handles mailbox files in MMDF
      format.
      本类的参数和`mailbox.UnixMailbox`相同. 处理MMDF格式
      的信箱文件.

  mailbox.MHMailbox(dirname [,factory=rfc822.Message])
      The MH format uses the directory structure of the
      underlying native filesystem to organize mail folders.
      Each message is held in a separate file.  The initializer
      argument for `mailbox.MHMailbox` is a string giving the
      name of the directory to be processed.  The 'factory'
      argument is the same as with `mailbox.UnixMailbox`.
      MH格式使用底层系统的原生目录结构来组织邮件目录.
      每个消息被存储在单独的文件中. `mailbox.MHMailbox`
      的初始化参数是一个字符串, 给出了欲处理文件夹的名字.
      'factory'参数和`mailbox.UnixMailbox`一样.

  mailbox.Maildir(dirname [,factory=rfc822.Message])
      The QMail format, like the MH format,  uses the directory
      structure of the underlying native filesystem to organize
      mail folders. The initializer argument for `mailbox.Maildir`
      is a string giving the name of the directory to be
      processed.  The 'factory' argument is the same as with
      `mailbox.UnixMailbox`.
      QMail格式, 和MH一样, 使用底层系统的原生目录结构来管理
      邮件目录. `mailbox.Maildir`的初始化参数是一个字符串, 
      给出了欲处理文件夹的名字.
      'factory'参数和`mailbox.UnixMailbox`一样.


  SEE ALSO, [email], [poplib], [imaplib], `nntplib`, [smtplib], `rfc822`
  看见 [email], [poplib], [imaplib], `nntplib`, [smtplib], `rfc822`

  =================================================================
    MODULE -- mimetypes : Guess the MIME type of a file
    模块 -- mimetype : 猜测文件的MIME类型
  =================================================================

  The [mimetypes] module maps file extensions to MIME datatypes.
  At its heart, the module is a dictionary, but several
  convenience functions let you work with system configuration
  files containing additional mappings, and also query the
  mapping in some convenient ways.  As well as actual MIME types,
  the [mimetypes] module tries to guess file encodings, for
  example, compression wrapper.
  [mimetypes]模块将文件扩展名配对到MIME数据类型. 此模块的核心
  乃是一个字典, 不过另有便利函数可让你与包含额外配对的系统配置文件
  一起协同工作, 另外还可以方便地查询配对. 和实际的MIME类型一样,
  [mimetypes]模块试图猜测文件编码. 例如, compression wrapper.

  In Python 2.2+, the [mimetypes] module also provides a
  `mimetypes.MimeTypes` class that lets instances each maintain
  their own MIME types mapping, but the requirement for multiple
  distinct mapping is rare enough not to be worth covering here.
  在Python 2.2+, [mimetypes]模块还提供了一个`mimetypes.MimeTypes`
  类, 它让每个实例拥有自己的一个MIME类型匹配, 但是关于多个不同匹配,
  并没有太多需求, 所以不值得在这里涉及.

  FUNCTIONS:
  函数:

  mimetypes.guess_type(url [,strict=0])
      Return a pair '(typ,encoding)' based on the file or
      Uniform Resource Locator (URL) named by 'url'.  If the
      'strict' option is specified with a true value, only
      officially specified types are considered. Otherwise, a
      larger number of widespread MIME types are examined.  If
      either 'type' or 'encoding' cannot be guessed, 'None' is
      returned for that value.
      基于名为'url'的文件或者统一资源定位器(URL), 返回一个
      '(typ,encoding)'对. 如果'strict'选项被指定为true值, 只考虑
      正式指定的类型. 否则, 检查的类型将是很多广泛使用的MIME类型.
      如果'type'或者'encoding'无法猜测, 返回'None'.

      >>> import mimetypes
      >>> mimetypes.guess_type('x.abc.gz')
      (None, 'gzip')
      >>> mimetypes.guess_type('x.tgz')
      ('application/x-tar', 'gzip')
      >>> mimetypes.guess_type('x.ps.gz')
      ('application/postscript', 'gzip')
      >>> mimetypes.guess_type('x.txt')
      ('text/plain', None)
      >>> mimetypes.guess_type('a.xyz')
      (None, None)

  mimetypes.guess_extension(type [,strict=0])
      Return a string indicating a likely extension associated
      with the MIME type.  If multiple file extensions are
      possible, one is returned (generally the one that is first
      alphabetically, but this is not guaranteed).  The argument
      'strict' has the same meaning as in `mimetypes.guess_type()`.
      返回一个字符串, 显示了可能和MIME类型关联的扩展名. 
      如果可能有多个文件扩展名, 只返回一个(通常是按照字母顺序的第一个,
      但是没有保证). 参数'strict'的意义和`mimetypes.guess_type()`中
      的一样.

      >>> print mimetypes.guess_extension('application/EDI-Consent')
      None
      >>> print mimetypes.guess_extension('application/pdf')
      .pdf
      >>> print mimetypes.guess_extension('application/postscript')
      .ai

  mimetypes.init([list-of-files])
      Add the definitions from each filename listed in
      'list-of-files' to the MIME type mapping.  Several default
      files are examined even if this function is not called, but
      additional configuration files may be added as needed on
      your system.  For example, on my MacOSX system, which uses
      somewhat different directories than a Linux system, I find
      it useful to run:
      将'list-of-files'中列出的文件中的定义加入MIME类型匹配.
      即使未调用本函数, 还是会检查几个默认文件的, 但是对于你的系统,
      可以添加需要的配置文件. 例如, 在我的MacOSX系统上, 它使用
      目录和Linux系统略有不同, 我发现这样比较有用:

      >>> mimetypes.init(['/private/etc/httpd/mime.types.default',
      ...                 '/private/etc/httpd/mime.types'])

      Notice that even if you are specifying only one additional
      configuration file, you must enclose its name inside a
      list.
      注意, 即使你只指定一个附加配置文件, 你也必须将其名字置于列表中.

  mimetypes.read_mime_types(fname)
      Read the single file named 'fname' and return a dictionary
      mapping extensions to MIME types.
      读入一个名为'fname'的文件, 返回一个字典, 匹配扩展名到MIME类型.

      >>> from mimetypes import read_mime_types
      >>> types = read_mime_types('/private/etc/httpd/mime.types')
      >>> for _ in range(5): print types.popitem()
      ...
      ('.wbxml', 'application/vnd.wap.wbxml')
      ('.aiff', 'audio/x-aiff')
      ('.rm', 'audio/x-pn-realaudio')
      ('.xbm', 'image/x-xbitmap')
      ('.avi', 'video/x-msvideo')

  ATTRIBUTES:

  mimetypes.common_types
      Dictionary of widely used, but unofficial MIME types.
      字典, 其中是广泛使用, 但非正式的MIME类型.

  mimetypes.inited
      True value if the module has been initialized.
      如果模块已经初始化, 则为True.

  mimetypes.encodings_map
      Dictionary of encodings.
      编码的字典.

  mimetypes.knownfiles
      List of files checked by default.
      默认检查的文件列表.

  mimetypes.suffix_map
      Dictionary of encoding suffixes.
      编码后缀字典.

  mimetypes.types_map
      Dictionary mapping extensions to MIME types.
      字典, 将扩展名匹配到MIME类型.


SECTION 2 -- World Wide Web Applications
第2节 -- 万维网程序
------------------------------------------------------------------------

  TOPIC -- Common Gateway Interface
  主题 -- 通用网关接口
  --------------------------------------------------------------------

  =================================================================
    MODULE --   cgi : Support for Common Gateway Interface scripts
    模块 -- cgi : 支持通用网关接口的脚本
  =================================================================

  The module [cgi] provides a number of helpful tools for
  creating CGI scripts.  There are two elements to CGI,
  basically: (1) Reading query values. (2) Writing the results
  back to the requesting browser.  The first of these elements is
  aided by the [cgi] module, the second is just a matter of
  formatting suitable text to return.  The [cgi] module contains
  one class that is its primary interface; it also contains
  several utility functions that are not documented here because
  their use is uncommon (and not hard to replicate and customize
  for your specific needs).  See the _Python Library Reference_
  for details on the utility functions.
  模块[cgi]提供了许多有用工具来创建CGI脚本. CGI有两个基本元素:
  (1) 读入查询值. (2) 将结果写回发出请求的浏览器. 第一个元素可以
  使用[cgi]模块, 第二个只是将合适文本格式化后返回. [cgi]模块包含了
  一个类, 这是它的主要接口; 它还包含了若干工具函数, 此处并未涵盖, 
  因为并不常用(为了达到你特定的目的, 复制和定义这样的函数也不是很难).
  参见_Python库参考_以获得这些工具函数的细节.

  A CGI PRIMER:
  CGI导读:

  A primer on the Common Gateway Interface is in order. A CGI
  script is just an application--in any programming language--that
  runs on a Web server. The server software recognizes a request
  for a CGI application, sets up a suitable environment, then
  passes control to the CGI application. By default, this is done
  by spawning a new process space for the CGI application to run
  in, but technologies like [FastCGI] and [mod_python] perform some
  tricks to avoid extra process creation. These latter techniques
  speed performance but change little from the point of view of the
  CGI application creator.
  通用网关接口的导读是有秩序的. CGI脚本就是程序--使用任何编程语言--
  在Web服务器上运行. 服务器软件识别到CGI程序的一个请求, 设置好合适的
  环境, 将控制权转交给CGI程序. 默认的方法是, 为CGI程序创建一个子进程
  空间来运行, 但是类似[FastCGI]和[mod_python]的技术耍了一些小花招
  来避免创建额外的进程. 这些后起之秀提高了性能, 但是稍稍偏离CGI程序创始者
  的观点.

  A Python CGI script is called in exactly the same way any other
  URL is. The only difference between a CGI and a static URL is
  that the former is marked as executable by the Web
  server--conventionally, such scripts are confined to a
  './cgi-bin/' subdirectory (sometimes another directory name is
  used); Web servers generally allow you to configure where CGI
  scripts may live. When a CGI script runs, it is expected to
  output a 'Content-Type' header to STDOUT, followed by a blank
  line, then finally some content of the appropriate type--most
  often an HTML document. That is really all there is to it.
  调用Python CGI脚本就和其他任何URL一样. CGI和静态URL之间唯一
  的不同是, 前者被Web服务器标记为可执行的--按照惯例, 此类
  脚本被限制在'./cgi-bin/'子目录中(有时候也使用其他目录名); Web服务器
  通常允许你配置何处放置CGI脚本. 当运行CGI脚本时, 通常期待它输出
  一个'Content-Type'头到STDOUT, 其后有一个空白行, 最后是合适类型
  的一些内容--最常见的是HTML文档. 这正是CGI的用途.

  CGI requests may utilize one of two methods: POST or GET. A POST
  request sends any associated query data to the STDIN of the CGI
  script (the Web server sets this up for the script). A GET
  request puts the query in an environment variable called
  'QUERY_STRING'. There is not a lot of difference between the two
  methods, but GET requests encode their query information in a
  Uniform Resource Identifier (URI), and may therefore be composed
  without HTML forms and saved/bookmarked. For example, the
  following is an HTTP GET query to a script example discussed
  below:
  CGI请求可以使用这两种方法之一: POST或者GET. POST请求将关联的查询
  发送到CGI脚本的STDIN (Web服务器会为脚本设置好). 而GET请求将查询
  置于名为'QUERY_STRING'的环境变量中. 此两种方法并无太多不同,
  只是GET请求将它们的查询信息在统一资源标识符(URI)中编码, 因此可能
  没有HTML形式, 从而不能保存, 或者保留书签. 例如, 这个HTTP GET
  向下面要讨论的脚本发出查询:

      #*--------------------- HTTP GET request -----------------#
      <http://gnosis.cx/cgi-bin/simple.cgi?this=that&spam=eggs+are+good>

  You do not actually -need- the [cgi] module to create CGI
  scripts.  For example, let us look at the script 'simple.cgi'
  mentioned above:
  想要创建CGI脚本, [cgi]模块并非-必需-的. 例如, 让我们看看
  下面提到的这个'simple.cgi'脚本:

      #---------------------- simple.cgi -----------------------#
      #!/usr/bin/python
      import os,sys
      print "Content-Type: text/html"
      print
      print "<html><head><title>Environment test</title></head><body><pre>"
      for k,v in os.environ.items():
          print k, "::",
          if len(v)<=40: print v
          else:          print v[:37]+"..."
      print "&lt;STDIN&gt; ::", sys.stdin.read()
      print "</pre></body></html>"

  I happen to have composed the above sample query by hand, but
  you will often call a CGI script from another Web page.  Here is
  one that does so:
  上面的脚本碰巧是我手工编写的, 但是你通常会从其他网页调用CGI脚本.
  下面的网页就是这么做的:

      #----------- http://gnosis.cx/simpleform.html ------------#
      <html><head><title>Test simple.cgi</title></head><body>
      <form action="cgi-bin/simple.cgi" method="GET" name="form">
      <input type="hidden" name="this" value="that">
      <input type="text" value="" name="spam" size="55" maxlength="256">
      <input type="submit" value="GET">
      </form>
      <form action="cgi-bin/simple.cgi" method="POST" name="form">
      <input type="hidden" name="this" value="that">
      <input type="text" value="" name="spam" size="55" maxlength="256">
      <input type="submit" value="POST">
      </form>
      </body></html>

  It turns out that the script 'simple.cgi' is moderately useful;
  it tells the requester exactly what it has to work with.  For
  example, the query above (which could be generated exactly by
  the GET form on 'simpleform.html') returns a Web page that looks
  like the one below (edited):
  我们发现脚本'simple.cgi'还是有点用的; 它告诉请求者它用来协作的所有内容.
  例如, 上面的查询(它可以在 'simpleform.html'中以GET形式构造出来)返回
  的网页类似下面这个(编辑过后):

      #*------- Response from simple.cgi GET request -----------#
      #*------- simple.cgi GET请求的反馈 -----------#
      DOCUMENT_ROOT :: /www/gnosis
      HTTP_ACCEPT_ENCODING :: gzip, deflate, compress;q=0.9
      CONTENT_TYPE :: application/x-www-form-urlencoded
      SERVER_PORT :: 80
      REMOTE_ADDR :: 151.203.xxx.xxx
      SERVER_NAME :: www.gnosis.cx
      HTTP_USER_AGENT :: Mozilla/5.0 (Macintosh; U; PPC Mac OS...
      REQUEST_URI :: /cgi-bin/simple.cgi?this=that&spam=eg...
      QUERY_STRING :: this=that&spam=eggs+are+good
      SERVER_PROTOCOL :: HTTP/1.1
      HTTP_HOST :: gnosis.cx
      REQUEST_METHOD :: GET
      SCRIPT_NAME :: /cgi-bin/simple.cgi
      SCRIPT_FILENAME :: /www/gnosis/cgi-bin/simple.cgi
      HTTP_REFERER :: http://gnosis.cx/simpleform.html
      <STDIN> ::

  A few environment variables have been omitted, and those
  available will differ between Web servers and setups.  The most
  important variable is 'QUERY_STRING'; you may perhaps want to
  make other decisions based on the requesting 'REMOTE_ADDR',
  'HTTP_USER_AGENT', or 'HTTP_REFERER' (yes, the variable name is
  spelled wrong).  Notice that STDIN is empty in this case.
  However, using the POST form on the sample Web page will give
  a slightly different response (trimmed):
  一些环境变量已经被忽略掉了, 而不同的Web服务器和配置都会导致
  可用变量的不同. 最重要的变量是 'QUERY_STRING'; 根据请求方的
  'REMOTE_ADDR', 'HTTP_USER_AGENT', 或者 'HTTP_REFERER', 
  你可以做出其他的决定. 但是, 对于同样的网页, 使用POST表单会给出
  一个略微不同的相应(修整过的):

      #*------- Response from simple.cgi POST request ----------#
      #*------- simple.cgi POST请求得到的相应 ----------#
      CONTENT_LENGTH :: 28
      REQUEST_URI :: /cgi-bin/simple.cgi
      QUERY_STRING ::
      REQUEST_METHOD :: POST
      <STDIN> :: this=that&spam=eggs+are+good

  The 'CONTENT_LENGTH' environment variable is new, 'QUERY_STRING'
  has become empty, and STDIN contains the query.  The rest of the
  omitted variables are the same.
  'CONTENT_LENGTH' 环境变量是新的, 'QUERY_STRING'变成空的, 而STDIN
  包含了这个查询. 剩余的变量都是一样的, 故被省略.

  A CGI script need not utilize any query data and need not return
  an HTML page. For example, on some of my Web pages, I utilize a
  "Web bug"--a 1x1 transparent gif file that reports back who
  "looks" at it. Web bugs have a less-honorable use by spammers who
  send HTML mail and want to verify receipt covertly; but in my
  case, I only want to check some additional information about
  visitors to a few of my own Web pages. A Web page might contain,
  at bottom:
  CGI脚本不需要使用查询数据, 也不需要返回HTML页面. 例如, 在我的一些网页上,
  我使用"Web bug"--一个1x1的透明gif文件来报告返回谁在"看"它. Web bug还有
  一个名声不好的用途, 就是垃圾邮件发送者发送了HTML的邮件, 想要偷偷的
  核对收信人; 但在我的这个案例中, 我只想检查我自己某些网页的访问者的
  额外信息. 网页可能在底部包含:

      #*------------- Web bug link on a Web page ----------------#
      <img src="http://gnosis.cx/cgi-bin/visitor.cgi">

  The script itself is:
  此脚本本身:

      #---------------------- visitor.cgi ----------------------#
      #!/usr/bin/python
      import os
      from sys import stdout
      addr = os.environ.get("REMOTE_ADDR","Unknown IP Address")
      agent = os.environ.get("HTTP_USER_AGENT","No Known Browser")
      fp = open('visitor.log','a')
      fp.write('%s\t%s\n' % (addr, agent))
      fp.close()
      stdout.write("Content-type: image/gif\n\n")
      stdout.write('GIF89a\001\000\001\000\370\000\000\000\000\000')
      stdout.write('\000\000\000!\371\004\001\000\000\000\000,\000')
      stdout.write('\000\000\000\001\000\001\000\000\002\002D\001\000;')

  CLASSES:
  类:

  The point where the [cgi] module becomes useful is in
  automating form processing.  The class `cgi.FieldStorage` will
  determine the details of whether a POST or GET request was
  made, and decode the urlencoded query into a dictionary-like
  object.  You could perform these checks manually, but [cgi]
  makes it much easier to do.
  [cgi]在自动表单处理的时候变得很有用. 类`cgi.FieldStorage`会决定
  是POST还是GET请求, 将url编码的查询解码为类似字典的对象.
  你可以手工执行此类检查, 但[cgi]使此类工作更加简单.

  cgi.FieldStorage([fp=sys.stdin [,headers [,ob [,environ=os.environ
    -?                            [,keep_blank_values=0
    -?                             [,strict_parsing=0]]]]]])
      Construct a mapping object containing query information.
      You will almost always use the default arguments and
      construct a standard instance.  A `cgi.FieldStorage` object
      allows you to use name indexing and also supports several
      custom methods.  On initialization, the object will
      determine all relevant details of the current CGI
      invocation.
      构造一个匹配对象, 内含查询信息. 你总会使用默认的参数来构造一个
      标准实例. `cgi.FieldStorage`对象允许你使用名字索引, 另外还支持
      若干个自定义方法. 在初始化时候, 此对象会确定当前调用CGI的所有
      相关细节.
      

      #*--------------- Using cgi.FieldStorage -----------------#
      #*--------------- 使用cgi.FieldStorage -----------------#
      import cgi
      query = cgi.FieldStorage()
      eggs = query.getvalue('eggs','default_eggs')
      numfields = len(query)
      if query.has_key('spam'):
          spam = query['spam']
      [...]

      When you retrieve a `cgi.FieldStorage` value by named
      indexing, what you get is not a string, but either an
      instance of `cgi.FieldStorage` objects (or maybe
      `cgi.MiniFieldStorage') or a list of such objects.  The
      string query is in their '.value' attribute. Since HTML
      forms may contain multiple fields with the same name,
      multiple values might exist for a key--a list of such
      values is returned. The safe way to read the actual
      strings in queries is to check whether a list is returned:
      当你通过名字索引来获取`cgi.FieldStorage`值时, 你得到的
      并非字符串, 而是`cgi.FieldStorage`
      (或许是`cgi.MiniFieldStorage`)对象的一个实例, 要不然就是
      包含此类对象的一个列表. 字符串查询位于它们的'.value'属性中.
      因为HTML表单中可能包含多个相同名字的域, 对于同一个
      键来说, 可能存在多个值--返回的是一个列表, 其中是这样的值.
      一个读取查询中实际字符串的安全方法是, 检查返回的是否列表:

      #*-------- Checking the type of a query value ------------#
      #*-------- 检查查询值的类型 ------------#
      if type(eggs) is type([]):  # several eggs
          for egg in eggs:
              print "<dt>Egg</dt>\n<dd>", egg.value, "</dd>"
      else:
          print "<dt>Eggs</dt>\n<dd>", eggs.value, "</dd>"

      For special circumstances you might wish to change the
      initialization of the instance by specifying an optional
      (named) argument.  The argument 'fp' specifies the input
      stream to read for POST requests.  The argument 'headers'
      contains a dictionary mapping HTTP headers to
      values--usually consisting of '{"Content-Type":...}'; the
      type is determined from the environment if no argument is
      given.  The argument 'environ' specified where the
      environment mapping is found.  If you specify a true value
      for 'keep_blank_values', a key will be included for a blank
      HTML form field--mapping to an empty string.  If
      'string_parsing' is specified, a 'ValueError' will be
      raised if there are any flaws in the query string.
      在特殊情况下, 你可能希望修改实例的初始化, 指定可选的
      (命名的)参数. 参数'fp'指定读取POST请求的输入流. 参数
      'headers'包含了一个字典, 将HTTP头匹配到值--通常包含
      '{"Content-Type":...}';如果没有指定的话, 类型由环境来决定.
      参数'environ'指定了何处去寻找环境匹配. 如果你指定
      'keep_blank_values'为true值, 会包含一个键, 用于空白的
      HTML表单域--就是说, 匹配到空白字符串. 如果指定
      'string_parsing', 如果在查询字符串中有任何瑕疵, 
      会引发'ValueError'.

  METHODS:
  方法:

  The methods '.keys()', '.values()', and '.has_key()' work as with
  a standard dictionary object. The method '.items()', however, is
  not supported.
  方法'.keys()', '.values()', 以及 '.has_key()' 工作方式和标准字典对象一样.
  但是不支持方法'.items()'.

  cgi.FieldStorage.getfirst(key [,default=None])
      Python 2.2+ has this method to return exactly one string
      corresponding to the key 'key'.  You cannot rely on which
      such string value will be returned if multiple submitting
      HTML form fields have the same name--but you are assured of
      this method returning a string, not a list.
      Python 2.2+拥有此方法, 返回对应键'key'的完整的字符串. 
      如果多个提交的表单域拥有相同的名字, 你不能指望返回的字符串靠得住
      --你能确定的是, 这个方法返回的是字符串, 而不是列表.

  cgi.FieldStorage.getlist(key [,default=None])
      Python 2.2+ has this method to return a list of strings
      whether there are one or several matches on the key 'key'.
      This allows you to loop over returned values without
      worrying about whether they are a list or a single string.
      Python 2.2+ 拥有此方法, 返回一个字符串列表, 不管键'key'
      匹配到一个还是多个字符串. 这将允许你循环操作返回值, 
      而不需要担心它是列表还是单个字符串.

      >>> spam = form.getlist('spam')
      >>> for s in spam:
      ...     print s

  cgi.FieldStorage.getvalue(key [,default=None])
      Return a string or list of strings that are the value(s)
      corresponding to the key 'key'.  If the argument 'default'
      is specified, return the specified value in case of key
      miss.  In contrast to indexing by name, this method
      retrieves actual strings rather than storage objects with a
      '.value' attribute.
      返回字符串或者字符串列表, 它(们)是键'key'对应的值. 
      如果指定了参数'default', 且键缺失的话, 返回指定的值.
      与名字索引不同的是, 此方法取回实际的字符串, 而非
      拥有'.value'属性的存储对象.

      >>> import sys, cgi, os
      >>> from cStringIO import StringIO
      >>> sys.stdin = StringIO("this=that&this=other&spam=good+eggs")
      >>> os.environ['REQUEST_METHOD'] = 'POST'
      >>> form = cgi.FieldStorage()
      >>> form.getvalue('this')
      ['that', 'other']
      >>> form['this']
      [MiniFieldStorage('this','that'),MiniFieldStorage('this','other')]

  ATTRIBUTES:
  属性:

  cgi.FieldStorage.file
      If the object handled is an uploaded file, this attribute
      gives the file handle for the file.  While you can read the
      entire file contents as a string from the
      'cgi.FieldStorage.value' attribute, you may want to read it
      line-by-line instead.  To do this, use the '.readline()' or
      '.readlines()' method of the file object.
      如果处理的对象是个上传的文件, 此属性给出文件的句柄.
      你可以把整个文件内容以字符串形式从'cgi.FieldStorage.value'
      属性中读出, 但你也可以一行接一行的读入, 只要使用文件对象
      的'.readline()' 或者 '.readlines()'方法.

  cgi.FieldStorage.filename
      If the object handled is an uploaded file, this attribute
      contains the name of the file.  An HTML form to upload a
      file looks something like:
      如果处理的对象是个上传的文件,此属性给出文件的名字. 
      上传文件的HTML表单看起来好像这样:

      #*----------- File upload from HTML form -----------------#
      #*----------- 用HTML表单来上传文件 -----------------#
      <form action="upload.cgi" method="POST"
            enctype="multipart/form-data">
        Name: <input name="" type="file" size="50">
        <input type="submit" value="Upload">
      </form>

      Web browsers typically provide a point-and-click method to
      fill in a file-upload form.
      网络浏览器通常提供"指点"的方法来输入文件上传表单.

  cgi.FieldStorage.list
      This attribute contains the list of mapping object within a
      `cgi.FieldStorage` object.  Typically, each object in the
      list is itself a `cgi.MiniStorage` object instead (but this
      can be complicated if you upload files that themselves
      contain multiple parts).
      此属性包含了一个列表, 包含了`cgi.FieldStorage`对象中的
      匹配对象. 通常来说, 此列表中的每个对象本身就是一个
      `cgi.MiniStorage`(但是如果你上传的文件本身包含多个块, 
      这个就复杂了).

      >>> form.list
      [MiniFieldStorage('this', 'that'),
      MiniFieldStorage('this', 'other'),
      MiniFieldStorage('spam', 'good eggs')]

      SEE ALSO, `cgi.FieldStorage.getvalue()`
      参见`cgi.FieldStorage.getvalue()`

  cgi.FieldStorage.value
  cgi.MiniFieldStorage.value
      The string value of a storage object.
      存储对象的字符串值.

  SEE ALSO, [urllib], [cgitb], [dict]
  参见[urllib], [cgitb], [dict]

  =================================================================
    MODULE -- cgitb : Traceback manager for CGI scripts
    模块 -- cgitb : CGI脚本的traceback管理器
  =================================================================

  Python 2.2 added a useful little module for debugging CGI
  applications.  You can download it for earlier Python versions
  from <http://lfw.org/python/cgitb.py>.  A basic difficulty with
  developing CGI scripts is that their normal output is sent to
  STDOUT, which is caught by the underlying Web server and
  forwarded to an invoking Web browser.  However, when a
  traceback occurs due to a script error, that output is sent to
  STDERR (which is hard to get at in a CGI context).  A more
  useful action is either to log errors to server storage or
  display them in the client browser.
  Python 2.2 为CGI程序的出错增加了一个有用的小模块. 如果你用的是
  老版本的Python, 可以从<http://lfw.org/python/cgitb.py>下载.
  开发CGI脚本的一个基本麻烦是, 它通常的输出是STDOUT, 被下面的
  Web服务器捕获, 并发送到调用的浏览器中. 但是, 当脚本错误引发
  traceback时, 输出被送到STDERR(在CGI语境中, 这个很难获取).
  一个更有用的动作是, 要么将错误记录到服务器上, 要么在客户端浏览器
  中显示.

  Using the [cgitb] module to examine CGI script errors is almost
  embarrassingly simple.  At the top of your CGI script, simply
  include the lines:
  使用[cgitb]模块来检查CGI脚本的错误, 简单得让人尴尬. 
  在CGI脚本的开始, 只要包含这些行:

      #------------- Traceback enabled CGI script --------------#
      import cgitb
      cgitb.enable()

  If any exceptions are raised, a pretty, formatted report is
  produced (and possibly logged to a name starting with '@').
  如果引发了任何异常, 一个漂亮而又格式化后的报告就产生了
  (可能记录在以'@'开始的名字后面).

  METHODS:
  方法:

  cgitb.enable([display=1 [,logdir=None [context=5]]])
      Turn on traceback reporting.  The argument 'display'
      controls whether an error report is sent to the
      browser--you might not want this to happen in a production
      environment, since users will have little idea what to
      make of such a report (and there may be security issues in
      letting them see it).  If 'logdir' is specified, tracebacks
      are logged into files in that directory.  The argument
      'context' indicates how many lines of code are displayed
      surrounding the point where an error occurred.
      打开traceback报告. 参数'display'控制错误报告是否送到浏览器
      --在产品环境中, 你可能不想怎么做, 因为用户对于此类报告的愿意
      毫不知情(另外让他们看到这些可能有安全隐患). 如果指定了'logdir',
      trackback记录于该文件夹中的文件中. 参数'context'表明错误发生点
      前后的多少行会被显示出来.

  For earlier versions of Python, you will have to do your own
  error catching.  A simple approach is:
  对于Python的早期版本, 你必须自己捕捉错误. 一个简单的方法就是:

      #---------- Debugging CGI script in Python -------------#
      #---------- 在 Python 中进行CGI脚本除错 -------------#
      import sys
      sys.stderr = sys.stdout
      def main():
          import cgi
          # ...do the actual work of the CGI...
          # perhaps ending with:
          print template % script_dictionary
      print "Content-type: text/html\n\n"
      main()

  This approach is not bad for quick debugging; errors go back to
  the browser. Unfortunately, though, the traceback (if one occurs)
  gets displayed as HTML, which means that you need to go to "View
  Source" in a browser to see the original line breaks in the
  traceback. With a few more lines, we can add a little extra
  sophistication.
  对于快速除错而言, 此方法并不坏; 错误返回到浏览器. 但是不幸的是,
  traceback(如果发生的话)是作为HTML显示的, 也就意味者你必须在
  浏览器中"View Source (查看源代码)", 才能看见traceback中原始的换行.
  只要再多几行代码, 我们可以让其更加耐用.

      #------- Debugging/logging CGI script in Python --------#
      import sys, traceback
      print "Content-type: text/html\n\n"
      try:               # use explicit exception handling
          import my_cgi  # main CGI functionality in 'my_cgi.py'
          my_cgi.main()
      except:
          import time
          errtime = '--- '+ time.ctime(time.time()) +' ---\n'
          errlog = open('cgi_errlog', 'a')
          errlog.write(errtime)
          traceback.print_exc(None, errlog)
          print "<html>\n<head>"
          print "<title>CGI Error Encountered!</title>\n</head>"
          print "<body><p>A problem was encountered running MyCGI</p>"
          print "<p>Please check the server error log for details</p>"
          print "</body></html>"

  The second approach is quite generic as a wrapper for any real
  CGI functionality we might write.  Just 'import' a different
  CGI module as needed, and maybe make the error messages more
  detailed or friendlier.
  第二个方法比较通用, 就是给我们写的CGI函数加上一个包装. 只需'import'
  CGI模块, 还可以让错误信息更加详细或者更加友好一点.

  SEE ALSO, [cgi]
  参见 [cgi]


  TOPIC -- Parsing, Creating, and Manipulating HTML Documents
  主题 -- 解析, 创建, 以及操作HTML文档
  --------------------------------------------------------------------

  =================================================================
    MODULE -- htmlentitydefs : HTML character entity references
    模块 -- htmlentitydefs :      HTML字符实体参考
  =================================================================

  The module [htmlentitydefs] provides a mapping between
  ISO-8859-1 characters and the symbolic names of corresponding
  HTML 2.0 entity references.  Not all HTML named entities have
  equivalents in the ISO-8859-1 character set; in such cases,
  names are mapped the HTML numeric references instead.
  模块[htmlentitydefs]提供了ISO-8859-1和对应HTML 2.0实体参考
  的符号名字之间的配对. 并未所有HTML命名实体拥有对应的ISO-8859-1
  字符; 在此情况中, 名字被匹配为HTML数字参考.

  ATTRIBUTES:
  属性:

  htmlentitydefs.entitydefs
      A dictionary mapping symbolic names to character entities.
      字典, 将符号名字匹配到字符实体.

      >>> import htmlentitydefs
      >>> htmlentitydefs.entitydefs['omega']
      '&#969;'
      >>> htmlentitydefs.entitydefs['uuml']
      '\xfc'

  For some purposes, you might want a reverse dictionary to find
  the HTML entities for ISO-8859-1 characters.
  处于某些目的, 你也许想要调转字典来寻找ISO-8859-1字符的
  HTML实体.

      >>> from htmlentitydefs import entitydefs
      >>> iso8859_1 = dict([(v,k) for k,v in entitydefs.items()])
      >>> iso8859_1['\xfc']
      'uuml'

  =================================================================
    MODULE -- HTMLParser : Simple HTML and XHTML parser
    模块 -- HTMLParser : 简单的HTML和XHMTL解析器
  =================================================================

  The module [HTMLParser] is an event-based framework for
  processing HTML files. In contrast to [htmllib], which is based
  on [sgmllib], [HTMLParser] simply uses some regular expressions
  to identify the parts of an HTML document--starttag, text,
  endtag, comment, and so on. The different internal
  implementation, however, makes little difference to users of the
  modules.
  [HTMLParser]模块是一个基于时间的框架, 用于处理HTML文件. 
  与[htmllib]不同的是, 后者是基于 [sgmllib]的, 而前者只是使用正则表达式
  来识别HTML文档的各部分--开始标签, 文本, 结束标签, 注释, 等等.
  但是内部实现的不同, 对于模块使用者来说, 并未有太多不同.

  I find the module [HTMLParser] much more straightforward to use
  than [htmllib], and therefore [HTMLParser] is documented in
  detail in this book, while [htmllib] is not. While [htmllib] more
  or less -requires- the use of the ancillary module [formatter] to
  operate, there is no extra difficultly in letting [HTMLParser]
  make calls to a formatter object. You might want to do this, for
  example, if you have an existing formatter/writer for a complex
  document format.
  我发现[HTMLParser]模块比[htmllib]使用起来更直观, 因此此书中
  关于[HTMLParser]有更多细节, 而[htmllib]就没有. [htmllib]或多或少
  -要求-使用辅助模块[formatter]来进行操作, 而[HTMLParser]调用
  formatter对象的难度也不会更大. 例如, 如果你已有一个复杂文档格式的
  formatter/writer, 你也许想这样做.
  
  Both [HTMLParser] and [htmllib] provide an interface that is
  very similar to that of 'SAX' or 'expat' XML parsers.  That is,
  a document--HTML or XML--is processed purely as a sequence of
  events, with no data structure created to represent the
  document as a whole.  For XML documents, another processing API
  is the Document Object Model (DOM), which treats the document as
  an in-memory hierarchical data structure.
  [HTMLParser]和[htmllib]都提供了和 'SAX' 或 'expat' XML解析器相同的
  界面. 也就是说, 文档--HTML或XML格式--是作为一个纯粹的事件流来处理,
  并未创建任何数据结构来表示整个文档. 对于XML文档, 另一个处理API是
  文档对象模型(DOM), 它将文档作为内存中的分层数据结构处理.

  In principle, you could use [xml.sax] or [xml.dom] to process
  HTML documents that conformed with XHTML--that is, tightened up
  HTML that is actually an XML application The problem is that very
  little existing HTML is XHTML compliant. A syntactic issue is
  that HTML does not require closing tags in many cases, where
  XML/XHTML requires every tag to be closed. But implicit closing
  tags can be inferred from subsequent opening tags (e.g., with
  certain names). A popular tool like 'tidy' does an excellent job
  of cleaning up HTML in this way. The more significant problem is
  semantic. A whole lot of actually existing HTML is quite lax
  about tag matching--Web browsers that successfully display the
  majority of Web pages are quite complex software projects.
  理论上, 你可以用 [xml.sax] 或 [xml.dom]来处理符合XHTML的HTML文档--
  也就是说, 加强的HTML实际上是个XML的应用. 问题在于, 现有的HTML很少
  是兼容XHTML的. 一个句法上的问题是, HTML在很多情况下不要求有结束标签,
  而XML/XHTML则要求关闭每个标签. 但是后续的开始标签(例如某些名字的开始标签)
  可以用来提示结束标签. 如'tidy'这样的流行工具以这种方式清理HTML, 效果很好.
  另一个更显著的问题是语意. 许多现存HTML对于标签匹配非常宽松--能够
  成功显示大部分网页的浏览器是非常复杂的软件工程.

  For example, a snippet like that below is quite likely to occur
  in HTML you come across:
  例如你可能经常遇到类似下面的代码片断:

      #*------------- Snippet of oddly nested HTML -------------#
      <p>The <a href="http://ietf.org">IETF admonishes:
         <i>Be lenient in what you <b>accept</i></a>.</b>

  If you know even a little HTML, you know that the author of this
  snippet presumably wanted the whole quote in italics, the word
  'accept' in bold. But converting the snippet into a data
  structure such as a DOM object is difficult to generalize.
  Fortunately, [HTMLParser] is fairly lenient about what it will
  process; however, for sufficiently badly formed input (or any
  other problem), the module will raise the exception
  'HTMLParser.HTMLParseError'.
  如果你了解一点HTML, 你知道这段代码的作者想要整段引文都使用斜体字,
  而单词'accept'是粗体. 但是将此片段转换成数据结构, 例如DOM对象, 
  是很难概括的. 幸运的是, [HTMLParser]对于它要处理的内容比较宽大;
  尽管如此, 对于组织很坏的输入(或者其他问题), 此模块会引发
  'HTMLParser.HTMLParseError'异常.

  SEE ALSO, `htmllib`, `xml.sax`
  参见 `htmllib`, `xml.sax`

  CLASSES:
  类:

  HTMLParser.HTMLParser()
      The [HTMLParser] module contains the single class
      `HTMLParser.HTMLParser`.  The class itself is fairly useful,
      since it does not actually do anything when it encounters
      any event.  Utilizing `HTMLParser.HTMLParser()` is a matter
      of subclassing it and providing methods to handle the events
      you are interested in.
      [HTMLParser]模块包含一个类`HTMLParser.HTMLParser`.
      此类本身相当有用, 因为它不管遇到任何事件, 都啥事不做. 使用
      `HTMLParser.HTMLParser`主要是建立子类, 并提供方法来处理
      你感兴趣的事件.

      If it is important to keep track the structural position
      of the current event within the document, you will need to
      maintain a data structure with this information.  If you are
      certain that the document you are processing is well-formed
      XHTML, a stack suffices.  For example:
      如果跟踪当前事件在文档中的结构位置是比较重要的, 那你需要
      维护数据结构来保存此信息. 如果你确信你处理的文档是结构良好的
      XHTML, 一个堆栈就足够了. 例如:

      #------------------ HTMLParser_stack.py ------------------#
      #!/usr/bin/env python
      import HTMLParser
      html = """<html><head><title>Advice</title></head><body>
      <p>The <a href="http://ietf.org">IETF admonishes:
         <i>Be strict in what you <b>send</b>.</i></a></p>
      </body></html>
      """
      tagstack = []
      class ShowStructure(HTMLParser.HTMLParser):
          def handle_starttag(self, tag, attrs): tagstack.append(tag)
          def handle_endtag(self, tag): tagstack.pop()
          def handle_data(self, data):
              if data.strip():
                  for tag in tagstack: sys.stdout.write('/'+tag)
                  sys.stdout.write(' >> %s\n' % data[:40].strip())
      ShowStructure().feed(html)

      Running this optimistic parser produces:
      运行此解析器会产生:

      #*--------------- HTMLParser_stack output ----------------#
      % ./HTMLParser_stack.py
      /html/head/title >> Advice
      /html/body/p >> The
      /html/body/p/a >> IETF admonishes:
      /html/body/p/a/i >> Be strict in what you
      /html/body/p/a/i/b >> send
      /html/body/p/a/i >> .

      You could, of course, use this context information however
      you wished when processing a particular bit of content (or
      when you process the tags themselves).
      你当然可以使用上下文信息, 但是当处理内容的特定位置(或者处理
      标签本身)时, 那就不可能了.

      A more pessimistic approach is to maintain a "fuzzy"
      tagstack.  We can define a new object that will remove the
      most recent starttag corresponding to an endtag and will
      also prevent '<p>' and '<blockquote>' tags from nesting if
      no corresponding endtag is found.  You could do more along
      this line for a production application, but a class like
      'TagStack' makes a good start:
      另一个比较悲观的方法是, 维护一个"模糊"标签堆栈. 我们可以定义
      一个新的对象, 它移除对应结束标签的那个最新开始标签,  还防止
      嵌套'<p>' 和 '<blockquote>'标签, 如果没有找到对应的结束标签.
      如果要做一个产品程序, 从这条线上出发可以做很多事情, 但至少,
      类似'标签堆栈'的类是个不错的开始:

      #*--------------- TagStack class example -----------------#
      class TagStack:
          def __init__(self, lst=[]): self.lst = lst
          def __getitem__(self, pos): return self.lst[pos]
          def append(self, tag):
              # Remove every paragraph-level tag if this is one
              if tag.lower() in ('p','blockquote'):
                  self.lst = [t for t in self.lst
                                if t not in ('p','blockquote')]
              self.lst.append(tag)
          def pop(self, tag):
              # "Pop" by tag from nearest pos, not only last item
              self.lst.reverse()
              try:
                  pos = self.lst.index(tag)
              except ValueError:
                  raise HTMLParser.HTMLParseError, "Tag not on stack"
              del self.lst[pos]
              self.lst.reverse()
      tagstack = TagStack()

      This more lenient stack structure suffices to parse badly
      formatted HTML like the example given in the module
      discussion.
      这个堆栈结构更加宽松, 这样可以解析模块讨论中给出的那个格式
      不好的HTML了.

  METHODS AND ATTRIBUTES:
  方法和属性:

  HTMLParser.HTMLParser.close()
      Close all buffered data, and treat any current data as if
      an EOF was encountered.
      关闭所有缓冲的数据, 处理当前所有数据时, 就如同遇到EOF一样. 

  HTMLParser.HTMLParser.feed(data)
      Send some additional HTML data to the parser instance, from
      the string in the argument 'data'.  You may feed the
      instance with whatever size chunks of data you wish, and
      each will be processed, maintaining the previous state.
      从参数'data'的字符串中, 发送一些额外的HTML数据到解析器实例中.
      你可以用任意尺寸的数据块来喂给实例, 每个都会被处理, 
      保持前面一个状态.

  HTMLParser.HTMLParser.getpos()
      Return the current line number and offset.  Generally
      called within a '.handle_*()' method to report or analyze
      the state of the processing of the HTML text.
      返回当前行号和位移. 通常在'.handle_*()'方法中调用, 以报告
      或者分析HTML文本处理的状态.

  HTMLParser.HTMLParser.handle_charref(name)
      Method called when a character reference is encountered,
      such as '&#971;'.  Character references may be interspersed
      with element text, much as with entity references.  You can
      construct a Unicode character from a character reference,
      and you may want to pass the Unicode (or raw character
      reference) to `HTMLParser.HTMLParser.handle_data()`.
      当遇到字符参考时候, 例如'&#971;', 调用此方法. 字符参考可能和
      基础文本散布在一起, 特别是实体参考. 你可以从字符参考
      构建一个Unicode字符, 你还能将Unicode(或者原始字符参考)
      传递给`HTMLParser.HTMLParser.handle_data()`.

      #*-------------- Call back to .handle_data() -------------#
      class CharacterData(HTMLParser.HTMLParser):
          def handle_charref(self, name):
              import unicodedata
              char = unicodedata.name(unichr(int(name)))
              self.handle_data(char)
          [...other methods...]

  HTMLParser.HTMLParser.handle_comment(data)
      Method called when a comment is encountered.  HTML comments
      begin with '<!--' and end with '-->'.  The argument 'data'
      contains the contents of the comment.
      当遇到注释时, 调用此方法. HTML注释以'<!--'开始, 以'-->'结束.
      参数'data'包含了注释的内容.

  HTMLParser.HTMLParser.handle_data(data)
      Method called when content data is encountered.  All the
      text between tags is contained in the argument 'data', but
      if character or entity references are interspersed with
      text, the respective handler methods will be called in an
      interspersed fashion.
      当遇到内容数据时, 调用此函数. 所有标签之间的文本都包含于
      参数'data'中, 但如果字符或者实体参考散布于文本中, 会以散布地
      方式调用个别的句柄方法.

  HTMLParser.HTMLParser.handle_decl(data)
      Method called when a declaration is encountered.  HTML
      declarations with '<!' and end with '>'.  The argument
      'data' contains the contents of the comment. Syntactically,
      comments look like a type of declaration, but are handled by
      the `HTMLParser.HTMLParser.handle_comment()` method.
      当遇到声明时, 调用此方法. HTML声明以'<!'开始, 以'>'结束.
      参数'data'包含了声明的内容. 在语句构造上, 注释看起来像
      某种类型的声明, 但是以`HTMLParser.HTMLParser.handle_comment()`
      方法来处理.
## 疑似原文错误

  HTMLParser.HTMLParser.handle_endtag(tag)
      Method called when an endtag is encountered.  The argument
      'tag' contains the tag name (without brackets).
      当遇到结束标签时候, 调用此方法. 参数'tag'包含了标签名字(没有尖括号).

  HTMLParser.HTMLParser.handle_entityref(name)
      Method called when an entity reference is encountered, such
      as '&amp;'.  When entity references occur in the middle of
      an element text, calls to this method are interspersed with
      calls to `HTMLParser.HTMLParser.handle_data()`.  In many
      cases, you will want to call the latter method with decoded
      entities; for example:
      当遇到实体参考时, 例如'&amp;', 调用此方法. 当实体参考出现在
      基础文本的中间时, 对此函数和`HTMLParser.HTMLParser.handle_data()`
      的调用交错进行. 在很多情况中, 你会想要用解码后的实体来调用后者;
      例如:

      #*-------------- Call back to .handle_data() -------------#
      class EntityData(HTMLParser.HTMLParser):
          def handle_entityref(self, name):
              import htmlentitydefs
              self.handle_data(htmlentitydefs.entitydefs[name])
          [...other methods...]

  HTMLParser.HTMLParser.handle_pi(data)
      Method called when a processing instruction (PI) is
      encountered. PIs begin with '<?' and end with '?>'.  They
      are less common in HTML than in XML, but are allowed.  The
      argument 'data' contains the contents of the PI.
      当遇到处理指示(PI)的时候, 调用此方法. PI以 '<?'开始, 以'?>'
      结束. 它们在HTML没有在XML中常见, 但也是允许的. 
      参数'data'包含了PI的内容.

  HTMLParser.HTMLParser.handle_startendtag(tag, attrs)
      Method called when an XHTML-style empty tag is
      encountered, such as:
      当遇到XHTML风格的空白标签时, 调用此方法, 例如:

      #*----------------- Closed empty tag ---------------------#
      <img src="foo.png" alt="foo"/>

      The arguments 'tag' and 'attrs' are identical to those
      passed to `HTMLParser.HTMLParser.handle_starttag()`.
      参数'tag' 和 'attrs'和传送给`HTMLParser.HTMLParser.handle_starttag()`
      的一样.

  HTMLParser.HTMLParser.handle_starttag(tag, attrs)
      Method called when a starttag is encountered.  The argument
      'tag' contains the tag name (without brackets), and the
      argument 'attrs' contains the tag attributes as a list of
      pairs, such as '[("href","http://ietf.org")]'.
      当遇到开始标签时候, 调用此标签. 参数'tag'包含了标签名字(不含尖括号),
      而参数'attrs'以成对列表的形式包含了这些标签, 例如'[("href","http://ietf.org")]'.

  HTMLParser.HTMLParser.lasttag
      The last tag--start or end--that was encountered.
      Generally maintaining some sort of stack structure like
      those discussed is more useful.  But this attribute is
      available automatically.  You should treat it as read-only.
      遇到的最后一个--开始或者结束--标签. 和刚才讨论的一样, 
      通常维护某种堆栈结构更有用处. 但此属性是自动提供的.
      你应该将其作为只读处理.

  HTMLParser.HTMLParser.reset()
      Restore the instance to its initial state, lose any
      unprocessed data (for example, content within unclosed
      tags).
      将实例恢复到初始值, 丢弃任何未处理的数据(例如, 没有关闭的标签
      之间的内容)


  TOPIC -- Accessing Internet Resources
  主题 -- 存取互联网资源
  --------------------------------------------------------------------

  =================================================================
    MODULE -- urllib : Open an arbitrary URL
    模块 -- urllib : 打开任意RUL
  =================================================================

  The module [urllib] provides convenient, high-level access to
  resources on the Internet. While [urllib] lets you connect to a
  variety of protocols, to manage low-level details of
  connections--especially issues of complex authentication--you
  should use the module [urllib2] instead. However, [urllib] -does-
  provide hooks for HTTP basic authentication.
  [urllib]模块提供了简便而高层的方式来存取互联网上的资源. 
  [urllib]让你使用许多协议来连接, 但是想要管理连接的底层细节--特别是复杂的授权问题--
  你应该使用[urllib2]. 但是, [urllib]-确实-提供了钩子以进行HTTP基本授权.

  The interface to [urllib] objects is file-like. You can
  substitute an object representing a URL connection for almost any
  function or class that expects to work with a read-only file. All
  of the World Wide Web, File Transfer Protocol (FTP) directories,
  and gopherspace can be treated, almost transparently, as if it
  were part of your local filesystem.
  [urllib]对象的接口和文件类似. 你可以将表示URL连接的对象替换为
  任何函数或类, 只要它们预期能和只读文件一起工作.
  所有的万维网, FTP目录, Gopher 空间可以当作透明的处理, 就好像
  它们是位于你的本地文件系统中.

  Although the module provides two classes that can be utilized or
  subclassed for more fine-tuned control, generally in practice the
  function `urllib.urlopen()` is the only interface you need to the
  [urllib] module.
  尽管此模块提供了两个类以使用或者衍生子类, 获取更多微调控制, 
  但在实际运用中, 函数`urllib.urlopen()`是你唯一需要的[urllib]模块
  接口.

  FUNCTIONS:
  函数:

  urllib.urlopen(url [,data])
      Return a file-like object that connects to the Uniform
      Resource Locator (URL) resource named in 'url'.  This
      resource may be an HTTP, FTP, Gopher, or local file.  The
      optional argument 'data' can be specified to make a POST
      request to an HTTP URL.  This data is a urlencoded string,
      which may be created by the `urllib.urlencode()` method.
      If no 'postdata' is specified with an HTTP URL, the GET
      method is used.
      返回一个类文件对象, 它连接到统一资源定位器(URL)资源, 
      后者名字在'url'中. 这个资源可以是HTTP, FTP, Gopher或者本地
      文件. 可选参数'data'可以用来指定发送POST请求到HTTP URL.
      这个数据是url编码的字符串, 可以用`urllib.urlencode()`方法来
      创建. 如果没有'postdata'指定为HTTP URL, 则使用GET方法.

      Depending on the type of resource specified, a slightly
      different class is used to construct the instance, but
      each provides the methods: '.read()', '.readline()',
      '.readlines()', '.fileno()', '.close()', '.info()' and
      '.geturl()' (but not '.xreadlines()', '.seek()', or
      '.tell()').
      根据指定资源的类别, 使用略微不同的类来构建实例, 但
      它们都提供了一下方法: '.read()', '.readline()',
      '.readlines()', '.fileno()', '.close()', '.info()' 和
      '.geturl()' (但没有'.xreadlines()', '.seek()', 或
      '.tell()').

      Most of the provided methods are shared by file objects,
      and each provides the same interface--arguments and return
      values--as actual file objects.  The method '.geturl()'
      simply contains the URL that the object connects to,
      usually the same string as the 'url' argument.
      绝大部分提供的方法在文件对象中也有, 而且每个都是一样的接口--
      参数和返回值--即和实际的文件对象一样. 方法'.geturl()'只是包含了
      连接到的对象的URL, 通常是和'url'参数一样的字符串.

      The method '.info()' returns `mimetools.Message` object.
      While the [mimetools] module is not documented in detail in
      this book, this object is generally similar to an
      `email.Message.Message` object--specifically, it responds
      to both the built-in `str()` function and dictionary-like
      indexing:
      方法'.info()'返回`mimetools.Message`对象. 在本书中对于
      [mimetools]并未着墨太多, 它通常和`email.Message.Message`
      对象类似--特别是, 它对内建`str()`函数和字典式索引给出反应:

      >>> u = urllib.urlopen('urlopen.py')
      >>> print `u.info()`
      <mimetools.Message instance at 0x62f800>
      >>> print u.info()
      Content-Type: text/x-python
      Content-Length: 577
      Last-modified: Fri, 10 Aug 2001 06:03:04 GMT

      >>> u.info().keys()
      ['last-modified', 'content-length', 'content-type']
      >>> u.info()['content-type']
      'text/x-python'

      SEE ALSO, `urllib.urlretrieve()`, `urllib.urlencode()`
      参见 `urllib.urlretrieve()`, `urllib.urlencode()`

  urllib.urlretrieve(url [,fname [,reporthook [,data]]])
      Save the resources named in the argument 'url' to a local
      file.  If the optional argument 'fname' is specified, that
      filename will be used; otherwise, a unique temporary
      filename is generated.  The optional argument 'data' may
      contain a urlencoded string to pass to an HTTP POST
      request, as with `urllib.urlopen()`.
      将参数'url'中的资源保存到本地文件中. 如果指定了可选参数'fname',
      则使用该文件名; 否则产生一个独一无二的临时文件名. 可选参数
      'data'可能包含url编码的字符串, 以传递给HTTP POST请求, 
      正如`urllib.urlopen()`中的一样.

      The optional argument 'reporthook' may be used to specify a
      callback function, typically to implement a progress meter
      for downloads.  The function 'reporthook()' will be called
      repeatedly with the arguments 'bl_transferred', 'bl_size',
      and 'file_size'.  Even remote files smaller than the block
      size will typically call 'reporthook()' a few times, but
      for larger files, 'file_size' will -approximately- equal
      'bl_transferred*bl_size'.
      可选参数 'reporthook'可用于指定callback函数, 典型做法是实现
      下载的进度条. 'reporthook()'函数会被用参数'bl_transferred', 'bl_size',
       和 'file_size'重复调用. 即使远程文件比块尺寸(block size)小, 通常
       也会调用'reporthook()'若干次, 但是对于大一些文件, 'file_size'
       将-约-等于'bl_transferred*bl_size'.

      The return value of `urllib.urlretrieve()` is a pair
      '(fname,info)'.  The returned 'fname' is the name of the
      created file--the same as the 'fname' argument if it was
      specified.  The 'info' return value is a `mimetools.Message`
      object, like that returned by the '.info()' method of a
      `urllib.urlopen` object.
      返回值`urllib.urlretrieve()`是一对'(fname,info)'. 返回的'fname'
      是创建文件的名字--和'fname'参数一样, 如果指定后者的话.
      'info'返回值是一个`mimetools.Message`对象, 正如
      `urllib.urlopen`对象的'.info()'方法返回的值.

      SEE ALSO, `urllib.urlopen()`, `urllib.urlencode()`
      参见 `urllib.urlopen()`, `urllib.urlencode()`

  urllib.quote(s [,safe="/"])
      Return a string with special characters escaped.  Exclude
      any characters in the string 'safe' for being quoted.
      返回一个字符串, 其中特殊字符已经转义过. 而字符串'safe'中的
      所有字符都不会转义.

      >>> urllib.quote('/~username/special&odd!')
      '/%7Eusername/special%26odd%21'

  urllib.quote_plus(s [,safe="/"])
      Same as `urllib.quote()`, but encode spaces as '+' also.
      和`urllib.quote()`一样, 但是另外还将空格编码为'+'.

  urllib.unquote(s)
      Return an unquoted string.  Inverse operation of
      `urllib.quote()`.
      返回一个未注明的字符串. `urllib.quote()`的逆操作.

  urllib.unquote_plus(s)
      Return an unquoted string.  Inverse operation of
      `urllib.quote_plus()`.
      返回一个未注明的字符串. `urllib.quote_plus()`的逆操作.

  urllib.urlencode(query)
      Return a urlencoded query for an HTTP POST or GET request.
      The argument 'query' may be either a dictionary-like object
      or a sequence of pairs.  If pairs are used, their order is
      preserved in the generated query.
      返回HTTP POST或者GET请求的url编码请求. 参数'query'要么是
      类字典对象, 要么是对子序列(a sequence of pairs). 如果使用了
      对子, 产生请求中保留了它们的顺序.

      >>> query = urllib.urlencode([('hl','en'),
      ...                           ('q','Text Processing in Python')])
      >>> print query
      hl=en&q=Text+Processing+in+Python
      >>> u = urllib.urlopen('http://google.com/search?'+query)

      Notice, however, that at least as of the moment of this
      writing, Google will refuse to return results on this
      request because a Python shell is not a recognized browser
      (Google provides a SOAP interface that is more lenient,
      however).  You -could-, but -should not-, create a custom
      [urllib] class that spoofed an accepted browser.
      但是, 要注意的是, 至少在本书写作时, Google会拒绝对此请求返回结果,
      因为Python shell并非一个认可的浏览器(尽管Google提供了一个
      更加宽松的SOAP接口). 你-可以-, 但是-不应该-, 创建自定义[urllib]类
      来冒充可接受的浏览器.

  CLASSES:
  类:

  You can change the behavior of the basic `urllib.urlopen()` and
  `urllib.urlretrieve()` functions by substituting your own class
  into the module namespace.  Generally this is the best way to
  use [urllib] classes:
  你可以改变基本的`urllib.urlopen()` 和`urllib.urlretrieve()`函数的
  行为, 只要把模块名字空间的类替换为自己的类即刻. 通常这是
  使用[urllib]类的最好方法:

      #*------------ Opening URLs with a custom class ----------#
      import urllib
      class MyOpener(urllib.FancyURLopener):
          pass
      urllib._urlopener = MyOpener()
      u = urllib.urlopen("http://some.url")   # uses custom class

  urllib.URLopener([proxies [,**x509]])
      Base class for reading URLs.  Generally you should subclass
      from `urllib.FancyURLopener` unless you need to implement a
      nonstandard protocol from scratch.
      读入URL的基础类. 通常你应该从`urllib.FancyURLopener`衍生之类, 
      除非你要从头开始实现一个非标准的协议.

      The argument 'proxies' may be specified with a mapping if
      you need to connect to resources through a proxy.  The
      keyword arguments may be used to configure HTTPS
      authentication; specifically, you should give named
      arguments 'key_file' and 'cert_file' in this case.
      可以用一个匹配来指定参数'proxies', 如果你需要通过代理服务器来
      连接到资源. 关键词参数可以用来配置HTTPS授权; 特别地是,
      在此情况中, 你应该给出命名参数'key_file' 和 'cert_file'.

      #*-------- specifying proxies and authentication ---------#
      import urllib
      proxies = {'http':'http://192.168.1.1','ftp':'ftp://192.168.256.1'}
      urllib._urlopener = urllib.URLopener(proxies, key_file='mykey',
                                           cert_file='mycert')

  urllib.FancyURLopener([proxies [,**x509]])
      The optional initialization arguments are the same as for
      `urllib.URLopener`, unless you subclass further to use
      other arguments.  This class knows how to handle 301 and
      302 HTTP redirect codes, as well as 401 authentication
      requests.  The class `urllib.FancyURLopener` is the one
      actually used by the [urllib] module, but you may subclass
      it to add custom capabilities.
      可选初始化参数和`urllib.URLopener`中的一样, 除非你衍生子类以
      使用其他参数. 此类了解如何处理301和302HTTP重导向代码, 以及401
      授权请求. `urllib.FancyURLopener`类是[urllib]模块实际使用的类, 
      但你可以衍生子类以增加自定义能力.

  METHODS AND ATTRIBUTES:
  方法和属性:

  urllib.URLFancyopener.get_user_passwd(host, realm)
      Return the pair '(user,passwd)' to use for authentication.
      The default implementation calls the method
      '.prompt_user_passwd()' in turn.  In a subclass you might
      want to either provide a GUI login interface or obtain
      authentication information from some other source, such as
      a database.
      返回对子 '(user,passwd)' 用于授权目的. 默认实现接下来调用
      '.prompt_user_passwd()'方法. 在子类中, 你可能想要提供GUI
      登录界面或者或者从其他资源获取授权信息, 例如某数据库.

  urllib.URLopener.open(url [,data])
  urllib.URLFancyopener.open(url [,data])
      Open the URL 'url', optionally using HTTP POST query 'data'.
      打开URL'url', 可选使用HTTP POST请求'data'.

      SEE ALSO, `urllib.urlopen()`
      参见 `urllib.urlopen()`

  urllib.URLopener.open_unknown(url [,data])
  urllib.URLFancyopener.open_unknown(url [,data])
      If the scheme is not recognized, the '.open()' method
      passes the request to this method.  You can implement error
      reporting or fallback behavior here.
      如果方案未被识别, '.open()'方法将请求传递给本方法.
      你可在此实现错误报告或者fallback行为.

  urllib.URLFancyopener.prompt_user_passwd(host, realm)
      Prompt for the authentication pair '(user,passwd)' at the
      terminal.  You may override this to prompt within a GUI.
      If the authentication is not obtained interactively, but by
      other means, directly overriding '.get_user_passwd()' is
      more logical.
      在终端中提示用户提供授权对 '(user,passwd)'. 你可以将其改写,
      以用GUI获取信息. 如果授权并非以互动方式获取, 而是以其他方式,
      直接改写 '.get_user_passwd()'更有逻辑性.

  urllib.URLopener.retrieve(url [,fname [,reporthook [,data]]])
  urllib.URLFancyopener.retrieve(url [,fname [,reporthook [,data]]])
      Copies the URL 'url' to the local file named 'fname'.
      Callback to the progress function 'reporthook' if
      specified.  Use the optional HTTP POST query data in
      'data'.
      复制URL'url'到名为'fname'的本地文件. 如果指定的话,
      回调进度函数'reporthook'. 使用'data'中可选HTTP POST 请求数据.

      SEE ALSO, `urllib.urlretrieve()`
      参见 `urllib.urlretrieve()`

  urllib.URLopener.version
  urllib.URFancyLopener.version
      The User Agent string reported to a server is contained in
      this attribute.  By default it is 'urllib/###', where the
      [urllib] version number is used rather than '###'.
      向服务器报告的User Agent字符串即包含于本属性中.
      默认是'urllib/###', '###'实际上是[urllib]版本号.

  =================================================================
    MODULE -- urlparse : Parse Uniform Resource Locators
    模块 -- urlparse : 解析统一资源定位器 (URL)
  =================================================================

  The module [urlparse] support just one fairly simple task, but
  one that is just complicated enough for quick implementations to
  get wrong. URLs describe a number of aspects of resources on the
  Internet: access protocol, network location, path, parameters,
  query, and fragment. Using [urlparse], you can break out and
  combine these components to manipulate or generate URLs. The
  format of URLs is based on RFC-1738, RFC-1808, and RFC-2396.
  [urparse]模块只支持一个相当简单的任务, 但其又足够复杂, 以至于
  快速实现会搞错. URL描述了互联网上资源的很多方面: 存取协议,
  网络位置, 路径, 参数, 请求, 片段. 使用[urlparse], 你可以逃离这些,
  把这些合并在一起, 以操作或者产生URL. URL的格式基于
  RFC-1738, RFC-1808, 和 RFC-2396.

  Notice that [urlparse] does not parse the components of the
  network location, but merely returns them as a field.  For
  example, 'ftp://guest:gnosis@192.168.1.102:21//tmp/MAIL.MSG'
  is a valid identifier on my local network (at least at the
  moment this is written).  Tools like Mozilla and wget are happy
  to retrieve this file.  Parsing this fairly complicated URL
  with [urlparse] gives us:
  注意[urlparse]并不解析网络位置的组件, 而主要将其作为一个域返回.
  例如, 'ftp://guest:gnosis@192.168.1.102:21//tmp/MAIL.MSG'
  在我本地网络上(至少在写作的时候)是个有效的标识符. 诸如Mozilla和wget
  的工具会很高兴地获取此文件. 使用[urlparse]来解析这个相当复杂的URL,
  我们会得到:

      >>> import urlparse
      >>> url = 'ftp://guest:gnosis@192.168.1.102:21//tmp/MAIL.MSG'
      >>> urlparse.urlparse(url)
      ('ftp', 'guest:gnosis@192.168.1.102:21', '//tmp/MAIL.MSG',
      '', '', '')

  While this information is not incorrect, this network location
  itself contains multiple fields; all but the host are optional.
  The actual structure of a network location, using square
  bracket nesting to indicate optional components, is:
  如果此信息并不正确, 网络位置本身会包含多个域; 除了主机,
  所有东西都是可选的. 网络位置的实际结构, 如果使用方括号嵌套
  来显示可选组件的话, 会是:

      #*------------- Diagram of network location --------------#
      [user[:password]@]host[:port]

  The following mini-module will let you further parse these
  fields:
  下面的迷你模块可以让你更进一步解析这些域:

      #------------------ location_parse.py --------------------#
      #!/usr/bin/env python
      def location_parse(netloc):
          "Return tuple (user, passwd, host, port) for netloc"
          if '@' not in netloc:
              netloc = ':@' + netloc
          login, net = netloc.split('@')
          if ':' not in login:
              login += ':'
          user, passwd = login.split(':')
          if ':' not in net:
              net += ':'
          host, port = net.split(':')
          return (user, passwd, host, port)

      #-- specify network location on command-line
      if __name__=='__main__':
          import sys
          print location_parse(sys.argv[1])

  FUNCTIONS:
  函数:

  urlparse.urlparse(url [,def_scheme="" [,fragments=1]])
      Return a tuple consisting of six components of the URL
      'url', '(scheme, netloc, path, params, query, fragment)'.
      A URL is assumed to follow the pattern
      'scheme://netloc/path;params?query#fragment'.  If a default
      scheme 'def_scheme' is specified, that string will be
      returned in case no scheme is encoded in the URL itself.
      If 'fragments' is set to a false value, any fragments will
      not be split from other fields.
      返回一个元组, 包含了URL'url'的六个组件, 
      '(scheme, netloc, path, params, query, fragment)'.
      假设URL符合这样的模式'scheme://netloc/path;params?query#fragment'.
      如果指定了默认方案'def_scheme', 它会被返回, 如果URL本身并未
      编入此信息. 如果'fragments'被设置为false值, 所有片段都不会
      从其他域中分隔开.

      >>> from urlparse import urlparse
      >>> urlparse('gnosis.cx/path/sub/file.html#sect', 'http', 1)
      ('http', '', 'gnosis.cx/path/sub/file.html', '', '', 'sect')
      >>> urlparse('gnosis.cx/path/sub/file.html#sect', 'http', 0)
      ('http', '', 'gnosis.cx/path/sub/file.html#sect', '', '', '')
      >>> urlparse('http://gnosis.cx/path/file.cgi?key=val#sect',
      ...          'gopher', 1)
      ('http', 'gnosis.cx', '/path/file.cgi', '', 'key=val', 'sect')
      >>> urlparse('http://gnosis.cx/path/file.cgi?key=val#sect',
      ...          'gopher', 0)
      ('http', 'gnosis.cx', '/path/file.cgi', '', 'key=val#sect', '')

  urlparse.urlunparse(tup)
      Construct a URL from a tuple containing the fields returned
      by `urlparse.urlparse()`.  The returned URL has canonical
      form (redundancy eliminated) so `urlparse.urlparse()` and
      `urlparse.urlunparse()` are not precisely inverse
      operations; however, the composed 'urlunparse(urlparse(s))'
      should be idempotent.
      从一个元组构建一个URL, 该元组包含的域是从`urlparse.urlparse()`
      中返回的. 返回URL拥有规范格式(消除了冗余性), 因此
      `urlparse.urlparse()` 和`urlparse.urlunparse()`并非严格的
      逆操作; 但是编写的'urlunparse(urlparse(s))'应该是幂等的,
      即总是相同的结果.

  urlparse.urljoin(base, file)
      Return a URL that has the same base path as 'base', but has
      the file component 'file'.  For example:
      返回一个URL, 它和'base'拥有同样的基准路径, 但是拥有
      文件组件'file'. 例如:

      >>> from urlparse import urljoin
      >>> urljoin('http://somewhere.lan/path/file.html',
      ...                  'sub/other.html')
      'http://somewhere.lan/path/sub/other.html'

  In Python 2.2+ the functions `urlparse.urlsplit()` and
  `urlparse.urlunsplit()` are available.  These differ from
  `urlparse.urlparse()` and `urlparse.urlunparse()` in returning
  a 5-tuple that does not split out 'params' from 'path'.
  在Python 2.2+中, 可以使用`urlparse.urlsplit()`
  和`urlparse.urlunsplit()`函数. `urlparse.urlparse()`和
  `urlparse.urlunparse()`的不同之处在于, 返回的元组(长度为五)
  并不把'params'从'path'中剥离出来.
  

SECTION 3 -- Synopses of Other Internet Modules
节 3 -- 其他互联网模块的摘要性评述
------------------------------------------------------------------------

  There are a variety of Internet-related modules in the standard
  library that will not be covered here in their specific usage. In
  the first place, there are two general aspects to writing
  Internet applications. The first aspect is the parsing,
  processing, and generation of messages that conform to various
  protocol requirements. These tasks are solidly inside the realm
  of text processing and should be covered in this book. The second
  aspect, however, are the issues of actually sending a message
  "over the wire": choosing ports and network protocols,
  handshaking, validation, and so on. While these tasks are
  important, they are outside the scope of this book. The synopses
  below will point you towards appropriate modules, though; the
  standard documentation, Python interactive help, or other texts
  can help with the details.
  标准库中还有众多互联网相关的模块, 在此无法一一详述它们的特殊用途.
  首先, 编写互联网程序有两个方面. 第一个方面是解析,处理和生成
  符合不同协议要求的消息. 这些任务完全位于文字处理的范畴, 因此
  也应该涵盖于本书中. 而第二个方面, 却是"跨线"实际发送消息:
  选择端口和网络协议, 握手, 验证, 诸如此类. 尽管这些任务很重要, 
  它们已经越出此书范围. 但是下面的简要性评述会帮你找到合适的模块;
  标准文档, Python互动性帮助, 或者其他文字会帮助你, 给出许多细节的.

  A second issue comes up also, moreover. As Internet
  standards--usually canonicalized in RFCs--have evolved, and as
  Python libraries have become more versatile and robust, some
  newer modules have superceded older ones. In a similar way, for
  example, the [re] module replaced the older [regex] module. In
  the interests of backwards compatibility, Python has not dropped
  any Internet modules from its standard distributions.
  Nonetheless, the [email] module represents current "best
  practice" for most tasks related to email and newsgroup message
  handling. The modules [mimify], [mimetools], [MimeWriter],
  [multifile], and [rfc822] are likely to be utilized in existing
  code, but for new applications, it is better to use the
  capabilities in [email] in their stead.
  第二个方面还有更多问题. 正如互联网标准--通常在RFC中规范--
  会发展, 而Python模块变得越来越万能和健壮, 一些更新的模块
  已经取代了老一点的. 例如, [re]模块取代了[regex]模块. 为了向后兼容,
  Python并未将其标准分发版中的任何互联网模块丢弃.
  而且, [email]模块代表了当前于email和新闻组相关处理任务的"最佳实施".
  [mimify], [mimetools], [MimeWriter], [multifile], 和[rfc822]
  仍在现存代码中使用, 但是对于新程序, 最好替换成使用[email]中的能力.

  As well as standard library modules, a few third-party tools
  deserve special mention (at the bottom of this section). A large
  number of Python developers have created tools for various
  Internet-related tasks, but a small number of projects have
  reached a high degree of sophistication and a widespread usage.
  和标准库模块一样, 一些第三方工具值得特别提一下 (在本节最后).
  很多Python开发者已经为不同的互联网相关的任务创造了工具,
  但是只有一小部分项目达到了足够精密和广泛的应用.

  TOPIC -- Standard Internet-Related Tools
  主题 -- 标准的互联网相关工具
  --------------------------------------------------------------------

  asyncore
      Asynchronous socket service clients and servers.
      异步套接字服务客户端和服务器.

  Cookie
      Manage Web browser cookies.  Cookies are a common mechanism
      for managing state in Web-based applications.  RFC-2109 and
      RFC-2068 describe the encoding used for cookies, but in
      practice MSIE is not very standards compliant, so the
      parsing is relaxed in the [Cookie] module.
      管理网络浏览器的cookie. Cookie在基于网页的程序中, 是
      管理状态的常见机制. RFC-2109和RFC-2068描述了cookie的
      编码, 但在实际运用中, MSIE和标准并不十分兼容, 所以[Cookie]模块
      中的解析比较宽松.

      SEE ALSO, [cgi], `httplib`
      参见 [cgi], `httplib`

  email.Charset
      Work with character set encodings at a fine-tuned level.
      Other modules within the [email] package utilize this
      module to provide higher-level interfaces.  If you need to
      dig deeply into character set conversions, you might want
      to use this module directly.
      以微调级别与字符集编码协作. [emaill]包中的其他模块使用
      此模块来提供更高级别的接口. 如果你需要深入
      字符集转换, 你可能想要直接使用此模块.

      SEE ALSO, [email], [email.Header], `unicode`, [codecs]
      参见  [email], [email.Header], `unicode`, [codecs]

  ftplib
      Support for implementing custom file transfer protocol
      (FTP) clients.  This protocol is detailed in RFC-959.
      For a full FTP application, [ftplib] provides a very
      good starting point; for the simple capability to
      retrieve publicly accessible files over FTP,
      `urllib.urlopen()` is more direct.
      支持实现自定义文件传输协议(FTP)客户端. RFC-959描述了
      此协议的细节. 对于一个完整的FTP客户端, [ftplib]提供了
      一个很好的出发点; 对于只要能简单地从FTP取回公共共享的文件,
      `urllib.urlopen()`会更加直接.

      SEE ALSO, [urllib], `urllib2`
      参见 [urllib], `urllib2`

  gopherlib
      Gopher protocol client interface.  As much as I am still
      personally fond of the gopher protocol, it is used so
      rarely that it is not worth documenting here.
      Gopher 协议客户端界面. 我本人很喜欢gopher协议, 但是
      它很少被使用, 因此不值得在此详述.

  httplib
      Support for implementing custom Web clients.  Higher-level
      access to the HTTP and HTTPS protocols than using raw
      [sockets] on ports 80 or 443, but lower-level, and more
      communications oriented, than using the higher-level
      [urllib] to access Web resources in a file-like way.
      支持实现自定义客户端. 是对于HTTP和HTTPS协议的高层存取,
      而非在80或443端口直接使用原始[sockets], 而且更多的是
      以通迅为目的, 而非以高层[urllib]来用类似文件的方式
      存取网络资源.

      SEE ALSO, [urllib], `socket`
      参见 [urllib], `socket`

  ic, icopen
      Internet access configuration (Macintosh).
      互联网存取配置 (Macintosh).

  icopen
      Internet Config replacement for 'open()' (Macintosh).
      互联网配置, 'open()'的替换品 (Macintosh).

  imghdr
      Recognize image file formats based on their first few
      bytes.
      根据图片文件的前几个字节来判断它们的格式.

  mailcap
      Examine the 'mailcap' file on Unix-like systems.  The files
      '/etc/mailcap', '/usr/etc/mailcap', '/usr/local/etc/mailcap,
      and '$HOME/.mailcap' are typically used to configure MIME
      capabilities in client applications like mail readers and
      Web browsers (but less so now than a few years ago).  See
      RFC-1524.
      在类Unix系统中, 检查'mailcap'文件. '/etc/mailcap', '/usr/etc/mailcap', 
      '/usr/local/etc/mailcap, 以及'$HOME/.mailcap'这些文件被通常
      用于配置客户端程序中的MIME, 例如邮件阅读器和网络浏览器(几年前
      少得多). 参见 RFC-1524.

  mhlib
      Interface to MH mailboxes.  The MH format consists of a
      directory structure that mirrors the folder organization of
      message.  Each message is contained in its own file.  While
      the MH format is in many ways -better-, the Unix mailbox
      format seems to be more widely used.  Basic access to a
      single folder in an MH hierarchy can be achieved with the
      `mailbox.MHMailbox` class, which satisfies most working
      requirements.
      MH邮箱的接口. MH格式包含了一个目录结构, 反映了消息的
      目录组织. 每个消息保存于其本身的文件中. 尽管MH格式在
      很多方面都-更好-, Unix邮箱格式看起来使用更广. 对MH系统
      中某文件夹的存取可从`mailbox.MHMailbox`类中获得,
      后者满足绝大部分工作需求.

      SEE ALSO, [mailbox], [email]
      参见 [mailbox], [email]

  mimetools
      Various tools used by MIME-reading or MIME-writing programs.
      MIME-reading或MIME-writing程序使用的许多工具.

  MimeWriter
      Generic MIME writer.
      通用MIME撰稿者.

  mimify
      Mimification and unmimification of mail messages.
      缩小或者反缩小邮件信息.
## 疑似作者错误. mimi应为 mini...?

  netrc
      Examine the 'netrc' file on Unix-like systems.  The file
      '$HOME/.netrc' are typically used to configure FTP clients.
      检查类Unix系统中的'netrc'文件. 通常检查'$HOME/.netrc'
      来配置FTP客户端.

      SEE ALSO, `ftplib`, [urllib]
      参见 `ftplib`, [urllib]

  nntplib
      Support for Network News Transfer Protocol (NNTP) client
      applications.  This protocol is defined in RFC-977.
      Although Usenet has a different distribution system from
      email, the message format of NNTP messages still follows
      the format defined in RFC-822.  In particular, the [email]
      package, or the [rfc822] module, are useful for creating
      and modifying news messages.
      支持网络新闻传输协议(NNTP)客户端程序. RFC-977中定义了此协议.
      尽管Usenet和email的分布系统不一样, NNTP消息格式仍然遵从
      RFC-822中的定义. 特别是, [email]包, 或者[rfc822]模块,
      可用于创建和修改新闻消息.

      SEE ALSO, [email], `rfc822`
      参见[email], `rfc822`

  nsremote
      Wrapper around Netscape OSA modules (Macintosh).
      Netscape OSA模块(Macintosh)的包装.

  rfc822
      RFC-822 message manipulation class.  The [email] package is
      intended to supercede [rfc822], and it is better to use
      [email] for new application development.
      RFC-822消息维护类. [email]包的意图是取代[rfc822],
      所以在新闻程序开放中, 使用[email]更佳.

      SEE ALSO, [email], [poplib], [mailbox], [smtplib]
      参见 [email], [poplib], [mailbox], [smtplib]

  select
      Wait on I/O completion, such as sockets.
      等到I/O完成, 例如套接字.

  sndhdr
      Recognize sound file formats based on their first few
      bytes.
      根据声音文件的前几个字节, 辨别它们的格式.

  socket
      Low-level interface to BSD sockets.  Used to communicate
      with IP addresses at the level underneath protocols like
      HTTP, FTP, POP3, Telnet, and so on.
      BSD套接字的低层接口. 用于和IP地址通迅, 使用比
      HTTP, FTP, POP3, Telnet, 等更低层的协议.

      SEE ALSO, `ftplib`, `gopherlib`, `httplib`, [imaplib],
                `nntplib`, [poplib], [smtplib], `telnetlib`
      参见 `ftplib`, `gopherlib`, `httplib`, [imaplib],
                `nntplib`, [poplib], [smtplib], `telnetlib`

  SocketServer
      Asynchronous I/O on sockets.  Under Unix, pipes can also be
      monitored with [select].  [socket] supports SSL in recent
      Python versions.
      套接字上的异步I/O. 在Unix中, 管道也可以用[select]来监视.
      在最近的Python版本中, [select]支持SSL.

  telnetlib
      Support for implementing custom telnet clients.  This
      protocol is detailed in RFC-854.  While possibly useful for
      intranet applications, Telnet is an entirely unsecured
      protocol and should not really be used on the Internet.
      Secure Shell (SSH) is an encrypted protocol that otherwise
      is generally similar in capability to Telnet.  There is no
      support for SSH in the Python standard library, but
      third-party options exist, such as [pyssh].  At worst, you
      can script an SSH client using a tool like the third-party
      [pyexpect].
      支持实现自定义telnet客户端. RFC-854中定义了此协议.
      对于内联网程序可能比较有用, 但是telnet是完全没有加密的协议,
      因此不能用于互联网. 加密Shell (SSH) 是个加密协议, 除此之外
      和Telnet都很相似. 在Python标准库中, 没有对SSH的支持,
      但是存在第三方选择, 例如[pyssh]. 最坏的打算是, 
      你能使用工具, 如第三方的[pyexpect]来编写SSH客户端脚本.

  urllib2
      An enhanced version of the [urllib] module that adds
      specialized classes for a variety of protocols.  The main
      focus of [urllib2] is the handling of authentication and
      encryption methods.
      [urllib]的增强版本, 它给很多协议都增加了特别的类.
      [urllib2]主要关注授权和加密方法的处理.

      SEE ALSO, [urllib]
      参见 [urllib]

  Webbrowser
      Remote-control interfaces to some browsers.
      一些浏览器的远程控制接口.

  TOPIC -- Third-Party Internet-Related Tools
  主题 -- 第三方互联网相关工具
  --------------------------------------------------------------------

  There are many very fine Internet-related tools that this book
  cannot discuss, but to which no slight is intended.  A good
  index to such tools is the relevant page at the Vaults of
  Parnassus:
  还有很多很棒的与互联网相关的工具, 无法在本书中讨论. 
##后面这句什么意思?
  在Vaults of Parnassus有个相关页, 它是个关于此类工具的很好的索引.
  
    <http://py.vaults.ca/apyllo.py/812237977>

  Quixote
      In brief, [Quixote] is a templating system for HTML
      delivery.  More so than systems like PHP, ASP, and JSP to
      an extent, [Quixote] puts an emphasis on Web application
      structure more than page appearance.  The home page for
      [Quixote] is <http://www.mems-exchange.org/software/quixote/>
      简单来说, [Quixote]是个用于HTML投递的模板系统.
      在此方面, 远胜PHP, ASP以及JSP一筹. [Quixote]将重心置于
      网络程序结构, 而非页面外观.  [Quixote] 的主页是
      <http://www.mems-exchange.org/software/quixote/>

  Twisted
      To describe [Twisted], it is probably best simply to quote
      from Twisted Matrix Laboratories' Web site
      <http://www.twistedmatrix.com/>:
      为了描述[Twisted], 最好最简单的方法是引用Twisted Matrix Laboratories
      的网站<http://www.twistedmatrix.com/>:

      "Twisted is a framework, written in Python, for writing
      networked applications.  It includes implementations of a
      number of commonly used network services such as a Web
      server, an IRC chat server, a mail server, a relational
      database interface and an object broker.  Developers can
      build applications using all of these services as well as
      custom services that they write themselves.  Twisted also
      includes a user authentication system that controls access
      to services and provides services with user context
      information to implement their own security models."
      "Twisted是个Python写就的框架, 用于编写联网程序. 
      它包含了许多常见联网服务的实现, 例如Web服务器, IRC聊天服务器,
      邮件服务器, 关系数据库接口以及对象代理. 开发者打造程序,
      可以使用所有这些服务, 甚至他们编写的自定义服务. Twisted
      还包含了一个用户授权系统, 它可以控制对服务的存取,
      根据用户上下文信息提供服务, 以实现自己的安全模型. "

      While [Twisted] overlaps significantly in purpose with
      [Zope], [Twisted] is generally lower-level and more modular
      (which has both pros and cons).  Some protocols supported
      by [Twisted]--usually both server and client--and
      implemented in pure Python are  SSH; FTP; HTTP; NNTP;
      SOCKSv4; SMTP; IRC; Telnet; POP3; AOL's instant messaging
      TOC; OSCAR, used by AOL-IM as well as ICQ; DNS; MouseMan;
      finger; Echo, discard, chargen, and friends; Twisted
      Perspective Broker, a remote object protocol; and XML-RPC.
      尽管[Twisted]的目的和[Zope]很大程度重合, [Twisted]整体来说是
      比较低层, 更加模块化(这既是优点也是缺点). [Twisted]支持
      一些协议--通常同时包括服务器和客户端--使用纯Python
      来实现SSH; FTP; HTTP; NNTP;
      SOCKSv4; SMTP; IRC; Telnet; POP3; AOL即时消息
      TOC; OSCAR, 用于AOL-IM以及ICQ; DNS; MouseMan;
      finger; Echo, discard, chargen, 及其朋友; Twisted
      Perspective Broker, 远程对象协议; 以及XML-RPC.

  Zope
      [Zope] is a sophisticated, powerful, and just plain
      -complicated- Web application server.  It incorporates
      everything from dynamic page generation, to database
      interfaces, to Web-based administration, to back-end
      scripting in several styles and languages.  While the
      learning curve is steep, experienced Zope developers can
      develop and manage Web applications more easily, reliably,
      and faster than users of pretty much any other technology.
      [Zipe]是个精密,强大, 只是普通-复杂-的Web程序服务器.
      它可以和所有事情协作, 从动态网页生成, 到数据库接口, 从
      基于网页的管理, 到多种风格和语言的后端脚本.
      尽管学习曲线比较陡峭, 有经验的Zope开发者可以更易更稳更快地
      开发和管理Web程序, 远胜其他技术的用户.

      The home page for Zope is <http://zope.org/>.
      Zope的主页在<http://zope.org/>.

SECTION 4 -- Understanding XML
节4 -- 理解XML
------------------------------------------------------------------------

  Extensible Markup Language (XML) is a text format increasingly
  used for a wide variety of storage and transport requirements.
  Parsing and processing XML is an important element of many text
  processing applications. This section discusses the most common
  techniques for dealing with XML in Python. While XML held an
  initial promise of simplifying the exchange of complex and
  hierarchically organized data, it has itself grown into a
  standard of considerable complexity. This book will not cover
  most of the API details of XML tools; an excellent book dedicated
  to that subject is:
  可扩展标记语言(XML)是种文本格式, 它在很多对存储空间和传输有要求
  的使用正在增加. 解析和处理XML在很多文本处理程序中是个重要元素.
  本节讨论使用Python来处理XML的最常用技术. 尽管XML还保持其开始的保证,
  尽量简化复杂度和分级组织的数据, 它本身已经是相当复杂.
  本书不会涵盖XML工具的绝大部分API细节; 有本优秀的书已经奉献给这个主题了:

    _Python & XML_, Christopher A. Jones & Fred L. Drake, Jr.,
    O'Reilly 2002. ISBN: 0-596-00128-2.

  The XML format is sufficiently rich to represent any structured
  data, some forms more straightforwardly than others. A task that
  XML is quite natural at is in representing marked-up
  text--documentation, books, articles, and the like--as is its
  parent SGML. But XML is probably used more often to represent
  -data- than texts--record sets, OOP data containers, and so on.
  In many of these cases, the fit is more awkward and requires
  extra verbosity. XML itself is more like a metalanguage than a
  language--there are a set of syntax constraints that any XML
  document must obey, but typically particular APIs and document
  formats are defined as XML -dialects-. That is, a dialect
  consists of a particular set of tags that are used within a type
  of document, along with rules for when and where to use those
  tags. What I refer to as an XML dialect is also sometimes more
  formally called "an -application- of XML."
  XML格式非常丰富, 足够代表任何结构数据, 有的格式比其他的都要直观.
  有个任务使用XML是非常自然的, 那就是表示标记文本--文档, 书, 文章,
  诸如此类--正如它的父类SGML. 但是XML使用更广泛的是表示-数据-
  而非文本--记录集合,  OOP数据容器, 等等. 在很多这种情况中, 
  安装比较棘手, 需要额外冗余输出. XML本身更像一个元语言, 而非
  单个语言--XML文档都必须遵守一套语法限制, 但典型做法是, 
  一些特别的API和文档格式被定义为XML-方言-. 也就是说, 
  一个方言包含了一个特别集合的标签, 利用何时何处使用这些标签的规矩, 
  它们被用于某类别的文档中. 我成为XML方言的东西, 它有个更加正式的
  名字, 叫"XML-应用程序-".

  THE DATA MODEL:
  数据模型:

  At base, XML has two ways to represent data. Attributes in XML
  tags map names to values. Both names and values are Unicode
  strings (as are XML documents as a whole), but values frequently
  encode other basic datatypes, especially when specified in W3C
  XML Schemas. Attribute names are mildly restricted by the special
  characters used for XML markup; attribute values can encode any
  strings once a few characters are properly escaped. XML attribute
  values are whitespace normalized when parsed, but whitespace can
  itself also be escaped. A bare example is:
  从底层说, XML有两种方法来表示数据. XML标签中的属性将名字匹配到数值.
  名字和数值都是Unicode字符串(正如XML文档本身都是), 但是数值经常
  对其他基础数据类型编码, 特别是在W3C XML Schema中指定. 属性名字
  有个略微的限制, 那就是用于XML标记的特殊字符; 属性值可以编码任何字符串,
  只要一些字符已经正确地解码了. XML属性值中的空白在解析的时候已经规范化了,
  但是空白本身也能转义. 下面是个简陋的例子:  

      >>> from xml.dom import minidom
      >>> x = '''<x a="b" d="e   f g" num="38" />'''
      >>> d = minidom.parseString(x)
      >>> d.firstChild.attributes.items()
      [(u'a', u'b'), (u'num', u'38'), (u'd', u'e   f g')]

  As with a Python dictionary, no order is defined for the list
  of key/value attributes of one tag.
  和Python字典一样, 对于标签的键/值属性列表而言, 并未定义顺序.

  The second way XML represents data is by nesting tags inside
  other tags.  In this context, a tag together with a corresponding
  "close tag" is called an -element-, and it may contain an
  ordered sequence of -subelements-.  The subelements themselves
  may also contain nested subelements.  A general term for any
  part of an XML document, whether an element, an attribute, or
  one of the special parts discussed below, is a "node."  A
  simple example of an element that contains some subelements is:
  XML表示数据的第二种方法是, 在标签中嵌套其他标签.
  在此上下文中, 一个标签, 伙同其对应的"关闭标签", 被称作-元素-,
  它也可包含一个有顺序的-子元素-. 对于XML文档的任意部分,
  有个通项, 即任何一个元素, 属性或者下面讨论的任何一个特殊部分,
  都是一个"节点". 下面例子是一个元素包含了一些子元素:

      >>> x = '''<?xml version="1.0" encoding="UTF-8"?>
      ... <root>
      ...   <a>Some data</a>
      ...   <b data="more data" />
      ...   <c data="a list">
      ...     <d>item 1</d>
      ...     <d>item 2</d>
      ...   </c>
      ... </root>'''
      >>> d = minidom.parseString(x)
      >>> d.normalize()
      >>> for node in d.documentElement.childNodes:
      ...     print node
      ...
      <DOM Text node "
        ">
      <DOM Element: a at 7033280>
      <DOM Text node "
        ">
      <DOM Element: b at 7051088>
      <DOM Text node "
        ">
      <DOM Element: c at 7053696>
      <DOM Text node "
      ">
      >>> d.documentElement.childNodes[3].attributes.items()
      [(u'data', u'more data')]

  There are several things to notice about the Python session
  above.
  关于上面这个Python会话, 有些事情需要注意:

  1.  The "document element," named 'root' in the example,
      contains three ordered subelement nodes, named 'a', 'b',
      and 'c'.
      "文档元素", 在本例中叫做'root', 包含了三个有序的子元素节点,
      名字分别是'a', 'b'和'c'.

  2.  Whitespace is preserved within elements.  Therefore the
      spaces and newlines that come between the subelements make
      up several text nodes.  Text and subelements can intermix,
      each potentially meaningful.  Spacing in XML documents is
      significant, but it is nonetheless also often used for
      visual clarity (as above).
      元素中的空白被保留了. 因此子元素之间的空格和新行符会成为
      文本节点. 文本和子元素可以混合, 各有潜在含义. XML文档中
      的空白是有意义的, 当其还被经常用于视觉清晰(如上).

  3.  The example contains an XML declaration, '<?xml...?>',
      which is optional but generally included.
      本例包含了一个XML声明, '<?xml...?>', 它是可选的, 但通常都包含在内.

  4.  Any given element may contain attributes -and- subelements
      -and- text data.
      所有给定元素都可以包含属性-和-子元素-以及-文本数据.

  OTHER XML FEATURES:
  其他XML特性:

  Besides regular elements and text nodes, XML documents can
  contain several kinds of "special" nodes.  Comments are common
  and useful, especially in documents intended to be hand edited
  at some point (or even potentially).  Processing instructions
  may indicate how a document is to be handled.  Document type
  declarations may indicate expected validity rules for where
  elements and attributes may occur.  A special type of node
  called CDATA lets you embed mini-XML documents or other
  special codes inside of other XML documents, while leaving
  markup untouched.  Examples of each of these forms look like:
  除了常规元素和文本节点, XML文档还可包含若干种"特别"节点.
  注释通常比较有用, 特别是对于那些需要不时手工修改的文档(或者至少有可能).
  处理指示(Processing instruction)可以标明如何处理文档. 文档类型声明
  可以标明预期的确认规则对于哪些元素和属性生效. 还有一个特别类型的节点,
  叫做CDATA, 可以让你嵌入迷你XML文档, 或者其他XML文档中的特殊节点,
  还不会碰标记. 上述格式的例子看起来如下:

      #*------------- XML document with special nodes ----------#
      <?xml version="1.0" ?>
      <!DOCTYPE root SYSTEM "sometype.dtd">
      <root>
      <!-- This is a comment -->
      This is text data inside the &lt;root&gt; element
      <![CDATA[Embedded (not well-formed) XML:
               <this><that> >>string<< </that>]]>
      </root>

  XML documents may be either "well-formed" or "valid." The first
  characterization simply indicates that a document obeys the
  proper syntactic rules for XML documents in general: All tags are
  either self-closed or followed by a matching endtag; reserved
  characters are escaped; tags are properly hierarchically nested;
  and so on. Of course, particular documents can also fail to be
  well-formed--but in that case they are not XML documents sensu
  stricto, but merely fragments or near-XML. A formal description
  of well-formed XML can be found at <http://www.w3.org/TR/REC-xml>
  and <http://www.w3.org/TR/xml11/>.
  XML文档要么"格式良好", 要么"有效". 第一个特征只是显示该文档大体上遵守
  XML文旦的正确句法规则: 所有标签要么自我关闭的, 要么后面有一个匹配的关闭标签;
  保留字符被转义; 标签被正确地分级嵌套; 等等. 当然, 特殊的文档也会
  不是格式良好的--但在其例子中, 它们也非严格意义上的XML文档,
  而只是片段, 或者接近XML. 可在<http://www.w3.org/TR/REC-xml>
  和<http://www.w3.org/TR/xml11/>找到格式良好的XML的正式描述.

  Beyond well-formedness, some XML documents are also valid.
  Validity means that a document matches a further grammatical
  specification given in a Document Type Definition (DTD), or
  in an XML Schema.  The most popular style of XML Schema is the
  W3C XML Schema specification, found in formal detail at
  <http://www.w3.org/TR/xmlschema-0/>, and in linked documents.
  There are competing schema specifications, however--one popular
  alternative is RELAX NG, which is documented at
  <http://www.oasis-open.org/committees/relax-ng/>.
  除了结构良好, 有的XML文档还是有效的. 有效意味着文档匹配到某文档类别定义
  (DTD)或者XML Schema给出的语法规范. 最流行的XML Schema风格是
  W3C XML Schema规范, 可在<http://www.w3.org/TR/xmlschema-0/>及其链接中
  找到正式细节. 另外还存在竞争的schema规范--一个流行的替代品是RELAX NG,
  它的文档位于 <http://www.oasis-open.org/committees/relax-ng/>.

  The grammatical specifications indicated by DTDs are strictly
  structural.  For example, you can specify that certain
  subelements must occur within an element, with a certain
  cardinality and order.  Or, certain attributes may or must
  occur with a certain tag.  As a simple case, the following DTD
  is one that the prior example of nested subelements would
  conform to.  There are an infinite number of DTDs that the
  sample -could- match, but each one describes a slightly
  different -range- of valid XML documents:
  DTD显示的语法规范是严格地结构上的. 例如, 你可以指定某些
  子元素必须在元素内部出现, 还有一定的基数和顺序. 或者, 
  某些属性可能或者必须出现在一定的标签中. 作为一个简单的例子,
  下面的DTD就是前面嵌套子元素的例子需要遵守的. 这个例子
  -能够-匹配无数的DTD, 但是每个都描述了-范围-稍稍不同的
  有效XML文档:

      #*-------- DTD for simple subelement XML document --------#
      <!ELEMENT root ((a|OTHER-A)?, b, c*)>
      <!ELEMENT a (#PCDATA)>
      <!ELEMENT b EMPTY>
      <!ATTLIST b data CDATA #REQUIRED
                  NOT-THERE (this|that) #IMPLIED>
      <!ELEMENT c (d+)>
      <!ATTLIST c data CDATA #IMPLIED>
      <!ELEMENT d (#PCDATA)>

  The W3C recommendation on the XML standard also formally
  specifies DTD rules. A few features of the above DTD example can
  be noted here. The element 'OTHER-A' and the attribute
  'NOT-THERE' are permitted by this DTD, but were not utilized in
  the previous sample XML document. The quantifications '?', '*',
  and '+'; the alternation '|'; and the comma sequence operator
  have similar meaning as in regular expressions and BNF grammars.
  Attributes may be required or optional as well and may contain
  any of several specific value types; for example, the 'data'
  attribute must contain any string, while the 'NOT-THERE'
  attribute may contain 'this' or 'that' only.
  W3C在关于XML标准的推荐中还正式指定DTD规则. 上面DTD例子
  的一些特性可以在此说明一下. 这个DTD允许'OTHER-A'和属性'NOT-THERE',
  但在前面XML文档的例子中, 并未使用到. 量词'?', '*', 和 '+'; 交替符 '|'; 以及
  逗号序列操作符的意思和正则表达式以及BNF语法类似. 属性可以是必须的,
  也可以是可选的, 可以包含任何几个指定值类型; 例如, 'data'属性必须包含
  字符串, 而'NOT-THERE'属性只能包含'this' 或者 'that'.

  Schemas go farther than DTDs, in a way. Beyond merely specifying
  that elements or attributes must contain strings describing
  particular datatypes, such as numbers or dates, schemas allow
  more flexible quantification of subelement occurrences. For
  example, the following W3C XML Schema might describe an XML
  document for purchases:
  从某种角度看, schema比DTD作用时间长. Schema不只是指定
  元素或属性必须包含字符串来描述特定数据类型, 例如数字或者日期, 
  它还允许子元素出现的次数更有弹性. 例如, 下面的W3C XML Schema
  可以描述购买的XML文档:

      #*--------- XML Schema "item" Element Definition ---------#
      <xsd:element name="item">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:element name="USPrice"  type="xsd:decimal"/>
            <xsd:element name="shipDate" type="xsd:date"
                         minOccurs="0" maxOccurs=3 />
          </xsd:sequence>
          <xsd:attribute name="partNum" type="SKU"/>
        </xsd:complexType>
      </xsd:element>
      <!-- Stock Keeping Unit, a code for identifying products -->
      <xsd:simpleType name="SKU">
         <xsd:restriction base="xsd:string">
            <xsd:pattern value="\d{3}-[A-Z]{2}"/>
         </xsd:restriction>
      </xsd:simpleType>

  An XML document that is valid under this schema is:
  在此schema下有效的XML文档是:

      #*------------- Order info XML document ------------------#
      <item partNum="123-XQ">
        <USPrice>21.95</USPrice>
        <shipDate>2002-11-26</shipDate>
      </item>

  Formal specifications of schema languages can be found at the
  above-mentioned URLs; this example is meant simply to
  illustrate the types of capabilities they have.
  Schema语言的正式规范可在前述URL中找到; 此类只是展示它们拥有
  能力的类别.

  In order to check the validity of an XML document to a DTD or
  schema, you need to use a -validating parser-.  Some stand-alone
  tools perform validation, generally with diagnostic messages in
  cases of invalidity.  As well, certain libraries and modules
  support validation within larger applications.  As a rule,
  however, -most- Python XML parsers are nonvalidating and
  check only for well-formedness.
  为了检查XML文档对于某DTD或者schema是否有效, 你需要使用
  -验证解析器-. 有些独立工具可以进行验证, 无效的时候一般会给出
  诊断消息. 而且, 某些库和模块还支持在更大的程序中进行验证.
  但是, 一个规则是, -绝大部分-Python XML解析器并不验证有效性,
  而只是检查是否格式良好.

  Quite a number of technologies have been built on top of XML,
  many endorsed and specified by W3C, OASIS, or other standards
  groups. One in particular that you should be aware of is XSLT.
  There are a number of thick books available that discuss XSLT,
  so the matter is too complex to document here. But in shortest
  characterization, XSLT is a declarative programming language
  whose syntax is itself an XML application. An XML document is
  processed using a set of rules in an XSLT stylesheet, to produce
  a new output, often a different XML document. The elements in an
  XSLT stylesheet each describe a pattern that might occur in a
  source document and contain an output block that will be
  produced if that pattern in encountered. That is the simple
  characterization, anyway; in the details, "patterns" can have
  loops, recursions, calculations, and so on. I find XSLT to be
  more complicated than genuinely powerful and would rarely choose
  the technology for my own purposes, but you are fairly likely to
  encounter existing XSLT processes if you work with existing XML
  applications.
  已有很多技术建立在XML之上, 许多是W3C, OASIS或者其他标准组织
  批准和指定的. 其中一个特别值得注意的是XSLT. 讨论XSLT已有
  很多大部头, 所以在此就不涉及这件麻烦事. 但是在最简单的描述中,
  XSLT是一个陈述式编程语言, 它的语法本身就是一个XML程序.
  XML文档使用XSLT样式表中的规则集来处理, 进而产生新的输出,
  通常是个不同的XML文档. XSLT样式表中的元素各自描述
  一个可能在源文档中出现的模式, 还包含了如果模式出现之后, 
  需要产生的输出块. 无论如何, 这是一个简单的特性; 如果要细节的话,
  "patterns"可以拥有循环, 递归, 计算等等. 我发现XSLT复杂远胜
  强大, 从个人目的出发, 我很少会选择这个科技, 但如果你和已存在
  XML程序协作的话, 你很有可能遇到已有的XSLT进程.


  TOPIC -- Python Standard Library XML Modules
  主题 -- Python标准库XML模块
  --------------------------------------------------------------------

  There are two principle APIs for accessing and manipulating XML
  documents that are in widespread use: DOM and SAX. Both are
  supported in the Python standard library, and these two APIs
  make up the bulk of Python's XML support.  Both of these APIs
  are programming language neutral, and using them in other
  languages is substantially similar to using them in Python.
  关于存取和维护XML文档, 有两大原则的API使用广泛: DOM和SAX.
  Python标准库同时支持两者, 而两者也撑起了Python的XML支持的大部分
  内容. 两者的API都是与编程语言独立的, 在其他语言中使用这些API
  本质上和在Python中使用相似.

  The Document Object Model (DOM) represents an XML document as a
  tree of -nodes-.  Nodes may be of several types--a document
  type declaration, processing instructions, comments, elements,
  and attribute maps--but whatever the type, they are arranged in
  a strictly nested hierarchy.  Typically, nodes have children
  attached to them; of course, some nodes are -leaf nodes-
  without children.  The DOM allows you to perform a variety of
  actions on nodes: delete nodes, add nodes, find sibling nodes,
  find nodes by tag name, and other actions.  The DOM itself
  does not specify anything about how an XML document is
  transformed (parsed) into a DOM representation, nor about how a
  DOM can be serialized to an XML document.  In practice,
  however, all DOM libraries--including [xml.dom]--incorporate
  these capabilities.  Formal specification of DOM can be found
  at:
  文档对象模型(DOM)将XML文档表示为-节点-树. 节点可以是多个类型
  --文档类别声明, 处理指示, 注释, 元素, 属性地图--但不管类型是什么,
  它们都是以严格的嵌套分级安排的. 典型做法是, 节点有子节点附在其上;
  当然, 有的节点是-叶节点-, 并无子节点. DOM允许你对节点实施多种
  动作:删除节点, 添加节点, 寻找同级节点, 根据标签名字寻找节点, 以及
  其他动作. DOM本身并不指定如何将XML文档转换(解析)到DOM格式,
  也没有指定如何将DOM序列化到XML文档. 但是在实际运用中, 所有
  DOM库--包括[xml.dom]--都能和这些能力协作. DOM的正式规范
  可于此处找到:

    <http://www.w3.org/DOM/>

  and:
  以及:

    <http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/>.

  The Simple API for XML (SAX) is an -event-based- API for XML
  documents. Unlike DOM, which envisions XML as a rooted tree of
  nodes, SAX sees XML as a sequence of events occurring linearly in
  a file, text, or other stream. SAX is a very minimal interface,
  both in the sense of telling you very little inherently about the
  -structure- of an XML documents, and also in the sense of being
  extremely memory friendly. SAX itself is forgetful in the sense
  that once a tag or content is processed, it is no longer in
  memory (unless you manually save it in a data structure).
  However, SAX does maintain a basic stack of tags to assure
  well-formedness of parsed documents. The module [xml.sax] raises
  exceptions in case of problems in well-formedness; you may define
  your own custom error handlers for these. Formal specification of
  SAX can be found at:
  Simple API for XML (SAX)是个-基于事件-的XML文档API. 与DOM不同的是,
  后者将XML想象为节点组成的有根树, 而SAM将XML看作一系列的事件,
  在文件, 文本, 或者其他流中线性出现. SAX是个最小化的接口, 最小化体现在
  只告诉你极少的关于XML文档-结构-的信息, 还体现在极度内存友好.
  在这一点上, SAX本身常被遗忘, 某标签或者常数一旦处理过, 将从内存中
  消失(除非你手工将其保存到某数据结构中). 但是, SAX确实也维护一个标签的
  基本堆栈, 以确保解析后文档的良好结构. 如果结构良好性方面出现问题, 
  [xml.sax]模块会引发异常; 你可以为此定义自己的错误处理器. SAX的正式
  规范可在此处寻获:

    <http://www.saxproject.org/>.

  -*-

  xml.dom
      The module [xml.dom] is a Python implementation of most of
      the W3C Document Object Model, Level 2.  As much as
      possible, its API follows the DOM standard, but a few
      Python conveniences are added as well.  A brief example of
      usage is below:
      [xml.dom]模块是绝大部分W3C 文档对象模型, 2级, 的Python实现.
      它的API尽可能多地跟随DOM标准, 但也添加了一些Python便利个噢你据.
      下面有个关于用法的简单例子:

      >>> from xml.dom import minidom
      >>> dom = minidom.parse('address.xml')
      >>> addrs = dom.getElementsByTagName('address')
      >>> print addrs[1].toxml()
      <address city="New York" number="344" state="NY" street="118 St."/>
      >>> jobs = dom.getElementsByTagName('job-info')
      >>> for key, val in jobs[3].attributes.items():
      ...     print key,'=',val
      ...
      employee-type = Part-Time
      is-manager = no
      job-description = Hacker

      SEE ALSO, `gnosis.xml.objectify`
      参见 `gnosis.xml.objectify`

  xml.dom.minidom
      The module [xml.dom.minidom] is a lightweight DOM
      implementation built on top of SAX.  You may pass in a
      custom SAX parser object when you parse an XML document;
      by default, [xml.dom.minidom] uses the fast, nonvalidating
      [xml.parser.expat] parser.
      [xml.dom.minidom]模块是个轻量级的DOM实现, 建立于SAX之上.
      在解析XML文档时, 你可以传入一个自定义的SAX解析器对象;默认的是,
      [xml.dom.minidom]使用一个快速, 但不进行验证的[xml.parser.expat]
      解析器.

  xml.dom.pulldom
      The module [xml.dom.pulldom] is a DOM implementation that
      conserves memory by only building the portions of a DOM
      tree that are requested by calls to accessor methods.  In
      some cases, this approach can be considerably faster than
      building an entire tree with [xml.dom.minidom] or another
      DOM parser; however, the [xml.dom.pulldom] remains somewhat
      underdocumented and experimental at the time of this
      writing.
      [xml.dom.pulldom]模块是个DOM实现, 它节省内存, 因为它根据
      存取方法请求的节点, 而只建立DOM树的一部分. 在某些情况中,
      这种方法可以认为比[xml.dom.minidom]或其他DOM解析建立
      一整棵树要快; 但是, [xml.dom.pulldom]还缺乏文档, 在本书写作
      时, 尚处于实验阶段.

  xml.parsers.expat
      Interface to the 'expat' nonvalidating XML parser.  Both
      [xml.sax] and [xml.dom.minidom] utilize the services of the
      fast 'expat' parser, whose functionality lives mostly in a
      C library.  You can use [xml.parser.expat] directly if you
      wish, but since the interface uses the same general
      event-driven style of the standard [xml.sax], there is
      usually no reason to.
      'Expat'非验证XML解析器的接口. [xml.sax] 和 [xml.dom.minidom]
      都使用快速'expat'解析器,  后者的功能几乎都在C库中. 
      如果你想的话, 你可以直接使用[xml.parser.expat],
      但是这个接口和标准[xml.sax]使用同样通用的事件驱动风格,
      通常没有理由需要这样做.

  xml.sax
      The package [xml.sax] implements the Simple API for XML.
      By default, [xml.sax] relies on the underlying
      [xml.parser.expat] parser, but any parser supporting a set
      of interface methods may be used instead.  In particular,
      the validating parser [xmlproc] is included in the [PyXML]
      package.
      [xml.sax]实现了Simple API for XML. 默认的是, [xml.sax]
      依赖域底层的[xml.parser.expat]解析器, 但是任何支持某套
      接口方法的解析器都可以替代使用. 特别的是, 验证解析器[xmlproc]
      也包含在[PyXML]包中.

      When you create a SAX application, your main task is to
      create one or more callback handlers that will process
      events generated during SAX parsing.  The most important
      handler is a 'ContentHandler', but you may also define a
      'DTDHandler', 'EntityResolver', or 'ErrorHandler'.
      Generally you will specialize the base handlers in
      [xml.sax.handler] for your own applications.  After
      defining and registering desired handlers, you simply call
      the '.parse()' method of the parser that you registered
      handlers with.  Or alternately, for incremental processing,
      you can use the 'feed()' method.
      当你创建SAX程序时, 你的主要任务是创建一个或多个回调句柄,
      以处理SAX解析时生成的事件. 最重要的句柄是'ContentHandler',
      但你还可以定义'DTDHandler', 'EntityResolver', 或者'ErrorHandler'.
      通常你为你自己的程序在[xml.sax.handler]中指定基本句柄.
      在定义和注册想要的句柄之后, 你只要调用句柄注册的那个解析器的
      '.parse()'方法. 或者, 为了增量处理, 你可以使用'feed()'方法.
      
      
# # handler: 句柄? 还是处理器?

      A simple example illustrates usage.  The application below
      reads in an XML file and writes an equivalent, but not
      necessarily identical, document to STDOUT.  The output can
      be used as a canonical form of the document:
      下面是一个简单例子,用来展示用法. 下面的程序读入一个XML文件,
      写入一个等价的, 但不一定相同的文档到STDOUT. 输出可以被用作
      文档的规范格式:

      #------------------------- xmlcat.py ---------------------#
      #!/usr/bin/env python
      import sys
      from xml.sax import handler, make_parser
      from xml.sax.saxutils import escape
      
      class ContentGenerator(handler.ContentHandler):
          def __init__(self, out=sys.stdout):
              handler.ContentHandler.__init__(self)
              self._out = out
          def startDocument(self):
              xml_decl = '<?xml version="1.0" encoding="iso-8859-1"?>\n'
              self._out.write(xml_decl)
          def endDocument(self):
              sys.stderr.write("Bye bye!\n")
          def startElement(self, name, attrs):
              self._out.write('<' + name)
              name_val = attrs.items()
              name_val.sort()                 # canonicalize attributes
              for (name, value) in name_val:
                  self._out.write(' %s="%s"' % (name, escape(value)))
              self._out.write('>')
          def endElement(self, name):
              self._out.write('</%s>' % name)
          def characters(self, content):
              self._out.write(escape(content))
          def ignorableWhitespace(self, content):
              self._out.write(content)
          def processingInstruction(self, target, data):
              self._out.write('<?%s %s?>' % (target, data))
      
      if __name__=='__main__':
          parser = make_parser()
          parser.setContentHandler(ContentGenerator())
          parser.parse(sys.argv[1])

  xml.sax.handler
      The module [xml.sax.handler] defines classes
      'ContentHandler', 'DTDHandler', 'EntityResolver' and
      'ErrorHandler' that are normally used as parent classes of
      custom SAX handlers.
      [xml.sax.handler]模块定义了类'ContentHandler', 'DTDHandler',
       'EntityResolver'以及'ErrorHandler', 它们正常都是由自定义SAX句柄
       父类使用.

  xml.sax.saxutils
      The module [xml.sax.saxutils] contains utility functions
      for working with SAX events.  Several functions allow
      escaping and munging special characters.
      [xml.sax.saxutils]模块包含了工具函数, 可以和SAX时间协作.
      若干函数允许对特殊字符转义和割裂.

  xml.sax.xmlreader
      The module [xml.sax.xmlreader] provides a framework for
      creating new SAX parsers that will be usable by the
      [xml.sax] module.  Any new parser that follows a set of API
      conventions can be plugged in to the
      `xml.sax.make_parser()` class factory.
      [xml.sax.xmlreader]模块提供了一个框架来创建新的SAX解析器,
      后者可以被[xml.sax]模块使用. 任何新的解析器, 只要符合一定集合
      的API约定的话, 都可以插入`xml.sax.make_parser()`类工厂.

  xmllib
      Deprecated module for XML parsing.  Use [xml.sax] or other
      XML tools in Python 2.0+.
      XML解析的废弃模块. 在Python 2.0+, 使用[xml.sax]或者其他XML工具.

  xmlrpclib
  SimpleXMLRPCServer
      XML-RPC is an XML-based protocol for remote procedure
      calls, usually layered over HTTP.  For the most part, the
      XML aspect is hidden from view.  You simply use the
      module [xmlrpclib] to call remote methods and the module
      [SimpleXMLRPCServer] to implement your own server that
      supports such method calls.  For example:
      XML-RPC是个基于XML的协议, 用于远程程序调用, 通常是HTTP
      以上的层. 对于大部分来说, XML方面对于视图来说是隐藏的.
      你只要使用[xmlrpclib]模块来调用远程方法, 而[SimpleXMLRPCServer]
      模块用于实现你自己的服务器, 支持此类方法调用. 例如:

      >>> import xmlrpclib
      >>> betty = xmlrpclib.Server("http://betty.userland.com")
      >>> print betty.examples.getStateName(41)
      South Dakota

      The XML-RPC format itself is a bit verbose, even as XML
      goes.  But it is simple and allows you to pass argument
      values to a remote method:
      XML-RPC格式本身有点冗长, 即使不谈XML. 但它简单, 还允许你
      传递参数值到远程方法:

      >>> import xmlrpclib
      >>> print xmlrpclib.dumps((xmlrpclib.True,37,(11.2,'spam')))
      <params>
      <param>
      <value><boolean>1</boolean></value>
      </param>
      <param>
      <value><int>37</int></value>
      </param>
      <param>
      <value><array><data>
      <value><double>11.199999999999999</double></value>
      <value><string>spam</string></value>
      </data></array></value>
      </param>
      </params>

      SEE ALSO, `gnosis.xml.pickle`
      参见 `gnosis.xml.pickle`

  TOPIC -- Third-Party XML-Related Tools
  主题 -- 第三方XML相关工具
  --------------------------------------------------------------------

  A number of projects extend the XML capabilities in the Python
  standard library. I am the principle author of several
  XML-related modules that are distributed with the [gnosis]
  package. Information on the current release can be found at:
  很多项目将Python标准库中的XML能力进行了扩展.
  我是若干个XML相关模块的主要作者, 它们和[gnosis]包一起分发.
  关于当前发布的信息, 可在此处找到:

    <http://gnosis.cx/download/Gnosis_Utils.ANNOUNCE>.

  The package itself can be downloaded as a [distutils] package
  tarball from:
  此包本身可以[distutils]包tarball格式下载:

    <http://gnosis.cx/download/Gnosis_Utils-current.tar.gz>.

  The Python XML-SIG (special interest group) produces a package
  of XML tools known as [PyXML].  The work of this group is
  incorporated into the Python standard library with new Python
  releases--not every [PyXML] tool, however, makes it into the
  standard library.  At any given moment, the most
  sophisticated--and often experimental--capabilities can be
  found by downloading the latest [PyXML] package.  Be aware that
  installing the latest [PyXML] overrides the default Python XML
  support and may break other tools or applications.
  Python XML-SIG (特殊兴趣小组) 创作了一个XML工具包, 唤作[PyXML].
  这个小组的工作正被合并到新的Python发布的标准库中. 在任何时间,
  最精密的--通常也是实验性的--能力可以在最新版的[PyXML]包中找到.
  注意安装最新版[PyXML]会覆盖默认的Python XML支持, 也许会破坏其他
  工具或者程序.

    <http://pyxml.sourceforge.net/>

  Fourthought, Inc. produces the [4Suite] package, which contains
  a number of XML tools.  Fourthought releases [4Suite] as free
  software, and many of its capabilities are incorporated into the
  [PyXML] project (albeit at a varying time delay); however,
  Fourthought is a for-profit company that also offers
  customization and technical support for [4Suite].  The
  community page for [4Suite] is:
  Fourthought, Inc. 创作了[4Suite]包, 它包含了很多XML工具.
  Fourthought以自由软件发布[4Suite], 它的许多能力也被合并入
  [PyXML]项目 (尽管有不同的时间延迟); 但是, Fourthought是个
  追求利润的公司, 他们还为[4Suite]提供定制和技术支持.
  [4Suite]的社区页位于:

    <http://4suite.org/index.xhtml>.

  The Fourthought company Web site is:
  Fourthought的公司网站是:

    <http://fourthought.com/>.

  Two other modules are discussed briefly below. Neither of these
  are XML tools per se. However, both [PYX] and [yaml] fill many
  of the same requirements as XML does, while being easier to
  manipulate with text processing techniques, easier to read, and
  easier to edit by hand. There is a contrast between these two
  formats, however. [PYX] is semantically identical to XML, merely
  using a different syntax. YAML, on the other hand, has a quite
  different semantics from XML--I present it here because in many
  of the concrete applications where developers might instinctively
  turn to XML (which has a lot of "buzz"), YAML is a better
  choice.
  下面简略讨论一下另外两个模块. 两者都不是XML工具. 但是[PYX]和[yaml]
  满足很多和XML一样的要求, 同时更容易使用文本处理技术来操作, 更易读,
  更易手工处理. 但是这两种格式之间也有不同. [PYX]语义上和XML是一样的,
  主要使用不同的语法. 而YAML, 和XML拥有相当不同的语义--我在此处这样说, 
  因为在很多具体程序中, 开发者可能会本能地转向XML(它有许多"噪音"), 其实
  YAML是个更好的选择.

  The home page for [PYX] is:
  [PYX] 的主页是:

    <http://pyxie.sourceforge.net/>.

  I have written an article explaining PYX in more detail than in
  this book at:
  我写过一篇文章来解释PYX, 其中有比此书更多的细节, 地址在:

    <http://gnosis.cx/publish/programming/xml_matters_17.html>.

  The home page for YAML is:
  YAML的主页是:

    <http://yaml.org>.

  I have written an article contrasting the utility and
  semantics of YAML and XML at:
  我写过一篇文章, 比较YAML和XML的效用和语义:

    <http://gnosis.cx/publish/programming/xml_matters_23.html>.

  -*-

  gnosis.xml.indexer
      The module [gnosis.xml.indexer] builds on the full-text
      indexing program presented as an example in Chapter 2 (and
      contained in the [gnosis] package as [gnosis.indexer]).
      Instead of file contents, [gnosis.xml.indexer] creates
      indices of (large) XML documents.  This allows for a kind
      of "reverse XPath" search.  That is, where a tool like
      [4xpath], in the [4Suite] package, lets you see the
      contents of an XML node specified by XPath,
      [gnosis.xml.indexer] identifies the XPaths to the point
      where a word or words occur.  This module may be used
      either in a larger application or as a command-line tool;
      for example:
      [gnosis.xml.indexer]模块打造一个全文索引程序, 就如第二章中
      给出的例子(包含在[gnosis]包中, 名为[gnosis.indexer]).
      [gnosis.xml.indexer]创建的是(大)XML文档的索引, 而非文件内容.
      这个将允许某种"逆XPath"搜索. 也就是说, 和[4Suite]包中的[4xpath]
      类似, 让你看到XPath指定的XML节点内容, [gnosis.xml.indexer]
      将XPath定位到单词出现的地方. 此模块可在更大程序中使用,
      也可以作为命令行工具; 例如:

      #*------------ gnosis.xml.indexer search -----------------#
      % indexer symmetric
      ./crypto1.xml::/section[2]/panel[8]/title
      ./crypto1.xml::/section[2]/panel[8]/body/text_column/code_listing
      ./crypto1.xml::/section[2]/panel[7]/title
      ./crypto2.xml::/section[4]/panel[6]/body/text_column/p[1]
      4 matched wordlist: ['symmetric']
      Processed in 0.100 seconds (SlicedZPickleIndexer)

      #*------ Limit matches to ones in a title element --------#
      % indexer "-filter=*::/*/title" symmetric
      ./crypto1.xml::/section[2]/panel[8]/title
      ./crypto1.xml::/section[2]/panel[7]/title
      2 matched wordlist: ['symmetric']
      Processed in 0.080 seconds (SlicedZPickleIndexer)

      Indexed searches, as the example shows, are very fast.  I
      have written an article with more details on this module:
      索引搜索, 正如例子所示, 非常迅速. 我写过一篇文章, 里面有
      更多此模块的细节:

      <http://gnosis.cx/publish/programming/xml_matters_10.html>.

  gnosis.xml.objectify
      The module [gnosis.xml.objectify] transforms arbitrary XML
      documents into Python objects that have a "native" feel to
      them.  Where XML is used to encode a data structure, I
      believe that using [gnosis.xml.objectify] is the quickest
      and simplest way to utilize that data in a Python
      application.
      [gnosis.xml.objectify]模块将任何XML文档转换为Python对象,
      后者有种"天然的"感觉. 当使用XML来对数据结构进行编码时,
      我相信要想在Python程序中使用这些数据, 
      使用[gnosis.xml.objectify]是最快最简单的方法, 

      The Document Object Model defines an OOP model for
      working with XML, across programming languages.  But while
      DOM is nominally object-oriented, its access methods are
      distinctly un-Pythonic.  For example, here is a typical
      "drill down" to a DOM value (skipping whitespace text
      nodes for some indices, which is far from obvious):
      文档对象模型定义了一个跨语言的OOP模型来和XML协作.
      但是DOM名义上是面向对象的, 它的存取方法却明显不是Python形的.
      例如, 这儿有个典型"向下钻取"某DOM值(对于某些索引而言, 略过
      空白文本节点, 这是不言而喻的):

      >>> from xml.dom import minidom
      >>> dom_obj = minidom.parse('address.xml')
      >>> dom_obj.normalize()
      >>> print dom_obj.documentElement.childNodes[1].childNodes[3]\
      ...                              .attributes.get('city').value
      Los Angeles

      In contrast, [gnosis.xml.objectify] feels like you are
      using Python:
      作为对比, [gnosis.xml.objectify]让你感觉在使用Python:

      >>> from gnosis.xml.objectify import XML_Objectify
      >>> xml_obj = XML_Objectify('address.xml')
      >>> py_obj = xml_obj.make_instance()
      >>> py_obj.person[2].address.city
      u'Los Angeles'

  gnosis.xml.pickle
      The module [gnosis.xml.pickle] lets you serialize
      arbitrary Python objects to an XML format.  In most
      respects, the purpose is the same as for the [pickle]
      module, but an XML target is useful for certain purposes.
      You may process the data in an xml_pickle using standard
      XML parsers, XSLT processors, XML editors, validation
      utilities, and other tools.
      [gnosis.xml.pickle]模块让你把任意Python对象序列化到XML格式.
      在很多方面, 这个目的和[pickle]模块的一样, 但目标作为XML在
      某些情况下比较有用.你可以用xml_pickle方式处理数据, 运用那些
      标准XML解析器, XSLT处理器, XML编辑器, 验证功能, 诸如此类.

      In several respects, [gnosis.xml.pickle] offers
      finer-grained control than the standard [pickle] module
      does. You can control security permissions accurately; you
      can customize the representation of object types within an
      XML file; you can substitute compatible classes during the
      pickle/unpickle cycle; and several other "guru-level"
      manipulations are possible.  However, in basic usage,
      [gnosis.xml.pickle] is fully API compatible with [pickle].
      An example illustrates both the usage and the format:
      在若干方面, [gnosis.xml.pickle]都比标准[pickle]模块提供了
      更精细的控制. 你可以精确控制安全许可; 你可以自定义XML文件
      中的对象类型表现; 你可以在pickle/unpickle循环中替换兼容的
      类; 还有其他一些"大师级"的操作可供选择. 但是, 在基础应用中,
      [gnosis.xml.pickle]是和[pickle]完全兼容的. 下面例子同时展示了
      用法和格式:

      >>> class Container: pass
      ...
      >>> inst = Container()
      >>> dct = {1.7:2.5, ('t','u','p'):'tuple'}
      >>> inst.this, inst.num, inst.dct = 'that', 38, dct
      >>> import gnosis.xml.pickle
      >>> print gnosis.xml.pickle.dumps(inst)
      <?xml version="1.0"?>
      <!DOCTYPE PyObject SYSTEM "PyObjects.dtd">
      <PyObject module="__main__" class="Container" id="5999664">
      <attr name="this" type="string" value="that" />
      <attr name="dct" type="dict" id="6008464" >
        <entry>
          <key type="tuple" id="5973680" >
            <item type="string" value="t" />
            <item type="string" value="u" />
            <item type="string" value="p" />
          </key>
          <val type="string" value="tuple" />
        </entry>
        <entry>
          <key type="numeric" value="1.7" />
          <val type="numeric" value="2.5" />
        </entry>
      </attr>
      <attr name="num" type="numeric" value="38" />
      </PyObject>

      SEE ALSO, [pickle], [cPickle], `yaml`, [pprint]
      参见 [pickle], [cPickle], `yaml`, [pprint]

  gnosis.xml.validity
      The module [gnosis.xml.validity] allows you to define Python
      container classes that restrict their containment according
      to XML validity constraints.  Such validity-enforcing
      classes -always- produce string representations that are
      valid XML documents, not merely well-formed ones.  When you
      attempt to add an item to a [gnosis.xml.validity] container
      object that is not permissible, a descriptive exception is
      raised.  Constraints, as with DTDs, may specify
      quantification, subelement types, and sequence.
      [gnosis.xml.validity]模块允许你定义Python容器类, 以根据XML
      有效性限制来约束他们的包含内容. 这样的有效性强制执行类-总是-
      生成有效XML文档的字符串表示, 而非只是格式良好的. 当你试图
      将项目添加进[gnosis.xml.validity]容器对象, 如果不被允许的话,
      将引发一个描述性异常. 限制, 连同DTD一起, 可以指定量词,
      子元素类别, 以及序列.

      For example, suppose you wish to create documents that
      conform with a "dissertation" Document Type Definition:
      例如, 架设你希望创建一个文档, 它符合某个"dissertation"文档类别
      定义(DTD):

      #------------------ dissertation.dtd ----------------------#
      <!ELEMENT dissertation (dedication?, chapter+, appendix*)>
      <!ELEMENT dedication (#PCDATA)>
      <!ELEMENT chapter (title, paragraph+)>
      <!ELEMENT title (#PCDATA)>
      <!ELEMENT paragraph (#PCDATA | figure | table)+>
      <!ELEMENT figure EMPTY>
      <!ELEMENT table EMPTY>
      <!ELEMENT appendix (#PCDATA)>

      You can use [gnosis.xml.validity] to assure your
      application produced only conformant XML documents. First,
      you create a Python version of the DTD:
      你可以使用[gnosis.xml.validity]来确保你的程序生成一致性的XML
      文档. 首先, 你创建一个Python版本的DTD:

      #----------------- dissertation.py ---------------------#
      from gnosis.xml.validity import *
      class appendix(PCDATA):   pass
      class table(EMPTY):       pass
      class figure(EMPTY):      pass
      class _mixedpara(Or):     _disjoins = (PCDATA, figure, table)
      class paragraph(Some):    _type = _mixedpara
      class title(PCDATA):      pass
      class _paras(Some):       _type = paragraph
      class chapter(Seq):       _order = (title, _paras)
      class dedication(PCDATA): pass
      class _apps(Any):         _type = appendix
      class _chaps(Some):       _type = chapter
      class _dedi(Maybe):       _type = dedication
      class dissertation(Seq):  _order = (_dedi, _chaps, _apps)

      Next, import your Python validity constraints, and use them
      in an application:
      接着, 导入你的Python有效性限制, 并在程序中使用它们:

      >>> from dissertation import *
      >>> chap1 = LiftSeq(chapter,('About Validity','It is a good thing'))
      >>> paras_ch1 = chap1[1]
      >>> paras_ch1 += [paragraph('OOP can enforce it')]
      >>> print chap1
      <chapter><title>About Validity</title>
      <paragraph>It is a good thing</paragraph>
      <paragraph>OOP can enforce it</paragraph>
      </chapter>

      If you attempt an action that violates constraints, you get
      a relevant exception; for example:
      如果你尝试的动作违反了限制, 你会得到一个相关的异常; 例如:

      >>> try:
      ..     paras_ch1.append(dedication("To my advisor"))
      .. except ValidityError, x:
      ...    print x
      Items in _paras must be of type <class 'dissertation.paragraph'>
      (not <class 'dissertation.dedication'>)

  PyXML
      The [PyXML] package contains a number of capabilities in
      advance of those in the Python standard library.  [PyXML]
      was at version 0.8.1 at the time this was written, and as
      the number indicates, it remains an in-progress/beta
      project.  Moreover, as of this writing, the last released
      version of Python was 2.2.2, with 2.3 in preliminary
      stages.  When you read this, [PyXML] will probably be at a
      later number and have new features, and some of the current
      features will have been incorporated into the standard
      library.  Exactly what is where is a moving target.
      [PyXML]包包含了远超Python标准库的许多能力. [PyXML]
      在本书写作时的版本是0.8.1, 正如此数字显示, 它仍是个
      发展中/不稳定项目. 而且, 与此同时, Python的最新版本是
      2.2.2, 2.3仍处于初步阶段. 当你读到这个的时候, [PyXML]
      应该有更新版本, 拥有新的特性, 而且现有的一些特性应该
      已被合并到标准库中. 具体到达什么位置, 仍还不确定.

      Some of the significant features currently available in
      [PyXML] but not in the standard library are listed below.
      You may install [PyXML] on any Python 2.0+ installation,
      and it will override the existing XML support.
      下面这些值得注意的特性都是[PyXML]提供, 而Python标准尚未
      提供. 你可以在Python 2.0+中安装, 它会覆盖已有的XML支持.

      *** A validating XML parser written in Python called
      [xmlproc].  Being a pure Python program rather than a C
      extension, [xmlproc] is slower than [xml.sax] (which uses
      the underlying [expat] parser).
      *** 有个Python写就的验证XML解析器叫做[xmlproc].
      作为一个纯Python程序, 而非C扩展, [xmlproc]相对
      [xml.sax]较慢 (后者使用了底层的[expat]解析器).

      *** A SAX extension called [xml.sax.writers] that will
      reserialize SAX events to either XML or other formats.
      *** 有个SAX扩展, 名唤[xml.sax.writers], 可以将SAX事件
      重新序列化到XML或者其他格式.

      *** A fully compliant DOM Level 2 implementation called
      [4DOM], borrowed from [4Suite].
      *** 有个完全兼容的DOM 2级实现, 名曰[4DOM], 乃从[4Suite]中所借.

      *** Support for canonicalization.  That is, two XML
      documents can be semantically identical even though they
      are not byte-wise identical.  You have freedom in choice of
      quotes, attribute orders, character entities, and some
      spacing that change nothing about the -meaning- of the
      document.  Two canonicalized XML documents are semantically
      identical if and only if they are byte-wise identical.
      *** 支持标准化. 也就是说, 两个XML文档可以在语义上相等, 
      而它们不需要每个字节的都一样. 你可以自由选择引用, 属性顺序,
      字符实体, 以及一些空格, 它们不会改变文档的-意义-. 而两个
      标准化后的XML文档如果在语义上相同, 也就等价于它们是每个字节都相同.

      *** XPath and XSLT support, with implementations written in
      pure Python.  There are faster XSLT implementations around,
      however, that call C extensions.
      *** XPath和XSLT支持, 实现是用纯Python写成. 现在也存在更快的XSLT实现,
      但是它调用C扩展.

      *** A DOM implementation that supports lazy instantiation
      of nodes, called [xml.dom.pulldom], has been incorporated
      into recent versions of the standard library.  For older
      Python versions, this is available in [PyXML].
      *** 一个支持节点懒惰安装的DOM实现, 称作 [xml.dom.pulldom],
      已经被合并到最新的标准库中. 对于老版本的Python, 可以在
      [PyXML]中找到.

      *** A module with several options for serializing Python
      objects to XML.  This capability is comparable to
      [gnosis.xml.pickle], but I like the tool I created better
      in several ways.
      *** 一个支持多种选项以将Python对象序列化到XML的模块.
      此项能力与[gnosis.xml.pickle]相若, 但是我喜欢以多种方式
      创建工具.

  PYX
      PYX is both a document format and a Python module to
      support working with that format.  As well as the Python
      module, tools written in C are available to transform
      documents between XML and PYX format.
      PYX既是文档格式, 又是一个Pyhon模块, 支持与此格式协作.
      除了Python模块, 还有C编写的工具可以用来将文档在XML和PYX
      格式之间转换.

      The idea behind PYX is to eliminate the need for complex
      parsing tools like [xml.sax].  Each node in an XML document
      is represented, in the PYX format on a separate line, using
      a prefix character to indicate the node type.  Most of XML
      semantics is preserved, with the exception of document type
      declarations, comments, and namespaces.  These features
      could be incorporated into an updated PYX format, in
      principle.
      PYX后面的出发点是, 减少对复杂解析工具的需求, 例如[xml.sax].
      XML文档中的每个节点都在PYX格式中都是单独一行, 使用
      一个前缀字母来表明节点类型. 绝大部分XML语法都被保留了, 
      除了文档类型声明, 注释以及名字空间. 原则上, 这些特性可以
      合并入更新后的PYX格式.

      Documents in the PYX format are easily processed using
      traditional line-oriented text processing tools like 'sed',
      'grep', 'awk', 'sort', 'wc', and the like.  Python
      applications that use a basic `FILE.readline()` loop are
      equally able to process PYX nodes, one per line.  This
      makes it much easier to use familiar text processing
      programming styles with PYX than it is with XML.  A brief
      example illustrates the PYX format:
      PYX格式中的文档可以很容易使用传统的基于行的文本处理工具来处理,
      例如'sed', 'grep', 'awk', 'sort', 'wc', 等等. 使用`FILE.readline()`循环的
      Python程序一样可以处理PYX节点, 每次一行. 这就可以使用自己熟悉的
      文本处理编程风格, 比使用XML风格更轻松. 下面简单展示一下PYX格式:

      #*------------------ PYX format example ------------------#
      % cat test.xml
      <?xml version="1.0"?>
      <?xml-stylesheet href="test.css" type="text/css"?>
      <Spam flavor="pork">
        <Eggs>Some text about eggs.</Eggs>
        <MoreSpam>Ode to Spam (spam="smoked-pork")</MoreSpam>
      </Spam>
      % ./xmln test.xml
      ?xml-stylesheet href="test.css" type="text/css"
      (Spam
      Aflavor pork
      -\n
      (Eggs
      -Some text about eggs.
      )Eggs
      -\n
      (MoreSpam
      -Ode to Spam (spam="smoked-pork")
      )MoreSpam
      -\n
      )Spam

  4Suite
      The tools in [4Suite] focus on the use of XML documents for
      knowledge management.  The server element of the [4Suite]
      software is useful for working with catalogs of XML
      documents, searching them, transforming them, and so on.
      The base [4Suite] tools address a variety of XML
      technologies.  In some cases [4Suite] implements standards
      and technologies not found in the Python standard library
      or in [PyXML], while in other cases [4Suite] provides more
      advanced implementations.
      [4Suite]中的工具着眼于使用XML文档来进行知识管理. [4Suite]软件
      的服务器元素擅长协作以下方面, XML文档目录, 对其进行搜索,
      转换, 诸如此类. 基本的[4Suite]工具提出了许多XML技术.
      在某些方面, [4Suite]实现了一些标准和技术, 而它们并未出现在
      Python标准库或者[PyXML]中. 同时在其他方面, [4Suite]提供了更多
      高级实现.

      Among the XML technologies implemented in [4Suite] are DOM,
      RDF, XSLT, XInclude, XPointer, XLink and XPath, and SOAP.
      Among these, of particular note is [4xslt] for performing
      XSLT transformations.  [4xpath] lets you find XML nodes
      using concise and powerful XPath descriptions of how to
      reach them.  [4rdf] deals with "meta-data" that documents
      use to identify their semantic characteristics.
      [4Suite]中实现的XML技术包括DOM,
      RDF, XSLT, XInclude, XPointer, XLink and XPath, 以及 SOAP.
      其中值得注意的是, [4xslt]用于执行XSLT转换. [4xpath]让你
      使用简明有力的XPath来寻找XML节点, XPath可以描述如何到达
      这些节点. [4rdf]处理"meta-data", 后者文档用于识别他们的语法特征.

      I detail [4Suite] technologies in a bit more detail in an
      article at:
      我在一篇文章中给出了关于[4Suite]的更多细节:

      <http://gnosis.cx/publish/programming/xml_matters_15.html>

  yaml
      The native data structures of object-oriented programming
      languages are not straightforward to represent in XML.
      While XML is in principle powerful enough to represent any
      compound data, the only inherent mapping in XML is within
      attributes--but that only maps strings to strings.
      Moreover, even when a suitable XML format is found for a
      given data structure, the XML is quite verbose and
      difficult to scan visually, or especially to edit manually.
      面向对象编程语言的原生数据结构用于表示XML并不直观.
      尽管XML原则上能够表示任何复合数据, XML中的唯一的固有映射
      位于属性中--但其也只是将字符串映射到字符串. 而且, 对于某
      给定数据结构, 即使找到合适的XML格式, 此XML也相当冗长,
      要想视觉扫描, 特别是手工编辑, 会有些困难.
      
## mapping -> 映射, 而非匹配. 需要修改

      The YAML format is designed to match the structure of
      datatypes prevalent in scripting languages: Python, Perl,
      Ruby, and Java all have support libraries at the time of
      this writing.  Moreover, the YAML format is extremely
      concise and unobtrusive--in fact, the acronym cutely
      stands for "YAML Ain't Markup Language."  In many ways,
      YAML can act as a better pretty-printer than [pprint],
      while simultaneously working as a format that can be used
      for configuration files or to exchange data between
      different programming languages.
      YAML格式是设计用来匹配脚本语言中流行的数据类型结构:
      Python, Perl, Ruby, 以及Java在本书写作时, 都有支持库.
      而且YAML格式非常简洁又谦虚--实际上, 它的首字母缩略字
      很可爱的表示"YAML Ain't Markup Language". 在很多
      方面YAML可以充当比[pprint]更好的美化打印机, 而与此同时,
      作为一个格式, 可以用作配置文件, 或者在不同编程语言中交换数据.

      There is no fully general and clean way, however, to
      convert between YAML and XML.  You can use the [yaml]
      module to read YAML data files, then use the
      [gnosis.xml.pickle] module to read and write to one
      particular XML format.  But when XML data starts out in
      other XML dialects than [gnosis.xml.pickle], there are
      ambiguities about the best Python native and YAML
      representations of the same data.  On the plus side--and
      this can be a very big plus--there is essentially a
      straightforward and one-to-one correspondence between
      Python data structures and YAML representations.
      但是并不存在一个完全通用而又干净的方法来转换YAML和XML.
      你可以使用[yaml]模块来读入YAML数据文件, 然后使用
      [gnosis.xml.pickle]模块来读写到特定XML格式. 但如果XML数据
      使用的是其他XML方言, 而非[gnosis.xml.pickle], 关于数据的最佳Python
      原生和YAML表示就会有歧义. 从好的方面想--而且这是非常好的--
      本质上在Python数据结构和YAML表示之间, 
      应该存在一个直观而且一对一的对应关系.

      In the YAML example below, refer back to the same Python
      instance serialized using [gnosis.xml.pickle] and [pprint]
      in their respective discussions.  As with
      [gnosis.xml.pickle]--but in this case unlike [pprint]--the
      serialization can be read back in to re-create an identical
      object (or to create a different object after editing the
      text, by hand or by application).
      在下面的这个YAML例子中, 参考前面的[gnosis.xml.pickle]和[pprint]
      各自章节的实例序列化例子. 和[gnosis.xml.pickle]一样--但这儿和
      [pprint]不同--序列化可以向后读入, 以再造一个同样的对象(或者在
      手工或者通过程序编辑文本后, 创建一个不同的对象).

      >>> class Container: pass
      ...
      >>> inst = Container()
      >>> dct = {1.7:2.5, ('t','u','p'):'tuple'}
      >>> inst.this, inst.num, inst.dct = 'that', 38, dct
      >>> import yaml
      >>> print yaml.dump(inst)
      --- !!__main__.Container
      dct:
          1.7: 2.5
          ?
              - t
              - u
              - p
      : tuple
      num: 38
      this: that

      SEE ALSO, [pprint], `gnosis.xml.pickle`
      参见 [pprint], `gnosis.xml.pickle`

